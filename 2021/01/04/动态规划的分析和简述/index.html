<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="动态规划," />










<meta name="description" content="1 动态规划的概念1.1 定义动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的数学方法。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。 决策过程是什么呢？在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划的分析和简述">
<meta property="og:url" content="http://yoursite.com/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="1 动态规划的概念1.1 定义动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的数学方法。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。 决策过程是什么呢？在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-b0743e22223d2b97f33727c532090c6508e.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-acaa938a3d53c298fca66158871c356f97f.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-9eb1183a125b7d520063b9e2186994a2829.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-8da65c224aabb364fa3138a3251ca96f4b2.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-31a037616da8a00acebff111b6ab70b8839.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-15876d948b7646fe660df2f8f4c0a2e7002.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-5ce30f61ba85ff4958b92a5ff78c1fe8a45.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-d671671532f7c420a05c31da74ec67b099c.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-6ce7c95efa043dec4651f7da63b41745970.png">
<meta property="article:published_time" content="2021-01-04T13:29:35.000Z">
<meta property="article:modified_time" content="2021-01-04T13:31:05.033Z">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="动态规划">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oscimg.oschina.net/oscnet/up-b0743e22223d2b97f33727c532090c6508e.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/01/04/动态规划的分析和简述/"/>





  <title>动态规划的分析和简述 | cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">动态规划的分析和简述</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-04T21:29:35+08:00">
                2021-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/04/动态规划的分析和简述/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-动态规划的概念"><a href="#1-动态规划的概念" class="headerlink" title="1 动态规划的概念"></a>1 动态规划的概念</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解<strong>决策过程最优化</strong>的数学方法。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。</p>
<p><strong>决策过程是什么呢</strong>？在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。各个阶段决策的选取依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。</p>
<p>在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前的<strong>状态</strong>，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。</p>
<h2 id="1-2-概念和术语"><a href="#1-2-概念和术语" class="headerlink" title="1.2 概念和术语"></a>1.2 概念和术语</h2><p>关于动态规划，我们要了解如下概念和术语，我们以0-1背包问题为例：</p>
<blockquote>
<p>0-1背包问题:我们有n种物品，物品j的重量为wj，价格为pj，背包的总重量是W，如果限定每种物品只能选择0个或1个，那么如何选取物品，使背包内物品的总价值最大。</p>
</blockquote>
<ol>
<li>阶段：<ul>
<li>把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同</li>
<li>0-1背包问题中，我们每一次选取一个新的物品放入背包的这个过程，就是一个阶段。</li>
</ul>
</li>
<li>状态：<ul>
<li>状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。</li>
<li>0-1背包问题中，我们每一次选取一个新的物品后，（已选取物品，已选取的物品总价值），这二者的值就是一个阶段的状态。</li>
</ul>
</li>
<li>决策<ul>
<li>一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。</li>
<li>0-1背包问题中，每次我们选取哪个物品放入，这就是一个决策，</li>
</ul>
</li>
<li>策略：<ul>
<li>由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</li>
<li>一次连续阶段的多个决策序列就是策略，比如策略A可以是：放入钢笔——放入水壶——放入睡袋。策略B是放入钢笔——放入睡袋——放入头盔。以此类推</li>
</ul>
</li>
<li>多阶段决策问题：<ul>
<li>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题</li>
<li>0-1背包问题就是一个典型的多阶段决策问题。</li>
</ul>
</li>
</ol>
<h2 id="1-3-核心思路"><a href="#1-3-核心思路" class="headerlink" title="1.3 核心思路"></a>1.3 核心思路</h2><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>不过与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往<strong>不是互相独立的</strong>。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。</p>
<p>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。在动态规划中，我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p>
<p>动态规划的核心除了<strong>分阶段决策</strong>外，还有上面所说的<strong>避免重复计算</strong>。这个如何理解呢？</p>
<p>比如0-1背包问题，我们现在有1，2，3三个物品，xj=1表示j物品放入背包，xj=0则表示j物品没放入。同时策略C(x1x2x3)=001，表示x1和x2都没有放入背包，x3放入了背包。</p>
<p>现在假如通过穷举得到了如下的5种可行策略：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b0743e22223d2b97f33727c532090c6508e.png" alt=""></p>
<p>那么由图我们可以知道，C2=011和C3=010这两种策略，都要经过01这个策略，如果在计算011的时候我们计算一遍01，在计算010的时候我们又计算一遍01，那么就重复计算了，我们为什么不把01这个策略的状态（已选取物品，已选取的物品总价值）保存下来呢？这样在计算010的时候，直接就可以把01的结果拿出来用了。</p>
<p>动态规划算法可以理解为是<strong>分治法</strong>和<strong>穷举法</strong>的结合：</p>
<ol>
<li>它用分治法的思想将一个问题分为多个决策阶段，既将问题复杂性减小，也为后续的局部结果复用提供前提。</li>
<li>它搜索解的方式还是穷举法那一套，只不过因为可以局部复用，所以它的复杂性会大大降低。</li>
</ol>
<p>其关键在于解决冗余，这是动态规划算法的<strong>根本目的</strong>。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间</p>
<h2 id="1-4-适用场景"><a href="#1-4-适用场景" class="headerlink" title="1.4 适用场景"></a>1.4 适用场景</h2><p>动态规划算法通常用于求解具有某种最优性质的多阶段决策问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p>
<p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和状态无后效性：</p>
<ol>
<li>最优化原理（最优子结构性质）<ul>
<li>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。</li>
<li>在0-1背包问题中，我们假设策略C=011是最优解，也就是说背包存放x2和x3，才能使价值最高，那么它的子策略，01x和x11，也同样都是最优解。最优化原理通俗的讲就是：011是最优解，那么01x肯定也是最优解，01x表示x3先不论，x1肯定不能选，x2肯定要选，否则就不是最优解。</li>
</ul>
</li>
<li>状态无后效性：<ul>
<li>状态无后效性指的是每个阶段的状态都是过去阶段的一个完整总结，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策。这就是无后向性，又称为无后效性。</li>
<li>在0-1背包问题中，我们的状态是（已选取物品，已选取的物品总价值），我们之所以选择这样的两个值作为状态，就是因为它都是对过去阶段的完整总结。这使得从这个状态基础上进行的新的决策，可以不用去关心之前的状态，因为之前的状态被总结了。之所以要使状态无后效性，就是为了便于存储和复用阶段的结果，避免重复计算。</li>
<li>试想一下，如果状态不是无后效性的，比如我们选择的状态是（本次选取的物品），那么我们保存这个状态的值，根本对后面的复用没有帮助，后面要想知道背包还剩多少空间，还是要把之前经历过的阶段的解都计算一遍。</li>
</ul>
</li>
</ol>
<h2 id="1-5-解题技巧"><a href="#1-5-解题技巧" class="headerlink" title="1.5 解题技巧"></a>1.5 解题技巧</h2><p>前文我们提到过，动态规划是分治法和穷举法的结合，同时，在动态规划中，我们可以用一个表来记录所有已穷举出的已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p>
<p>那么，如何将上述的经验整理成解题技巧呢？还是用0-1背包问题为例，来看下所谓的填表格式到底是什么：</p>
<blockquote>
<p>假设你是个小偷，背着一个可装4磅东西的背包。你可盗窃的商品有如下3件。为了让盗窃的商品价值最高，你该选择哪些商品？</p>
</blockquote>
<table>
<thead>
<tr>
<th>商品名称</th>
<th>重量（磅）</th>
<th>价值（美元）</th>
</tr>
</thead>
<tbody><tr>
<td>音响</td>
<td>4</td>
<td>3000</td>
</tr>
<tr>
<td>笔记本电脑</td>
<td>3</td>
<td>2000</td>
</tr>
<tr>
<td>吉他</td>
<td>1</td>
<td>1500</td>
</tr>
</tbody></table>
<p>每个动态规划算法都从一个填表的网格开始，背包问题的网格如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-acaa938a3d53c298fca66158871c356f97f.png" alt=""></p>
<ul>
<li>网格的各行为商品，各列为不同容量（1～4磅）的背包。单元格内填入当前情况下的最大背包价值。</li>
<li>第一行表示只能选吉他，第二行表示可以选吉他+音响，以此类推。</li>
<li>虽然我们题目的背包是4磅，但我们仍然需要1到3磅的前三列，因为它们将帮助我们在计算剩余空间时发挥作用。</li>
<li>网格最初是空的。我们将填充其中的每个单元格，网格填满后，就找到了问题的答案！</li>
</ul>
<p>【填充第一行】</p>
<p>第一个单元格表示背包的容量为1磅。吉他的重量也是1磅，这意味着它能装入背包！因此这个单元格包含吉他，价值为1500美元。</p>
<p>由于这是第一行，只有吉他可供你选择，于是不管背包多大，单元格内的值都是1500美元，所以第一行的值都是1500。</p>
<p>【填充第二行】</p>
<p>我们现在处于第二行，可偷的商品有吉他和音响。我们先来看第一个单元格，它表示容量为1磅的背包。在此之前，可装入1磅背包的商品的最大价值为1500美元，由于容量1磅的背包装不下音响，因此最大价值依然是1500美元。接下来的两个单元格的情况与此相同。在这些单元格中，背包的容量分别为2磅和3磅，而以前的最大价值为1500美元。由于这些背包装不下音响，因此最大价值保持不变。</p>
<p>但如果背包的容量为4磅，那就能够装下音响！原来的最大价值为1500美元，但如果在背包中装入音响而不是吉他，价值将为3000美元！你更新了最大价值！在这个网格中，你逐步地更新最大价值。</p>
<p>于是我们得到了第二行：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9eb1183a125b7d520063b9e2186994a2829.png" alt=""></p>
<p>【填充第三行】</p>
<p>笔记本电脑重3磅，没法将其装入容量为1磅或2磅的背包，因此前两个单元格的最大价值还是1500美元。</p>
<p>对于容量为3磅的背包，原来的最大价值为1500美元，但现在你可选择盗窃价值2000美元的笔记本电脑而不是吉他，这样新的最大价值将为2000美元！</p>
<p><strong>对于容量为4磅的背包</strong>，当前的最大价值为3000美元，你可不偷音响，而偷笔记本电脑，但它只值2000美元。价值没有原来高。但笔记本电脑的重量只有3磅，背包还有1磅的容量没用！</p>
<p>在1磅的容量中，可装入的商品的最大价值是多少呢？根据之前计算的最大价值可知（第一列中最大的值），在1磅的容量中可装入吉他，价值1500美元。</p>
<blockquote>
<p>注意，此时我们就用到了背包容量为1的那一列，所以我们之所以要算出与4磅无关的容量为1,2,3磅的结果，就是为了这一刻。</p>
</blockquote>
<p>笔记本电脑和吉他的总价值为3500美元，因此偷它们是更好的选择。最终的网格类似于下面这样。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-8da65c224aabb364fa3138a3251ca96f4b2.png" alt=""></p>
<p>【总结】</p>
<p>经过上面的分析，我们可以发现，题目所要的答案，其实只是网格最右下角的那一个单元格。那我们为什么要算出其他的单元格呢？</p>
<p>因为下一个单元格的值，需要用到之前单元格的值来计算，比如最后的答案3500美元，就用到了背包容量为1的那一列的数据来计算剩余1磅空间的时候选择哪个物品最合算。</p>
<p>我们记录下之前单元格的值，就是为了计算新单元格的时候不用重复计算，就像这道题，我们最后想知道背包容量为1时应该如何选取物品，如果没有保存下结果，那我们要重新算一遍第一列的场景，那效率就很低了。</p>
<blockquote>
<p>记忆化搜索，即用一个二维数组保存已经计算好的子问题的解，下次再计算相同子问题时，就不用重复求解了。</p>
</blockquote>
<p>每一个新的单元格的值，都需要复用到之前单元格的数据来算出，如果我们能归纳出一个通用的<strong>以旧单元格值推导出新单元格值的公式</strong>，那就相当于找到了一条可得到最优解的方法。这个公式，我们称为<strong>状态转移方程</strong>。</p>
<p>我们前文提到过，状态是每一个阶段的总结，动态规划是多阶段决策的过程，我们在多个阶段间行进，状态也在一直转移。状态转移方程，顾名思义，就是状态变化的方程，比如说我们可以归纳出该题的状态转移方程如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-31a037616da8a00acebff111b6ab70b8839.png" alt=""></p>
<p>于是我们知道了：</p>
<ol>
<li>填表法是动态规划的固定套路，它能帮助我们理解状态转移的过程，并且记录和复用之前的结果。</li>
<li>网格的每一个单元格，都可以理解为是一个阶段，阶段变量有两个，可选取物品类型和背包重量，也就是网格的横纵轴。</li>
<li>每个阶段的策略，就是我们的状态转移方程，即我们用现有的状态，决策出了当前阶段的状态。</li>
<li>动态规划的核心就在于：<ul>
<li><strong>将题目划分为多个子问题，对应多个阶段</strong></li>
<li><strong>确定哪些变量属于状态</strong></li>
<li><strong>归纳出状态转移方程</strong></li>
</ul>
</li>
</ol>
<h1 id="2-经典题型"><a href="#2-经典题型" class="headerlink" title="2 经典题型"></a>2 经典题型</h1><h2 id="2-1-0-1背包问题"><a href="#2-1-0-1背包问题" class="headerlink" title="2.1 0-1背包问题"></a>2.1 0-1背包问题</h2><h3 id="2-1-1-题目"><a href="#2-1-1-题目" class="headerlink" title="2.1.1 题目"></a>2.1.1 题目</h3><p>【描述】：有 n 个物品和一个大小为 bagSize 的背包. 给定数组 itemSizes 表示每个物品的大小和数组 itemValues 表示每个物品的价值。问最多能装入背包的总价值是多大?</p>
<ul>
<li><code>itemSizes[i], itemValues[i], n, bagSize 均为整数</code></li>
<li><code>你不能将物品进行切分</code></li>
<li><code>你所挑选的要装入背包的物品的总大小不能超过 bagSize</code></li>
<li><code>每个物品只能取一次</code></li>
</ul>
<p>【样例 1】:</p>
<ul>
<li>输入: <code>bagSize = 10, itemSizes = [2, 3, 5, 7], itemValues = [1, 5, 2, 4]</code></li>
<li>输出: 9</li>
<li>解释: 装入 <code>itemSizes[1] 和 itemSizes[3]</code> 可以得到最大价值, <code>itemValues[1] + itemValues[3] = 9</code></li>
</ul>
<p>【样例 2】:</p>
<ul>
<li>输入: <code>bagSize = 10, itemSizes = [2, 3, 8], itemValues = [2, 5, 8]</code></li>
<li>输出: 10</li>
<li>解释: 装入 <code>itemSizes[0] 和 itemSizes[2]</code> 可以得到最大价值, <code>itemValues[0] + itemValues[2] = 10</code></li>
</ul>
<h3 id="2-1-2-题解"><a href="#2-1-2-题解" class="headerlink" title="2.1.2 题解"></a>2.1.2 题解</h3><p>前文已叙述，不再赘述。</p>
<h3 id="2-1-3-代码"><a href="#2-1-3-代码" class="headerlink" title="2.1.3 代码"></a>2.1.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int backPack(int bagSize, int[] itemSizes, int[] itemValues) &#123;</span><br><span class="line">    int itemsNum &#x3D; itemSizes.length;</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组，存放已计算过的结果，填表法。</span><br><span class="line">    int[][] values &#x3D; new int[itemsNum][bagSize];</span><br><span class="line">    &#x2F;&#x2F; 开始填表，itemSizes数组中，0-itemIdx区间内的物品，为当前可选物品</span><br><span class="line">    for (int itemIdx &#x3D; 0;itemIdx &lt; itemsNum;itemIdx++)&#123;</span><br><span class="line">        for (int bagIdx &#x3D; 0;bagIdx &lt; bagSize;bagIdx++)&#123;</span><br><span class="line">            int thisBagSize &#x3D; bagIdx+1;&#x2F;&#x2F; 因为下标为0开始，但背包size从1开始。</span><br><span class="line">            &#x2F;&#x2F; 从已计算的结果中获取【当前背包size下，如果当前物品不可取时，背包可存放的最大价值】。</span><br><span class="line">            int maxValueWithoutThisItem &#x3D; getCachedValue(itemIdx-1,bagIdx,values);</span><br><span class="line">            &#x2F;&#x2F; 计算【当前背包size下，如果当前物品可取时，背包可存放的最大价值】</span><br><span class="line">            &#x2F;&#x2F; 计算方法为：如果当前物品可以被当前背包size容纳</span><br><span class="line">            &#x2F;&#x2F;      那么尝试优先存放该物品，并从之前的不包含当前物品的结果中</span><br><span class="line">            &#x2F;&#x2F;          寻找【可以填满剩余空间的最大价值】，二者相加即为结果。</span><br><span class="line">            int maxValueIncludeThisItem &#x3D; itemSizes[itemIdx] &lt;&#x3D; thisBagSize ?</span><br><span class="line">                    itemValues[itemIdx] + getCachedValue(itemIdx-1,thisBagSize-itemSizes[itemIdx]-1,values): maxValueWithoutThisItem;</span><br><span class="line">            &#x2F;&#x2F; 比较【当前背包size下，如果当前物品不可取时，背包可存放的最大价值】和【当前背包size下，如果当前物品可取时，背包可存放的最大价值】</span><br><span class="line">            &#x2F;&#x2F; 哪个大就选择哪个值作为当前阶段的解。</span><br><span class="line">            values[itemIdx][bagIdx] &#x3D; Math.max(maxValueWithoutThisItem,maxValueIncludeThisItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return values[itemsNum-1][bagSize-1];</span><br><span class="line">&#125;</span><br><span class="line">private int getCachedValue(int i,int j,int[][] values)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return values[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-最长公共子串"><a href="#2-2-最长公共子串" class="headerlink" title="2.2 最长公共子串"></a>2.2 最长公共子串</h2><h3 id="2-2-1-题目"><a href="#2-2-1-题目" class="headerlink" title="2.2.1 题目"></a>2.2.1 题目</h3><p>【描述】：给出两个字符串，找到最长公共子串，并返回其长度。</p>
<ul>
<li><code>子串的字符应该连续的出现在原字符串中，这与子序列有所不同。</code></li>
</ul>
<p>【样例 1】:</p>
<ul>
<li>输入:  “hish” and “fish”</li>
<li>输出:  3</li>
<li>解释: 最长公共子串是 “ish”</li>
</ul>
<p>【样例 2】:</p>
<ul>
<li>输入: “hish” and “vista”</li>
<li>输出: 2</li>
<li>解释: 最长公共子串是 ‘is’</li>
</ul>
<h3 id="2-2-2-题解"><a href="#2-2-2-题解" class="headerlink" title="2.2.2 题解"></a>2.2.2 题解</h3><p>将两个单词的字母分列为横纵轴，如下图所示。</p>
<p>因为公共子串有顺序和连续的要求（如is和si就不是一个公共子串，ios和is不是一个共同子串，只有is和is才是。），所以在矩阵当中，两个相邻的对角线的单元格都为1的时候，才是公共子串出现的时候。</p>
<p>那我们把两个相邻的成对角线的单元格都赋值1可以吗？不行，还记得我们动态规划状态的定义吗？状态是过去阶段的总结！</p>
<p>所以，我们应该用右下角的单元格来存储目前已出现的这个公共子串的长度，而不是单纯的赋值1。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-15876d948b7646fe660df2f8f4c0a2e7002.png" alt=""></p>
<p>对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。</p>
<h3 id="2-2-3-代码"><a href="#2-2-3-代码" class="headerlink" title="2.2.3 代码"></a>2.2.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 最长公共子串</span><br><span class="line"> * @param Str1: Str1 string</span><br><span class="line"> * @param str2: str2 string</span><br><span class="line"> * @return: the length of the longest common substring</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int longestCommonSubstring(String str1, String str2) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    if (str1.isEmpty()|| str2.isEmpty())&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组，存放已计算过的结果，填表法。</span><br><span class="line">    int[][] values &#x3D; new int[str1.length()][str2.length()];</span><br><span class="line">    for (int i &#x3D; 0;i&lt;str1.length();i++)&#123;</span><br><span class="line">        for (int j &#x3D; 0;j&lt;str2.length();j++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 状态转移方程为：当两个字母相等时，当前值取左上角的单元格的值+1</span><br><span class="line">            if (str1.charAt(i) &#x3D;&#x3D; str2.charAt(j))&#123;</span><br><span class="line">                values[i][j] &#x3D; getCachedValue(i-1,j-1,values)+1;</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; Math.max(result,values[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private int getCachedValue(int i,int j,int[][] values)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; values.length || j &gt;&#x3D;values[0].length)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return values[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-最长公共子串"><a href="#2-3-最长公共子串" class="headerlink" title="2.3 最长公共子串"></a>2.3 最长公共子串</h2><h3 id="2-3-1-题目"><a href="#2-3-1-题目" class="headerlink" title="2.3.1 题目"></a>2.3.1 题目</h3><p>【描述】：给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>
<p>最长公共子序列的定义：</p>
<ul>
<li>最长公共子序列问题是在一组序列（通常2个）中找到最长公共子序列（注意：不同于子串，LCS不需要是连续的子串）。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用。</li>
</ul>
<p>【样例 1】:</p>
<ul>
<li>输入:  “fosh” and “fort”</li>
<li>输出:  2</li>
<li>解释: 最长公共子序列是 “f”,”o”</li>
</ul>
<p>【样例 2】:</p>
<ul>
<li>输入: “fosh” and “fish”</li>
<li>输出: 3</li>
<li>解释: 最长公共子序列是 “f”,”s”,”h”</li>
</ul>
<h3 id="2-3-2-题解"><a href="#2-3-2-题解" class="headerlink" title="2.3.2 题解"></a>2.3.2 题解</h3><p>将两个单词的字母分列为横纵轴，如下图所示。</p>
<p>因为公共子序列有顺序的要求，但是没有连续的要求（如is和si就不是一个公共子序列，但ios和is中的is是公共子序列），所以在矩阵当中，某个字母相等的单元格的左上部分存在另一个字母相等的单元格，才是公共子序列出现的时候。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5ce30f61ba85ff4958b92a5ff78c1fe8a45.png" alt=""></p>
<p>但因为公共子序列没有连续的要求，故而两个1，可能离得有点远，没法像最长公共子串那一题一样直接根据左上相邻单元格来判断，所以在该题状态转移方程中，我们要注意将1一直传递下去。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d671671532f7c420a05c31da74ec67b099c.png" alt=""></p>
<p>所以我们得到状态转移方程：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6ce7c95efa043dec4651f7da63b41745970.png" alt=""></p>
<h3 id="2-3-3-代码"><a href="#2-3-3-代码" class="headerlink" title="2.3.3 代码"></a>2.3.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 最长公共子序列</span><br><span class="line"> * @param Str1: Str1 string</span><br><span class="line"> * @param str2: Str1 string</span><br><span class="line"> * @return: The length of longest common subsequence of Str1 and str2</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int longestCommonSubsequence(String Str1, String str2) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    if (Str1.isEmpty()|| str2.isEmpty())&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组，存放已计算过的结果，填表法。</span><br><span class="line">    int[][] values &#x3D; new int[Str1.length()][str2.length()];</span><br><span class="line">    for (int i &#x3D; 0;i&lt;Str1.length();i++)&#123;</span><br><span class="line">        for (int j &#x3D; 0;j&lt;str2.length();j++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 状态转移方程为：</span><br><span class="line">            &#x2F;&#x2F; 1. 当两个字母相等时，当前值取左上角的单元格的值+1</span><br><span class="line">            &#x2F;&#x2F; 2. 当两个字母不等时，当前值取左方和上方两个单元格中最大的值</span><br><span class="line">            if (Str1.charAt(i) &#x3D;&#x3D; str2.charAt(j))&#123;</span><br><span class="line">                values[i][j] &#x3D; getCachedValue(i-1,j-1,values)+1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                values[i][j] &#x3D; Math.max(getCachedValue(i,j-1,values),getCachedValue(i-1,j,values));</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; Math.max(result,values[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private int getCachedValue(int i,int j,int[][] values)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return values[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"># 动态规划</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%92%8C%E6%95%B4%E7%90%86/" rel="next" title="排序算法汇总和整理">
                <i class="fa fa-chevron-left"></i> 排序算法汇总和整理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/05/MySQL%E7%9A%84%E5%88%86%E5%8C%BA-%E5%88%86%E5%BA%93-%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/" rel="prev" title="MySQL的分区/分库/分表总结">
                MySQL的分区/分库/分表总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2021/01/04/动态规划的分析和简述/"
           data-title="动态规划的分析和简述" data-url="http://yoursite.com/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-动态规划的概念"><span class="nav-text">1 动态规划的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-定义"><span class="nav-text">1.1 定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-概念和术语"><span class="nav-text">1.2 概念和术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-核心思路"><span class="nav-text">1.3 核心思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-适用场景"><span class="nav-text">1.4 适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-解题技巧"><span class="nav-text">1.5 解题技巧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-经典题型"><span class="nav-text">2 经典题型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-0-1背包问题"><span class="nav-text">2.1 0-1背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-题目"><span class="nav-text">2.1.1 题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-题解"><span class="nav-text">2.1.2 题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-代码"><span class="nav-text">2.1.3 代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-最长公共子串"><span class="nav-text">2.2 最长公共子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-题目"><span class="nav-text">2.2.1 题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-题解"><span class="nav-text">2.2.2 题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-代码"><span class="nav-text">2.2.3 代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-最长公共子串"><span class="nav-text">2.3 最长公共子串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-题目"><span class="nav-text">2.3.1 题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-题解"><span class="nav-text">2.3.2 题解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-代码"><span class="nav-text">2.3.3 代码</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">433.1k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
