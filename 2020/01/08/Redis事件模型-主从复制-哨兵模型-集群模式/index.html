<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="分布式,Redis,缓存,Sentinel," />










<meta name="description" content="1. Redis的事件模型Redis服务器需要处理两类事件：文件事件和时间事件。 1.1 文件事件Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。 Redis基于Reactor模式开发了网络事件处理器，由四部分组成：套接字、I&#x2F;O多路复用程序、文件事件分派器以及事件处理器。   套接字：当有一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis事件模型&#x2F;主从复制&#x2F;哨兵模型&#x2F;集群模式">
<meta property="og:url" content="http://yoursite.com/2020/01/08/Redis%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%9E%8B-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="1. Redis的事件模型Redis服务器需要处理两类事件：文件事件和时间事件。 1.1 文件事件Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。 Redis基于Reactor模式开发了网络事件处理器，由四部分组成：套接字、I&#x2F;O多路复用程序、文件事件分派器以及事件处理器。   套接字：当有一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-4f1ecfb38834ecc1e56da223851c70253d1.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-63c1d7f685fe82c9b6de8a1db0cf63425b1.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-9e0589e377a8ff80d66c0ddef54da95b6d9.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-e1c7b32c5ca809d372507522a169da2effa.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-a1b2a265b2286571ce9313c80598511599a.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-afd39c7736ceb3cb769fdfd7d588e8943d6.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-39f2148ba5785661a77fbdecd5375a765a6.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-cfd59b02030b3f463de3d8e6ee7d4fa1e63.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-6b85f71f0d739997ec61cae37975871ef3b.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-9844df2ae892d6aa2f0eb9bbfe8e2dc0a94.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-cea89403237d39529cf8fe68b1aac463c01.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-6c6228d79603ed7e8091349805b818b0477.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-d8186e4f60ecb5a5f4a3d94a6953b0c0f69.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-693b46071c249bb5a9ec8795a47317135ac.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-cca80560a551e9d92bb2561bc4beac8b8f7.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-7297be982c2757e9849b1d018d7e14a69a4.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-74b74416d8986d2bc2260d9848302bd26c5.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-2e8b33cdecf632546ed70b2a91e16901f44.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-d17c827a40ef959aa665c9f24c9b1bbe054.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-63050f2a3d66283638dc1c17d2f1ec19778.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-f7d42df36db19bd7fa4c53b9e289381dc62.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-238ac368f60e323211e08ebaeb8e7308450.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-235ef5d9525c74626220b099acbff598f27.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-4dd23054ec9ad51b2c753001abd3bbe46a5.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-5cc7e6782bf95df108607d7a9179b94f625.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-5b9e81f3a2d2692d744f2dd17340e377a4a.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-e15a80cc3eaec80234386903b967ca94f1d.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-cc3509fe121399c911c2c76c9141eae43f0.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-bc6314d42194e83e8c3024d39401f1ba78e.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-39a3a3f5b3381711f3063c1719f4ab03f89.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-0301ec71756c260aaae4f67a696c939939c.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-0554962e101651acacc73f8c04897f3d7ef.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-084760de95dd05ca210595633b1328d141f.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-e15a80cc3eaec80234386903b967ca94f1d.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-1bff3ef7742eb8463677f3e0c00fb30240d.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-6885d13841ad33d7783816ac2e8c63736dd.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-cb0413dac3d1923097cdf136316e96c8f4f.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-40fa2846f5067087ba601c5ba8b0658df00.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-08c2162c6cae22ff35c3fd9c53e0ec5bf8c.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-4068617fde399f6fe494c764ff1e330620c.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-ef32357ce2410db6cf95670fec70e865b75.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-d08d4389ea5a796d227eed8522533cc9bf9.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-1cfff66398d714cab3142e3825989d4f9d0.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-6d3519de440528a8af1eded3347c9337236.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-dbb09c36a7db3dcb13c5f538cb3ccc80092.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-0bc955e758a048378d24a0e10ca3a39540a.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-ee9006a45f14bd9001e3118803ba0f3e6a8.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-0e420042cc4a84d00d7ef383c8c9a540889.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-1b3f9629997cc535ef543380112d098d3e0.png">
<meta property="article:published_time" content="2020-01-08T14:48:41.000Z">
<meta property="article:modified_time" content="2020-08-17T13:22:58.994Z">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="缓存">
<meta property="article:tag" content="Sentinel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oscimg.oschina.net/oscnet/up-4f1ecfb38834ecc1e56da223851c70253d1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/01/08/Redis事件模型-主从复制-哨兵模型-集群模式/"/>





  <title>Redis事件模型/主从复制/哨兵模型/集群模式 | cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/08/Redis%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%9E%8B-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis事件模型/主从复制/哨兵模型/集群模式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-08T22:48:41+08:00">
                2020-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/08/Redis%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%9E%8B-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/01/08/Redis事件模型-主从复制-哨兵模型-集群模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  15.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  57
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-Redis的事件模型"><a href="#1-Redis的事件模型" class="headerlink" title="1. Redis的事件模型"></a>1. Redis的事件模型</h1><p>Redis服务器需要处理两类事件：文件事件和时间事件。</p>
<h2 id="1-1-文件事件"><a href="#1-1-文件事件" class="headerlink" title="1.1 文件事件"></a>1.1 文件事件</h2><p>Redis服务器通过<strong>套接字</strong>与客户端进行连接，<strong>而文件事件就是服务器对套接字操作的抽象</strong>。</p>
<p>Redis基于Reactor模式开发了网络事件处理器，由四部分组成：<strong>套接字、I/O多路复用程序、文件事件分派器以及事件处理器</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4f1ecfb38834ecc1e56da223851c70253d1.png" alt=""></p>
<ul>
<li><p>套接字：当有一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件（多个套接字就会有多个文件事件产生；</p>
<ul>
<li>事件类型有AE_READABLE和AE_WRITABLE<ul>
<li>如果客户端对套接字执行write或close操作，或者客户端对服务端的监听套接字执行connect操作，那么产生一个AE_READABLE事件。</li>
<li>如果客户端对套接字执行read操作，那么产生一个AE_WRITABLE事件。</li>
<li>如果一个事件既可读又可写，则先处理AE_READABLE事件，再处理AE_WRITABLE事件。</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O多路复用程序：负责监听多个套接字，并向文件事件分派器传送产生事件的套接字。</p>
<ul>
<li>I/O多路复用程序会将产生的所有事件的套接字放在一个队列中，以有序（sequentially）、同步（synchronously）、每次一个的方式向文件事件分派器传送套接字，只有一个套接字的事件处理完成后才会再发下一个：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-63c1d7f685fe82c9b6de8a1db0cf63425b1.png" alt=""></li>
</ul>
</li>
<li>I/O多路复用的功能是<strong>evport、epoll、kqueue和select这些常见的I/O多路复用函数</strong>的包装。Redis会在编译时自动选择系统中性能最高的I/O多路复用函数。<strong>默认实现是epoll</strong>。关于I/O多路复用可见本博客文章《详解IO多路复用和其三种模式——select/poll/epoll》<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-9e0589e377a8ff80d66c0ddef54da95b6d9.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>文件事件分派器</p>
<ul>
<li>接收I/O多路复用程序传来的套接字，根据套接字产生的事件类型，调用相应事件处理器</li>
</ul>
</li>
<li><p>文件事件处理器</p>
<ul>
<li>连接应答处理器：acceptTCPhandler<ul>
<li>对连接服务器的各个客户端进行应答</li>
<li>Redis初始化时，将监听套接字的AE_READABLE事件与该处理器关联</li>
<li>客户端连接服务器时，监听套接字产生AE_READABLE事件，触发该处理器执行。</li>
<li>服务器将会创建一个redisClient结构的实例，并添加进自身的RedisServer结构的clients链表中。</li>
<li>处理器对客户端请求进行应答，并创建客户端套接字，将客户端套接字的AE_READABLE事件与命令请求处理器关联。</li>
</ul>
</li>
<li>命令请求处理器：readQueryFromClient<ul>
<li>接收客户端传来的命令请求</li>
<li>客户端成功连接服务器后，连接应答处理器将该客户端套接字的AE_READABLE事件与命令请求处理器关联</li>
<li>客户端向服务器发送命令请求时，客户端套接字产生AE_READABLE事件</li>
<li>命令请求处理器读取命令内容，传给相关程序执行。</li>
</ul>
</li>
<li>命令回复处理器：sendReplyToClient<ul>
<li>向客户端返回命令执行结果</li>
<li>服务器有命令执行结果要传送给客户端时，将客户端套接字的AE_WRITABLE事件始终与该处理器关联</li>
<li>客户端准备好接收命令执行结果时，客户端套接字产生AE_WRITABLE事件，触发命令回复处理器执行。</li>
<li>将全部回复写入套接字后，关联解除</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-e1c7b32c5ca809d372507522a169da2effa.png" alt=""></p>
<h2 id="1-2-时间事件"><a href="#1-2-时间事件" class="headerlink" title="1.2 时间事件"></a>1.2 时间事件</h2><p>一个时间事件包括三要素：</p>
<ul>
<li>id<ul>
<li>时间时间的全局唯一表示，新事件id大于旧事件。</li>
</ul>
</li>
<li>when<ul>
<li>毫秒精度的unix时间戳，记录了时间事件的到达时间。</li>
</ul>
</li>
<li>timeproc（时间事件处理器）<ul>
<li>时间事件处理器，一个函数，时间事件到达时，服务器调用对应处理器来执行。</li>
</ul>
</li>
</ul>
<p>时间事件分为两类：</p>
<ul>
<li><p>定时事件：让一段程序在指定时间后执行一次。</p>
<ul>
<li>定时事件的处理器返回值是固定的数值，存在ae.h/AE_NOMORE中，如果一个事件的返回为该值，那么该事件在到达一次后，就会被删除</li>
</ul>
</li>
<li><p>周期事件：让一段程序每隔一段指定时间就执行一次。</p>
<ul>
<li>周期事件的处理器返回值是非ae.h/AE_NOMORE的值，这时，返回值会覆写when值。让这个时间过一段时间再次到达，以此类推。</li>
</ul>
</li>
</ul>
<p>服务器将时间事件都放在一个无序链表中（不是按时间顺序排序，而是按照ID排序，新产生的时间事件放在链表的表头），每次时间事件执行器运行时，processTimeEvents函数遍历整个链表，查找所有已经到达的时间事件，并调用相应的事件处理器。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a1b2a265b2286571ce9313c80598511599a.png" alt=""></p>
<h3 id="1-2-1-serverCron函数"><a href="#1-2-1-serverCron函数" class="headerlink" title="1.2.1 serverCron函数"></a>1.2.1 serverCron函数</h3><p>时间时间最典型的实例就是serverCron函数，它平均100毫秒执行一次，负责Redis定期对自身资源和状态的调整，包括：</p>
<ul>
<li>更新服务器的统计信息：时间，内存，数据库占用情况</li>
<li>清理过期键值对</li>
<li>关闭失效的连接</li>
<li>尝试进行aof\rdb持久化操作</li>
<li>对从服务器进行定期同步</li>
<li>集群模式下的定期同步，连接测试</li>
</ul>
<h2 id="1-3-事件调度与执行"><a href="#1-3-事件调度与执行" class="headerlink" title="1.3 事件调度与执行"></a>1.3 事件调度与执行</h2><p>aeProcessEvents函数负责何时处理文件事件、何时处理时间事件，以及花费多久的时间<br><img src="https://oscimg.oschina.net/oscnet/up-afd39c7736ceb3cb769fdfd7d588e8943d6.png" alt=""></p>
<p>将aeProcessEvents函数放置在循环中，加上初始化、清理函数，就构成了redis服务器的主函数</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-39f2148ba5785661a77fbdecd5375a765a6.png" alt=""></p>
<blockquote>
<p>文件事件和时间事件是合作关系，服务器会轮流处理这两种事件，并且处理过程中也不会抢占线程。因此时间事件的实际处理时间要比设定的时间晚一些。</p>
</blockquote>
<h1 id="2-Redis主从复制"><a href="#2-Redis主从复制" class="headerlink" title="2. Redis主从复制"></a>2. Redis主从复制</h1><p>关系数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有的读请求，Redis采用了同样方法来实现自己的复制特性。</p>
<h2 id="2-1-旧版复制功能"><a href="#2-1-旧版复制功能" class="headerlink" title="2.1 旧版复制功能"></a>2.1 旧版复制功能</h2><p><strong>Redis 2.8以前采用的复制都为旧版复制，主要使用SYNC命令同步复制</strong>，SYNC存在很大的缺陷严重消耗主服务器的资源以及大量的网络连接资源。Redis 2.8之后采用PSYNC命令替代SYNC，解决完善这些缺陷，但在介绍新版复制功能之前，必须先介绍旧版复制过程，这样才能更好地形成对比。</p>
<p>复制功能有两种模式，分为<strong>同步sync</strong>与<strong>命令传播（command propagate）</strong>，两个过程配合执行才能实现Redis复制。</p>
<ul>
<li>SYNC命令同步操作<ul>
<li>通过从服务器发送到SYNC命令给 <em>主服务器</em></li>
<li><em>主服务器</em> 执行BGSAVE命令，在后台生成RDB文件，并从现在开始将所有写命令记录进缓冲区</li>
<li>并发送给 <em>从服务器</em>，同时发送缓冲区保存的所有写命令给 <em>从服务器</em>。</li>
<li><em>从服务器</em> 清空之前数据并执行解释RDB文件，然后执行缓冲区的写命令。</li>
<li>保持数据基本一致（还需要命令传播过程才能保持一致）</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-cfd59b02030b3f463de3d8e6ee7d4fa1e63.png" alt=""></li>
</ul>
</li>
<li>命令传播操作：<ul>
<li>在同步之后，<em>主服务器</em> 仍然在不断的接受写命令，这会导致好不容易一致的主从状态再次不一致。</li>
<li>通过发送让主从服务器不一致的命令（主服务器接收到的新写命令）给从服务器并执行，让主从服务器的数据库重新回到一致状态。</li>
</ul>
</li>
</ul>
<blockquote>
<p>SYNC命令的缺陷：如果因为网络问题，导致主从断开链接一段时间，那么重新同步的时候， SYNC无法做到断点继续，而是仍要清空之前数据，并重新开始复制操作。</p>
</blockquote>
<p>SYNC命令非常消耗资源，原因有三点：</p>
<ol>
<li><p>主服务器执行BGSAVE命令生成RDB文件，这个生成过程会大量消耗主服务器资源（CPU、内存和磁盘I/O资源）</p>
</li>
<li><p>主服务器需要将自己生成的RBD文件发送给从从服务器，这个发送操作会消耗主从服务器大量的网络资源（带宽与流量）</p>
</li>
<li><p>接收到RDB文件你的从服务器需要载入RDB文件，载入期间从服务器会因为阻塞而导致没办法处理命令请求。</p>
</li>
</ol>
<h2 id="2-2-新版复制功能"><a href="#2-2-新版复制功能" class="headerlink" title="2.2 新版复制功能"></a>2.2 新版复制功能</h2><p>为了解决旧版本中断线情况下SYNC低效问题，在Redis 2.8之后使用PSYNC命令代替SYNC命令执行复制同步操作，自然PSYNC具备完整重同步和部分重同步模式</p>
<ul>
<li>完整重同步：跟旧版复制基本是一致的，可以理解为“全量”复制。</li>
<li>部分重同步：在命令传播阶段，<strong>断线重复制</strong>只需要发送主服务器<strong>在断开期间执行的写命令</strong>给从服务器即可，可以理解为“增量”复制。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-6b85f71f0d739997ec61cae37975871ef3b.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="2-3-复制的实现"><a href="#2-3-复制的实现" class="headerlink" title="2.3 复制的实现"></a>2.3 复制的实现</h2><p>Redis不管是旧版还是新版，复制的实现都可以分为七个步骤，流程图如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9844df2ae892d6aa2f0eb9bbfe8e2dc0a94.png" alt=""></p>
<ol>
<li>设置主服务的地址与端口<ul>
<li>当客户端向从服务器发送一下命令时或者在配置文件中配置slaveof选项</li>
<li><code>127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379</code></li>
</ul>
</li>
<li>建立套接字连接<ul>
<li>从服务器根据设置的套接字创建连向主服务器的套接字连接<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-cea89403237d39529cf8fe68b1aac463c01.png" alt=""></li>
</ul>
</li>
<li>主服务器接收从服务器的套接字连接之后，为该套接字创建响应的客户端状态，并将此时的从服务器看做是主服务器的客户端，也就是该从服务器同时具备服务器与客户端两个身份。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-6c6228d79603ed7e8091349805b818b0477.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>发送PING命令<ul>
<li>从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送PING命令。PING命令主要有两种作用：<ol>
<li>虽然建立了套接字连接，但是还未使用过，通过发送PING命令检查套接字的读写状态是否正常</li>
<li>通过发送PING命令检查主服务器能否正常处理命令请求</li>
</ol>
</li>
<li>从服务器在发送PING命令之后将遇到以下三种情况的其中一种：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d8186e4f60ecb5a5f4a3d94a6953b0c0f69.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>身份验证<ul>
<li>从服务器接收到主服务器返回的“PONG”回复，接下来就需要考虑身份验证的事。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-693b46071c249bb5a9ec8795a47317135ac.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>发送端口信息<ul>
<li>在身份验证步骤之后，从服务器将执行命令<code>REPLCONF listening-port &lt;port&gt;</code>，向主服务器发送从服务器的监听端口号。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-cca80560a551e9d92bb2561bc4beac8b8f7.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>同步<ul>
<li>就是上述所指的同步操作，从服务器向主服务器发送PSYNC命令，执行同步操作，值得注意的是开始只有从服务器是主服务器的客户端，但是执行同步操作之后，主服务器也会成为从服务器的客户端。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-7297be982c2757e9849b1d018d7e14a69a4.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>命令传播<ul>
<li>主从服务器就会进入命令传播阶段，主服务器只要将自己执行的写命令发送给从服务器，而从服务器只要一直执行并接收主服务器发来的写命令（上述已经介绍过，这里不过多介绍）</li>
</ul>
</li>
</ol>
<h1 id="3-Redis哨兵模型"><a href="#3-Redis哨兵模型" class="headerlink" title="3. Redis哨兵模型"></a>3. Redis哨兵模型</h1><p><strong>Sentinel(哨兵、哨岗)是Redis 的高可用性的解决方案</strong>：有一个或多个Sentinel实例组成的Sentinel系统可以<strong>监视任意多个主服务器，以及这些主服务器属下的所有从服务器</strong>，并在被监视的主服务器进入下线状态时，<strong>自动将下线主服务器属下的某个从服务器升级为主服务器</strong>，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-74b74416d8986d2bc2260d9848302bd26c5.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2e8b33cdecf632546ed70b2a91e16901f44.png" alt=""></p>
<blockquote>
<p>在替换了新的主服务器之后，如果之前下线的主服务器上线了，就会被降为新的主服务器的从服务器。</p>
</blockquote>
<h2 id="3-1-Sentinel的启动"><a href="#3-1-Sentinel的启动" class="headerlink" title="3.1 Sentinel的启动"></a>3.1 Sentinel的启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-sentinel &#x2F;path&#x2F;to&#x2F;your&#x2F;sentinel.conf</span><br><span class="line">或者</span><br><span class="line">$ redis-sentinel &#x2F;path&#x2F;to&#x2F;your&#x2F;sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>

<p>这两个命令都能启动Sentinel，效果都是一样的。</p>
<p>Sentinel启动后，会有五个步骤：</p>
<ol>
<li><p><strong>初始化服务器</strong></p>
<ul>
<li><strong>Sentinel的本质是一个运行在特殊模式下的Redis服务器</strong>，因此启动时必须对其进行初始化，但是由于Sentinel与普通的服务器不同，<strong>它的初始化需要执行的操作也不同</strong>。</li>
<li>下表是Sentinel 模式下Redis服务器的主要功能的使用情况</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-d17c827a40ef959aa665c9f24c9b1bbe054.png" alt=""></li>
</ul>
</li>
<li><p><strong>使用Sentinel专用代码</strong></p>
<ul>
<li>启动Sentinel的第二步，就是将普通Redis服务器使用的代码替换成Sentinel专用的代码。</li>
<li>比如 普通Redis服务器使用 redis.h/REDIS_SERVERPORT常量作为服务端口(#define REDIS_SERVERPORT 6379),使用 redis.h/redisCommandTable 作为服务器的命令表。</li>
<li>而Sentinel使用 reids.h/REDIS_SENTINEL_PORT 常量作为服务器端口，默认26379，使用 redis.h/sentinelcmds 作为服务器的命令表</li>
</ul>
</li>
<li><p><strong>初始化Sentinel状态</strong></p>
<ul>
<li>接下来，服务器会初始化一个 sentinel.c/sentinelState 结构(简称“Sentinel状态”)，这个结构保存了服务器所有和Sentinel功能有关的状态，服务器的一般状态仍然由 redis.h/redisServer 结构保存：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct sentinelState&#123;</span><br><span class="line">	&#x2F;&#x2F; 当前纪元，用于实现故障转移</span><br><span class="line">	uint64_t current_epoch;</span><br><span class="line">	&#x2F;&#x2F; 保存了所有被这个 Sentinel监视的主服务器</span><br><span class="line">	&#x2F;&#x2F; 字典的键是主服务器的名字</span><br><span class="line">	&#x2F;&#x2F; 字典的值是一个指向 sentinelRedisInstance 结构的指针</span><br><span class="line">	dict *masters;</span><br><span class="line">	&#x2F;&#x2F; 是否进入了 TILT 模式</span><br><span class="line">	int tilt;</span><br><span class="line">	&#x2F;&#x2F; 目前正在执行的脚本数量</span><br><span class="line">	int running_scripts;</span><br><span class="line">	&#x2F;&#x2F; 进入 TILT 模式的时间</span><br><span class="line">	mstime_t tilt_start_time;</span><br><span class="line">	&#x2F;&#x2F; 最后一次执行事件处理器的时间</span><br><span class="line">	mstime_t previous_time;</span><br><span class="line">	&#x2F;&#x2F; 一个 FIFO 队列，包含了所有需要执行的用户脚本</span><br><span class="line">	list *scripts_queue;</span><br><span class="line">&#125;sentinel;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>初始化Sentinel状态的 masters 属性</strong></p>
<ul>
<li><p>接下来要做的是将sentinel状态的 masters 属性进行初始化，上面已经说过了，masters 里面保存的是所有被监视的主服务器的信息。master属性是字典，键是主服务器的名字，值是一个指向 sentinelRedisInstance 结构的指针。</p>
</li>
<li><p>我们先介绍一下 sentinelRedisInstance 结构(简称“实例结构”)，这个结构代表着一个被Sentinel监视的Redis服务器实例，可以是主服务器、从服务器或者另外一个Sentinel.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">ypedef struct sentinelRedisInstance &#123;</span><br><span class="line">	&#x2F;&#x2F; 标识值，记录了当前Redis实例的类型和状态</span><br><span class="line">	int flags;      &#x2F;* See SRI_... defines *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 实例的名字</span><br><span class="line">	&#x2F;&#x2F; 主节点的名字由用户在配置文件中设置</span><br><span class="line">	&#x2F;&#x2F; 从节点以及Sentinel节点的名字由Sentinel自动设置，格式为：ip:port</span><br><span class="line">	char *name;     &#x2F;* Master name from the point of view of this sentinel. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;实例的运行 ID</span><br><span class="line">	char *runid;    &#x2F;* Run ID of this instance, or unique ID if is a Sentinel.*&#x2F;</span><br><span class="line">	&#x2F;&#x2F;配置纪元，用于实现故障转移</span><br><span class="line">	uint64_t config_epoch;  &#x2F;* Configuration epoch. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;实例的地址:ip和port</span><br><span class="line">	sentinelAddr *addr; &#x2F;* Master host. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;实例的连接，有可能是被Sentinel共享的</span><br><span class="line">	instanceLink *link; &#x2F;* Link to the instance, may be shared for Sentinels. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 最近一次通过 Pub&#x2F;Sub 发送信息的时间</span><br><span class="line">	mstime_t last_pub_time;   &#x2F;* Last time we sent hello via Pub&#x2F;Sub. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 只有被Sentinel实例使用</span><br><span class="line">	&#x2F;&#x2F; 最近一次接收到从Sentinel发送来hello的时间</span><br><span class="line">	mstime_t last_hello_time; &#x2F;* Only used if SRI_SENTINEL is set. Last time</span><br><span class="line">								 we received a hello from this Sentinel</span><br><span class="line">								 via Pub&#x2F;Sub. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 最近一次回复SENTINEL is-master-down的时间                             </span><br><span class="line">	mstime_t last_master_down_reply_time; &#x2F;* Time of last reply to</span><br><span class="line">											 SENTINEL is-master-down command. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 实例被判断为主观下线的时间                                         </span><br><span class="line">	mstime_t s_down_since_time; &#x2F;* Subjectively down since time. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 实例被判断为客观下线的时间</span><br><span class="line">	mstime_t o_down_since_time; &#x2F;* Objectively down since time. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down）</span><br><span class="line">	mstime_t down_after_period; &#x2F;* Consider it down after that period. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 从实例获取INFO命令回复的时间</span><br><span class="line">	mstime_t info_refresh;  &#x2F;* Time at which we received INFO output from it. *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Role and the first time we observed it.</span><br><span class="line">	 * This is useful in order to delay replacing what the instance reports</span><br><span class="line">	 * with our own configuration. We need to always wait some time in order</span><br><span class="line">	 * to give a chance to the leader to report the new configuration before</span><br><span class="line">	 * we do silly things. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 实例的角色 </span><br><span class="line">	int role_reported;</span><br><span class="line">	&#x2F;&#x2F; 角色更新的时间</span><br><span class="line">	mstime_t role_reported_time;</span><br><span class="line">	&#x2F;&#x2F; 最近一次从节点的主节点地址变更的时间</span><br><span class="line">	mstime_t slave_conf_change_time; &#x2F;* Last time slave master addr changed. *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Master specific. *&#x2F;</span><br><span class="line">	 &#x2F;*----------------------------------主节点特有的属性----------------------------------*&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 其他监控相同主节点的Sentinel</span><br><span class="line">	dict *sentinels;    &#x2F;* Other sentinels monitoring the same master. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 如果当前实例是主节点，那么slaves保存着该主节点的所有从节点实例</span><br><span class="line">	&#x2F;&#x2F; 键是从节点命令，值是从节点服务器对应的sentinelRedisInstance</span><br><span class="line">	dict *slaves;       &#x2F;* Slaves for this master instance. *&#x2F;</span><br><span class="line">	  &#x2F;&#x2F; 判定该主节点客观下线（objectively down）的投票数</span><br><span class="line">	&#x2F;&#x2F; 由SENTINEL monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;配置</span><br><span class="line">	unsigned int quorum;&#x2F;* Number of sentinels that need to agree on failure. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; SENTINEL parallel-syncs &lt;master-name&gt; &lt;number&gt; 选项的值</span><br><span class="line">	&#x2F;&#x2F; 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span><br><span class="line">	int parallel_syncs; &#x2F;* How many slaves to reconfigure at same time. *&#x2F;</span><br><span class="line">	  &#x2F;&#x2F; 连接主节点和从节点的认证密码</span><br><span class="line">	char *auth_pass;    &#x2F;* Password to use for AUTH against master &amp; slaves. *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Slave specific. *&#x2F;</span><br><span class="line">	&#x2F;*----------------------------------从节点特有的属性----------------------------------*&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 从节点复制操作断开时间</span><br><span class="line">	mstime_t master_link_down_time; &#x2F;* Slave replication link down time. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 按照INFO命令输出的从节点优先级</span><br><span class="line">	int slave_priority; &#x2F;* Slave priority according to its INFO output. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 故障转移时，从节点发送SLAVEOF &lt;new&gt;命令的时间</span><br><span class="line">	mstime_t slave_reconf_sent_time; &#x2F;* Time at which we sent SLAVE OF &lt;new&gt; *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 如果当前实例是从节点，那么保存该从节点连接的主节点实例</span><br><span class="line">	struct sentinelRedisInstance *master; &#x2F;* Master instance if it&#39;s slave. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; INFO命令的回复中记录的主节点的IP</span><br><span class="line">	char *slave_master_host;    &#x2F;* Master host as reported by INFO *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; INFO命令的回复中记录的主节点的port</span><br><span class="line">	int slave_master_port;      &#x2F;* Master port as reported by INFO *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; INFO命令的回复中记录的主从服务器连接的状态</span><br><span class="line">	int slave_master_link_status; &#x2F;* Master link status as reported by INFO *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 从节点复制偏移量</span><br><span class="line">	unsigned long long slave_repl_offset; &#x2F;* Slave replication offset. *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Failover *&#x2F;</span><br><span class="line">	 &#x2F;*----------------------------------故障转移的属性----------------------------------*&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 如果这是一个主节点实例，那么leader保存的是执行故障转移的Sentinel的runid</span><br><span class="line">	&#x2F;&#x2F; 如果这是一个Sentinel实例，那么leader保存的是当前这个Sentinel实例选举出来的领头的runid</span><br><span class="line">	char *leader;       &#x2F;* If this is a master instance, this is the runid of</span><br><span class="line">						   the Sentinel that should perform the failover. If</span><br><span class="line">						   this is a Sentinel, this is the runid of the Sentinel</span><br><span class="line">						   that this Sentinel voted as leader. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; leader字段的纪元                       </span><br><span class="line">	uint64_t leader_epoch; &#x2F;* Epoch of the &#39;leader&#39; field. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 当前执行故障转移的纪元</span><br><span class="line">	uint64_t failover_epoch; &#x2F;* Epoch of the currently started failover. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 故障转移操作的状态</span><br><span class="line">	int failover_state; &#x2F;* See SENTINEL_FAILOVER_STATE_* defines. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 故障转移操作状态改变的时间</span><br><span class="line">	mstime_t failover_state_change_time;</span><br><span class="line">	&#x2F;&#x2F; 最近一次故障转移尝试开始的时间</span><br><span class="line">	mstime_t failover_start_time;   &#x2F;* Last failover attempt start time. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;  更新故障转移状态的最大超时时间</span><br><span class="line">	mstime_t failover_timeout;      &#x2F;* Max time to refresh failover state. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 记录故障转移延迟的时间</span><br><span class="line">	mstime_t failover_delay_logged; &#x2F;* For what failover_start_time value we</span><br><span class="line">									   logged the failover delay. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 晋升为新主节点的从节点实例                                   </span><br><span class="line">	struct sentinelRedisInstance *promoted_slave; &#x2F;* Promoted slave instance. *&#x2F;</span><br><span class="line">	&#x2F;* Scripts executed to notify admin or reconfigure clients: when they</span><br><span class="line">	 * are set to NULL no script is executed. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 通知admin的可执行脚本的地址，如果设置为空，则没有执行的脚本 </span><br><span class="line">	char *notification_script;</span><br><span class="line">	 &#x2F;&#x2F; 通知配置的client的可执行脚本的地址，如果设置为空，则没有执行的脚本</span><br><span class="line">	char *client_reconfig_script;</span><br><span class="line">	&#x2F;&#x2F; 缓存INFO命令的输出 </span><br><span class="line">	sds info; &#x2F;* cached INFO output *&#x2F;</span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure></li>
<li><p>其中的 addr 属性是一个指向 sentinel.c/sentinelAddr 结构的指针，这个结构保存实例的IP地址和端口号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct sentinelAddr&#123;</span><br><span class="line">	char *p;</span><br><span class="line">	int port;</span><br><span class="line">&#125;sentinelAddr;</span><br></pre></td></tr></table></figure></li>
<li><p>对Sentinel 状态的初始化将引发对 masters 字典的初始化,而 masters 字典的初始化是根据被载入的Sentinel配置文件来进行的。<strong>假设我们有master1和master2，由如下图1的配置文件导入</strong>：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-63050f2a3d66283638dc1c17d2f1ec19778.png" alt=""></li>
</ul>
</li>
<li><p>那么我们得到两个sentinelRedisInstance：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-f7d42df36db19bd7fa4c53b9e289381dc62.png" alt=""></li>
<li><img src="https://oscimg.oschina.net/oscnet/up-238ac368f60e323211e08ebaeb8e7308450.png" alt=""></li>
</ul>
</li>
<li><p>最终sentinelRedisInstance为：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-235ef5d9525c74626220b099acbff598f27.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>创建连向主服务器的网络连接</p>
<ul>
<li>这是最后一步啦，这一步是创建连向被监视主服务器的网络连接，<strong>Sentinel将成为主服务器的客户端</strong>，可以向主服务器发送命令，并从命令回复中获取相关的信息。</li>
<li>每个被Sentinel监视的主服务器，Sentinel会创建两个连向主服务器的异步网络连接：<ol>
<li>命令连接，用于向主服务器发送命令，并接收命令回复</li>
<li>订阅连接，用于订阅主服务器的<code>__sentinel__:hello</code>频道</li>
</ol>
</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-4dd23054ec9ad51b2c753001abd3bbe46a5.png" alt=""><h2 id="3-2-Sentinel与服务器的交互"><a href="#3-2-Sentinel与服务器的交互" class="headerlink" title="3.2 Sentinel与服务器的交互"></a>3.2 Sentinel与服务器的交互</h2></li>
</ul>
</li>
</ol>
<p>Sentinel作为一个监视Redis服务器的监控系统，必然需要有如下的权利或者义务：</p>
<ol>
<li><p>要能掌握被自己监视的主服务器和其从服务器的状态信息</p>
<ul>
<li><strong>INFO命令</strong>：每十秒一次，通过<strong>命令链接</strong>向被监视的主服务和从服务器发送<strong>INFO命令</strong>。分析主服务器的应答得到主服务器的状态信息。</li>
</ul>
</li>
<li><p>要有为“与自己监视了相同服务器的其他Sentinel”感知到自己提供便利的义务。</p>
<ul>
<li><strong>广播频道消息</strong>：Sentinel每两秒一次，通过<strong>命令链接</strong>向所有被自己监视的主服务器和从服务器发送<strong>PUBLISH命令</strong>，发布自己的一些状态信息到对应主服务器的<strong>sentinel</strong>:hello频道，以便让其他监视了同一服务器的Sentinel（当然这些Sentinel也订阅了该服务器的<strong>sentinel</strong>:hello频道）感知到自己的存在，宣誓主权。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-5cc7e6782bf95df108607d7a9179b94f625.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>要能感知到“与自己监视了同一服务器的其他Sentinel”的状态信息。</p>
<ul>
<li><strong>接收频道消息</strong>：Sentinel在与主服务器创建订阅链接后就会通过订阅命令来订阅主服务器的<strong>sentinel</strong>:hello频道。通过<strong>订阅链接</strong>，Sentinel能接收到该频道上其他Sentinel发布的他们各自的状态信息。从而感知到他们的存在。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-5b9e81f3a2d2692d744f2dd17340e377a4a.png" alt=""></li>
</ul>
</li>
<li><strong>创建Sentinel之间的链接</strong>：Sentinel A 感知到另一个Sentinel B 时，如果是第一次感知到，那么A会创建连向B的命令链接。当然B也会有一个发现A的过程，所以对于监视相同服务器的Sentinel来说，他们是这样相互关联的。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-e15a80cc3eaec80234386903b967ca94f1d.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>归纳完毕，现在我们来一一展开介绍：</p>
<h3 id="3-2-1-INFO命令"><a href="#3-2-1-INFO命令" class="headerlink" title="3.2.1 INFO命令"></a>3.2.1 INFO命令</h3><p>假设有个主服务器和三个从服务器。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-cc3509fe121399c911c2c76c9141eae43f0.png" alt=""></p>
<p>Sentinel 默认每十秒一次，通过命令连接向被监视的主服务器发送 INFO 命令，得到如下信息：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bc6314d42194e83e8c3024d39401f1ba78e.png" alt=""></p>
<ul>
<li>关于服务器本身的信息<ul>
<li>包括 run_id 域记录的服务器运行ID，以及 role 域记录的服务器角色</li>
</ul>
</li>
<li>关于主服务器属下的所有从服务器信息<ul>
<li>每个从服务器都由一个“slave”字符串开头的行记录，每行的 ip= 域记录了从服务器的IP地址, port= 域记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器。</li>
</ul>
</li>
</ul>
<p>根据 run_id 域和 role 域的信息，Sentinel将对主服务器的实例结构（sentinelRedisInstance）进行更新。而主服务器返回的从服务器信息，将会被用于更新主服务器实例结构（sentinelRedisInstance）的 slaves 字典(记录了属下从服务器的名单，key为ip:port格式，值指向从服务器的sentinelRedisInstance实例)。</p>
<p>Sentinel 分析 INFO 命令中包含的从服务器信息时，会检查这个从服务器实例结构(sentinelRedisInstance）是否已经存在于主服务器的 slaves 字典： 如果存在，就对从服务器的实例结构进行更新，如果不存在(表明这个从服务器是新发现的从服务器)，Sentinel会在 slaves 字典中为这个从服务器创建一个新的实例结构。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-39a3a3f5b3381711f3063c1719f4ab03f89.png" alt=""></p>
<p>当Sentinel发现主服务器有新的服务器出现时，除了会为这个新从服务器创建相应的实例结构之外，<strong>还会创建连接到从服务器的命令连接和订阅连接</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0301ec71756c260aaae4f67a696c939939c.png" alt=""></p>
<p>创建了命令连接之后，每10秒一次向从服务器发送 INFO 命令，依次来维护从服务器的实例结构(sentinelRedisInstance）的状态。</p>
<blockquote>
<p>主服务器实例结构的 flags 值为 SRI_MASTER,从服务器是 SRI_SLAVE</p>
</blockquote>
<h3 id="3-2-2-广播频道消息"><a href="#3-2-2-广播频道消息" class="headerlink" title="3.2.2 广播频道消息"></a>3.2.2 广播频道消息</h3><p>Sentinel会<strong>每两秒一次</strong>，通过<strong>命令连接</strong>向所有被监视的主服务器和从服务器发送以下格式的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,</span><br><span class="line">	&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>这条命令就表示向服务器的 __sentinel__:hello 频道发送一条信息，信息由一下部分组成：</p>
<ul>
<li>以 s_ 开头的参数记录Sentinel本身的信息</li>
<li>以 m_ 开头的参数则是该频道所属的主服务器的信息，当然如果监视的是从服务器，这个信息表示的就是所属的从服务器的信息</li>
<li>具体含义如下图</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-0554962e101651acacc73f8c04897f3d7ef.png" alt=""></li>
</ul>
<h3 id="3-2-3-接收频道消息"><a href="#3-2-3-接收频道消息" class="headerlink" title="3.2.3 接收频道消息"></a>3.2.3 接收频道消息</h3><p>在建立起订阅连接之后，Sentinel会通过这个连接，向服务器发送<code>SUBSCRIBE __sentinel__:hello</code>命令，也就是订阅这个频道，这个订阅关系会一直持续到Sentinel与服务器的连接断开之后。</p>
<p>对于监视同一服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他的Sentinel接收到，并用于更新其他Sentinel对发送信息Sentinel的认知，和被用于更新其他Sentinel对被监视服务器的认知。</p>
<p>假如该<strong>Sentinel A</strong>从其监控的<strong>主服务器M</strong>的 <code>__sentinel__:hello</code>频道中，接收到其他<strong>Sentinel B</strong>发来的<code>&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;</code>格式的信息后，Sentinel A会从信息中分析出以下信息：</p>
<ul>
<li>与Sentinel相关的参数：Sentinel B的IP、port、run_id、配置纪元</li>
<li>与主服务器相关参数：Sentinel B 正在监视的这个主服务器（也就是主服务器M）的名字、IP、port、配置纪元</li>
</ul>
<p>服务器实例结构（sentinelRedisInstance）中除了slave字典外，还有一个sentinels字典，存放着其他共同监控着这个主服务器的sentinels的状态信息。<strong>这个字典的键是Sentinel的名字，格式：ip:port。值是对应Sentinel的实例结构(还是sentinelRedisInstance结构)。</strong></p>
<p>根据之前那些主服务器参数，Sentinel A 会在自己的Sentinel状态（sentinelState）的 masters 字典中查找相应的主服务器实例结构（sentinelRedisInstance），然后根据Sentinel参数，检查主服务器实例结构的 sentinels 字典中，Sentinel B的实例结构是否存在：</p>
<ul>
<li>存在，就对Sentinel B的实例结构进行更新</li>
<li>存在，说明Sentinel B是才开始监视主服务器的新Sentinel，Sentinel A 会为Sentinel B创建一个新的实例结构，并将这个结构添加到 sentinels 字典里面</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-084760de95dd05ca210595633b1328d141f.png" alt=""></p>
<h3 id="3-2-4-创建Sentinel之间的链接"><a href="#3-2-4-创建Sentinel之间的链接" class="headerlink" title="3.2.4 创建Sentinel之间的链接"></a>3.2.4 创建Sentinel之间的链接</h3><p>当Sentinel通过频道信息发现了一个新的Sentinel时，它不仅会为新的Sentinel在 sentinels 字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接。</p>
<p>新的Sentinel同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的多个Sentinel将形成相互连接的网络：SentinelA有连向SentinelB的命令连接，SentinelB也有连向SentinelA的命令连接。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e15a80cc3eaec80234386903b967ca94f1d.png" alt=""></p>
<blockquote>
<p>Sentinel之间不会创建订阅连接</p>
</blockquote>
<h2 id="3-3-监控下线和故障转移"><a href="#3-3-监控下线和故障转移" class="headerlink" title="3.3 监控下线和故障转移"></a>3.3 监控下线和故障转移</h2><p>了解了Sentinel与服务器/其他Sentinel的交互方式后，就可以来着手解决实际问题了，Sentinel的使命主要有两点：</p>
<ul>
<li>监控下线</li>
<li>选举领头sentinel</li>
<li>故障转移</li>
</ul>
<h3 id="3-3-1-监控下线"><a href="#3-3-1-监控下线" class="headerlink" title="3.3.1 监控下线"></a>3.3.1 监控下线</h3><h4 id="3-3-1-1-检测主观下线状态"><a href="#3-3-1-1-检测主观下线状态" class="headerlink" title="3.3.1.1 检测主观下线状态"></a>3.3.1.1 检测主观下线状态</h4><p>主观下线状态，即单个sentinel认为某个<strong>主服务器/从服务器/sentinel</strong>下线了，至于是不是真的已经下线，则不一定。</p>
<ul>
<li>默认情况下，Sentinel会以<strong>每秒一次</strong>的频率向所有与它创建了<strong>命令连接</strong>的实例(包括主服务器、从服务器、其他Sentinel在内)发送 <code>PING</code> 命令，并通过实例返回的 <code>PING</code> 命令回复来判断实例是否在线。</li>
<li>对 <code>PING</code> 命令的回复，Redis只认两种含义：<ul>
<li>有效回复：实例返回 +PONG 、 -LOADING 、-MASTERDOWN 三种其中一种</li>
<li>无效回复，除了上面三种之外的其它回复，或者在指定时限内没有返回任何回复</li>
</ul>
</li>
<li>Sentinel配置文件中的 down-after-millseconds 选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在 down-after-millseconds 毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的 flags 属性中打上 <code>SRI_S_DOWN</code> 标识，用于表示这个实例已经进入主观下线状态。（也就是我认为你已经下线了）</li>
</ul>
<blockquote>
<p>主观下线时长选项，即 down-after-millseconds 的值，不仅会被Sentinel用于判断其监控的主服务器的主观下线状态，还会被用于判断该主服务器属下的所有从服务器，以及所有同样监视这个主服务器的其他Sentinel的主观下线状态。</p>
</blockquote>
<blockquote>
<p>多个Sentinel设置的主观下线时长可能不同，对于监视同一个主服务器的多个Sentinel来说，这些Sentinel设置的 down-after-milliseconds 选项的值可能不同，因此，当一个Sentinel将主服务器判断为主观下线时，其它Sentinel可能任然会认为主服务器处于在线状态。</p>
</blockquote>
<h4 id="3-3-1-2-检测客观下线状态"><a href="#3-3-1-2-检测客观下线状态" class="headerlink" title="3.3.1.2 检测客观下线状态"></a>3.3.1.2 检测客观下线状态</h4><p>客观下线状态，即经过确认后，可断定为事实上确实下线了。</p>
<p>当Sentinel将一个主服务器判断为主观下线之后，为确定这个服务器是否真的下线，它会<strong>向同样监视这个主服务器的其它Sentinel进行询问</strong>，当接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器进行故障转移操作。</p>
<ul>
<li>发送 <code>SENTINEL is-master-down-by-addr</code> 命令<ul>
<li>entinel会发送下面的命令询问其它Sentinel是否同意主服务器下线：</li>
<li><code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code></li>
<li><img src="https://oscimg.oschina.net/oscnet/up-1bff3ef7742eb8463677f3e0c00fb30240d.png" alt=""></li>
</ul>
</li>
<li>接收 <code>SENTINEL is-master-down-by-addr</code> 命令<ul>
<li>当一个Sentinel(目标Sentinel)接收到另外一个Sentinel(源Sentinel)发来的 <code>SENTINEL is-master-by-addr</code>命令时，目标Sentinel会分析并取出命令请求中包含的各个参数，并根据其中的IP和port，判断主服务器是否已经下线，然后向源Sentinel返回一个包含三个参数的 Multi Bulk 回复作为这个命令的回复。这三个参数分别是：<ol>
<li><strong><down_state></strong>：返回目标Sentinel对主服务器的检查结果，1表示主服务器已下线，0表示主服务器未下线</li>
<li><strong><leader_runid></strong>：可以是 * 符号或者目标Sentinel的局部领头Sentinel的运行ID，*表示命令仅仅用于检测主服务器的下线状态，而局部领头Sentinel的运行ID则用于选举领头Sentinel</li>
<li><strong><leader_epoch></strong>：目标Sentinel的局部领头Sentinel的配置纪元，用于选举领头Sentinel。仅在 leader_runid 值不为 * 时有效，如果其值为 * ,这个参数总为0</li>
</ol>
</li>
</ul>
</li>
<li>接收 <code>SENTINEL is-master-down-by-addr</code> 命令之后<ul>
<li>根据其他Sentinel发回的 <code>SENTINEL is-master-down-by-addr</code>回复，Sentinel会统计反馈了“同意这个主服务器已经下线”这个信息的sentinel数量。</li>
<li>当这个值达到配置指定的判断客观下线所需的数量时(即 quorum 属性的值)，Sentinel会将主服务器实例结构中（sentinelRedisInstance） flags 属性的 SRI_O_DOWN 标识打开，标识主服务器已经进入客观下线状态。</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-选举领头sentinel"><a href="#3-3-2-选举领头sentinel" class="headerlink" title="3.3.2 选举领头sentinel"></a>3.3.2 选举领头sentinel</h3><p>当一个Master服务器客观下线后，<strong>监控这个Master服务器的所有Sentinel</strong>将会选举出一个领头Sentinel。并由领头Sentinel对客观下线的Master进行故障转移。</p>
<p>选举领头Sentinel的规则和方法:</p>
<ol>
<li><p>所有监控客观下线Master的Sentinel都有可能成为领头Sentinel。每次进行领头Sentinel选举之后，不论是否选举成功，<strong>所有Sentinel的配置纪元（configuration epoch）的值都会自动增加一次</strong>。</p>
</li>
<li><p>在一个配置纪元里面，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头Sentinel一旦设置，<strong>在这个配置纪元里面将不能再更改</strong>。</p>
</li>
<li><p>监视Master客观下线的所有在线Sentinel都有要求其它Sentinel将自己设置为局部领头Sentinel的机会。</p>
</li>
<li><p>当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送<code>SENTINEL is-master-down-by-addr</code>命令，<strong>并且命令中的runid参数不是“*”符号而是当前Sentinel的运行ID时，这表示当前Sentinel要求目标Sentinel将自己设置为领头Sentinel</strong>。</p>
</li>
<li><p>Sentinel设置局部领头Sentinel的规则是<strong>先到先得</strong>。即最先向目标Sentinel发送设置要求的Sentinel将会成为局部领头Sentinel，之后<strong>接受到的请求都会被拒绝</strong>。</p>
</li>
<li><p>目标Sentinel接收到SENTINEL is-master-down-by-addr命令后，将向源Sentinel返回一条命令回复，<strong>回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元</strong>。</p>
</li>
<li><p>源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源Sentinel继续取出回复中的leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一直，<strong>那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel，记录下来</strong>。</p>
</li>
<li><p>记录之后，如果有某个Sentinel发现自己已经被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel就会成为领头Sentinel。</p>
</li>
<li><p>领头Sentinel的产生需要半数以上的Sentinel支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel。</p>
</li>
<li><p>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后<strong>再次进行选举</strong>，直到选出领头Sentinel为止，（所以建议哨兵设置奇数个，且数量不小于3）。</p>
</li>
</ol>
<h3 id="3-3-3-故障转移"><a href="#3-3-3-故障转移" class="headerlink" title="3.3.3 故障转移"></a>3.3.3 故障转移</h3><p>接收到<code>SENTINEL is-master-down-by-addr</code>命令回复的源Sentinel可以统计出有多少个Sentinel将自己设置成局部领头Sentinel。如果超过半数，则当前Sentinel就会被选为领头Sentinel并进行故障转移。</p>
<p>故障转移包括以下三步：</p>
<ol>
<li>在已下线的Master主机下面挑选一个他的Slave服务器，并将其转换为主服务器。</li>
<li>让<strong>其余</strong>所有Slave服务器复制新的Master服务器。</li>
<li>让已下线的Master服务器变成新的Master服务器的Slave。当已下线的服务器再次上线后将复新的Master的数据。</li>
</ol>
<h4 id="3-3-3-1-选举新的主服务器的过程"><a href="#3-3-3-1-选举新的主服务器的过程" class="headerlink" title="3.3.3.1 选举新的主服务器的过程"></a>3.3.3.1 选举新的主服务器的过程</h4><p>领头Sentinel会在所有Slave中选出新的Master，发送<strong>SLAVEOF no one</strong>命令，将这个服务器确定为主服务器。</p>
<p>领头Sentinel会将已下线Master的所有从服务器保存在一个列表中，按照以下规则，一项一项进行<strong>过滤</strong>。</p>
<ol>
<li><p>删除列表中所有处于下线或者短线状态的Slave。（保证剩下都是在线的）</p>
</li>
<li><p>删除列表中所有最近5s内没有回复过领头Sentinel的INFO命令的Slave。（保证剩下都是近期成功通信过的）</p>
</li>
<li><p>删除所有与<strong>下线Master</strong>连接断开超过down-after-milliseconds * 10毫秒的Slave。（过滤掉过早的和下线Master断开连接的，这样可以保证剩下的Slave，数据都比较新）</p>
</li>
<li><p>领头Sentinel将根据Slave优先级，对列表中剩余的Slave进行排序，并选出其中优先级最高的Slave。</p>
</li>
<li><p>如果有多个具有相同优先级的Slave，那么领头Sentinel将按照Slave复制偏移量，选出其中偏移量最大的Slave。（复制偏移量的slave就是保存的最新数据的slave）</p>
</li>
<li><p>如果有多个优先级最高，偏移量最大的Slave，那么根据运行ID最小原则选出新的Master。</p>
</li>
</ol>
<p>确定新的Master之后，领头Sentinel会以<strong>每秒一次</strong>的频率向新的Master发送INFO命令，当得到确切的回复：role由slave变为master之后，当前服务器顺利升级为Master服务器。</p>
<h4 id="3-3-3-2-修改从服务器的复制目标"><a href="#3-3-3-2-修改从服务器的复制目标" class="headerlink" title="3.3.3.2 修改从服务器的复制目标"></a>3.3.3.2 修改从服务器的复制目标</h4><p>选出新的Master服务器后，领头Sentinel会向<strong>下线Master的剩余Slave</strong>发送SLAVEOF命令，让它们复制新的Master。</p>
<h4 id="3-3-3-3-将旧的Master变成Slave"><a href="#3-3-3-3-将旧的Master变成Slave" class="headerlink" title="3.3.3.3 将旧的Master变成Slave"></a>3.3.3.3 将旧的Master变成Slave</h4><p>当已下线的Master重新上线后，领头Sentinel会向此服务器发送SLAVEOF命令，将当前服务器变成新的Master的Slave。</p>
<h1 id="4-集群模式"><a href="#4-集群模式" class="headerlink" title="4. 集群模式"></a>4. 集群模式</h1><p>Redis集群是Redis的分布式数据库方案，通过分片来进行数据共享，并提供复制和故障转移功能。集群为Redis提供了更加便利的水平拓展能力，是现代企业级Redis实现高吞吐高并发的重要实现。</p>
<ul>
<li>集群模式和主从模式的区别：<ul>
<li>主从模式<ul>
<li>指的是针对多台redis实例时候，只存在一台主服务器master，提供读写的功能，同时存在依附在这台主服务器的从服务器slaver，只提供读服务。</li>
<li>主从作用是：读写分离，分散访问量，提高访问可读性，同时保证数据的冗余和备份。</li>
</ul>
</li>
<li>集群模式<ul>
<li>指的是针对多个redis实例，去中心化，去中间件，集群中的每个节点都是平等的关系，都是对等的。</li>
<li>集群的作用是：实现扩容、分摊压力、无中心配置相对简单。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-1-节点"><a href="#4-1-节点" class="headerlink" title="4.1 节点"></a>4.1 节点</h2><p>节点，<strong>指的就是我们之前说的Redis服务器</strong>。</p>
<p>一个Redis 集群通常由多个节点组成，在刚开始的时候，每个节点都是独立的，只处于只包含自己的集群中（也就是之前我们说到的单机模式），当要组成一个真正可工作的集群时，就需要将这些独立的节点连接起来，构建成一个包含多个节点的集群。</p>
<p>如何连接各个节点？使用<code>CLUSTER MEET</code>命令</p>
<p><code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code></p>
<p>向一个节点发送<code>CLUSTER MEET</code>命令，可以让节点与ip和port所指定的节点进行握手，握手成功，节点就会将ip和port指定的节点添加到当前的集群中。</p>
<blockquote>
<p>节点A向节点B发送<code>CLUSTER MEET</code>命令，那么B将会加入A的集群中。反之，A加入B的集群中。</p>
</blockquote>
<p>在启动时，服务器会根据 <code>cluster-enabled</code> 配置选项来决定是否开启集群模式。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6885d13841ad33d7783816ac2e8c63736dd.png" alt=""></p>
<h3 id="4-2-集群数据结构"><a href="#4-2-集群数据结构" class="headerlink" title="4.2  集群数据结构"></a>4.2  集群数据结构</h3><p>Redis使用clusterNode结构来保存一个节点的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一个节点的当前状态</span><br><span class="line">struct clusterNode&#123;    </span><br><span class="line">    &#x2F;&#x2F; 创建节点的时间    </span><br><span class="line">    mstime_t ctime;    </span><br><span class="line">    &#x2F;&#x2F; 节点的名字，由40个16进制字符组成    </span><br><span class="line">    char name[REDIS_CLUSTER_NAMELEN];    </span><br><span class="line">    &#x2F;&#x2F; 节点标识    </span><br><span class="line">    int flags;    </span><br><span class="line">    &#x2F;&#x2F; 节点当前的配置纪元，用于实现故障转移    </span><br><span class="line">    uint64_t configEpoch;    </span><br><span class="line">    &#x2F;&#x2F; 节点的ip地址    </span><br><span class="line">    char ip[REDIS_IP_STR_LEN];    </span><br><span class="line">    &#x2F;&#x2F; 节点的端口号    </span><br><span class="line">    int port；    </span><br><span class="line">    &#x2F;&#x2F; 保存连接节点所需的有关信息   </span><br><span class="line">    clusterLink *link；    </span><br><span class="line">    &#x2F;&#x2F;……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>clusterNode 结构的 link 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterLink &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 连接的创建时间</span><br><span class="line">    mstime_t ctime;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TCP 套接字描述符</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 输出缓冲区，保存着等待发送给其他节点的消息（message）。</span><br><span class="line">    sds sndbuf;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 输入缓冲区，保存着从其他节点接收到的消息。</span><br><span class="line">    sds rcvbuf;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 与这个连接相关联的节点，如果没有的话就为 NULL</span><br><span class="line">    struct clusterNode *node;</span><br><span class="line"></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>
<p>最后，每个节点都保存着一个clusterState结构，这个结构记录了<strong>在当前节点的视角下集群目前所处的状态</strong>，比如集群是在线还是下线，包含多少个节点，当前的配置纪元等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向当前节点的指针</span><br><span class="line">    clusterNode *myself;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集群当前的配置纪元，用于实现故障转移</span><br><span class="line">    uint64_t currentEpoch;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集群当前的状态：是在线还是下线</span><br><span class="line">    int state;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集群中至少处理着一个槽的节点的数量</span><br><span class="line">    int size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集群节点名单（包括 myself 节点）</span><br><span class="line">    &#x2F;&#x2F; 字典的键为节点的名字，字典的值为节点对应的 clusterNode 结构</span><br><span class="line">    dict *nodes;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/up-cb0413dac3d1923097cdf136316e96c8f4f.png" alt=""></p>
<h3 id="4-2-1-CLUSTER-MEET-命令的实现"><a href="#4-2-1-CLUSTER-MEET-命令的实现" class="headerlink" title="4.2.1 CLUSTER MEET 命令的实现"></a>4.2.1 CLUSTER MEET 命令的实现</h3><p>向节点A发送 CLUSTER MEET 命令，能让接收命令的节点A将另一个节点B（ip和port指向的节点）添加到节点A当前所处的集群里。</p>
<p>收到命令的节点A 和节点B进行握手，以此来确认彼此的存在，并为将来的进一步通信打好基础：</p>
<ol>
<li><p>节点A为节点B创建一个clusterNode结构，并将该结构添加到节点A自己的clusterState.nodes字典中。</p>
</li>
<li><p>节点A根据ip和port发送meet消息给节点B。</p>
</li>
<li><p>如果一切顺利，节点B收到meet消息，为节点A创建一个clusterNode结构，并将该结构添加到节点B自己的clusterState.nodes字典中。</p>
</li>
<li><p>如果一切顺利，节点B向节点A发送PONG消息</p>
</li>
<li><p>如果一切顺利，节点A向节点B返回PING消息</p>
</li>
<li><p>如果一切顺利，至此，握手完成</p>
</li>
<li><p>最后节点A会向自己处于的集群内的其他节点发送信息，让其他节点也和B节点握手，最终达到集群内的所有节点都相互认识彼此。至此，B节点加入进集群。</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-40fa2846f5067087ba601c5ba8b0658df00.png" alt=""></p>
<h2 id="4-3-redis负载均衡算法——hash-slot"><a href="#4-3-redis负载均衡算法——hash-slot" class="headerlink" title="4.3 redis负载均衡算法——hash slot"></a>4.3 redis负载均衡算法——hash slot</h2><p>Redis使用分片的方式来保存数据库中的键值对：整个集群被分为16384个槽(slot)，数据库中的每个键都位于这其中的某个槽上，集群中的节点，最少可以处理0个槽，最多可以处理16384个槽。</p>
<p><strong>当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态，否则，处于下线状态。</strong></p>
<p>我们可以使用CLUSTER ADDSLOTS命令来给某个节点指派要处理的槽：</p>
<p><code>CLUSTER ADDSLOTS [slot ...]</code></p>
<p>这个命令接受一个或多个槽的编号作为参数，并将所有输入的槽指派给接收该命令的节点负责。</p>
<p>如<code>CLUSTER ADDSLOTS 0 1 2 3 ... 1000</code></p>
<p>表示将槽0到槽1000指派给接收到命令的整个节点负责。</p>
<h3 id="4-3-1-记录节点的槽指派信息"><a href="#4-3-1-记录节点的槽指派信息" class="headerlink" title="4.3.1 记录节点的槽指派信息"></a>4.3.1 记录节点的槽指派信息</h3><p>clusterNode结构中的slots数组和numslots字段记录了该节点负责处理的槽。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个节点的当前状态</span><br><span class="line">struct clusterNode&#123;</span><br><span class="line">    &#x2F;&#x2F;……</span><br><span class="line">    &#x2F;&#x2F; 记录处理那些槽</span><br><span class="line">    &#x2F;&#x2F; 二进制位数组，长度为 2048 个字节，包含 16384 个二进制位</span><br><span class="line">    &#x2F;&#x2F; 如果slots数组在索引i上的二进制位的值为1，那么表示节点负责处理槽i；否则表示节点不负责处理槽i</span><br><span class="line">    unsigned char slots[16384&#x2F;8];</span><br><span class="line">    &#x2F;&#x2F;记录自己负责处理的槽的数量</span><br><span class="line">    int numslots;</span><br><span class="line">    &#x2F;&#x2F;……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>slots数组有16384个二进制位，<strong>第i项上的二进制值如果为1，则表示槽i由自己负责。为0则表示槽i不是由自己负责</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-08c2162c6cae22ff35c3fd9c53e0ec5bf8c.png" alt=""></p>
<p>数组的定位时间复杂度是O(1)，这样的设计可以让节点非常快速的知道某个槽到底是不是由自己负责。</p>
<h3 id="4-3-2-传播节点的槽指派信息"><a href="#4-3-2-传播节点的槽指派信息" class="headerlink" title="4.3.2 传播节点的槽指派信息"></a>4.3.2 传播节点的槽指派信息</h3><p>一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外，它还会<strong>将自己的slots数组通过消息发送给集群中其他的节点</strong>，以此来告知其他节点自己目前负责处理哪些槽。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4068617fde399f6fe494c764ff1e330620c.png" alt=""></p>
<p>当节点A通过消息从节点B那里接收到节点B的slots数组时，节点A会在<strong>自己的clusterState.nodes字典中</strong>查找<strong>节点B对应的clusterNode结构</strong>，并对该clusterNode结构中的slots数组进行保存或者更新。</p>
<p>每个节点都相互分享自己的槽指派信息，每个节点又在自己的clusterState.nodes字典中保存其他节点的槽指派信息，因此，集群中的每个节点都会知道整个集群数据库的全部槽，都分别被分派给了哪些节点。</p>
<h3 id="4-3-3-记录集群所有槽的指派信息"><a href="#4-3-3-记录集群所有槽的指派信息" class="headerlink" title="4.3.3 记录集群所有槽的指派信息"></a>4.3.3 记录集群所有槽的指派信息</h3><p>我们知道，每个节点都保存着一个clusterState结构，这个结构，<strong>我们可以看做节点自己对整个集群所描绘的详细概念地图</strong>。</p>
<p>节点除了会在clusterState.nodes字典中维护每个节点的槽分派信息外，还会在clusterState结构结构中维护一个clusterNode *slots[16384]数组。</p>
<p>clusterState.slots数组有16384项，每个数组项都是一个指向clusterNode的指针：</p>
<ul>
<li>如果slots[i]指向NULL，那么表示槽i尚未指派给任何节点。</li>
<li>如果slots[i]指向一个clusterNode，那么表示槽i已经指派给了这个clusterNode所对应的节点</li>
</ul>
<p>假设槽被指派给了集群中的三个节点，那么slots数组结构如下图：<br><img src="https://oscimg.oschina.net/oscnet/up-ef32357ce2410db6cf95670fec70e865b75.png" alt=""></p>
<ul>
<li>clusterState.nodes[i].slots<ul>
<li>节点A在自己的clusterState.nodes字典中的某个clusterNode结构（假设对应节点B）中保存的槽分派信息，是以单节点（节点B）为视角的槽分派信息，即——<strong>我这个节点负责如下这些槽</strong>。</li>
</ul>
</li>
<li>clusterState.slots</li>
<li>节点A在自己的clusterState.slots数组中保存的槽分派信息，是以每个槽为视角的槽分派信息。即——<strong>我这个槽被某个节点负责</strong>。</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-d08d4389ea5a796d227eed8522533cc9bf9.png" alt=""></p>
<h2 id="4-4-集群处理命令"><a href="#4-4-集群处理命令" class="headerlink" title="4.4 集群处理命令"></a>4.4 集群处理命令</h2><p>当集群中的所有槽都被指派之后，集群就会进入上线状态，这是客户端就可以向集群中的节点发送命令了。</p>
<p>一张图解释如下过程：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1cfff66398d714cab3142e3825989d4f9d0.png" alt=""></p>
<h3 id="4-4-1-计算键属于哪个槽"><a href="#4-4-1-计算键属于哪个槽" class="headerlink" title="4.4.1 计算键属于哪个槽"></a>4.4.1 计算键属于哪个槽</h3><p>节点用以下算法计算给定键 key 属于哪个槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def slot_number(key):</span><br><span class="line">	return CRC16(key) &amp; 16383 &#x2F;&#x2F;CRC16(key) 计算key的CRC-16校验和，然后和16383与出一个0-16383的序号来。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用于查看一个给定键属于哪个槽</span><br><span class="line">CLUSTER KETSLOT &lt;key&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-2-判断某个槽是否由当前节点负责"><a href="#4-4-2-判断某个槽是否由当前节点负责" class="headerlink" title="4.4.2 判断某个槽是否由当前节点负责"></a>4.4.2 判断某个槽是否由当前节点负责</h3><p>当节点计算出键所属槽 i 之后，节点会检查自己在 clusterState.slots 数组中的项 i ，判断键所处的槽是否由自己负责：</p>
<ul>
<li>如果 <code>clusterState.slots[i]</code> 等于 <code>clusterState.myself</code> ，那么说明槽 i 由当前节点负责，节点可以执行客户端发送的命令；</li>
<li>否则，槽 i 不由当前节点负责,节点会根据 <code>clusterState.slots[i]</code> 所指向的 clusterNode 结构所记录的节点IP和端口号，向客户端返回 MOVED 错误并指引客户端转向正在处理槽i的节点，格式如下：<ul>
<li><code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code></li>
<li>客户端接收到 MOVED 命令之后，根据其提供的IP和端口，转向负责处理槽 slot 的节点，并向节点<strong>重新发送之前想要执行的命令</strong>。</li>
<li>客户端会和每个节点创建套接字连接，所谓的转向，其实就是换一个套接字来发送命令。</li>
</ul>
</li>
</ul>
<h2 id="4-5-节点数据库的实现"><a href="#4-5-节点数据库的实现" class="headerlink" title="4.5 节点数据库的实现"></a>4.5 节点数据库的实现</h2><p>我们在文章<a href="https://my.oschina.net/lscherish/blog/3147447" target="_blank" rel="noopener" title="Redis数据库结构/键空间/过期字典/事务/锁/持久化">Redis数据库结构/键空间/过期字典/事务/锁/持久化</a>中讨论过Redis服务器的键空间（即如何存储键值对）redisDb结构的dict字典数组，保存了所有的键值对。redisDb结构的expires字典数组，保存了所有的过期字典。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6d3519de440528a8af1eded3347c9337236.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dbb09c36a7db3dcb13c5f538cb3ccc80092.png" alt=""></p>
<p><strong>单机服务器和集群服务器（节点）的保存键值对以及键值对过期时间，实现都是一样的</strong>。只不过节点只能使用 0 号数据库，单机服务器没有限制。</p>
<p>和单机服务器不同的是，除了键值对之外，节点还需要维护<strong>槽和键的关系</strong>，节点会用 clusterState 结构中的 <code>slots_to_keys</code> 跳跃表来保存槽和键之间的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    zskiolist *slots_to_keys;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p>这个跳跃表每个节点的分值( score )都是一个槽号，节点的成员( member )都是一个数据库键：</p>
<ul>
<li><p>每当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到 slots_to_key s跳跃表</p>
</li>
<li><p>当节点删除数据库中的某个键值对时，节点就会在slots_to_keys跳跃表解除被删除键与槽号的关联</p>
</li>
</ul>
<p>图例：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0bc955e758a048378d24a0e10ca3a39540a.png" alt=""></p>
<p>该图表示：</p>
<ul>
<li>键”book”所在跳跃表节点的分值为1337.0，这表示键”book”所在的槽为1337</li>
<li>键”date”所在跳跃表节点的分值为2022.0，这表示键”date”所在的槽为2022</li>
<li>键”lst”所在跳跃表节点的分值为3347.0，这表示键”lst”所在的槽为3347</li>
</ul>
<blockquote>
<p>slots_to_keys 的存在是为了使节点可以很方便的对属于某个或者某些槽的所有键做批量操作。例如命令<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令可以返回最多count个属于槽slot的数据库键，而这个命令就是通过遍历 slots_to_keys跳跃表来实现的</p>
</blockquote>
<h2 id="4-6-重新分片"><a href="#4-6-重新分片" class="headerlink" title="4.6 重新分片"></a>4.6 重新分片</h2><p>Redis集群的重新分片操作可以将<strong>任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点，并且相关槽所属的键值对也会从源节点移动到目标节点。</strong> 重新分片可以在线进行，在这过程中，集群不用下线，且源节点和目标节点都可以继续处理命令。</p>
<p>重新分片由Redis的集群管理软件 redis-trib 负责执行，redis-trib 通过向源节点和目标节点发送命令来进行重新分片：</p>
<ul>
<li><p>redis-trib对集群的单个槽 slot 进行重新分片的步骤如下：</p>
<ol>
<li><p>redis-trib 对目标节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令，让目标节点<strong>准备好</strong>从源节点导入槽 slot 的键值对</p>
</li>
<li><p>redis-trib 对源节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;source_id&gt;</code>命令，让源节点<strong>准备好</strong>将属于槽 slot的键值对迁移至目标节点</p>
</li>
<li><p>redis-trib 对源节点发送 <code>CLUSTER GETKEYSINSLOT&lt;slot&gt; &lt;count&gt;</code> 命令，获得最多 count 个属于槽 slot 的键值对的键名。</p>
</li>
<li><p>对于步骤三获得的每个键名，redis-trib 都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code> 命令，<strong>将被选中的键原子的从源节点迁移至目标节点</strong>。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-ee9006a45f14bd9001e3118803ba0f3e6a8.png" alt=""></li>
</ul>
<ol start="5">
<li>重复步骤3和4，直到源节点保存的所有属于槽slot的键值对都被迁移到目标节点为止。</li>
<li>redis-trib向集群中的任意一个节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code> 命令，将槽slot指派给目标节点的信息发送给整个集群。</li>
</ol>
</li>
</ol>
</li>
<li><p>如果重新分片涉及多个槽，那么 redis-trib 将对<strong>每个给定的槽</strong>  <strong>分别</strong>执行上面给出的步骤。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-0e420042cc4a84d00d7ef383c8c9a540889.png" alt=""></li>
</ul>
</li>
</ul>
<p>重新分片的实战操作，可以参考该篇文章：<a href="http://weizijun.cn/2016/01/08/redis%20cluster%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7redis-trib-rb%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener" title="redis cluster管理工具redis-trib.rb详解">redis cluster管理工具redis-trib.rb详解</a></p>
<h2 id="4-6-ASK-错误"><a href="#4-6-ASK-错误" class="headerlink" title="4.6 ASK 错误"></a>4.6 ASK 错误</h2><p>在重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种中间状态：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对保存在目标节点中。</p>
<p>这时候如果客户端向源节点发送了一个key的操作请求，就可能会触发ASK 错误。</p>
<p>当客户端向源节点发送关于键key的命令，源节点先在自己的数据库里查找这个键，如果找到就直接返回执行客户端命令，如果没找到，这个键可能已经被迁移到了目标节点，源节点向客户端返回一个 ASK 错误，指引客户端转向正在导入槽的目标节点，并再次发送之前要执行的命令。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1b3f9629997cc535ef543380112d098d3e0.png" alt=""></p>
<p>接到ASK 错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后向目标节点发送一个 ASKING 命令， 之后再重新发送原本想要执行的命令。</p>
<h3 id="4-6-1-ASKING-命令的实现"><a href="#4-6-1-ASKING-命令的实现" class="headerlink" title="4.6.1 ASKING 命令的实现"></a>4.6.1 ASKING 命令的实现</h3><p>在重新分片过程中，我们对目标节点执行了 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，这会使得clusterState状态的importing_slots_from数组会记录当前节点的哪些槽正在从哪些节点导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState&#123;</span><br><span class="line">	&#x2F;&#x2F; ……</span><br><span class="line">    &#x2F;&#x2F; 如果importing_slots_from[i]的值不为NULL，而是指向一个clusterNode结构，表示当前节点正在从</span><br><span class="line">    &#x2F;&#x2F; clusterNode所代表的节点导入槽i</span><br><span class="line">    clusterNode *importing_slots_from[16384];</span><br><span class="line">     &#x2F;&#x2F; ……</span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure>

<p>在重新分片过程中，我们对源节点执行了<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;source_id&gt;</code>命令，这会使得clusterState状态的migrating_slots_to数组会记录当前节点正在迁移至其他节点的槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState&#123;</span><br><span class="line">    &#x2F;&#x2F; ……</span><br><span class="line">    &#x2F;&#x2F; 如果migrating_slots_to[i]的值不为NULL，而是指向一个clusterNode结构，表示当前节点正在将</span><br><span class="line">    &#x2F;&#x2F; 槽i迁移至clusterNode所代表的节点</span><br><span class="line">    clusterNode *migrating_slots_to[16384];</span><br><span class="line">    &#x2F;&#x2F; ……</span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure>
<p>接到ASK 错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后向目标节点发送一个 ASKING 命令， 之后再重新发送原本想要执行的命令。</p>
<p><strong>ASKING命令要做的就是打开发送该命令的客户端的 REDIS_ASKING 标识。</strong></p>
<p>如果该客户端的 REDIS_ASKING 标识未打开，直接发送请求，由于槽的迁移过程还未完成，请求的键还属于源节点，此时直接请求目标节点，目标节点会返回一个MOVED错误。(因为迁移未完成，所以虽然部分的键已经迁移至目标节点了，但这部分键的归属，还是记在源节点上)</p>
<p>但是，如果节点的<code>clusterState.importing_slots_from[i]</code>显示节点正在导入槽 i ,并且发送命令的客户端带有 REDIS_ASKING 标识，<strong>那么节点将破例执行这个关于槽 i 的命令一次</strong>。</p>
<blockquote>
<p>客户端的 REDIS_ASKING 标识是一个一次性标识，当节点执行了一个带有 REDIS_ASKING 标识的客户单发送的命令之后，客户端的这个表示就会被移除。</p>
</blockquote>
<blockquote>
<p>ASK错误和MOVED错误的区别:<br>    MOVED错误代表槽的负责全已经从一个结点转移到了另一个节点<br>    ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施</p>
</blockquote>
<h2 id="4-7-节点的复制与故障转移"><a href="#4-7-节点的复制与故障转移" class="headerlink" title="4.7 节点的复制与故障转移"></a>4.7 节点的复制与故障转移</h2><p>集群中的节点分为主节点和从节点，主节点负责处理槽，而从节点负责复制某个主节点，并在被复制的主节点下线时，替代下线主节点继续处理命令请求。</p>
<h3 id="4-7-1-设置从节点"><a href="#4-7-1-设置从节点" class="headerlink" title="4.7.1 设置从节点"></a>4.7.1 设置从节点</h3><p>向一个节点发送命令：<code>CLUSTER REPLICATE &lt;node_id&gt;</code></p>
<p>这个命令可以让接收命令的节点成为 node_id 所指定的从节点，并开始对主节点进行复制：</p>
<ul>
<li><p>这个节点会先在自己的 clusterState.nodes 字典中找到 node_id 所对应节点的 clusterNode 结构，并将自己的 <code>clusterState.myself.slaveof</code>指针指向这个结构，以此来记录这个节点正在复制的主节点</p>
</li>
<li><p>然后节点修改自己在 clusterState.myself.flags 中的属性，关闭原本的 <code>REDIS_NODE_MASTER</code>标识，打开 <code>REDIS_NODE_SLAVE</code>标识，表示这个节点由原来的主节点变成了从节点</p>
</li>
<li><p>最后，节点调用复制代码，并跟据 clusterState.myself.slaveof 指向的 clusterNode 结构所保存的IP地址和端口号，对主节点进行复制。就是相当于向从节点发送命令 <code>SLAVEOF &lt;master_ip&gt; &lt;maste_port&gt;</code></p>
</li>
</ul>
<p>一个节点开始成为从节点的时候，会向集群广播这一事实，以便集群中的其他节点更新从节点和主节点的关系。</p>
<h3 id="4-7-2-故障检测"><a href="#4-7-2-故障检测" class="headerlink" title="4.7.2 故障检测"></a>4.7.2 故障检测</h3><p>集群中的每个节点都会定期地向集群中的其他节点发送 PING 消息，以此来检测对方是否在线</p>
<p>如果接受 PING 消息的节点没有在规定时间内返回 PONG ，那么发送 PING 的节点就会将该节点标记为<strong>疑似下线</strong>(PFAIL)。</p>
<p>当一个主节点A通过消息得知主节点B认为主节点C进入疑似下线状态，主节点A会在自己的 <code>clusterState.nodes</code> 字典中找到主节点C所对应的 clusterNode 结构，并将主节点B的下线报告添加到这个结构的 fail_reports 链表里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct clusterNode&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;&#x2F; 一个链表，记录了所有其他节点对该节点的下线报告</span><br><span class="line">    list *fail_reports;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个集群里，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线(FAIL)，将主节点X标记为已下线的节点会向集群广播一条关于主节点X的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点X标记为已下线。</p>
<p>比较绕，我们来举例：假设一个集群有ABCD四个节点，A和B节点都认为D节点进入了疑似下线状态，这时刚好半数的主节点认为D疑似下线。然后，C节点通过消息交换，也将D节点标记为疑似下线状态。这时候数量就超过了半数了，于是C节点会将D节点标记为<strong>已下线</strong>，并向整个集群广播一条D节点已下线的消息。这时A和B接到消息，会将D节点标记为<strong>已下线</strong>。</p>
<h3 id="4-7-3-故障转移"><a href="#4-7-3-故障转移" class="headerlink" title="4.7.3 故障转移"></a>4.7.3 故障转移</h3><p>当一个从节点发现自己正在复制的主节点进入了已下线状态，<strong>从节点将开始对下线主节点进行故障转移</strong>:</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个<strong>从节点</strong>被选中</li>
<li>被选中的从节点将执行 slaveof no one 命令，成为新的主节点</li>
<li>新的主节点撤销已下线主节点对指派槽的管理，并将这些槽全部指派给自己</li>
<li>新的主节点向集群广播一条PONG消息，告诉集群中的其他节点自己成为了新的主节点。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
<p>这里面涉及到新的主节点的选举：</p>
<ol>
<li><p>集群的配置纪元是一个自增计数器，初始值为0</p>
</li>
<li><p>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值就会加一</p>
</li>
<li><p>对于每个配置纪元，集群中的每个负责处理槽的主节点都有一次投票机会，而第一个向主节点要求投票的从节点将获得主节点的投票</p>
</li>
<li><p>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 消息，要求所有收到这条消息、并具有投票权的主节点向这个从节点投票</p>
</li>
<li><p>如果一个主节点具有投票权(它正在负责处理槽),并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条 CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 消息，表示这个主节点支持从节点成为新的主节点</p>
</li>
<li><p>每个参与选举的从节点都会接受 CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 消息，并根据自己受到了多少条这种消息来统计自己获得了多少主节点 的支持</p>
</li>
<li><p>如果集群库有N个具有投票权的朱及诶单，那么当一个从节点收集到大于等于N/2+1张支持票，这个从节点当选为新的主节点</p>
</li>
<li><p>因为在每个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个</p>
</li>
<li><p>如果在一个配置纪元里没有从节点能搜集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</p>
</li>
</ol>
<blockquote>
<p>和选举领头sentinel的算法一样，都是基于raft算法。</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag"># 分布式</a>
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"># 缓存</a>
          
            <a href="/tags/Sentinel/" rel="tag"># Sentinel</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84-%E9%94%AE%E7%A9%BA%E9%97%B4-%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8-%E4%BA%8B%E5%8A%A1-%E9%94%81-%E6%8C%81%E4%B9%85%E5%8C%96/" rel="next" title="Redis数据库结构/键空间/过期字典/事务/锁/持久化">
                <i class="fa fa-chevron-left"></i> Redis数据库结构/键空间/过期字典/事务/锁/持久化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/21/Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" rel="prev" title="Raft算法分析">
                Raft算法分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2020/01/08/Redis事件模型-主从复制-哨兵模型-集群模式/"
           data-title="Redis事件模型/主从复制/哨兵模型/集群模式" data-url="http://yoursite.com/2020/01/08/Redis%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%9E%8B-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Redis的事件模型"><span class="nav-text">1. Redis的事件模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-文件事件"><span class="nav-text">1.1 文件事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-时间事件"><span class="nav-text">1.2 时间事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-serverCron函数"><span class="nav-text">1.2.1 serverCron函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-事件调度与执行"><span class="nav-text">1.3 事件调度与执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Redis主从复制"><span class="nav-text">2. Redis主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-旧版复制功能"><span class="nav-text">2.1 旧版复制功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-新版复制功能"><span class="nav-text">2.2 新版复制功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-复制的实现"><span class="nav-text">2.3 复制的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Redis哨兵模型"><span class="nav-text">3. Redis哨兵模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Sentinel的启动"><span class="nav-text">3.1 Sentinel的启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Sentinel与服务器的交互"><span class="nav-text">3.2 Sentinel与服务器的交互</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-INFO命令"><span class="nav-text">3.2.1 INFO命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-广播频道消息"><span class="nav-text">3.2.2 广播频道消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-接收频道消息"><span class="nav-text">3.2.3 接收频道消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-创建Sentinel之间的链接"><span class="nav-text">3.2.4 创建Sentinel之间的链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-监控下线和故障转移"><span class="nav-text">3.3 监控下线和故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-监控下线"><span class="nav-text">3.3.1 监控下线</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-1-检测主观下线状态"><span class="nav-text">3.3.1.1 检测主观下线状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-2-检测客观下线状态"><span class="nav-text">3.3.1.2 检测客观下线状态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-选举领头sentinel"><span class="nav-text">3.3.2 选举领头sentinel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-故障转移"><span class="nav-text">3.3.3 故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-1-选举新的主服务器的过程"><span class="nav-text">3.3.3.1 选举新的主服务器的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-2-修改从服务器的复制目标"><span class="nav-text">3.3.3.2 修改从服务器的复制目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-3-将旧的Master变成Slave"><span class="nav-text">3.3.3.3 将旧的Master变成Slave</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-集群模式"><span class="nav-text">4. 集群模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-节点"><span class="nav-text">4.1 节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-集群数据结构"><span class="nav-text">4.2  集群数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-CLUSTER-MEET-命令的实现"><span class="nav-text">4.2.1 CLUSTER MEET 命令的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-redis负载均衡算法——hash-slot"><span class="nav-text">4.3 redis负载均衡算法——hash slot</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-记录节点的槽指派信息"><span class="nav-text">4.3.1 记录节点的槽指派信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-传播节点的槽指派信息"><span class="nav-text">4.3.2 传播节点的槽指派信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-记录集群所有槽的指派信息"><span class="nav-text">4.3.3 记录集群所有槽的指派信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-集群处理命令"><span class="nav-text">4.4 集群处理命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-计算键属于哪个槽"><span class="nav-text">4.4.1 计算键属于哪个槽</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-判断某个槽是否由当前节点负责"><span class="nav-text">4.4.2 判断某个槽是否由当前节点负责</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-节点数据库的实现"><span class="nav-text">4.5 节点数据库的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-重新分片"><span class="nav-text">4.6 重新分片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-ASK-错误"><span class="nav-text">4.6 ASK 错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-ASKING-命令的实现"><span class="nav-text">4.6.1 ASKING 命令的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-节点的复制与故障转移"><span class="nav-text">4.7 节点的复制与故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-1-设置从节点"><span class="nav-text">4.7.1 设置从节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-2-故障检测"><span class="nav-text">4.7.2 故障检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-3-故障转移"><span class="nav-text">4.7.3 故障转移</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">411.3k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
