<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Redis,缓存,算法," />










<meta name="description" content="前言本文讲述的两个缓存淘汰算法，LRU算法（Least recently used）和LFU算法（Least Frequently used），两者看起来很相似，但我们要明确其区别在于：  LRU是按访问时间排序，发生淘汰的时候，把访问时间最旧的淘汰掉。  LFU是按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。   本文旨在描述LRU&#x2F;LFU算法定义，并给出性能最">
<meta property="og:type" content="article">
<meta property="og:title" content="LRU和LFU算法以及其在Redis中的实现">
<meta property="og:url" content="http://yoursite.com/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="前言本文讲述的两个缓存淘汰算法，LRU算法（Least recently used）和LFU算法（Least Frequently used），两者看起来很相似，但我们要明确其区别在于：  LRU是按访问时间排序，发生淘汰的时候，把访问时间最旧的淘汰掉。  LFU是按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。   本文旨在描述LRU&#x2F;LFU算法定义，并给出性能最">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-c609868da6b2cfefb197343aeee43d3d711.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-04a2a22decea9ebd74bd5aab3ad4de3fbb6.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-9bbae79816c5ac35c34cd21e3bb7f20a342.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-e15263be2c99e9a89332fc6c464029aa4df.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-d6e14f11d52889dd33329a8330c815e5b10.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-fe014848ed18d0f5f5cc817267d06dc2268.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-da6975d89b1e5c0929529b709d71d0d0840.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-07e66e8579884f9a6e2e02cc87c79c8889b.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-bc7b790c06e282c599c94a25afdb0d0736c.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-ddad582bc4e83b730a0c8fff3336ddd3158.png">
<meta property="article:published_time" content="2020-08-04T15:34:29.000Z">
<meta property="article:modified_time" content="2020-08-05T13:31:13.277Z">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="缓存">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oscimg.oschina.net/oscnet/up-c609868da6b2cfefb197343aeee43d3d711.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/04/LRU和LFU算法以及其在Redis中的实现/"/>





  <title>LRU和LFU算法以及其在Redis中的实现 | cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LRU和LFU算法以及其在Redis中的实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-04T23:34:29+08:00">
                2020-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/04/LRU和LFU算法以及其在Redis中的实现/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文讲述的两个缓存淘汰算法，LRU算法（Least recently used）和LFU算法（Least Frequently used），两者看起来很相似，但我们要明确其区别在于：</p>
<ul>
<li><p>LRU是按访问时间排序，发生淘汰的时候，把访问时间最旧的淘汰掉。</p>
</li>
<li><p>LFU是按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。</p>
</li>
</ul>
<p>本文旨在描述LRU/LFU算法定义，并给出性能最佳的实现方式，最后再延伸至当前最热门的缓存中间件Redis中二者的实现。</p>
<p>其中，LRU/LFU算法性能最优的实现，也是各大厂技术面的常问题。leetcode上有两个这样的题目，要求是缓存的加入put()，缓存读取get()，都要在O(1)内实现：</p>
<ul>
<li>LRU：<a href="https://leetcode.com/problems/lru-cache/description/" target="_blank" rel="noopener">https://leetcode.com/problems/lru-cache/description/</a> 或者 <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache/</a></li>
<li>LFU：<a href="https://leetcode.com/problems/lfu-cache/description/" target="_blank" rel="noopener">https://leetcode.com/problems/lfu-cache/description/</a> 或者 <a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lfu-cache/</a></li>
</ul>
<h1 id="1-LRU算法"><a href="#1-LRU算法" class="headerlink" title="1 LRU算法"></a>1 LRU算法</h1><p>LRU（Least recently used）算法，也叫作<strong>最近最久未使用算法</strong>，顾名思义，就是哪个是最近不用的，就把他淘汰掉。它根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。它经常使用在内存/缓存空间不足的场景，以便在受限时舍弃掉不常用的数据。</p>
<h2 id="1-1-链表实现简单LRU"><a href="#1-1-链表实现简单LRU" class="headerlink" title="1.1 链表实现简单LRU"></a>1.1 链表实现简单LRU</h2><p>使用链表，可以实现最简单的LRU算法：</p>
<ol>
<li>维护一个定长的链表</li>
<li>当一个新的key被访问时<ul>
<li>如果这个key不存在链表中，那么新key插入到链表头部；</li>
<li>如果这个key存在链表中，那么将这个key移到链表头部；</li>
</ul>
</li>
<li>当链表满的时候，如果还有新的key要插入，则将链表尾部的key丢弃。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-c609868da6b2cfefb197343aeee43d3d711.png" alt=""></p>
<p>这种简单的实现固然能达到我们的目的，但也有致命的要求：这种实现的性能不是很好，查询一个key是否存在链表中，以及在链表中的具体位置的时间复杂度是O(n)，这在数据数量巨大的场景下是灾难的。</p>
<h2 id="1-2-HashMap和双向链表实现高性能LRU"><a href="#1-2-HashMap和双向链表实现高性能LRU" class="headerlink" title="1.2 HashMap和双向链表实现高性能LRU"></a>1.2 HashMap和双向链表实现高性能LRU</h2><p>链表实现的LRU算法瓶颈主要在<strong>定位一个key在链表中位置的消耗</strong>。</p>
<p>为了规避这个代价，我们可以引入在查询和定位方面具有极高优势的HashMap来作为互补，整体的设计思路是，可以使用 HashMap 存储 key，而HashMap的Value指向双向链表实现的LRU的 Node 节点。这样可以做到save和get的时间都是 O(1)。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-04a2a22decea9ebd74bd5aab3ad4de3fbb6.png" alt=""></p>
<p>假如我们预设链表的大小是3，下图展示了LRU链表在存储和访问过程中的变化。为了简化图复杂度，图中没有展示HashMap部分的变化，仅仅演示了上图LRU双向链表的变化。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9bbae79816c5ac35c34cd21e3bb7f20a342.png" alt=""></p>
<h2 id="1-3-继承LinkedHashMap实现LRU"><a href="#1-3-继承LinkedHashMap实现LRU" class="headerlink" title="1.3 继承LinkedHashMap实现LRU"></a>1.3 继承LinkedHashMap实现LRU</h2><p>LinkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储（也就是其put方法会将最近访问的数据放到表头）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e15263be2c99e9a89332fc6c464029aa4df.png" alt=""></p>
<p>此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry，用于在每次数据发生变更时（put和get）判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素（也正因此，LinkedHashMap是无限长的）。所以为了将其改造为一个定长且会自动移除队尾数据的链表，需要重写removeEldestEntry方法，即当缓存满后就移除最不常用的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里就是传递进来最多能缓存多少数据</span><br><span class="line">    public LRUCache(int cacheSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置一个hashmap的初始大小，最后一个true指的是让linkedhashmap按照访问顺序来进行排序，最近访问的放在头，最老访问的就在尾</span><br><span class="line">        super((int) Math.ceil(cacheSize &#x2F; 0.75) + 1, 0.75f, true);</span><br><span class="line">        CACHE_SIZE &#x3D; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据</span><br><span class="line">        return size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2-Redis中的LRU"><a href="#2-Redis中的LRU" class="headerlink" title="2 Redis中的LRU"></a>2 Redis中的LRU</h1><blockquote>
<p>在讨论Redis的LRU之前，需要明确，Redis的缓存淘汰策略（LRU）与Redis键的过期删除策略不是一回事，LRU是在Redis内存使用超过一定值的时候（一般这个值可以配置）使用的淘汰降级策略；而后者是通过定期删除+惰性删除两者结合的方式进行过期删除的。</p>
</blockquote>
<h2 id="2-1-Redis缓存淘汰策略"><a href="#2-1-Redis缓存淘汰策略" class="headerlink" title="2.1 Redis缓存淘汰策略"></a>2.1 Redis缓存淘汰策略</h2><p>当内存达到极限时，Redis就要开始利用回收策略对内存进行回收释放。回收的配置在 redis.conf 中填写，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 1073741824</span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure>

<ul>
<li>maxmemory： 指定了内存使用的极限，以字节为单位。当内存达到极限时，他会尝试去删除一些键值。</li>
<li>maxmemory-policy：指定删除的策略。Redis提供了如下几种缓存淘汰策略的取值<ul>
<li>noeviction：当内存使用超过配置的时候（如SET、LPUSH 等等命令）会返回错误，不会驱逐任何键。</li>
<li>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</li>
<li>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</li>
<li>allkeys-random：加入键的时候如果过限，从所有key随机删除</li>
<li>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐</li>
<li>volatile-ttl：从配置了过期时间的键中驱逐过期时间最近 (TTL 最小)的键</li>
<li>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</li>
<li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li>
</ul>
</li>
<li>maxmemory-samples ：指定了在进行删除时的键的采样数量。LRU 和 TTL 都是近似算法，所以可以根据参数来进行取舍，到底是要速度还是精确度。默认值一般填 5。10 的话已经非常近似正式的 LRU 算法了，但是会多一些 CPU 消耗；3 的话执行更快，然而不够精确。</li>
</ul>
<p>上述说到的缓存淘汰策略中，带lru后缀的，就是采用Redis LRU算法的策略，带有lfu后缀的策略，就是采用Redis LFU算法的策略（后文详述）。</p>
<h2 id="2-2-Redis中的LRU时钟"><a href="#2-2-Redis中的LRU时钟" class="headerlink" title="2.2 Redis中的LRU时钟"></a>2.2 Redis中的LRU时钟</h2><p>在LRU实现中，最核心的要点就是标记哪些数据是“最久”的，前文提到的LRU实现，我们利用链表的顺序来确定哪个数据“最久”，但如果按照性能较好的HashMap和双向链表来实现，在Redis key数量巨大的情况下，HashMap和双向链表的长度也会非常巨大，会牺牲比较大的存储空间，显然是不划算的。</p>
<p> 我们知道Redis中的所有对象都被定义为redisObject结构体。Redis LRU算法回收的数据，也正是这些对象。</p>
<p>Redis不采用链表来确定哪些redisObject是最久的，而是在redisObject结构体中定义了一个lru成员来用来记录该对象的最近一次被访问的时间。由于时钟的最大值只需要 24 个比特位就能表示，所以结构体定义时采用了位域。定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:LRU_BITS;</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>


<p>而在Redis在全局中也维护了一个24位全局时钟，可以简单理解为当前系统的时间戳。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">       pid_t pid;</span><br><span class="line">       char *configfile;</span><br><span class="line">       &#x2F;&#x2F;全局时钟</span><br><span class="line">       unsigned lruclock:LRU_BITS;</span><br><span class="line">       ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Redis每隔一定时间会通过全局的定时器函数serverCron来更新这个时钟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int serverCron(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    server.lruclock &#x3D; getLRUClock();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时钟的刷新频率由 server.hz 决定，即每秒钟会调用 server.hz （默认值为 10）次 serverCron 函数。那么，服务器每 1 / server.hz 秒就会调用一次定时器函数 serverCron。</p>
</blockquote>
<p>当一个对象redisObject新建或者被访问时，redis使用全局lru时钟来赋值对象内的lru时钟。</p>
<p>基于上面的基础，redis就可以很轻易的得到一个对象的空闲时间了：<strong>用全局的lru时钟减去对象本身的lru时钟，得到的就是这个对象没有被访问的时间间隔（也称空闲时间，idle time），空闲时间最大的就是需要淘汰的对象</strong>。</p>
<h2 id="2-3-Redis-LRU回收流程"><a href="#2-3-Redis-LRU回收流程" class="headerlink" title="2.3 Redis LRU回收流程"></a>2.3 Redis LRU回收流程</h2><p>Redis并不需要一个完全准确的LRU算法，就算移除了一个最近访问过的Key，影响也不大。为了性能计，Redis采用了一个近似LRU的实现：</p>
<p>Redis的数据库是一个巨大的字典，redisDb结构体中，维护着一个全局的，保存了数据库中的所有键值对的字典——dict字典，我们也称它做键空间。还维护着一个保存了所有带过期配置的键值对的字典——expire字典。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d6e14f11d52889dd33329a8330c815e5b10.png" alt=""></p>
<p>当内存使用超过最大使用数（即超过maxmemory的上限）时，就需要采用回收策略进行内存回收。如果回收策略采用带有LRU算法的策略，那么就会使用到Redis的近似LRU算法实现，流程如下</p>
<ol>
<li><p><strong>触发淘汰</strong>：在每一次处理客户端命令时。当 server.maxmemory的值非 0，则检测是否有需要回收淘汰的内存，如果有则触发redis.c/freeMemoryIfNeeded(void)函数以清理超出的内存，即步骤2的逻辑</p>
</li>
<li><p><strong>更新回收池</strong>：随机按策略从dict或者expire中取出maxmemory_samples个键（实际取到的数量取决于大字典原本的大小）</p>
<ul>
<li>然后用一个长度为16（由宏 MAXMEMORY_EVICTION_POOL_SIZE 指定）的evictionPool（回收池）对这几个键进行筛选</li>
<li>依次将取出的键的idle time和evictionPool中最小的idle time比较。将随机取出的键中，idle time比当前evictionPool中最小的idle time还要大的键，按idle time从小到大的顺序插入到evictionPool内的相应位置中（因为evictionPool是定长，所以如果在evictionPool已满的情况下插入新key，则要释放idle time较小的key）。</li>
</ul>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-fe014848ed18d0f5f5cc817267d06dc2268.png" alt=""></p>
<ol start="3">
<li><strong>删除淘汰的键</strong>：最后再从evictionPool池中取出idle time最大且在字典中存在的键作为bestkey执行删除，并且将该key从evictionPool池中移除；</li>
</ol>
<blockquote>
<p>注意这个清理过程是阻塞的，直到清理出足够的内存空间。所以如果在达到maxmemory并且调用方还在不断写入的情况下，可能会反复触发主动清理策略，导致请求会有一定的延迟。</p>
</blockquote>
<p>Redis采用回收池，把一个<strong>全局排序问题</strong>转化成为了<strong>局部的比较问题</strong>。要想知道idle time最大的key，精确的LRU需要对全局的key的idle time排序，这样的成本对于Redis来说太高了。Redis的LRU算法采用一种近似的思想，即随机采样(samping)若干个key，这若干个key就代表着全局的key，把samping得到的key放到pool里面，每次采样之后更新pool，使得pool里面总是保存着随机选择过的key的idle time最大的那些key。</p>
<p>需要evict key时，直接从pool里面取出idle time最大的key，将之evict掉。这种思想是很值得借鉴的。</p>
<p>而且，Redis团队经过试验，发现当samples=10时，Redis随机的LRU算法，已经能够很准确的淘汰掉最久没有使用的键，其效果和精确的LRU基本持平。如下图（浅灰色表示已经删除的键，深灰色表示没有被删除的键，绿色表示新加入的键，越往上表示键加入的时间越久）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-da6975d89b1e5c0929529b709d71d0d0840.png" alt=""></p>
<h1 id="3-LFU算法"><a href="#3-LFU算法" class="headerlink" title="3 LFU算法"></a>3 LFU算法</h1><p>LFU（Least Frequently used）算法，也叫作<strong>最近最少使用算法</strong>，顾名思义，就是淘汰缓存里面用的最少的数据。它根据数据的访问频次来进行淘汰数据，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。</p>
<h2 id="3-1-使用双哈希表实现高性能LFU"><a href="#3-1-使用双哈希表实现高性能LFU" class="headerlink" title="3.1 使用双哈希表实现高性能LFU"></a>3.1 使用双哈希表实现高性能LFU</h2><p>有了LRU的打底，我们知道，在排序问题中（LFU和LRU本质都是排序问题）要想实现O(1)时间复杂度的get性能，必须要借助哈希表来实现。但LFU相比LRU有个难点：<strong>频次相比于访问时间，更容易重复，即容易同时出现多于一个的key，他们的频次是一样的，且都是最低的。这时候出现平局，则需要在频次最低的基础上，再在重复的key中间，找到最久未使用的key，并淘汰</strong>。</p>
<p>也就是说，LFU的实现，除了要按照访问频率来排序，还要按照访问时间来排序。排序顺序是：访问频率降序&gt;访问时间降序。</p>
<p>为了达到上述目的，并且达到put和get都为O(1)复杂度，那么我们引入了双哈希表。</p>
<ul>
<li>第一个哈希表的含义是<strong>HashMap&lt;缓存的key，缓存数据节点的地址&gt;</strong><ul>
<li>第一个哈希表，和lru的实现一样，是用来实现O(1)时间查找key对应的节点。</li>
</ul>
</li>
<li>第一个哈希表的含义是<strong>HashMap&lt;访问频率，链表的头结点的地址&gt;</strong><ul>
<li>这个哈希表的每一个value，都是采用拉链法，挂上了一个缓存数据节点组成的双向链表（链表节点按照访问时间从近到远排序，表头访问时间最近，表尾访问时间最远）。</li>
<li>该哈希表的value值指向链表头部，而这个双向链表内存的，都是目前访问频率为其value对应的key值的缓存数据。</li>
<li>比如key=3的value是一个三个节点的链表，则表示这个链表内的三个缓存节点，访问频次都是3次。</li>
</ul>
</li>
</ul>
<p>一图胜万言：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-07e66e8579884f9a6e2e02cc87c79c8889b.png" alt=""></p>
<p>这样的实现下，我们对于get和put操作就可以：</p>
<ul>
<li><strong>get</strong>：如果第一个哈希表中能查到key，那么取得相应链表节点数据。接下来在第二个哈希表中，把该节点<strong>移到</strong>其访问频率+1位置的链表头部。</li>
<li><strong>put</strong>：如果第一个哈希表中能查找key，那么操作和get(key)一样，只是最后要把新节点的value更新为新value。</li>
<li><strong>当发生淘汰时</strong>：也就是要执行put操作，但是容量已经达到限制时，这时直接找到第二个哈希表中最小引用计数的链表，删除其末尾节点（最晚使用）。之后再添加新节点即可。</li>
</ul>
<blockquote>
<p>容量超限需要删除节点时，删除了第二个哈希表中的项的同时，第一个哈希表中对应的映射也应该删掉。</p>
</blockquote>
<blockquote>
<p>需要在双哈希表之外维护一个额外的min_cnt变量用来保存当前的最小访问频率。因为容量超限需要删除节点时，我们需要O(1)时间找到需要删除的节点。及调用get(min_cnt)来定位到要被删除的那个链表。</p>
</blockquote>
<h1 id="4-Redis中的LFU"><a href="#4-Redis中的LFU" class="headerlink" title="4 Redis中的LFU"></a>4 Redis中的LFU</h1><p>Redis4.0开始，maxmemory_policy淘汰策略添加了两个LFU模式：</p>
<ul>
<li>volatile-lfu：对有过期时间的key采用LFU淘汰算法</li>
<li>allkeys-lfu：对全部key采用LFU淘汰算法</li>
</ul>
<p>使用这两种淘汰策略，便会使用到Redis的LFU算法，一种<strong>近似计数算法</strong>。</p>
<h2 id="4-1-常规LFU算法面临的问题"><a href="#4-1-常规LFU算法面临的问题" class="headerlink" title="4.1 常规LFU算法面临的问题"></a>4.1 常规LFU算法面临的问题</h2><p>在数据请求模式比较稳定（没有对于某个数据突发的高频访问这样的不稳定模式）的情况下，LFU的表现还是很不错的。</p>
<p>但在数据的请求模式大多不稳定的情况下，LFU一般会有这样一些问题：</p>
<ol>
<li><strong>热点数据问题</strong>：热点数据一般只是几天内有较高的访问频次，过了这段时间就没那么大意义去缓存了。但是因为在热点期间他的频次被刷上去了，导致之后很长一段时间内很难被淘汰；</li>
<li><strong>新增数据问题</strong>：如果采用只记录缓存中的数据的访问信息，新加入的高频访问数据在刚加入的时候由于没有累积优势，很容易被淘汰掉；</li>
<li><strong>空间问题</strong>：如果记录全部出现过的数据的访问信息，会占用更多的内存空间。</li>
</ol>
<p>对于上面这些问题，其实也都有一些对应的解决方式，相应的出现了很多LFU的变种。如：Window-LFU、LFU*、LFU-Aging。在Redis的LFU算法实现中，也有其解决方案。</p>
<h2 id="4-2-Redis中的频次计算"><a href="#4-2-Redis中的频次计算" class="headerlink" title="4.2 Redis中的频次计算"></a>4.2 Redis中的频次计算</h2><p>在常规操作中，我们一般会引入一个字段作为计数器，对每个key的访问频次做简单的加法，但这样的实现显然无法规避上述的三个问题：一味做加法，过期的热点数据很难淘汰；新增的数据频次太低，容易被淘汰；Redis的访问频次量级非常大，每个key都维护一个长的字段，空间代价太大。</p>
<p>为了解决这三个问题，Redis的频次计算实现，引入了三个策略：</p>
<ol>
<li><strong>概率量级计数</strong>：该策略可以解决空间问题。<ul>
<li>可配参数server.lfu_log_factor就服务于该策略，它能够影响计数的量级范围，整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。</li>
</ul>
</li>
<li><strong>计数衰减</strong>：该策略可以解决热点数据问题。<ul>
<li>可配参数server.lfu-decay-time就服务于该策略，它能够控制LFU计数衰减，是一个以分钟为单位的数值，可以调整counter的减少速度。</li>
</ul>
</li>
<li><strong>新增数据赋值</strong>：该策略可以解决新增数据问题。<ul>
<li>固定常量LFU_INIT_VAL就服务于该策略，其值默认为5，即为新生key的counter设置一个初始频次，默认为5。</li>
</ul>
</li>
</ol>
<h3 id="4-2-1-概率量级计数"><a href="#4-2-1-概率量级计数" class="headerlink" title="4.2.1 概率量级计数"></a>4.2.1 概率量级计数</h3><p>Redis的LFU实现也是需要为每个key维护一个字段来承载该key的访问频次的，而且<strong>这个字段不能太大</strong>，不然Redis这么多key，那么消耗的空间将是一个可怕的数字，同时，本着Redis一贯对空间锱铢必较的心态，能重复利用的字段，我们绝不维护新的字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:LRU_BITS; &#x2F;* LRU time (relative to global lru_clock) or</span><br><span class="line">                            * LFU data (least significant 8 bits frequency</span><br><span class="line">                            * and most significant 16 bits access time). *&#x2F;</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>看来看去，redisObject结构中，也只有lru字段可以重复利用了，因为淘汰策略是互斥的，Redis同时只能选择一种淘汰策略，要么LRU，要么LFU，要么其他，所以lru字段重复利用不会冲突。</p>
<p>在LRU算法中，24 bits的lru是用来记录LRU time的，<strong>在LFU中使用这个字段，却是分成16 bits与8 bits使用</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*          16 bits      8 bits</span><br><span class="line">*     +----------------+--------+</span><br><span class="line">*     + Last decr time | LOG_C  |</span><br><span class="line">*     +----------------+--------+</span><br></pre></td></tr></table></figure>

<p>高16 bits用来记录最近一次计数器衰减的时间ldt，单位是分钟，这个我们下文再说。</p>
<p><strong>低8 bits记录计数器数值counter</strong>。8个bit位最大为255，显然如果只是简单的对counter做加法，那8 bit的counter根本无法容纳Redis那动辄百万或千万级别的命中频次。</p>
<p>那么，Redis如何使用8 bit的counter来承载百万或者千万级别的命中频次呢？相关源码在<code>evict.c</code>文件中的<code>LFULogIncr</code>方法中实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Logarithmically increment a counter. The greater is the current counter value</span><br><span class="line"> * the less likely is that it gets really implemented. Saturate it at 255. *&#x2F;</span><br><span class="line">uint8_t LFULogIncr(uint8_t counter) &#123;</span><br><span class="line">    if (counter &#x3D;&#x3D; 255) return 255;</span><br><span class="line">    &#x2F;&#x2F;这里的rand()方法会生成一个 0 ~ RAND_MAX 之间的随机数，所以r的范围也就是0~1之间。</span><br><span class="line">    double r &#x3D; (double)rand()&#x2F;RAND_MAX;</span><br><span class="line">    double baseval &#x3D; counter - LFU_INIT_VAL;</span><br><span class="line">    if (baseval &lt; 0) baseval &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;根据目前counter和server.lfu_log_factor值得出一个p</span><br><span class="line">    double p &#x3D; 1.0&#x2F;(baseval*server.lfu_log_factor+1);</span><br><span class="line">    &#x2F;&#x2F;如果r &lt; p，counter才+1</span><br><span class="line">    if (r &lt; p) counter++;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看p字段：</p>
<p>对于<code>p=1.0/(baseval*server.lfu_log_factor+1);</code></p>
<p>等价于<code>p=1/((counter−LFU_INIT_VAL)*factor+1);</code></p>
<p>因为LFU_INIT_VAL是常数，所以当counter够大时，近似等于：<code>p=1/(counter*factor+1)</code></p>
<p>factor是个常数，server.lfu_log_factor默认值是10，下图展示了factor不同时，p=f(counter)的函数曲线</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bc7b790c06e282c599c94a25afdb0d0736c.png" alt=""></p>
<p>紧接着再来看r，r是由random函数随机出来的范围在0~1之间的值，我们可以认为r的值是随机的，那么我们可以认为：</p>
<p>r的值在0 ~ 1范围内，也就是r&lt;=1的概率为100%（1）；</p>
<p>r的值在0 ~ 0.9范围内，也就是r&lt;=0.9的概率为90%（0.9）；</p>
<p>以此类推。</p>
<p>r的值在0 ~ p的范围内，也就是r&lt;=p的概率为p；</p>
<p><strong>所以综上所诉</strong>，Redis的概率量级计数的核心逻辑就是：</p>
<ol>
<li><p><strong>每一次key被访问，counter都有近似<code>p=1/(counter*factor+1)</code>的概率会+1。在factor是常数的情况下，counter+1的概率随着counter值的增大而减小</strong>。</p>
</li>
<li><p><strong>factor值我们设置的越大，则counter+1的概率在同等情况下则会越低，counter字段8 bit一共255的上限也就越不容易被触达，换句话说，factor越大，Redis的counter字段能够记录的访问频次量级也就越高</strong>。</p>
</li>
</ol>
<blockquote>
<p>概率量级计数，就体现在p和factor上，p控制的是counter的概率上升，factor控制的是counter承载的访问量级。</p>
</blockquote>
<p>下表是不同的factor的值能够控制计数代表的量级的范围，当factor为100时，能够最大代表10M，也就是千万级别的命中数。</p>
<table>
<thead>
<tr>
<th align="center">factor</th>
<th align="center">100 hits</th>
<th align="center">1000 hits</th>
<th align="center">100K hits</th>
<th align="center">1M hits</th>
<th align="center">10M hits</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">104</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">18</td>
<td align="center">49</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">18</td>
<td align="center">142</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">100</td>
<td align="center">8</td>
<td align="center">11</td>
<td align="center">49</td>
<td align="center">143</td>
<td align="center">255</td>
</tr>
</tbody></table>
<p>下图是不同factor场景下，不同key的counter字段的值（颜色不同的线）在固定访问频率下随着时间的上升走势。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ddad582bc4e83b730a0c8fff3336ddd3158.png" alt=""></p>
<h3 id="4-2-2-计数衰减"><a href="#4-2-2-计数衰减" class="headerlink" title="4.2.2 计数衰减"></a>4.2.2 计数衰减</h3><p>上一章节我们讲了counter是概率增加，但为了解决热点问题，使热点数据能够随着时间推移慢慢的降低频次，以至于最后淘汰，那么Redis引入了计数衰减的策略。</p>
<p><strong>某个key的counter被衰减的时机是在它被访问的时候</strong>。在缓存被访问时，会更新数据的访问计数，更新的步骤是：</p>
<ol>
<li>先在现有数据的计数上进行计数衰减。</li>
<li>再对完成衰减后的计数进行概率增加。</li>
</ol>
<blockquote>
<p>所以要注意，计数衰减的触发也是被动的，而非Redis主动或者定时触发的。</p>
</blockquote>
<p>计数衰减的实现在LFUDecrAndReturn方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Return the current time in minutes, just taking the least significant</span><br><span class="line"> * 16 bits. The returned time is suitable to be stored as LDT (last decrement</span><br><span class="line"> * time) for the LFU implementation. *&#x2F;</span><br><span class="line">unsigned long LFUGetTimeInMinutes(void) &#123;</span><br><span class="line">    return (server.unixtime&#x2F;60) &amp; 65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Given an object last access time, compute the minimum number of minutes</span><br><span class="line"> * that elapsed since the last access. Handle overflow (ldt greater than</span><br><span class="line"> * the current 16 bits minutes time) considering the time as wrapping</span><br><span class="line"> * exactly once. *&#x2F;</span><br><span class="line">unsigned long LFUTimeElapsed(unsigned long ldt) &#123;</span><br><span class="line">    &#x2F;&#x2F;计算当前时间和ldt的时间差值，如果now &lt; ldt，默认为过了一个周期了，那么差值应该是65535-ldt+now。</span><br><span class="line">    unsigned long now &#x3D; LFUGetTimeInMinutes();</span><br><span class="line">    if (now &gt;&#x3D; ldt) return now-ldt;</span><br><span class="line">    return 65535-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* If the object decrement time is reached decrement the LFU counter but</span><br><span class="line"> * do not update LFU fields of the object, we update the access time</span><br><span class="line"> * and counter in an explicit way when the object is really accessed.</span><br><span class="line"> * And we will times halve the counter according to the times of</span><br><span class="line"> * elapsed time than server.lfu_decay_time.</span><br><span class="line"> * Return the object frequency counter.</span><br><span class="line"> *</span><br><span class="line"> * This function is used in order to scan the dataset for the best object</span><br><span class="line"> * to fit: as we check for the candidate, we incrementally decrement the</span><br><span class="line"> * counter of the scanned objects if needed. *&#x2F;</span><br><span class="line">unsigned long LFUDecrAndReturn(robj *o) &#123;</span><br><span class="line">    unsigned long ldt &#x3D; o-&gt;lru &gt;&gt; 8;</span><br><span class="line">    unsigned long counter &#x3D; o-&gt;lru &amp; 255;</span><br><span class="line">    &#x2F;&#x2F;算出该key已经经历过num_periods个周期了</span><br><span class="line">    unsigned long num_periods &#x3D; server.lfu_decay_time ? LFUTimeElapsed(ldt) &#x2F; server.lfu_decay_time : 0;</span><br><span class="line">    if (num_periods)</span><br><span class="line">        counter &#x3D; (num_periods &gt; counter) ? 0 : counter - num_periods;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很晦涩，没关系，逻辑其实并不复杂：</p>
<ol>
<li><p>可配参数server.lfu-decay-time所代表的含义是计数衰减的周期长度，单位是分钟。当时间过去一个周期（也就是lfu-decay-time分钟），计数值就会减1。</p>
</li>
<li><p>redisObject结构中的lru字段的高16bit，记录的是该key上次进行衰减的时间。</p>
</li>
<li><p>有上述两个数据可以算出从上次衰减到现在，该key已经经历过n个周期了，这也表示着，key需要先将counter衰减n。</p>
<ul>
<li>n的计算过程如代码所示，即从上次衰减到现在经过的时间除以衰减周期长度 server.lfu_decay_time：</li>
<li><code>unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;</code></li>
</ul>
</li>
<li><p>通过<code>LFUDecrAndReturn</code>方法得到该key的counter需要衰减的值n，将counter=counter-n，然后再执行概率增加计数的操作。</p>
</li>
</ol>
<h3 id="4-2-3-新增数据赋值"><a href="#4-2-3-新增数据赋值" class="headerlink" title="4.2.3 新增数据赋值"></a>4.2.3 新增数据赋值</h3><p>为了解决新增数据问题，即如果采用只记录缓存中的数据的访问信息，新加入的高频访问数据在刚加入的时候由于没有累积优势，很容易被淘汰掉；</p>
<p>那么对于新增加的key，则不能将他们的counter设为0，Redis为新增的key的counter设置了一个初始值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">robj *createObject(int type, void *ptr) &#123;</span><br><span class="line">    robj *o &#x3D; zmalloc(sizeof(*o));</span><br><span class="line">    o-&gt;type &#x3D; type;</span><br><span class="line">    o-&gt;encoding &#x3D; OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr &#x3D; ptr;</span><br><span class="line">    o-&gt;refcount &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set the LRU to the current lruclock (minutes resolution), or</span><br><span class="line">     * alternatively the LFU counter. *&#x2F;</span><br><span class="line">    if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru &#x3D; (LFUGetTimeInMinutes()&lt;&lt;8) | LFU_INIT_VAL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        o-&gt;lru &#x3D; LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即counter会被初始化为LFU_INIT_VAL，默认5。</p>
<blockquote>
<p>回顾我们上文说道的p=1/((counter−LFU_INIT_VAL)*factor+1)，可以看到，当计数值等于LFU_INIT_VAL时， p=1，也就是说，对于新增的key，下一次访问时，counter增加的概率为100%</p>
</blockquote>
<h2 id="4-3-Redis-LFU回收流程"><a href="#4-3-Redis-LFU回收流程" class="headerlink" title="4.3 Redis LFU回收流程"></a>4.3 Redis LFU回收流程</h2><p>Redis LFU回收流程和Redis LRU的回收流程<strong>一模一样</strong>（有所遗忘可以回顾本文2.3章），<strong>都是采用抽样+回收池的实现方式，不同的是LRU比较的是idle time空闲时间，而LFU比较的是counter访问频次</strong>。故不再赘述。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
            <a href="/tags/%E7%BC%93%E5%AD%98/" rel="tag"># 缓存</a>
          
            <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="next" title="JAVA静态/动态代理">
                <i class="fa fa-chevron-left"></i> JAVA静态/动态代理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/05/JAVA%E7%9A%84CAS%E5%8F%8A%E5%85%B6ABA%E9%97%AE%E9%A2%98/" rel="prev" title="JAVA的CAS及其ABA问题">
                JAVA的CAS及其ABA问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2020/08/04/LRU和LFU算法以及其在Redis中的实现/"
           data-title="LRU和LFU算法以及其在Redis中的实现" data-url="http://yoursite.com/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">97</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-LRU算法"><span class="nav-text">1 LRU算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-链表实现简单LRU"><span class="nav-text">1.1 链表实现简单LRU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-HashMap和双向链表实现高性能LRU"><span class="nav-text">1.2 HashMap和双向链表实现高性能LRU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-继承LinkedHashMap实现LRU"><span class="nav-text">1.3 继承LinkedHashMap实现LRU</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Redis中的LRU"><span class="nav-text">2 Redis中的LRU</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Redis缓存淘汰策略"><span class="nav-text">2.1 Redis缓存淘汰策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Redis中的LRU时钟"><span class="nav-text">2.2 Redis中的LRU时钟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-Redis-LRU回收流程"><span class="nav-text">2.3 Redis LRU回收流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-LFU算法"><span class="nav-text">3 LFU算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-使用双哈希表实现高性能LFU"><span class="nav-text">3.1 使用双哈希表实现高性能LFU</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Redis中的LFU"><span class="nav-text">4 Redis中的LFU</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-常规LFU算法面临的问题"><span class="nav-text">4.1 常规LFU算法面临的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Redis中的频次计算"><span class="nav-text">4.2 Redis中的频次计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-概率量级计数"><span class="nav-text">4.2.1 概率量级计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-计数衰减"><span class="nav-text">4.2.2 计数衰减</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-新增数据赋值"><span class="nav-text">4.2.3 新增数据赋值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Redis-LFU回收流程"><span class="nav-text">4.3 Redis LFU回收流程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">394.8k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
