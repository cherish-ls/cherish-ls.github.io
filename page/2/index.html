<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/05/MySQL%E7%9A%84%E5%88%86%E5%8C%BA-%E5%88%86%E5%BA%93-%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/05/MySQL%E7%9A%84%E5%88%86%E5%8C%BA-%E5%88%86%E5%BA%93-%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/" itemprop="url">MySQL的分区/分库/分表总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-05T21:00:18+08:00">
                2021-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/05/MySQL%E7%9A%84%E5%88%86%E5%8C%BA-%E5%88%86%E5%BA%93-%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/05/MySQL的分区-分库-分表总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  7.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  28
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文一切基于MySql InnoDB</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li><p>分区：把一张表的数据分成多个区块，在逻辑上看最终只是一张表，但底层是由多个物理区块组成的</p>
</li>
<li><p>分表：把一张表按一定的规则分解成多个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。</p>
</li>
<li><p>分库：把一个库拆成多个库，突破库级别的数据库操作I/O瓶颈。</p>
</li>
</ol>
<blockquote>
<p>在mysql中，schema和库(database)是一个概念</p>
</blockquote>
<h2 id="数据库架构演变"><a href="#数据库架构演变" class="headerlink" title="数据库架构演变"></a>数据库架构演变</h2><p>一开始，我们只用单机数据库就足够满足业务需要了，但随着业务的拓展，带来越来越多的请求，我们将数据库的写操作和读操作进行分离，使用多个从库副本（Slaver Replication）负责读，使用主库（Master）负责写。从库从主库同步更新数据，保持数据一致。架构上的数据库主从同步，使得从库可以水平扩展，所以更多的读请求不成问题。</p>
<p>但是当用户量级上来后，写请求越来越多，该怎么办？加一个Master是不能解决问题的， 因为数据要保存一致性，写操作需要2个master之间同步，相当于是重复了，而且更加复杂。</p>
<p>这时就需要用到分库分表，对写操作进行切分。</p>
<h2 id="什么情况下要分库分表"><a href="#什么情况下要分库分表" class="headerlink" title="什么情况下要分库分表"></a>什么情况下要分库分表</h2><p>任何问题都是太大或者太小的问题，我们这主要面对的是数据量太大的问题。</p>
<ol>
<li><p>用户请求量太大</p>
<ul>
<li>瓶颈：单服务器的TPS，内存，IO都是有限的。</li>
<li>解决方法：分散请求到多个服务器上； 其实用户请求和执行一个sql查询是本质是一样的，都是请求一个资源，只是用户请求还会经过网关，路由，http服务器等。</li>
</ul>
</li>
<li><p>单表数据量太大</p>
<ul>
<li>瓶颈：索引膨胀，查询耗时长，影响正常CRUD。</li>
<li>解决方法：切分成多个数据集更小的表。</li>
</ul>
</li>
<li><p>单库数据量太大</p>
<ul>
<li>瓶颈：单个数据库处理能力有限，单库所在服务器上磁盘空间不足，I/O有限；</li>
<li>解决方法：切分成更多更小的库</li>
</ul>
</li>
</ol>
<h1 id="1-分区"><a href="#1-分区" class="headerlink" title="1 分区"></a>1 分区</h1><p>首先，我们要明白分区的区是指什么！</p>
<p>我们在《【InnoDB详解二】MySQL文件系统和InnoDB存储结构》一文中提到过，MySQL的物理数据，存储在表空间文件（.ibdata1和.ibd）中，<strong>这里讲的分区的意思是指将同一表中不同行的记录分配到不同的物理文件中，几个分区就有几个.idb文件</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0ad0669d4a4cb9b37ce32e63ee4fc717fde.png" alt=""></p>
<p>MySQL在5.1时添加了对水平分区的支持。分区是将一个表或索引分解成多个更小，更可管理的部分。每个区都是独立的，可以独立处理，也可以作为一个更大对象的一部分进行处理。这个是MySQL支持的功能，业务代码无需改动。</p>
<p>可以通过使用SHOW VARIABLES命令来确定MySQL是否支持分区，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;%partition%&#39;;</span><br><span class="line"> </span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| have_partition_engine | YES   |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>在如上列出的一个正确的SHOW VARIABLES 命令所产生的输出中，如果没有看到变量have_partition_engine的值为YES，那么MySQL的版本就不支持分区。</p>
<p>MySQL是面向OLTP的数据库，对于分区的使用应该更加小心，如果不清楚如何使用分区可能会对性能产生负面的影响。</p>
<h2 id="1-1-MySQL分区类型"><a href="#1-1-MySQL分区类型" class="headerlink" title="1.1 MySQL分区类型"></a>1.1 MySQL分区类型</h2><p>目前MySQL支持一下几种类型的分区：</p>
<ol>
<li>RANGE分区：基于一个给定区间边界，得到若干个连续区间范围，按照分区键的落点，把数据分配到不同的分区；</li>
<li>LIST分区：类似RANGE分区，区别在于LIST分区是基于枚举出的值列表分区，RANGE是基于给定连续区间范围分区；</li>
<li>HASH分区：基于用户自定义的表达式的返回值，对其根据分区数来取模，从而进行记录在分区间的分配的模式。这个用户自定义的表达式，就是MySQL希望用户填入的哈希函数。</li>
<li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且使用MySQL 服务器提供的自身的哈希函数。</li>
</ol>
<p>如果表存在主键或者唯一索引时，分区列必须是唯一索引的一个组成部分。</p>
<blockquote>
<p>在实战中，十有八九都是用RANGE分区。</p>
</blockquote>
<h3 id="1-1-1-RANGE分区"><a href="#1-1-1-RANGE分区" class="headerlink" title="1.1.1 RANGE分区"></a>1.1.1 RANGE分区</h3><p>RANGE分区是实战最常用的一种分区类型，行数据基于属于一个给定的连续区间的列值被放入分区。</p>
<p>但是记住，当插入的数据不在一个分区中定义的值的时候，会抛异常。</p>
<p>RANGE分区主要用于日期列的分区，比如交易表啊，销售表啊等。可以根据年月来存放数据。</p>
<p>如果你分区走的唯一索引中date类型的数据，那么注意了，优化器只能对YEAR(),TO_DAYS(),TO_SECONDS(),UNIX_TIMESTAMP()这类函数进行优化选择。</p>
<p>实战中可以用int类型的字段来存时间戳做分区列，那么只用存yyyyMM就好了，也不用关心函数了。</p>
<p>MySQL使用PARTITION命令来做分区，sql语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE</span><br><span class="line">    &#96;Order&#96; (</span><br><span class="line">        &#96;id&#96;</span><br><span class="line">        INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">        &#96;partition_key&#96;</span><br><span class="line">        INT NOT NULL,</span><br><span class="line">        &#96;amt&#96;</span><br><span class="line">        DECIMAL(5) NULL) PARTITION BY RANGE(partition_key)</span><br><span class="line">PARTITIONS 5(</span><br><span class="line">    PARTITION part0 VALUES LESS THAN(201901),</span><br><span class="line">    PARTITION part1 VALUES LESS THAN(201902),</span><br><span class="line">    PARTITION part2 VALUES LESS THAN(201903),</span><br><span class="line">    PARTITION part3 VALUES LESS THAN(201904),</span><br><span class="line">    PARTITION part4 VALUES LESS THAN(201905),</span><br><span class="line">    PARTITION part4 VALUES LESS THAN MAXVALUE;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RANGE分区通过使用PARTITION BY RANGE(expr)实现，其中“expr” 可以是某个列值，如id，no，partition_key等。或一个基于某个列值并返回一个整数值的表达式，如YEAR(date)。不过值得注意的是，expr的返回值，不可以为NULL。</p>
</blockquote>
<blockquote>
<p>其中，MAXVALUE 表示最大的可能的整数值。如果没有设置MAXVALUE这个分区，那么此时如果insert一个partition_key大于201905的记录，MySQL就会抛出异常，插入失败。</p>
</blockquote>
<blockquote>
<p>VALUES LESS THAN的排列必须从小到大顺序列出，这样MySQL才能识别一个一个的区间段。</p>
</blockquote>
<p>这时候我们先插入一些数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &#96;Order&#96; (&#96;id&#96;, &#96;partition_key&#96;, &#96;amt&#96;) VALUES (&#39;1&#39;, &#39;201901&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;Order&#96; (&#96;id&#96;, &#96;partition_key&#96;, &#96;amt&#96;) VALUES (&#39;2&#39;, &#39;201902&#39;, &#39;800&#39;);</span><br><span class="line">INSERT INTO &#96;Order&#96; (&#96;id&#96;, &#96;partition_key&#96;, &#96;amt&#96;) VALUES (&#39;3&#39;, &#39;201903&#39;, &#39;1200&#39;);</span><br></pre></td></tr></table></figure>

<p>现在我们查询一下，通过EXPLAIN PARTITION命令发现SQL优化器只需搜对应的区，不会搜索所有分区:</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2c6597ab4e7854d1fe18bc882da5eb04f8f.png" alt=""></p>
<p>因为partition_key是分区键。当然，我们也可以直接指定搜索哪个分区:</p>
<p><code>SELECT * FROM Order PARTITION (part0,part1) WHERE status amt &gt; 1000</code></p>
<p>注意，如果sql语句不指定分区，则会走所有分区，性能反而会不升反降。所以分区表后，select语句必须走分区键。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ef302df24f6cc6c6e9735100664bfad5b16.png" alt=""></p>
<p>涉及聚合函数SUM()、COUNT()的查询时，如果不指定分区，那么会在每个分区上并行处理。例如执行这条语句<code>SELECT COUNT(1) FROM Order</code>，则会在每个分区上都同时运行查询；</p>
<p>一个例子不够，我们再举一个例子，来看看expr是个函数表达式的场景，假如现在有如下雇员表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,</span><br><span class="line">    job_code INT,</span><br><span class="line">    store_id INT</span><br><span class="line">)</span><br><span class="line">PARTITION BY RANGE (YEAR(separated)) (</span><br><span class="line">    PARTITION p0 VALUES LESS THAN (1991),</span><br><span class="line">    PARTITION p1 VALUES LESS THAN (1996),</span><br><span class="line">    PARTITION p2 VALUES LESS THAN (2001),</span><br><span class="line">    PARTITION p3 VALUES LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这个方案中，在1991年前离职的所有雇员的记录保存在分区p0中，1991年到1995年期间离职的所有雇员的记录保存在分区p1中， 1996年到2000年期间离职的所有雇员的记录保存在分区p2中，2000年后离职的所有工人的信息保存在p3中。</p>
<p>当需要删除“旧的”数据时，使用分区会有意想不到的效果。</p>
<p>假如我们想删除所有在1991年前就已经离职的雇员的记录，你只需简单地使用<code>ALTER TABLE employees DROP PARTITION p0;</code></p>
<p>对于有大量行的表，这比运行<code>DELETE FROM employees WHERE YEAR(separated) &lt;= 1990</code>要有效得多。</p>
<h3 id="1-1-2-LIST分区"><a href="#1-1-2-LIST分区" class="headerlink" title="1.1.2 LIST分区"></a>1.1.2 LIST分区</h3><p>MySQL中的LIST分区在很多方面类似于RANGE分区。和RANGE分区一样，LIST分区的每个分区必须明确定义。它们的主要区别在于，LIST分区是基于枚举出的值列表分区，RANGE是基于给定连续区间范围分区；</p>
<p>LIST分区通过使用<code>PARTITION BY LIST(expr)</code>来实现，我们假定有20个音像店，分布在4个有经销权的地区，如下表所示：</p>
<table>
<thead>
<tr>
<th>地区</th>
<th>商店ID 号</th>
</tr>
</thead>
<tbody><tr>
<td>北区</td>
<td>3, 5, 6, 9, 17</td>
</tr>
<tr>
<td>东区</td>
<td>1, 2, 10, 11, 19, 20</td>
</tr>
<tr>
<td>西区</td>
<td>4, 12, 13, 14, 18</td>
</tr>
<tr>
<td>中心区</td>
<td>7, 8, 15, 16</td>
</tr>
</tbody></table>
<p>要按照属于同一个地区商店的记录保存在同一个分区的原则来分割表，可以使用下面的CREATE TABLE语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,</span><br><span class="line">    job_code INT,</span><br><span class="line">    store_id INT</span><br><span class="line">)</span><br><span class="line">PARTITION BY LIST(store_id)</span><br><span class="line">    PARTITION pNorth VALUES IN (3,5,6,9,17),</span><br><span class="line">    PARTITION pEast VALUES IN (1,2,10,11,19,20),</span><br><span class="line">    PARTITION pWest VALUES IN (4,12,13,14,18),</span><br><span class="line">    PARTITION pCentral VALUES IN (7,8,15,16)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>可以看到，和RANGE分区相比，LIST分区的VALUES IN后面接的是枚举值列表，不像RANGE是用VALUES LESS THAN来定义区间边界。</p>
<blockquote>
<p>如果试图插入字段值（或分区表达式的返回值）不在分区值列表中的任何一行时，那么“INSERT”查询将失败并报错。例如，假定LIST分区的采用上面的方案，那么下面的查询将失败：<code>INSERT INTO employees VALUES (224, &#39;Linus&#39;, &#39;Torvalds&#39;, &#39;2002-05-01&#39;, &#39;2004-10-12&#39;, 42, 21);</code>。因为“store_id”字段值21不能在用于定义分区pNorth, pEast, pWest,或pCentral的值列表中找到。</p>
</blockquote>
<blockquote>
<p>要重点注意的是，LIST分区没有类似如“VALUES LESS THAN MAXVALUE”这样的包含其他值在内的定义。所以将要匹配的任何值都必须在值列表中能够找到。</p>
</blockquote>
<h3 id="1-1-3-HASH分区"><a href="#1-1-3-HASH分区" class="headerlink" title="1.1.3 HASH分区"></a>1.1.3 HASH分区</h3><p>HASH分区主要用来确保数据在预先确定数目的分区中平均分布。在RANGE和LIST分区中，我们必须明确指定一个给定的区间或列值集合，来指定哪些记录进入哪些分区；而在HASH分区中，MySQL自动完成分配记录到区间的工作，你所要做的只是确定一个用来做哈希的字段或者表达式，以及指定被分区的表将要被分割成的分区数量。</p>
<p>要使用HASH分区来分割一个表，要在CREATE TABLE 语句上添加一个<code>PARTITION BY HASH (expr)</code>子句，其中“expr”同样可以是一个返回一个整数的表达式，或者仅仅是字段类型为整型的某个字段。</p>
<p>此外，你很可能需要在后面再添加一个“PARTITIONS num”子句，其中num 是一个非负的整数，它表示表将要被分割成分区的数量。</p>
<p>例如，下面的语句创建了一个使用基于“store_id”列进行哈希处理的表，该表被分成了4个分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,</span><br><span class="line">    job_code INT,</span><br><span class="line">    store_id INT</span><br><span class="line">)</span><br><span class="line">PARTITION BY HASH(store_id)</span><br><span class="line">PARTITIONS 4；</span><br></pre></td></tr></table></figure>

<p>如果没有包括一个PARTITIONS子句，那么分区的数量将默认为1。</p>
<blockquote>
<p>注意，expr不应该设置的过于复杂，因为每当插入或更新（或者可能删除）一行时，这个表达式都要计算一次；这意味着非常复杂的表达式可能会引起性能问题，尤其是在执行同时影响大量行的运算（例如批量插入）的时候。</p>
</blockquote>
<p>最有效率的哈希函数是只对单个表列进行计算，并且它的结果值随字段值进行一致地增大或减小，因为这考虑了在分区范围上的“修剪”。也就是说，表达式值和它所基于的列的值变化越接近，MySQL就可以越有效地使用该表达式来进行HASH分区。</p>
<p>当使用了“PARTITION BY HASH”时，MySQL将基于用户提供的函数结果的模数来确定使用哪个编号的分区。换句话，对于一个表达式“expr”，将要保存记录的分区编号为N ，其中“N = MOD(expr, num)”。</p>
<h3 id="1-1-4-KEY分区"><a href="#1-1-4-KEY分区" class="headerlink" title="1.1.4 KEY分区"></a>1.1.4 KEY分区</h3><p>按照KEY进行分区类似于按照HASH分区，除了HASH分区使用的用户定义的表达式，而KEY分区的哈希函数是由MySQL 服务器提供。</p>
<p>MySQLCluster使用函数MD5()来实现KEY分区；对于使用其他存储引擎的表，服务器使用其自己内部的 哈希函数，这些函数是基于与PASSWORD()一样的运算法则。</p>
<p>“CREATE TABLE … PARTITION BY KEY”的语法规则类似于创建一个通过HASH分区的表的规则。它们唯一的区别在于使用的关键字是KEY而不是HASH，并且KEY分区只采用一个或多个列名的一个列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tk (</span><br><span class="line">    col1 INT NOT NULL,</span><br><span class="line">    col2 CHAR(5),</span><br><span class="line">    col3 DATE</span><br><span class="line">)</span><br><span class="line">PARTITION BY LINEAR KEY (col1)</span><br><span class="line">PARTITIONS 3;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-5-子分区"><a href="#1-1-5-子分区" class="headerlink" title="1.1.5 子分区"></a>1.1.5 子分区</h3><p>子分区是分区表中每个分区的再次分割。例如，考虑下面的CREATE TABLE 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts (id INT, purchased DATE)</span><br><span class="line">    PARTITION BY RANGE(YEAR(purchased))</span><br><span class="line">    SUBPARTITION BY HASH(TO_DAYS(purchased))</span><br><span class="line">    SUBPARTITIONS 2</span><br><span class="line">    (</span><br><span class="line">        PARTITION p0 VALUES LESS THAN (1990),</span><br><span class="line">        PARTITION p1 VALUES LESS THAN (2000),</span><br><span class="line">        PARTITION p2 VALUES LESS THAN MAXVALUE</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>表ts有3个RANGE分区。这3个分区（p0, p1, 和 p2）中的每一个分区又被进一步分成了2个子分区。实际上，整个表被分成了3 * 2 = 6个分区。但是，由于PARTITION BY RANGE子句的作用，p0分区的子分区里，只会保存“purchased”列中值小于1990的那些记录。</p>
<p>在MySQL 5.1中，对于已经通过RANGE或LIST分区了的表再进行子分区是可能的。子分区既可以使用HASH希分区，也可以使用KEY分区。这也被称为复合分区（composite partitioning）。</p>
<p>为了对个别的子分区指定选项，使用SUBPARTITION 子句来明确定义子分区也是可能的。例如，创建在前面例子中给出的同一个表的、一个更加详细的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts (id INT, purchased DATE)</span><br><span class="line">    PARTITION BY RANGE(YEAR(purchased))</span><br><span class="line">    SUBPARTITION BY HASH(TO_DAYS(purchased))</span><br><span class="line">    (</span><br><span class="line">        PARTITION p0 VALUES LESS THAN (1990)</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s0,</span><br><span class="line">            SUBPARTITION s1</span><br><span class="line">        ),</span><br><span class="line">        PARTITION p1 VALUES LESS THAN (2000)</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s2,</span><br><span class="line">            SUBPARTITION s3</span><br><span class="line">        ),</span><br><span class="line">        PARTITION p2 VALUES LESS THAN MAXVALUE</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s4,</span><br><span class="line">            SUBPARTITION s5</span><br><span class="line">        )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>不过有几点要注意的语法项：</p>
<ol>
<li>每个分区必须有相同数量的子分区。</li>
<li>如果在一个分区表上的某个分区上使用SUBPARTITION来明确定义子分区，那么就必须定义其他所有分区的子分区。</li>
</ol>
<p>子分区可以用于特别大的表，在多个磁盘间分配数据和索引。假设有6个磁盘，分别为/disk0， /disk1， /disk2等。现在考虑下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts (id INT, purchased DATE)</span><br><span class="line">    PARTITION BY RANGE(YEAR(purchased))</span><br><span class="line">    SUBPARTITION BY HASH(TO_DAYS(purchased))</span><br><span class="line">    (</span><br><span class="line">        PARTITION p0 VALUES LESS THAN (1990)</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s0a</span><br><span class="line">                DATA DIRECTORY &#x3D; &#39;&#x2F;disk0&#39;</span><br><span class="line">                INDEX DIRECTORY &#x3D; &#39;&#x2F;disk1&#39;,</span><br><span class="line">            SUBPARTITION s0b</span><br><span class="line">                DATA DIRECTORY &#x3D; &#39;&#x2F;disk2&#39; </span><br><span class="line">                INDEX DIRECTORY &#x3D; &#39;&#x2F;disk3&#39;</span><br><span class="line">        ),</span><br><span class="line">        PARTITION p1 VALUES LESS THAN (2000)</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s1a</span><br><span class="line">                DATA DIRECTORY &#x3D; &#39;&#x2F;disk4&#x2F;data&#39; </span><br><span class="line">                INDEX DIRECTORY &#x3D; &#39;&#x2F;disk4&#x2F;idx&#39;,</span><br><span class="line">            SUBPARTITION s1b</span><br><span class="line">                DATA DIRECTORY &#x3D; &#39;&#x2F;disk5&#x2F;data&#39; </span><br><span class="line">                INDEX DIRECTORY &#x3D; &#39;&#x2F;disk5&#x2F;idx&#39;</span><br><span class="line">        ),</span><br><span class="line">        PARTITION p2 VALUES LESS THAN MAXVALUE</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s2a,</span><br><span class="line">            SUBPARTITION s2b</span><br><span class="line">        )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>DATA DIRECTORY表示数据的物理文件的存放目录</li>
<li>INDEX DIRECTORY表示索引的物理文件的存放目录</li>
</ul>
<p>在这个例子中，每个RANGE分区的数据和索引都使用一个单独的磁盘。存储的分配如下：</p>
<ol>
<li>购买日期在1990年前的记录占了大量的存储空间，所以把它分为了四个部分进行存储，组成p0分区的两个子分区（s0a 和s0b）的数据和索引都分别用一个单独的磁盘进行存储。换句话说：<ul>
<li>子分区s0a 的数据保存在磁盘/disk0中。</li>
<li>子分区s0a 的索引保存在磁盘/disk1中。</li>
<li>子分区s0b 的数据保存在磁盘/disk2中。</li>
<li>子分区s0b 的索引保存在磁盘/disk3中。</li>
</ul>
</li>
<li>保存购买日期从1990年到1999年间的记录（分区p1）不需要保存购买日期在1990年之前的记录那么大的存储空间。这些记录分在2个磁盘（/disk4和/disk5）上保存，而不是4个磁盘：<ul>
<li>属于分区p1的第一个子分区（s1a）的数据和索引保存在磁盘/disk4上 — 其中数据保存在路径/disk4/data下，索引保存在/disk4/idx下。</li>
<li>属于分区p1的第二个子分区（s1b）的数据和索引保存在磁盘/disk5上 — 其中数据保存在路径/disk5/data下，索引保存在/disk5/idx下。</li>
</ul>
</li>
<li>保存购买日期从2000年到现在的记录（分区p2）不需要前面两个RANGE分区那么大的空间。当前，在默认的位置能够足够保存所有这些记录。</li>
</ol>
<h2 id="1-2-分区维护"><a href="#1-2-分区维护" class="headerlink" title="1.2 分区维护"></a>1.2 分区维护</h2><p>MySQL提供了许多修改分区表的方式。添加、删除、重新定义、合并或拆分已经存在的分区是可能的。所有这些操作都可以通过使用<code>ALTER TABLE</code>命令的分区扩展来实现。</p>
<p>下面我们来总结一下所有分区维护的命令，为简便计，我们定义几种partitions_exprs来替代如下子命令：</p>
<ul>
<li>RANGE分区，range_partitions_exprs(n)即为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PARTITION p VALUES LESS THAN (xxx)</span><br><span class="line">...(n个PARTITION子句)</span><br></pre></td></tr></table></figure></li>
<li>LIST分区，list_partitions_exprs即为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PARTITION p VALUES IN (xxx,yyy,...),</span><br><span class="line">...(n个PARTITION子句)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-2-1-添加分区"><a href="#1-2-1-添加分区" class="headerlink" title="1.2.1 添加分区"></a>1.2.1 添加分区</h3><ol>
<li>为已创建的未分区表创建分区：<ul>
<li>RANGE：<code>ALTER TABLE tb PARTITION BY RANGE (expr) ( range_partitions_exprs(n&gt;0) );</code></li>
<li>LIST：<code>ALTER TABLE tb PARTITION BY LIST (expr) ( list_partitions_exprs(n&gt;0) );</code></li>
<li>HASH：<code>ALTER TABLE tb PARTITION BY HASH(expr) PARTITIONS 2;</code></li>
<li>KEY：<code>ALTER TABLE tb PARTITION BY KEY(expr) PARTITIONS 2;</code></li>
</ul>
</li>
<li>为分区表添加n个分区：<ul>
<li>RANGE：<code>ALTER TABLE tb ADD PARTITION ( range_partitions_exprs(n&gt;0) );</code></li>
<li>LIST：<code>ALTER TABLE tb ADD PARTITION ( list_partitions_exprs(n&gt;0) );</code></li>
<li>HASH &amp; KEY：<code>ALTER TABLE tb ADD PARTITION PARTITIONS n;</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>对于通过RANGE分区的表，只可以使用ADD PARTITION添加新的分区到分区列表的尾端。设法通过这种方式在现有分区的前面或之间增加一个新的分区，将会导致报错。此时建议使用下文的拆分操作，REORGANIZE命令可以运行expr重叠。</p>
</blockquote>
<blockquote>
<p>不能添加这样一个新的LIST分区，该分区包含有已经包含在现有分区值列表中的任意值。如果试图这样做，将会导致错误。此时建议使用下文的拆分操作，REORGANIZE命令可以运行expr重叠。</p>
</blockquote>
<h3 id="1-2-2-重调整分区"><a href="#1-2-2-重调整分区" class="headerlink" title="1.2.2 重调整分区"></a>1.2.2 重调整分区</h3><ol>
<li>数据不丢失的前提下，将m个分区<strong>合并</strong>为n个分区（m&gt;n），即减量重新组织分区<ul>
<li>RANGE：<code>ALTER TABLE tb REORGANIZE PARTITION s0,s1,... INTO ( range_partitions_exprs(n) )</code></li>
<li>LIST：<code>ALTER TABLE tb REORGANIZE PARTITION s0,s1,... INTO ( list_partitions_exprs(n) )</code></li>
<li>HASH &amp; KEY：<code>ALTER TABLE clients COALESCE PARTITION n; (n小于原有分区数)</code></li>
</ul>
</li>
<li>数据不丢失的前提下，将分区表的m个分区<strong>拆分</strong>为n个分区（m&lt;n），即增量重新组织分区<ul>
<li>RANGE：<code>ALTER TABLE tb REORGANIZE PARTITION p0,p1,... INTO ( range_partitions_exprs(n) )</code></li>
<li>LIST：<code>ALTER TABLE tb REORGANIZE PARTITION p0,p1,... INTO ( list_partitions_exprs(n) )</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>不能使用REORGANIZE PARTITION来改变表的分区类型；也就是说，例如，不能把RANGE分区变为HASH分区，反之亦然。也不能使用该命令来改变分区表达式或列。</p>
</blockquote>
<ol start="3">
<li>重建分区，即先删除分区中的所有记录，然后重新插入。可用于整理分区碎片。<ul>
<li><code>ALTER TABLE tb REBUILD PARTITION p0, p1;</code></li>
</ul>
</li>
<li>优化分区，整理分区碎片<ul>
<li><code>ALTER TABLE tb OPTIMIZE PARTITION p0, p1;</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>如从分区中删除了大量的行，或者对一个带有可变长度字段（VARCHAR、BLOB、TEXT类型）的行作了许多修改，可以使用优化分区来收回没有使用的空间，并整理分区数据文件的碎片。<br>5. 修复分区，修补被破坏的分区。<br>    - <code>ALTER TABLE tb REPAIR PARTITION p0,p1;</code><br>6.  检查分区，这个命令可以告诉你分区中的数据或索引是否已经被破坏，如果被破坏，请使用修复分区来修补<br>    - <code>ALTER TABLE tb CHECK PARTITION p1;</code></p>
</blockquote>
<h3 id="1-2-3-删除分区"><a href="#1-2-3-删除分区" class="headerlink" title="1.2.3 删除分区"></a>1.2.3 删除分区</h3><ol>
<li>删除一个分区，以及分区内的所有数据：<ul>
<li><code>ALTER TABLE tb DROP PARTITION p2;</code></li>
</ul>
</li>
<li>删除一个分区，但保留分区内的所有数据(MySQL 5.5引入)：<ul>
<li><code>ALTER TABLE tb TRUNCATE PARTITION p2;</code></li>
</ul>
</li>
</ol>
<h3 id="1-2-4-查询分区数据"><a href="#1-2-4-查询分区数据" class="headerlink" title="1.2.4 查询分区数据"></a>1.2.4 查询分区数据</h3><ol>
<li>查看某个schema下某个表的分区信息<ul>
<li><code>SELECT * FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA = &#39;xxx&#39; AND TABLE_NAME LIKE &#39;xxxx&#39;;</code></li>
</ul>
</li>
<li>分析某个分区,主要看行数和名称以及状态<ul>
<li><code>ALTER TABLE tb ANALYZE PARTITION p3;</code></li>
</ul>
</li>
</ol>
<h1 id="2-分表"><a href="#2-分表" class="headerlink" title="2 分表"></a>2 分表</h1><p>分表顾名思义，就是把一张超大的数据表，拆分为多个较小的表，使得一些超大表的痼疾，得到有效的缓解。</p>
<p>超大表会带来如下的影响：</p>
<ol>
<li>单表数据量太大，会被频繁读写，加锁操作密集，导致性能降低。</li>
<li>单表数据量太大，对应的索引也会很大，查询效率降低，增删操作的性能也会降低。</li>
</ol>
<p>分表和分区看起来十分类似，确实，分区已经能够在磁盘层面将一张表拆分成多个文件了，理论上前面提到的大表的问题都能得到有效解决。因为分区就是分表的数据库实现版本。</p>
<p>在MySQL 5.1分区功能出现以前，要想解决超大表问题，只能采用分表操作，因为这类问题十分常见，MySQL才自带了一个分区功能，以达到相同的效果。</p>
<p>所以你可以直接说分区就是分表的替代，分表是分区出现以前的做法。不过这不代表我们就没有必要学习分表了，相反，水平分表的功能或许可以用更加便捷的分区来替代，但是垂直分表的功能，分区却无法替代。</p>
<p>分表只能通过程序代码来实现，目前市面上有许多分表的框架。</p>
<h2 id="2-1-分表和分区的区别"><a href="#2-1-分表和分区的区别" class="headerlink" title="2.1 分表和分区的区别"></a>2.1 分表和分区的区别</h2><ol>
<li>分区只是一张表中的数据和索引的存储位置发生改变，分表则是将一张表分成多张表，是真实的有多套表的配套文件</li>
<li>分区没法突破数据库层面，不论怎么分区，这些分区都要在一个数据库下。而分表可以将子表分配在同一个库中，也可以分配在不同库中，突破数据库性能的限制。</li>
<li>分区只能替代水平分表的功能，无法取代垂直分表的功能。</li>
</ol>
<h2 id="2-2-分表的类型"><a href="#2-2-分表的类型" class="headerlink" title="2.2 分表的类型"></a>2.2 分表的类型</h2><p>分表分为水平分表和垂直分表。</p>
<h3 id="2-2-1-水平分表"><a href="#2-2-1-水平分表" class="headerlink" title="2.2.1 水平分表"></a>2.2.1 水平分表</h3><p>水平分表和分区很像，或者说分区就是水平分表的数据库实现版本，它们分的都是行记录，就像用一把刀，水平的将一个表切成多张表一样。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-84df96079a112e74ce0b9fb080cc16b4c84.png" alt=""></p>
<p>针对数据量巨大的单张表（比如订单表），我们按照某种规则，切分到多张表里面去。</p>
<p>但是需要注意，如果这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。分表可以将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与子表，这是分区所不能有的优势。</p>
<p>水平分表的切分规则一般有如下几种：</p>
<ol>
<li>范围切分<ul>
<li>可以根据某个字段的范围做划分，比如订单号字段，从0到10000一个表，10001到20000一个表。</li>
</ul>
</li>
<li>HASH取模<ul>
<li>可以根据某个字段的HASH取模做划分，比如将一个用户表分成10个子表，可以取用户id，然后hash后取10的模，从而分配到不同的数据库上。不过这种划分一旦确定后，就无法改变子表数量了。</li>
</ul>
</li>
<li>地理/国籍/类型等<ul>
<li>比如按照华东，华南，华北这样来区分业务表，或者安卓用户，IOS用户等来区分用户表。</li>
</ul>
</li>
<li>时间<ul>
<li>按照时间切分，比如将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</li>
</ul>
</li>
</ol>
<h3 id="2-2-2-垂直分表"><a href="#2-2-2-垂直分表" class="headerlink" title="2.2.2 垂直分表"></a>2.2.2 垂直分表</h3><p>水平分表分的是行记录，而垂直分表，分的是列字段，它就像用一把刀，垂直的将一个表切成多张表一样。</p>
<p>垂直分表是基于列字段进行的。一般是表中的字段较多，或者有数据较大长度较长（比如text，blob，varchar(1000)以上的字段）的字段时，我们将不常用的，或者数据量大的字段拆分到“扩展表”上。这样避免查询时，数据量太大造成的“跨页”问题。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-82f7ac5bade04db64ad8a3b49cc82777b12.png" alt=""></p>
<p>垂直分表的切分规则很好理解，一般是“不常用”或者“字段数据量大”这两点来做切割，我们不多赘述。</p>
<h1 id="3-分库"><a href="#3-分库" class="headerlink" title="3 分库"></a>3 分库</h1><p>分库同样是为了应对超大数据带来的巨大的IO需求，如果不拆库，那么单库所能支持的吞吐能力和磁盘空间，就会成为制衡业务发展的瓶颈。分库的主要目的是为突破单节点数据库服务器的I/O能力限制，解决数据库水平扩展性问题。</p>
<h2 id="3-1-分区分表之外的分库作用"><a href="#3-1-分区分表之外的分库作用" class="headerlink" title="3.1 分区分表之外的分库作用"></a>3.1 分区分表之外的分库作用</h2><p>也许你会问，我们有了分区和分表技术，还需要分库来解决大数据量的问题吗？对的，需要。</p>
<p>分区和分表可以把单表分到不同的硬盘上，但不能分配到不同服务器上。一台机器的性能是有限制的，用分库可以解决单台服务器性能不够，或者成本过高问题。</p>
<p>将一个库分成多个库，并在多个服务器上部署，就可以突破单服务器的性能瓶颈，这是分库必要性的最主要原因。</p>
<h2 id="3-2-分库的类型"><a href="#3-2-分库的类型" class="headerlink" title="3.2 分库的类型"></a>3.2 分库的类型</h2><p>分库同样分为水平分库和垂直分库。</p>
<ol>
<li>水平分库<ul>
<li>水平分库和水平分表相似，并且关系紧密，水平分库就是将单个库中的表作水平分表，然后将子表分别置于不同的子库当中，独立部署。</li>
<li>因为库中内容的主要载体是表，所以水平分库和水平分表基本上如影随形。</li>
<li>例如用户表，我们可以使用注册时间的范围来分表，将2020年注册的用户表usrtb2020部署在usrdata20中，2021年注册的用户表usrtb2021部署在usrdata21中。</li>
</ul>
</li>
<li>垂直分库<ul>
<li>同样的，垂直分库和垂直分表也十分类似，不过垂直分表拆分的是字段，而垂直分库，拆分的是表。</li>
<li>垂直分库是将一个库下的表作不同维度的分类，然后将其分配给不同子库的策略。</li>
<li>例如，我们可以将用户相关的表都放置在usrdata这个库中，将订单相关的表都放置在odrdata中，以此类推。</li>
<li>垂直分库的分类维度有很多，可以按照业务模块划分（用户/订单…），按照技术模块分（日志类库/图片类库…），或者空间，时间等等。</li>
</ul>
</li>
</ol>
<h1 id="4-分库分表存在的问题"><a href="#4-分库分表存在的问题" class="headerlink" title="4 分库分表存在的问题"></a>4 分库分表存在的问题</h1><ol>
<li>事务问题。<ul>
<li><strong>问题描述</strong>：在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</li>
<li><strong>解决方法</strong>：利用分布式事务，协调不同库之间的数据原子性，一致性。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>跨库跨表的join问题。</p>
<ul>
<li><strong>问题描述</strong>：在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。</li>
<li><strong>解决方法</strong>：tddl、MyCAT等都支持跨分片join。但是我们应该尽力避免跨库join，如果一定要整合数据，那么请在代码中多次查询完成。</li>
</ul>
</li>
<li><p>额外的数据管理负担和数据运算压力。</p>
<ul>
<li><strong>问题描述</strong>：额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。</li>
<li><strong>解决方法</strong>：无解，这是水平拓展的代价。</li>
</ul>
</li>
</ol>
<h1 id="5-分库分表方案产品"><a href="#5-分库分表方案产品" class="headerlink" title="5 分库分表方案产品"></a>5 分库分表方案产品</h1><p>目前市面上的分库分表中间件相对较多，其中基于代理方式的有MySQL Proxy和Amoeba；基于Hibernate框架的是Hibernate Shards；基于jdbc的有当当sharding-jdbc；基于mybatis的类似maven插件式的有蘑菇街的蘑菇街TSharding；通过重写spring的ibatis template类的Cobar Client。</p>
<p>还有一些大公司的开源产品：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-92e5751b3c11a7cbf834051e6129b5cf0cb.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/" itemprop="url">动态规划的分析和简述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-04T21:29:35+08:00">
                2021-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/04/动态规划的分析和简述/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-动态规划的概念"><a href="#1-动态规划的概念" class="headerlink" title="1 动态规划的概念"></a>1 动态规划的概念</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解<strong>决策过程最优化</strong>的数学方法。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。</p>
<p><strong>决策过程是什么呢</strong>？在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。各个阶段决策的选取依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。</p>
<p>在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前的<strong>状态</strong>，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。</p>
<h2 id="1-2-概念和术语"><a href="#1-2-概念和术语" class="headerlink" title="1.2 概念和术语"></a>1.2 概念和术语</h2><p>关于动态规划，我们要了解如下概念和术语，我们以0-1背包问题为例：</p>
<blockquote>
<p>0-1背包问题:我们有n种物品，物品j的重量为wj，价格为pj，背包的总重量是W，如果限定每种物品只能选择0个或1个，那么如何选取物品，使背包内物品的总价值最大。</p>
</blockquote>
<ol>
<li>阶段：<ul>
<li>把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同</li>
<li>0-1背包问题中，我们每一次选取一个新的物品放入背包的这个过程，就是一个阶段。</li>
</ul>
</li>
<li>状态：<ul>
<li>状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。</li>
<li>0-1背包问题中，我们每一次选取一个新的物品后，（已选取物品，已选取的物品总价值），这二者的值就是一个阶段的状态。</li>
</ul>
</li>
<li>决策<ul>
<li>一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。</li>
<li>0-1背包问题中，每次我们选取哪个物品放入，这就是一个决策，</li>
</ul>
</li>
<li>策略：<ul>
<li>由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</li>
<li>一次连续阶段的多个决策序列就是策略，比如策略A可以是：放入钢笔——放入水壶——放入睡袋。策略B是放入钢笔——放入睡袋——放入头盔。以此类推</li>
</ul>
</li>
<li>多阶段决策问题：<ul>
<li>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题</li>
<li>0-1背包问题就是一个典型的多阶段决策问题。</li>
</ul>
</li>
</ol>
<h2 id="1-3-核心思路"><a href="#1-3-核心思路" class="headerlink" title="1.3 核心思路"></a>1.3 核心思路</h2><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>不过与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往<strong>不是互相独立的</strong>。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。</p>
<p>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。在动态规划中，我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p>
<p>动态规划的核心除了<strong>分阶段决策</strong>外，还有上面所说的<strong>避免重复计算</strong>。这个如何理解呢？</p>
<p>比如0-1背包问题，我们现在有1，2，3三个物品，xj=1表示j物品放入背包，xj=0则表示j物品没放入。同时策略C(x1x2x3)=001，表示x1和x2都没有放入背包，x3放入了背包。</p>
<p>现在假如通过穷举得到了如下的5种可行策略：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b0743e22223d2b97f33727c532090c6508e.png" alt=""></p>
<p>那么由图我们可以知道，C2=011和C3=010这两种策略，都要经过01这个策略，如果在计算011的时候我们计算一遍01，在计算010的时候我们又计算一遍01，那么就重复计算了，我们为什么不把01这个策略的状态（已选取物品，已选取的物品总价值）保存下来呢？这样在计算010的时候，直接就可以把01的结果拿出来用了。</p>
<p>动态规划算法可以理解为是<strong>分治法</strong>和<strong>穷举法</strong>的结合：</p>
<ol>
<li>它用分治法的思想将一个问题分为多个决策阶段，既将问题复杂性减小，也为后续的局部结果复用提供前提。</li>
<li>它搜索解的方式还是穷举法那一套，只不过因为可以局部复用，所以它的复杂性会大大降低。</li>
</ol>
<p>其关键在于解决冗余，这是动态规划算法的<strong>根本目的</strong>。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间</p>
<h2 id="1-4-适用场景"><a href="#1-4-适用场景" class="headerlink" title="1.4 适用场景"></a>1.4 适用场景</h2><p>动态规划算法通常用于求解具有某种最优性质的多阶段决策问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p>
<p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和状态无后效性：</p>
<ol>
<li>最优化原理（最优子结构性质）<ul>
<li>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。</li>
<li>在0-1背包问题中，我们假设策略C=011是最优解，也就是说背包存放x2和x3，才能使价值最高，那么它的子策略，01x和x11，也同样都是最优解。最优化原理通俗的讲就是：011是最优解，那么01x肯定也是最优解，01x表示x3先不论，x1肯定不能选，x2肯定要选，否则就不是最优解。</li>
</ul>
</li>
<li>状态无后效性：<ul>
<li>状态无后效性指的是每个阶段的状态都是过去阶段的一个完整总结，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策。这就是无后向性，又称为无后效性。</li>
<li>在0-1背包问题中，我们的状态是（已选取物品，已选取的物品总价值），我们之所以选择这样的两个值作为状态，就是因为它都是对过去阶段的完整总结。这使得从这个状态基础上进行的新的决策，可以不用去关心之前的状态，因为之前的状态被总结了。之所以要使状态无后效性，就是为了便于存储和复用阶段的结果，避免重复计算。</li>
<li>试想一下，如果状态不是无后效性的，比如我们选择的状态是（本次选取的物品），那么我们保存这个状态的值，根本对后面的复用没有帮助，后面要想知道背包还剩多少空间，还是要把之前经历过的阶段的解都计算一遍。</li>
</ul>
</li>
</ol>
<h2 id="1-5-解题技巧"><a href="#1-5-解题技巧" class="headerlink" title="1.5 解题技巧"></a>1.5 解题技巧</h2><p>前文我们提到过，动态规划是分治法和穷举法的结合，同时，在动态规划中，我们可以用一个表来记录所有已穷举出的已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p>
<p>那么，如何将上述的经验整理成解题技巧呢？还是用0-1背包问题为例，来看下所谓的填表格式到底是什么：</p>
<blockquote>
<p>假设你是个小偷，背着一个可装4磅东西的背包。你可盗窃的商品有如下3件。为了让盗窃的商品价值最高，你该选择哪些商品？</p>
</blockquote>
<table>
<thead>
<tr>
<th>商品名称</th>
<th>重量（磅）</th>
<th>价值（美元）</th>
</tr>
</thead>
<tbody><tr>
<td>音响</td>
<td>4</td>
<td>3000</td>
</tr>
<tr>
<td>笔记本电脑</td>
<td>3</td>
<td>2000</td>
</tr>
<tr>
<td>吉他</td>
<td>1</td>
<td>1500</td>
</tr>
</tbody></table>
<p>每个动态规划算法都从一个填表的网格开始，背包问题的网格如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-acaa938a3d53c298fca66158871c356f97f.png" alt=""></p>
<ul>
<li>网格的各行为商品，各列为不同容量（1～4磅）的背包。单元格内填入当前情况下的最大背包价值。</li>
<li>第一行表示只能选吉他，第二行表示可以选吉他+音响，以此类推。</li>
<li>虽然我们题目的背包是4磅，但我们仍然需要1到3磅的前三列，因为它们将帮助我们在计算剩余空间时发挥作用。</li>
<li>网格最初是空的。我们将填充其中的每个单元格，网格填满后，就找到了问题的答案！</li>
</ul>
<p>【填充第一行】</p>
<p>第一个单元格表示背包的容量为1磅。吉他的重量也是1磅，这意味着它能装入背包！因此这个单元格包含吉他，价值为1500美元。</p>
<p>由于这是第一行，只有吉他可供你选择，于是不管背包多大，单元格内的值都是1500美元，所以第一行的值都是1500。</p>
<p>【填充第二行】</p>
<p>我们现在处于第二行，可偷的商品有吉他和音响。我们先来看第一个单元格，它表示容量为1磅的背包。在此之前，可装入1磅背包的商品的最大价值为1500美元，由于容量1磅的背包装不下音响，因此最大价值依然是1500美元。接下来的两个单元格的情况与此相同。在这些单元格中，背包的容量分别为2磅和3磅，而以前的最大价值为1500美元。由于这些背包装不下音响，因此最大价值保持不变。</p>
<p>但如果背包的容量为4磅，那就能够装下音响！原来的最大价值为1500美元，但如果在背包中装入音响而不是吉他，价值将为3000美元！你更新了最大价值！在这个网格中，你逐步地更新最大价值。</p>
<p>于是我们得到了第二行：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9eb1183a125b7d520063b9e2186994a2829.png" alt=""></p>
<p>【填充第三行】</p>
<p>笔记本电脑重3磅，没法将其装入容量为1磅或2磅的背包，因此前两个单元格的最大价值还是1500美元。</p>
<p>对于容量为3磅的背包，原来的最大价值为1500美元，但现在你可选择盗窃价值2000美元的笔记本电脑而不是吉他，这样新的最大价值将为2000美元！</p>
<p><strong>对于容量为4磅的背包</strong>，当前的最大价值为3000美元，你可不偷音响，而偷笔记本电脑，但它只值2000美元。价值没有原来高。但笔记本电脑的重量只有3磅，背包还有1磅的容量没用！</p>
<p>在1磅的容量中，可装入的商品的最大价值是多少呢？根据之前计算的最大价值可知（第一列中最大的值），在1磅的容量中可装入吉他，价值1500美元。</p>
<blockquote>
<p>注意，此时我们就用到了背包容量为1的那一列，所以我们之所以要算出与4磅无关的容量为1,2,3磅的结果，就是为了这一刻。</p>
</blockquote>
<p>笔记本电脑和吉他的总价值为3500美元，因此偷它们是更好的选择。最终的网格类似于下面这样。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-8da65c224aabb364fa3138a3251ca96f4b2.png" alt=""></p>
<p>【总结】</p>
<p>经过上面的分析，我们可以发现，题目所要的答案，其实只是网格最右下角的那一个单元格。那我们为什么要算出其他的单元格呢？</p>
<p>因为下一个单元格的值，需要用到之前单元格的值来计算，比如最后的答案3500美元，就用到了背包容量为1的那一列的数据来计算剩余1磅空间的时候选择哪个物品最合算。</p>
<p>我们记录下之前单元格的值，就是为了计算新单元格的时候不用重复计算，就像这道题，我们最后想知道背包容量为1时应该如何选取物品，如果没有保存下结果，那我们要重新算一遍第一列的场景，那效率就很低了。</p>
<blockquote>
<p>记忆化搜索，即用一个二维数组保存已经计算好的子问题的解，下次再计算相同子问题时，就不用重复求解了。</p>
</blockquote>
<p>每一个新的单元格的值，都需要复用到之前单元格的数据来算出，如果我们能归纳出一个通用的<strong>以旧单元格值推导出新单元格值的公式</strong>，那就相当于找到了一条可得到最优解的方法。这个公式，我们称为<strong>状态转移方程</strong>。</p>
<p>我们前文提到过，状态是每一个阶段的总结，动态规划是多阶段决策的过程，我们在多个阶段间行进，状态也在一直转移。状态转移方程，顾名思义，就是状态变化的方程，比如说我们可以归纳出该题的状态转移方程如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-31a037616da8a00acebff111b6ab70b8839.png" alt=""></p>
<p>于是我们知道了：</p>
<ol>
<li>填表法是动态规划的固定套路，它能帮助我们理解状态转移的过程，并且记录和复用之前的结果。</li>
<li>网格的每一个单元格，都可以理解为是一个阶段，阶段变量有两个，可选取物品类型和背包重量，也就是网格的横纵轴。</li>
<li>每个阶段的策略，就是我们的状态转移方程，即我们用现有的状态，决策出了当前阶段的状态。</li>
<li>动态规划的核心就在于：<ul>
<li><strong>将题目划分为多个子问题，对应多个阶段</strong></li>
<li><strong>确定哪些变量属于状态</strong></li>
<li><strong>归纳出状态转移方程</strong></li>
</ul>
</li>
</ol>
<h1 id="2-经典题型"><a href="#2-经典题型" class="headerlink" title="2 经典题型"></a>2 经典题型</h1><h2 id="2-1-0-1背包问题"><a href="#2-1-0-1背包问题" class="headerlink" title="2.1 0-1背包问题"></a>2.1 0-1背包问题</h2><h3 id="2-1-1-题目"><a href="#2-1-1-题目" class="headerlink" title="2.1.1 题目"></a>2.1.1 题目</h3><p>【描述】：有 n 个物品和一个大小为 bagSize 的背包. 给定数组 itemSizes 表示每个物品的大小和数组 itemValues 表示每个物品的价值。问最多能装入背包的总价值是多大?</p>
<ul>
<li><code>itemSizes[i], itemValues[i], n, bagSize 均为整数</code></li>
<li><code>你不能将物品进行切分</code></li>
<li><code>你所挑选的要装入背包的物品的总大小不能超过 bagSize</code></li>
<li><code>每个物品只能取一次</code></li>
</ul>
<p>【样例 1】:</p>
<ul>
<li>输入: <code>bagSize = 10, itemSizes = [2, 3, 5, 7], itemValues = [1, 5, 2, 4]</code></li>
<li>输出: 9</li>
<li>解释: 装入 <code>itemSizes[1] 和 itemSizes[3]</code> 可以得到最大价值, <code>itemValues[1] + itemValues[3] = 9</code></li>
</ul>
<p>【样例 2】:</p>
<ul>
<li>输入: <code>bagSize = 10, itemSizes = [2, 3, 8], itemValues = [2, 5, 8]</code></li>
<li>输出: 10</li>
<li>解释: 装入 <code>itemSizes[0] 和 itemSizes[2]</code> 可以得到最大价值, <code>itemValues[0] + itemValues[2] = 10</code></li>
</ul>
<h3 id="2-1-2-题解"><a href="#2-1-2-题解" class="headerlink" title="2.1.2 题解"></a>2.1.2 题解</h3><p>前文已叙述，不再赘述。</p>
<h3 id="2-1-3-代码"><a href="#2-1-3-代码" class="headerlink" title="2.1.3 代码"></a>2.1.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int backPack(int bagSize, int[] itemSizes, int[] itemValues) &#123;</span><br><span class="line">    int itemsNum &#x3D; itemSizes.length;</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组，存放已计算过的结果，填表法。</span><br><span class="line">    int[][] values &#x3D; new int[itemsNum][bagSize];</span><br><span class="line">    &#x2F;&#x2F; 开始填表，itemSizes数组中，0-itemIdx区间内的物品，为当前可选物品</span><br><span class="line">    for (int itemIdx &#x3D; 0;itemIdx &lt; itemsNum;itemIdx++)&#123;</span><br><span class="line">        for (int bagIdx &#x3D; 0;bagIdx &lt; bagSize;bagIdx++)&#123;</span><br><span class="line">            int thisBagSize &#x3D; bagIdx+1;&#x2F;&#x2F; 因为下标为0开始，但背包size从1开始。</span><br><span class="line">            &#x2F;&#x2F; 从已计算的结果中获取【当前背包size下，如果当前物品不可取时，背包可存放的最大价值】。</span><br><span class="line">            int maxValueWithoutThisItem &#x3D; getCachedValue(itemIdx-1,bagIdx,values);</span><br><span class="line">            &#x2F;&#x2F; 计算【当前背包size下，如果当前物品可取时，背包可存放的最大价值】</span><br><span class="line">            &#x2F;&#x2F; 计算方法为：如果当前物品可以被当前背包size容纳</span><br><span class="line">            &#x2F;&#x2F;      那么尝试优先存放该物品，并从之前的不包含当前物品的结果中</span><br><span class="line">            &#x2F;&#x2F;          寻找【可以填满剩余空间的最大价值】，二者相加即为结果。</span><br><span class="line">            int maxValueIncludeThisItem &#x3D; itemSizes[itemIdx] &lt;&#x3D; thisBagSize ?</span><br><span class="line">                    itemValues[itemIdx] + getCachedValue(itemIdx-1,thisBagSize-itemSizes[itemIdx]-1,values): maxValueWithoutThisItem;</span><br><span class="line">            &#x2F;&#x2F; 比较【当前背包size下，如果当前物品不可取时，背包可存放的最大价值】和【当前背包size下，如果当前物品可取时，背包可存放的最大价值】</span><br><span class="line">            &#x2F;&#x2F; 哪个大就选择哪个值作为当前阶段的解。</span><br><span class="line">            values[itemIdx][bagIdx] &#x3D; Math.max(maxValueWithoutThisItem,maxValueIncludeThisItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return values[itemsNum-1][bagSize-1];</span><br><span class="line">&#125;</span><br><span class="line">private int getCachedValue(int i,int j,int[][] values)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return values[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-最长公共子串"><a href="#2-2-最长公共子串" class="headerlink" title="2.2 最长公共子串"></a>2.2 最长公共子串</h2><h3 id="2-2-1-题目"><a href="#2-2-1-题目" class="headerlink" title="2.2.1 题目"></a>2.2.1 题目</h3><p>【描述】：给出两个字符串，找到最长公共子串，并返回其长度。</p>
<ul>
<li><code>子串的字符应该连续的出现在原字符串中，这与子序列有所不同。</code></li>
</ul>
<p>【样例 1】:</p>
<ul>
<li>输入:  “hish” and “fish”</li>
<li>输出:  3</li>
<li>解释: 最长公共子串是 “ish”</li>
</ul>
<p>【样例 2】:</p>
<ul>
<li>输入: “hish” and “vista”</li>
<li>输出: 2</li>
<li>解释: 最长公共子串是 ‘is’</li>
</ul>
<h3 id="2-2-2-题解"><a href="#2-2-2-题解" class="headerlink" title="2.2.2 题解"></a>2.2.2 题解</h3><p>将两个单词的字母分列为横纵轴，如下图所示。</p>
<p>因为公共子串有顺序和连续的要求（如is和si就不是一个公共子串，ios和is不是一个共同子串，只有is和is才是。），所以在矩阵当中，两个相邻的对角线的单元格都为1的时候，才是公共子串出现的时候。</p>
<p>那我们把两个相邻的成对角线的单元格都赋值1可以吗？不行，还记得我们动态规划状态的定义吗？状态是过去阶段的总结！</p>
<p>所以，我们应该用右下角的单元格来存储目前已出现的这个公共子串的长度，而不是单纯的赋值1。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-15876d948b7646fe660df2f8f4c0a2e7002.png" alt=""></p>
<p>对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。</p>
<h3 id="2-2-3-代码"><a href="#2-2-3-代码" class="headerlink" title="2.2.3 代码"></a>2.2.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 最长公共子串</span><br><span class="line"> * @param Str1: Str1 string</span><br><span class="line"> * @param str2: str2 string</span><br><span class="line"> * @return: the length of the longest common substring</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int longestCommonSubstring(String str1, String str2) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    if (str1.isEmpty()|| str2.isEmpty())&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组，存放已计算过的结果，填表法。</span><br><span class="line">    int[][] values &#x3D; new int[str1.length()][str2.length()];</span><br><span class="line">    for (int i &#x3D; 0;i&lt;str1.length();i++)&#123;</span><br><span class="line">        for (int j &#x3D; 0;j&lt;str2.length();j++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 状态转移方程为：当两个字母相等时，当前值取左上角的单元格的值+1</span><br><span class="line">            if (str1.charAt(i) &#x3D;&#x3D; str2.charAt(j))&#123;</span><br><span class="line">                values[i][j] &#x3D; getCachedValue(i-1,j-1,values)+1;</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; Math.max(result,values[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private int getCachedValue(int i,int j,int[][] values)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; values.length || j &gt;&#x3D;values[0].length)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return values[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-最长公共子串"><a href="#2-3-最长公共子串" class="headerlink" title="2.3 最长公共子串"></a>2.3 最长公共子串</h2><h3 id="2-3-1-题目"><a href="#2-3-1-题目" class="headerlink" title="2.3.1 题目"></a>2.3.1 题目</h3><p>【描述】：给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>
<p>最长公共子序列的定义：</p>
<ul>
<li>最长公共子序列问题是在一组序列（通常2个）中找到最长公共子序列（注意：不同于子串，LCS不需要是连续的子串）。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用。</li>
</ul>
<p>【样例 1】:</p>
<ul>
<li>输入:  “fosh” and “fort”</li>
<li>输出:  2</li>
<li>解释: 最长公共子序列是 “f”,”o”</li>
</ul>
<p>【样例 2】:</p>
<ul>
<li>输入: “fosh” and “fish”</li>
<li>输出: 3</li>
<li>解释: 最长公共子序列是 “f”,”s”,”h”</li>
</ul>
<h3 id="2-3-2-题解"><a href="#2-3-2-题解" class="headerlink" title="2.3.2 题解"></a>2.3.2 题解</h3><p>将两个单词的字母分列为横纵轴，如下图所示。</p>
<p>因为公共子序列有顺序的要求，但是没有连续的要求（如is和si就不是一个公共子序列，但ios和is中的is是公共子序列），所以在矩阵当中，某个字母相等的单元格的左上部分存在另一个字母相等的单元格，才是公共子序列出现的时候。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5ce30f61ba85ff4958b92a5ff78c1fe8a45.png" alt=""></p>
<p>但因为公共子序列没有连续的要求，故而两个1，可能离得有点远，没法像最长公共子串那一题一样直接根据左上相邻单元格来判断，所以在该题状态转移方程中，我们要注意将1一直传递下去。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d671671532f7c420a05c31da74ec67b099c.png" alt=""></p>
<p>所以我们得到状态转移方程：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6ce7c95efa043dec4651f7da63b41745970.png" alt=""></p>
<h3 id="2-3-3-代码"><a href="#2-3-3-代码" class="headerlink" title="2.3.3 代码"></a>2.3.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 最长公共子序列</span><br><span class="line"> * @param Str1: Str1 string</span><br><span class="line"> * @param str2: Str1 string</span><br><span class="line"> * @return: The length of longest common subsequence of Str1 and str2</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int longestCommonSubsequence(String Str1, String str2) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    if (Str1.isEmpty()|| str2.isEmpty())&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组，存放已计算过的结果，填表法。</span><br><span class="line">    int[][] values &#x3D; new int[Str1.length()][str2.length()];</span><br><span class="line">    for (int i &#x3D; 0;i&lt;Str1.length();i++)&#123;</span><br><span class="line">        for (int j &#x3D; 0;j&lt;str2.length();j++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 状态转移方程为：</span><br><span class="line">            &#x2F;&#x2F; 1. 当两个字母相等时，当前值取左上角的单元格的值+1</span><br><span class="line">            &#x2F;&#x2F; 2. 当两个字母不等时，当前值取左方和上方两个单元格中最大的值</span><br><span class="line">            if (Str1.charAt(i) &#x3D;&#x3D; str2.charAt(j))&#123;</span><br><span class="line">                values[i][j] &#x3D; getCachedValue(i-1,j-1,values)+1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                values[i][j] &#x3D; Math.max(getCachedValue(i,j-1,values),getCachedValue(i-1,j,values));</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; Math.max(result,values[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private int getCachedValue(int i,int j,int[][] values)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return values[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%92%8C%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%92%8C%E6%95%B4%E7%90%86/" itemprop="url">排序算法汇总和整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-23T23:16:23+08:00">
                2020-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/12/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%92%8C%E6%95%B4%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/12/23/排序算法汇总和整理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  8.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>排序算法可以分为两大类：</p>
<ol>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-beed8280c979c6aa1de039bba09260c558e.png" alt=""></p>
<p>其中这些算法的复杂度如下表格：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>时间复杂度（最好）</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
<td></td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(nlogn)</td>
<td>O(logn)~O(n)</td>
<td>不稳定</td>
<td>O(logn)~O(n)分别表示最好情况和最坏情况</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.3)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>稳定</td>
<td>k为元素值范围差，或者说元素值的数量</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+nlogn-nlogk)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>O(n+k)</td>
<td>稳定</td>
<td>k表示桶个数</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(n+r)</td>
<td>稳定</td>
<td>d表示最大数字的位数，r表示基数，数字固定是10</td>
</tr>
</tbody></table>
<blockquote>
<p>稳定性：如果a原本在b前面，而a=b，排序之后a仍然在b的前面，则表示该算法是稳定的排序算法。</p>
</blockquote>
<h1 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1 冒泡排序（Bubble Sort）"></a>1 冒泡排序（Bubble Sort）</h1><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，每一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>
<p>遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><strong>1.1 算法描述</strong></p>
<p>冒泡排序的算法步骤如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，直到排序完成。</li>
</ol>
<p><strong>1.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dfb064de1152d2a9bf4e14aa204d13262a0.gif" alt=""></p>
<p><strong>1.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort() &#123;</span><br><span class="line">	int[] arr &#x3D; new int[]&#123;-12, 3, 2, 34, 5, 8, 1&#125;;</span><br><span class="line">	&#x2F;&#x2F; 冒泡排序，外层循环确定“冒泡”的次数，一共要进行n次冒泡</span><br><span class="line">	&#x2F;&#x2F; 每次冒泡完成，都会将当前数列的最大值推到数列尾端</span><br><span class="line">	for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">		&#x2F;&#x2F; 这一层循环是控制单次“冒泡”的，每次“冒泡”的遍历范围是未排序的部分数列</span><br><span class="line">		&#x2F;&#x2F; 所以j值小于arr.length-1-i，因为第i轮“冒泡”，数列的尾端就有i位已经排好序了。</span><br><span class="line">		for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">			&#x2F;&#x2F; 随着j的增大，泡沫逐渐上浮，如果相邻的两项顺序不是我们希望的，那么要交换顺序</span><br><span class="line">			if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">				&#x2F;&#x2F; 交换顺序</span><br><span class="line">				int temp &#x3D; arr[j];</span><br><span class="line">				arr[j] &#x3D; arr[j + 1];</span><br><span class="line">				arr[j + 1] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可见，冒泡排序的时间复杂度是O(n^2)，不过值得注意的是，在最好的情况下（即当前数列已经是我们想要的顺序了），它的时间复杂度是O(n)。要想得到线性的时间复杂度，我们需要改造一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort() &#123;</span><br><span class="line">	int[] arr &#x3D; &#123;1,3,2,45,65,33,12&#125;;</span><br><span class="line">	&#x2F;&#x2F; 添加一个变量来标记是否进行了交换操作</span><br><span class="line">	boolean didSwap &#x3D; false;</span><br><span class="line">	&#x2F;&#x2F; 冒泡排序，外层循环确定“冒泡”的次数，一共要进行n次冒泡</span><br><span class="line">	&#x2F;&#x2F; 每次冒泡完成，都会将当前数列的最大值推到数列尾端</span><br><span class="line">	for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">		&#x2F;&#x2F; 这一层循环是控制单次“冒泡”的，每次“冒泡”的遍历范围是未排序的部分数列</span><br><span class="line">		&#x2F;&#x2F; 所以j值小于arr.length-1-i，因为第i轮“冒泡”，数列的尾端就有i位已经排好序了。</span><br><span class="line">		for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">			&#x2F;&#x2F; 随着j的增大，泡沫逐渐上浮，如果相邻的两项顺序不是我们希望的，那么要交换顺序</span><br><span class="line">			if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">				&#x2F;&#x2F; 交换顺序</span><br><span class="line">				int temp &#x3D; arr[j];</span><br><span class="line">				arr[j] &#x3D; arr[j + 1];</span><br><span class="line">				arr[j + 1] &#x3D; temp;</span><br><span class="line">				didSwap &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 如果一次冒泡过程中，一次交换操作都没执行，那说明数列已经有序了，直接返回</span><br><span class="line">		if(didSwap &#x3D;&#x3D; false) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2 选择排序（Selection Sort）"></a>2 选择排序（Selection Sort）</h1><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<p><strong>2.1 算法描述</strong></p>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li>初始状态：无序区为<code>R[1,n]</code>，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为<code>R[1,i-1]</code>和<code>R(i,n）</code>。该趟排序从当前无序区中选出关键字最小的记录 <code>R[k]</code>，将它与无序区的第1个记录R交换，使<code>R[1,i]</code>和<code>R[i+1,n)</code>分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟选择，排序完成。</li>
</ol>
<p><strong>2.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-af80fe9d723b1f2ad1979e1b2a6fcb60940.gif" alt=""></p>
<p><strong>2.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void selectionSort() &#123;</span><br><span class="line">	int[] arr &#x3D; &#123;1,3,2,45,65,33,12&#125;;</span><br><span class="line">	&#x2F;&#x2F; 做第i趟选择排序，[0,i)是有序区</span><br><span class="line">	for(int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">		int minValIdx &#x3D; i;</span><br><span class="line">		&#x2F;&#x2F; 遍历无序区[i,n]</span><br><span class="line">		for(int j &#x3D; minValIdx + 1; j &lt; arr.length; j++)&#123;</span><br><span class="line">			if(arr[j] &lt; arr[minValIdx])&#123;</span><br><span class="line">				&#x2F;&#x2F;记下目前找到的最小值所在的位置</span><br><span class="line">				minValIdx &#x3D; j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span><br><span class="line">		if(i !&#x3D; minValIdx)&#123;</span><br><span class="line">			&#x2F;&#x2F;交换a[i]和a[minValIdx]</span><br><span class="line">			int temp &#x3D; arr[i];</span><br><span class="line">			arr[i] &#x3D; arr[minValIdx];</span><br><span class="line">			arr[minValIdx] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.4 算法总结</strong></p>
<p>选择排序是表现最稳定的排序算法之一，因为无论什么数据进去都是O(n^2)的时间复杂度，所以用到它的时候，数据规模越小越好。</p>
<p>同时值得注意的是，它还是不稳定的，如何理解选择排序是不稳定的呢？</p>
<p>举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<p>唯一的好处可能就是不占用额外的内存空间。选择排序也是一般人想到的最多的排序方法，它的排序思路非常的常规。</p>
<h1 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3 插入排序（Insertion Sort）"></a>3 插入排序（Insertion Sort）</h1><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p><strong>3.1 算法描述</strong></p>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的有序区间中从后向前扫描；</li>
<li>如果当前被扫描的元素（已排序）大于新元素，将该元素移到下一位置，即将它的空间让出来；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置；</li>
<li>重复步骤2~5。</li>
</ol>
<p><strong>3.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-da58c3f1d442fe72549dc2e08c286732249.gif" alt=""></p>
<p><strong>3.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void insertionSort()&#123;</span><br><span class="line">	int[] arr &#x3D; &#123;1,3,2,45,65,33,12&#125;;</span><br><span class="line">	&#x2F;&#x2F; i控制有序区[0,i),i从1开始，说明arr[0]一开始默认有序</span><br><span class="line">	&#x2F;&#x2F; 同时arr[i]即为这一趟排序，要被用来插入的值</span><br><span class="line">	for(int i&#x3D;1; i&lt;arr.length; i++)&#123;</span><br><span class="line">		int val &#x3D; arr[i];</span><br><span class="line">		&#x2F;&#x2F; j是在有序区[0,i)之间从前向后遍历的指针</span><br><span class="line">		for(int j&#x3D;i-1; j&gt;0; j--)&#123;</span><br><span class="line">			&#x2F;&#x2F; 如果j的值比val大，那么j向后挪一个位置</span><br><span class="line">			if(arr[j] &gt; val)&#123;</span><br><span class="line">				arr[j+1] &#x3D; arr[j];</span><br><span class="line">			&#125; else &#123;&#x2F;&#x2F; 否则，说明找到了val应该在的位置</span><br><span class="line">				arr[j+1] &#x3D; val;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.4 算法总结</strong></p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>值得注意的是，插入排序最好情况（数列本身已经有序）的时间复杂度是O(n)，也就是说，每一趟的插入操作，都是第一步就找到了插入的位置，这样的时间复杂度是线性的。</p>
<h1 id="4-快速排序（Quick-Sort）"><a href="#4-快速排序（Quick-Sort）" class="headerlink" title="4 快速排序（Quick Sort）"></a>4 快速排序（Quick Sort）</h1><p>快速排序是采用分治法的思路：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><strong>4.1 算法描述</strong></p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；一般都采用当前数列的第一个元素作为pivot。</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列，重复步骤1-2进行递归排序，直到所有子数列都有序为止。</li>
</ol>
<p><strong>4.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5cf2b1b31e71659b0e7518866bfc86e666a.gif" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-08ed33c9ac31e8e749f25e81cddde9b605e.gif" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6e51fb60e5fe3cb98438e420bfc296fd9e4.gif" alt="quick sort" title="quick sort"></p>
<p><strong>4.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param arr        待排序列</span><br><span class="line"> * @param start  待排序列起始位置</span><br><span class="line"> * @param end 待排序列结束位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static void quickSort(int[] arr, int start, int end) &#123;</span><br><span class="line">	if (start &gt;&#x3D; end) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int left &#x3D; start;</span><br><span class="line">	int right &#x3D; end;</span><br><span class="line">	&#x2F;&#x2F;待排序的第一个元素作为基准值</span><br><span class="line">	int pivot &#x3D; arr[left];</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;从左右两边交替扫描，直到left &#x3D; right</span><br><span class="line">	while (left &lt; right) &#123;</span><br><span class="line">		while (right &gt; left &amp;&amp; arr[right] &gt;&#x3D; pivot) &#123;</span><br><span class="line">			&#x2F;&#x2F;从右往左扫描，找到第一个比基准值小的元素</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;找到这种元素将arr[right]放入arr[left]中</span><br><span class="line">		arr[left] &#x3D; arr[right];</span><br><span class="line"></span><br><span class="line">		while (left &lt; right &amp;&amp; arr[left] &lt;&#x3D; pivot) &#123;</span><br><span class="line">			&#x2F;&#x2F;从左往右扫描，找到第一个比基准值大的元素</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;找到这种元素将arr[left]放入arr[right]中</span><br><span class="line">		arr[right] &#x3D; arr[left];</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;基准值归位</span><br><span class="line">	arr[left] &#x3D; pivot;</span><br><span class="line">	&#x2F;&#x2F;对基准值左边的元素进行递归排序</span><br><span class="line">	quickSort(arr, start, left - 1);</span><br><span class="line">	&#x2F;&#x2F;对基准值右边的元素进行递归排序。</span><br><span class="line">	quickSort(arr, right + 1, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.4 算法总结</strong></p>
<p>快速排序顾名思义，它的性能可以达到比较类排序算法最高的O(nlogn)级别。不过由于分治法主要采用递归实现，所以它也是有额外的递归造成的栈空间的使用。因为一般情况下，快排会递归logn次，所以他的空间复杂度是O(logn)。</p>
<p>可惜的是，由于关键字的比较和交换是跳跃进行的，因此，<strong>快速排序是一种不稳定的排序方法</strong>。</p>
<p>快排的最坏情况，是每次分隔，生成的两个subList都有一个是空集合，也就是每次选取的pivot是当前数列的最小值或者最大值，无法达到二分的效果。这种情况下，它的时间复杂度是O(n^2)，空间复杂度是O(n)。</p>
<h1 id="5-希尔排序（Shell’s-Sort）"><a href="#5-希尔排序（Shell’s-Sort）" class="headerlink" title="5 希尔排序（Shell’s Sort）"></a>5 希尔排序（Shell’s Sort）</h1><p>希尔排序(Shell’s Sort)是插入排序的一种，又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本，它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>
<p>希尔排序是非稳定排序算法，也是第一个突破O(n2)的排序算法。</p>
<p>该方法因 D.L.Shell 于 1959 年提出而得名。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>因为插入排序每次遍历一遍完整数组，只能将一个元素移动到已排序区间的正确位置。当n值很大时，为了找到移动一个元素到正确位置的时间太长了，所以插入排序一般来说是低效的算法。</li>
</ol>
<p>基于插入排序上述的这两点性质，希尔排序通过分组，达到了如下三个目的：</p>
<ol>
<li>通过分组，使得每个子序列的长度减少，使得每一次遍历，能较快的将一个元素确定位置。虽然这时确定的只是改元素在分组内的位置，可能并非整个序列的正确位置，但此时已经接近于它们排序后的最终位置了。</li>
<li>通过分组，使得只要完整遍历一次整个序列的时间，就可以使每个分组内都有一个元素确定大概的位置，相比于插入排序的一次完整遍历只能确定一个元素的正确位置，性能提升非常明显。</li>
<li>通过分组进行插入排序，使得希尔排序在进行最后一次全序列的插入排序时，基本上每个元素所在的位置已经接近于它排序后正确的位置了，面对这样的情况，插入排序的性能可以达到接近线性时间，即O(n)。</li>
</ol>
<p><strong>5.1 算法描述</strong></p>
<p>先将整个待排序的序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li>选择一个增量gap，一般默认初始为length/2。</li>
<li>确定了gap后，则可以得到如下gap个分组，每个分组最多有length/gap个元素，如gap=length/2时分组如：<code>{arr[0],arr[gap]}，{arr[1],arr[gap+1]}.....{arr[gap-1],arr[length-1]}</code></li>
<li>对每个分组，执行插入排序。</li>
<li>再确定一个新的gap，一般为再缩小一倍，gap=gap/2</li>
<li>重复步骤2、3、4，直到gap=1为止，这时不存在其他分组了，最后执行一次对整个序列的插入排序，算法结束。</li>
</ol>
<p><strong>5.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bec5b473f7795fd8b71884b45b484570a06.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-347588d22829aca9eecc3516801abe00a02.gif" alt=""></p>
<p><strong>5.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static void shellSort(int[] arr, int start, int end) &#123;</span><br><span class="line">    int[] array&#x3D;&#123;49,38,65,97,76,13,27,49,78,34,12,64,1&#125;;</span><br><span class="line">    &#x2F;&#x2F;希尔排序</span><br><span class="line">    int gap &#x3D; array.length;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        gap &#x2F;&#x3D; 2;   &#x2F;&#x2F;增量每次减半</span><br><span class="line">        for (int i &#x3D; 0; i &lt; gap; i++) &#123;&#x2F;&#x2F; i控制分组，</span><br><span class="line">            for (int j &#x3D; i + gap; j &lt; array.length; j +&#x3D; gap) &#123;&#x2F;&#x2F;这个循环里其实就是一个插入排序</span><br><span class="line">                int k &#x3D; j - gap;&#x2F;&#x2F; k是组内元素的index</span><br><span class="line">                while (k &gt;&#x3D; 0 &amp;&amp; array[k] &gt; array[k+gap]) &#123;</span><br><span class="line">                    int temp &#x3D; array[k];</span><br><span class="line">                    array[k] &#x3D; array[k+gap];</span><br><span class="line">                    array[k + gap] &#x3D; temp;</span><br><span class="line">                    k -&#x3D; gap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (gap &#x3D;&#x3D; 1)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.4 算法总结</strong></p>
<p>希尔排序的时间的平均时间复杂度为O(n^1.3)，希尔排序时间复杂度最快的是O(nlog(2n))，没有快速排序算法O(n(logn))快，因此希尔排序在中等大小规模时表现良好，但对规模非常大的数据排序不是最优选择。</p>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的。</p>
<p>希尔排序非常容易实现，算法代码短而简单。 此外，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，一般来说，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法。</p>
<h1 id="6-归并排序（Merge-Sort）"><a href="#6-归并排序（Merge-Sort）" class="headerlink" title="6 归并排序（Merge Sort）"></a>6 归并排序（Merge Sort）</h1><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列</p>
<p><strong>6.1 算法描述</strong></p>
<ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序，再进行对半分，一直分到子序列的长度为1为止。</li>
<li>将两个排序好的子序列合并，递归回溯，最后归并成一个最终的排序序列。</li>
</ol>
<p><strong>6.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c881994adeb171e99e6be71f3ee732ec044.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-28613ef2f194bd421ca494db2cc9bcef9a9.gif" alt=""></p>
<p><strong>6.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] nums &#x3D; new int[] &#123; 9, 8, 7, 6, 5, 4, 3, 2, 10,7,21,15,9,7,42 &#125;;</span><br><span class="line">    int[] newNums &#x3D; new int[nums.length];</span><br><span class="line">    mergeSort(nums,newNums, 0, nums.length - 1);</span><br><span class="line">    for (int x : newNums) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void mergeSort(int[] nums,int[] newNums, int left, int right) &#123;</span><br><span class="line">    if (left &#x3D;&#x3D; right)</span><br><span class="line">        return;</span><br><span class="line">    &#x2F;&#x2F; 归并排序就是不断的在nums和newNums之间相互倒腾数据，每次递归都发生两次倒腾。</span><br><span class="line">    int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">    int leftArrIdx &#x3D; left, rightArrIdx &#x3D; mid + 1;</span><br><span class="line">    mergeSort(nums,newNums, leftArrIdx, mid); &#x2F;&#x2F;左有序数组</span><br><span class="line">    mergeSort(nums,newNums, rightArrIdx, right); &#x2F;&#x2F;右有序数组</span><br><span class="line"></span><br><span class="line">    int newArrIdx &#x3D; leftArrIdx;</span><br><span class="line">    &#x2F;&#x2F; 此时，leftArr &#x3D; nums的[leftArrIdx,mid]区间，rightArr &#x3D; nums的[rightArrIdx,right]区间</span><br><span class="line">    &#x2F;&#x2F; leftArr和rightArr都有序了，接下来进行第一次倒腾。</span><br><span class="line">    &#x2F;&#x2F; 三个指针控制，在把leftArr和rightArr的数组搬运到newNums对应位置的期间顺便进行合并（再排序）</span><br><span class="line">    &#x2F;&#x2F; 每次循环，leftArr和rightArr中，两个被指针指向的元素，较小的那个才会加入newNums</span><br><span class="line">    while (leftArrIdx &lt;&#x3D; mid &amp;&amp; rightArrIdx &lt;&#x3D; right) &#123;</span><br><span class="line">        newNums[newArrIdx++] &#x3D; nums[leftArrIdx] &lt; nums[rightArrIdx] ? nums[leftArrIdx++] : nums[rightArrIdx++];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果rightArr都加入newNum了，leftArr还有剩余，则把leftArr一股脑加进去</span><br><span class="line">    while (leftArrIdx &lt;&#x3D; mid)</span><br><span class="line">        newNums[newArrIdx++] &#x3D; nums[leftArrIdx++];</span><br><span class="line">    &#x2F;&#x2F; 如果leftArr都加入newNum了，rightArr还有剩余，则把rightArr一股脑加进去</span><br><span class="line">    while (rightArrIdx &lt;&#x3D; right)</span><br><span class="line">        newNums[newArrIdx++] &#x3D; nums[rightArrIdx++];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 到这里为止，newNums的[letf,right]已经是有序的了。</span><br><span class="line">    &#x2F;&#x2F; 但nums的[letf,right]区间还是无序的，还是分成了[left,mid]和[mid+1,right]这两个有序区间</span><br><span class="line">    &#x2F;&#x2F; 这时用newNums的顺序覆盖nums，这一步不是多余的，因为递归出栈后，逻辑是从nums里面拿排序好的数据</span><br><span class="line">    &#x2F;&#x2F; 所以进行第二次倒腾，第二次倒腾是为了递归出栈后的第一次倒腾有意义。</span><br><span class="line">    for(int i&#x3D;left;i &lt;&#x3D; right;i++)&#123;</span><br><span class="line">        nums[i] &#x3D; newNums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.4 算法总结</strong></p>
<p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>
<p>速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p>
<h1 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7 堆排序（Heap Sort）"></a>7 堆排序（Heap Sort）</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>7.1 算法描述</strong></p>
<ol>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。</li>
<li>不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ol>
<p><strong>7.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b4a555766505348b187cf66d4519789ced4.gif" alt=""></p>
<p><strong>7.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr &#x3D; &#123;1, 4, 6, 8, 2, 5, 3, 7, 9&#125;;</span><br><span class="line">    heapSort(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void heapSort(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 首先我们要明确下，用数组表示堆&#x2F;二叉树的时候，有如下公式：</span><br><span class="line">    &#x2F;&#x2F; 1. arr[0]到arr[length&#x2F;2],都是非叶子节点</span><br><span class="line">    &#x2F;&#x2F; 2. 对于某个节点arr[i]，则可知它的左子结点是arr[2i+1]，右子结点是arr[2i+2]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 循环建立初始堆，大顶堆</span><br><span class="line">    &#x2F;&#x2F; parentIdx从后往前遍历，说明进行上滤操作，调整是从下而上的</span><br><span class="line">    &#x2F;&#x2F; 创建初始堆之所以要从下而上，是因为现在整个堆都是无序的</span><br><span class="line">    for (int parentIdx &#x3D; arr.length &#x2F; 2; parentIdx &gt;&#x3D; 0; parentIdx--) &#123;</span><br><span class="line">        heapAdjust(arr, parentIdx, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; lastUnsorted，指向未排序区间的最后一个元素</span><br><span class="line">    for (int lastUnsorted &#x3D; arr.length - 1; lastUnsorted &gt; 0; lastUnsorted--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将 堆顶元素 和 未排序区间的最后一个元素 进行交换</span><br><span class="line">        int temp &#x3D; arr[lastUnsorted];</span><br><span class="line">        arr[lastUnsorted] &#x3D; arr[0];</span><br><span class="line">        arr[0] &#x3D; temp;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 重新调整堆，此时要从上而下调整，进行下滤操作，</span><br><span class="line">        &#x2F;&#x2F; 因为此时除了堆顶，其他节点都有序了，这种情况下滤操作更快</span><br><span class="line">        heapAdjust(arr, 0, lastUnsorted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void heapAdjust(int[] arr, int parent, int length) &#123;</span><br><span class="line">    int left &#x3D; 2 * parent + 1; &#x2F;&#x2F; 左孩子</span><br><span class="line">    int right &#x3D; 2 * parent + 2; &#x2F;&#x2F; 右孩子</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果左子结点大于父节点，交换</span><br><span class="line">    if (left &lt; length &amp;&amp; arr[left] &gt; arr[parent]) &#123;</span><br><span class="line">        swap(arr,parent,left);</span><br><span class="line">        heapAdjust(arr, left,length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果右子结点大于父节点，交换</span><br><span class="line">    if (right &lt; length &amp;&amp; arr[right] &gt; arr[parent]) &#123;</span><br><span class="line">        swap(arr,parent,right);</span><br><span class="line">        heapAdjust(arr, right,length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">    int temp &#x3D; arr[i];</span><br><span class="line">    arr[i] &#x3D; arr[j];</span><br><span class="line">    arr[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7.4 算法总结</strong></p>
<p>堆排序是一种不稳定的选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。</p>
<p>所以堆排序时间复杂度一般认为就是O(nlogn)级。时间复杂度很稳定，都是O(nlogn)。</p>
<h1 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8 计数排序（Counting Sort）"></a>8 计数排序（Counting Sort）</h1><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p><strong>8.1 算法描述</strong></p>
<ol>
<li>找出待排序的数组A中最大元素值max和最小元素值min，并创建一个长度为max-min的数组C。</li>
<li>统计数组A中每个值为i的元素出现的次数，存入数组C的第i-min项；</li>
<li>数组C从小到大填充原数组A，数组C从第0项开始，每一项i输出C[i]次，输出的值是i+min。</li>
</ol>
<p><strong>8.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3a45777ec71d4b68fb8282cd8fdbd2f0ba0.gif" alt=""></p>
<p><strong>8.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void countingSort(int[] arr) &#123;</span><br><span class="line">    int min&#x3D;Integer.MAX_VALUE,max&#x3D;Integer.MIN_VALUE;</span><br><span class="line">    for (int val : arr)&#123;</span><br><span class="line">        max &#x3D; Math.max(max, val);</span><br><span class="line">        min &#x3D; Math.min(min, val);</span><br><span class="line">    &#125;</span><br><span class="line">    int[] bucket &#x3D; new int[max-min+1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int val : arr) &#123;</span><br><span class="line">        bucket[val-min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sortedIndex&#x3D;0;</span><br><span class="line">    for (int i &#x3D; 0;i &lt; bucket.length;i++) &#123;</span><br><span class="line">        while(bucket[i] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] &#x3D; i+min;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8.4 算法总结</strong></p>
<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个范围差为k的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h1 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9 桶排序（Bucket Sort）"></a>9 桶排序（Bucket Sort）</h1><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（一般使用快排），最后把每个桶里排好序的数据拼接起来。</p>
<p>算法思想和散列中的开散列法差不多，当冲突时放入同一个桶中；可应用于数据量分布比较均匀，或比较侧重于区间数量时。</p>
<p>桶排序利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>我们用k表示桶的个数，那假设数据是均匀分布的，则每个桶的元素平均个数为n/k，那么桶排序的时间复杂度是O(n+nlog(n/k))=O(n+nlogn-nlogk)。</p>
<p>故而我们可以很明显的看出，O(n+nlogn-nlogk)，为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量，即k越大越好。当然，做到这一点很不容易，数据量巨大的情况下，映射函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中，使得每个桶内的排序性能接近。（试想一下极端情况，所有元素都在一个桶内，那时间复杂度就是快排的O(nlogn)了）</li>
</ol>
<p><strong>9.1 算法描述</strong></p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。 </li>
</ol>
<p><strong>9.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5d7b7a7414e2c3e0b8661b7f06898fdecbd.png" alt=""></p>
<p><strong>9.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static void bucketSort(int[] arr,int bucketNum)&#123;</span><br><span class="line">    int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max &#x3D; Math.max(max, arr[i]);</span><br><span class="line">        min &#x3D; Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;桶数</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr &#x3D; new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将每个元素放入桶</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        int idx &#x3D; (arr[i]-min)&#x2F;(((max-min)&#x2F;bucketNum)+1);</span><br><span class="line">        bucketArr.get(idx).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(new Gson().toJson(bucketArr));</span><br><span class="line">    &#x2F;&#x2F;对每个桶进行排序</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将桶内数据填回原数组</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (ArrayList&lt;Integer&gt; bucket : bucketArr)&#123;</span><br><span class="line">        if (bucket.isEmpty())&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int val : bucket)&#123;</span><br><span class="line">            arr[i++] &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9.4 算法总结</strong></p>
<p>桶排序在最优情况下（数组内的元素均匀分布，可以使得分桶后，每个桶内的元素数量差异不大），可以达到接近线性的时间复杂度，因为它不是比较排序算法，所以可以突破O(nlogn)的极限。</p>
<p>桶排序最坏的时间复杂度是O(nlogn)，也就是所有元素都在同一个桶内，这样相当于对整个列表使用了快排。</p>
<p>不过桶排序是稳定的排序算法。</p>
<h1 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10 基数排序（Radix Sort）"></a>10 基数排序（Radix Sort）</h1><p>基数排序是按照低位先排序，然后收集；再按照次低位排序，然后再收集；依次类推，直到最高位。</p>
<p>有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p>比如一系列两位数数字组成的序列，他们比大小，十位上的数字肯定优先级更高，个位上的数字优先级较低。我们先按照个位上的数字排序，再按照十位上的数字排序，那么就可以得到十位&gt;个位标准下的有序。</p>
<blockquote>
<p>换句话说，如果对于数字大小的评价标准是个位&gt;十位，那基数排序先判断十位再判断个位即可。</p>
</blockquote>
<p>在十进制数中，<strong>基数</strong>r就等于10，即表示最大有10种可能，最多需要10个桶来映射数组元素。</p>
<p><strong>10.1 算法描述</strong></p>
<ol>
<li>取得数组中的最大数，并取得位数，这就确定了我们最多要判断多少位。</li>
<li>将待排元素按照个位进行分桶；然后将这些桶中的元素按桶的编号重新串接起来，得到以个位排序完成的序列。</li>
<li>再对序列按照十位进行分桶，然后将这些桶中的元素按桶的编号重新串接起来，得到以十位排序完成的序列。</li>
<li>以此类推，一直到最高位进行分桶并且重新串接，最后得到完整排序的序列。</li>
</ol>
<p><strong>10.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6274e50d68d284bd678d050abbd15001cf9.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-44175898186bf61ec2cc5b1dcb7b978ff25.gif" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-026bcce647bc3e389c8b4d002c7a2317123.gif" alt=""></p>
<p><strong>10.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static void radixsSort(int[] array) &#123;</span><br><span class="line">    &#x2F;&#x2F; 找到最大数</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    for (int i : array) &#123;</span><br><span class="line">        max &#x3D; Math.max(max,i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 判断位数</span><br><span class="line">    int d &#x3D; 0;</span><br><span class="line">    while (max &gt; 0) &#123;</span><br><span class="line">        max &#x3D; max &#x2F; 10;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 数字的基数都是10，所以建立十个队列</span><br><span class="line">    List&lt;ArrayList&gt; bucket &#x3D; new ArrayList&lt;ArrayList&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList queue &#x3D; new ArrayList();</span><br><span class="line">        bucket.add(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 进行times次分配和收集</span><br><span class="line">    for (int i &#x3D; 0; i &lt; d; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 分配</span><br><span class="line">        for (int j &#x3D; 0; j &lt; array.length; j++) &#123;</span><br><span class="line">            int x &#x3D; array[j] % (int) Math.pow(10, i + 1) &#x2F; (int) Math.pow(10, i);</span><br><span class="line">            ArrayList queue &#x3D; bucket.get(x);</span><br><span class="line">            queue.add(array[j]);</span><br><span class="line">            bucket.set(x, queue);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 收集</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">            while (bucket.get(j).size() &gt; 0) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; queue &#x3D; bucket.get(j);</span><br><span class="line">                array[count] &#x3D; queue.get(0);</span><br><span class="line">                queue.remove(0);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>10.4 算法总结</strong></p>
<p>假设待排序的数组<code>R[1..n]</code>，数组中最大的数是d位数，基数为r。那么每处理一位数，就需要将数组元素映射到r个桶中，映射完成后还需要收集，相当于遍历一遍桶+遍历一遍数组，最多元素数为n，则处理一位数的时间复杂度为O(n+r)。处理d位数的总的时间复杂度为O(d*(n+r))。</p>
<p>基数排序的空间复杂度为O(n+r)，n表示n个指针，用来给桶内的元素做后驱指向，r则是开辟了长度为r的队列，用来当做r个桶。</p>
<p>基数排序基于分别排序，分别收集，所以是稳定的。</p>
<p>基数排序算法适用于位数不多，待排序列最大位数不是特别大，每一位数的范围不大的情况下（当然对于数字排序，每一位的范围都是<code>[0,9]</code>）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/07/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" itemprop="url">通俗易懂的二叉树的前中后序遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-07T22:04:56+08:00">
                2020-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91-%E5%A0%86/" itemprop="url" rel="index">
                    <span itemprop="name">树/堆</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/12/07/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/12/07/通俗易懂的二叉树的前中后序遍历/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  656
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二叉树的遍历是指不重复地访问二叉树中所有结点，主要指非空二叉树，对于空二叉树则结束返回。二叉树的遍历主要包括前序遍历、中序遍历、后序遍历。</p>
<p>一棵二叉树由根结点、左子树和右子树三部分组成，若规定 D、L、R 分别代表遍历根结点、遍历左子树、遍历右子树，则二叉树的遍历方式有 6 种：DLR、DRL、LDR、LRD、RDL、RLD。由于先遍历左子树和先遍历右子树在算法设计上没有本质区别，所以默认都是先左后右，故而只讨论三种方式：</p>
<ul>
<li>DLR–前序遍历（根在前，从左往右，首先访问根结点，然后遍历左子树，最后遍历右子树，根-&gt;左-&gt;右）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-fe3d871ce8395fd6f34ee6645e1459ad9c0.png" alt=""></li>
</ul>
</li>
<li>LDR–中序遍历（根在中，从左往右，首先遍历左子树，然后访问根节点，最后遍历右子树，左-&gt;根-&gt;右）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-593f727f19cff095d4b280abe91a5d27f11.png" alt=""></li>
</ul>
</li>
<li>LRD–后序遍历（根在后，从左往右，首先遍历左子树，然后遍历右子树，最后访问根节点，左-&gt;右-&gt;根）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-f966df848db3ced6fdab494c8f42b1f5e83.png" alt=""></li>
</ul>
</li>
<li>层序遍历（除此之外，还有一种层序遍历，层序遍历嘛，就是按层，从上到下，从左到右遍历，这个没啥好说的）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-714abe2c67cb4d4b9a07d258b045892b3c3.png" alt=""></li>
</ul>
</li>
</ul>
<blockquote>
<p>所以前中后序遍历的前/中/后，指的是根节点在前/中/后输出的意思，因此这三种遍历也称为先根遍历，中根遍历，后根遍历。</p>
</blockquote>
<p>本文就不掉书袋再复述前序/中序/后序遍历的教科书方法了。我们这里介绍一种易记的方法。</p>
<h1 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1 先序遍历"></a>1 先序遍历</h1><p>先序遍历可以想象成，<strong>小人从树根开始绕着整棵树的外围转一圈，经过结点的顺序就是先序遍历的顺序</strong></p>
<p>先序遍历结果：ABDHIEJCFKG</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9b4a9d62bf8d228f2d211436db7a344cc99.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-78a1f955007b10af3e0f85fa67a66688ed6.gif" alt=""></p>
<h1 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2 中序遍历"></a>2 中序遍历</h1><p>中序遍历可以想象成，按树画好的左右位置<strong>投影</strong>下来就可以了</p>
<p>中序遍历结果：HDIBEJAFKCG</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bdae9f8ceb4d9808fce19eb1464f3e7cef6.gif" alt=""></p>
<h1 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3 后序遍历"></a>3 后序遍历</h1><p>后序遍历就像是剪葡萄，我们要把一串葡萄剪成一颗一颗的。还记得我们先序遍历绕圈的路线么？就是<strong>围着树的外围绕一圈</strong>，如果发现一剪刀就能剪下的一颗葡萄（<strong>注意必须是一颗葡萄</strong>），就把它剪下来，组成的就是后序遍历了。</p>
<p>后序遍历结果：HIDJEBKFGCA</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f1147b85157f8610b3e2e7526ff416a3e2f.gif" alt=""></p>
<h1 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4 层序遍历"></a>4 层序遍历</h1><p>层序遍历太简单了，就是按照一层一层的顺序，从左到右写下来就行了。</p>
<p>后序遍历结果：ABCDEFGHIJK</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4ed54e9cad9b2c712408fa19d45b1b0d425.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/02/JAVA%E7%9B%91%E6%8E%A7%E5%92%8C%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/02/JAVA%E7%9B%91%E6%8E%A7%E5%92%8C%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/" itemprop="url">JAVA监控和调优工具操作指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-02T20:39:02+08:00">
                2020-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%9B%91%E6%8E%A7%E5%92%8C%E8%B0%83%E4%BC%98/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA监控和调优</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/12/02/JAVA%E7%9B%91%E6%8E%A7%E5%92%8C%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/12/02/JAVA监控和调优工具操作指南/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  11.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  47
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在日常的开发和维护工作中，免不了需要对JAVA程序进行监控、调优以及问题排查。</p>
<p>给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括∶运行日志、异常堆栈、GC日志、线程快照（thread dump/java core文件）、堆转储快照（heap dump/hprof文件）等。</p>
<p>经常使用适当的监控和分析工具可以加快我们分析数据、定位解决问题的速度，但在学习工具前，也应当意识到工具永远都是知识技能的一层包装，没有什么工具是”秘密武器”，不可能学会了就能包治百病。</p>
<h2 id="进程id的获取"><a href="#进程id的获取" class="headerlink" title="进程id的获取"></a>进程id的获取</h2><p>许多工具或者命令需要用到java进程的进程id，有必要回顾一下。</p>
<blockquote>
<ol>
<li>查看当前运行的所有的java进程：<code>ps -ef|grep java</code>；</li>
<li>准确获取定位到tomcat下正在运行的java进程的PID命令：<code>ps -ef|grep java | grep catalina | awk &#39;{print $2}&#39;</code></li>
<li>准确定位到tomcat下正在运行的java进程相关信息：<code>ps -ef|grep java | grep catalina</code>.</li>
</ol>
</blockquote>
<h2 id="jinfo-jmap访问受限的解决"><a href="#jinfo-jmap访问受限的解决" class="headerlink" title="jinfo/jmap访问受限的解决"></a>jinfo/jmap访问受限的解决</h2><p>一般情况下，我们使用jinfo命令，可能会遇到如下的报错：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3bcb4835de13ba36eadb8b19630a824973f.png" alt=""></p>
<p>这是因为新版的Linux系统加入了 ptrace-scope 机制,该机制的目的是防止用户访问正在执行的进程的内存，但是如jinfo,jmap这些调试类工具本身就是利用ptrace来获取执行进程的内存等信息。</p>
<p><strong>解决：</strong></p>
<ol>
<li>临时解决，该方法在下次重启前有效：<code>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</code></li>
<li>永久解决，直接修改内核参数：<code>sudo vi /etc/sysctl.d/10-ptrace.conf</code><ul>
<li>编辑这行: <code>kernel.yama.ptrace_scope = 1</code></li>
<li>修改为: <code>kernel.yama.ptrace_scope = 0</code></li>
<li>重启系统，使修改生效。</li>
</ul>
</li>
</ol>
<blockquote>
<p>参数名：kernel.yama.ptrace_scope（值为１：表示禁止用户访问正在执行的进程的内存；０表示可以访问）</p>
</blockquote>
<h1 id="1-jps-显示JVM进程信息"><a href="#1-jps-显示JVM进程信息" class="headerlink" title="1 jps 显示JVM进程信息"></a>1 jps 显示JVM进程信息</h1><p>jps (Java Virtual Machine Process Status Tool)，是java提供的一个显示当前所有JAVA进程pid的命令，适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p>
<p>我们常常会用到unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程以及进程id。</p>
<p><strong>jps就是java程序版本的ps命令，它的作用是显示当前系统的java进程情况及进程id。</strong></p>
<p><strong>格式：<code>jps [-命令选项]</code></strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2c4c5b7173045d72f971624168e8cb70e73.png" alt=""></p>
<h2 id="1-1-jps的选项"><a href="#1-1-jps的选项" class="headerlink" title="1.1 jps的选项"></a>1.1 jps的选项</h2><p>jps默认只会打印进程id和java类名，如果要更具体的信息，则要借助更多的选项：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-16840d91b4bfcceb7cfb57aacb4b7f4e3b3.png" alt=""></p>
<ol>
<li><p>jps -q</p>
<ul>
<li>只显示pid，不显示class名称,jar文件名和传递给main方法的参数</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-62cd627d9ee93c1fe76cb2474e5b75dbba4.png" alt=""></li>
</ul>
</li>
<li><p>jps -m</p>
<ul>
<li>输出传递给main方法的参数，在嵌入式jvm上可能是null</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-a56eedc39b84a2f57451b3f7c5172fc7d32.png" alt=""></li>
</ul>
</li>
<li><p>jps -l</p>
<ul>
<li>输出应用程序main class的完整package名或者应用程序的jar文件完整路径名</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-7bf94c1599ea21d939c982c152f76125f6b.png" alt=""></li>
</ul>
</li>
<li><p>jps -v</p>
<ul>
<li>输出传递给JVM的参数</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-17e285a83ecb8b6d0aedd6efe5b5e3c91eb.png" alt=""></li>
</ul>
</li>
<li><p>jps -V</p>
<ul>
<li>隐藏输出传递给JVM的参数</li>
</ul>
</li>
</ol>
<h1 id="2-jinfo-显示JVM配置信息"><a href="#2-jinfo-显示JVM配置信息" class="headerlink" title="2 jinfo 显示JVM配置信息"></a>2 jinfo 显示JVM配置信息</h1><p>jinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的JVM一些参数。当系统崩溃时，jinfo也可以从core文件里面知道崩溃的Java应用程序的配置信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jinfo [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jinfo [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jinfo [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;&#x3D;&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -flags               to print VM flags</span><br><span class="line">    -sysprops            to print Java system properties</span><br><span class="line">    &lt;no option&gt;          to print both of the above</span><br><span class="line">    -h | -help           to print this help message</span><br></pre></td></tr></table></figure>

<p><strong>格式：<code>jinfo [-命令选项] &lt;pid&gt;</code> 或 <code>jinfo [-命令选项] &lt;executable core&gt;</code> 或 <code>jinfo [-命令选项] [server_id@] &lt;remote ip or hostname&gt;</code></strong></p>
<ul>
<li><code>pid</code>：对应jvm的进程id</li>
<li><code>executable core</code>：产生core dump文件</li>
<li><code>remote server IP or hostname</code>：远程调试服务的ip或者hostname</li>
<li><code>server-id</code>：唯一id,假如一台主机上多个远程debug服务;</li>
</ul>
<blockquote>
<p>Javacore，也可以称为“threaddump”或是“javadump”，它是 Java 提供的一种诊断特性，能够提供一份可读的当前运行的 JVM 中线程使用情况的快照。即在某个特定时刻，JVM 中有哪些线程在运行，每个线程执行到哪一个类，哪一个方法。<br>应用程序如果出现不可恢复的错误或是内存泄露，就会自动触发 Javacore 的生成。</p>
</blockquote>
<p>jinfo工具特别强大，有众多的可选命令选项，比如：</p>
<h2 id="2-1-输出JVM进程的参数和属性"><a href="#2-1-输出JVM进程的参数和属性" class="headerlink" title="2.1 输出JVM进程的参数和属性"></a>2.1 输出JVM进程的参数和属性</h2><p><code>jinfo &lt;pid&gt;</code></p>
<p>不带任何选项的情况下，输出当前 jvm 进程的全部参数和系统属性</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3d8f5e1a88b7882699b13e00bf379611362.png" alt=""></p>
<h2 id="2-2-打印JVM特定参数的值"><a href="#2-2-打印JVM特定参数的值" class="headerlink" title="2.2 打印JVM特定参数的值"></a>2.2 打印JVM特定参数的值</h2><p><code>jinfo -flag &lt;name&gt; &lt;pid&gt;</code></p>
<p>用于打印虚拟机标记参数的值，name表示虚拟机标记参数的名称。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4ea5b8737fb9011c4030aa2c2d57e242811.png" alt=""></p>
<h2 id="2-3-开启或关闭JVM特定参数"><a href="#2-3-开启或关闭JVM特定参数" class="headerlink" title="2.3 开启或关闭JVM特定参数"></a>2.3 开启或关闭JVM特定参数</h2><p><code>jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</code></p>
<p>用于开启或关闭虚拟机标记参数。+表示开启，-表示关闭。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9379bda74d5e129a548ffe7cfd724167ab1.png" alt=""></p>
<h2 id="2-4-设置JVM特定参数的值"><a href="#2-4-设置JVM特定参数的值" class="headerlink" title="2.4 设置JVM特定参数的值"></a>2.4 设置JVM特定参数的值</h2><p><code>jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</code></p>
<p>用于设置虚拟机标记参数，但并不是每个参数都可以被动态修改的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-adb15a8f73ef408099cbee2110bc9879f02.png" alt=""></p>
<h2 id="2-5-打印所有JVM参数"><a href="#2-5-打印所有JVM参数" class="headerlink" title="2.5 打印所有JVM参数"></a>2.5 打印所有JVM参数</h2><p><code>jinfo -flags &lt;pid&gt;</code></p>
<p>打印虚拟机参数。什么是虚拟机参数呢？如<code>-XX:NewSize,-XX:OldSize</code>等就是虚拟机参数。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b79b41e6b74426fa258da530dcfd256847b.png" alt=""></p>
<h2 id="2-6-打印所有系统参数"><a href="#2-6-打印所有系统参数" class="headerlink" title="2.6 打印所有系统参数"></a>2.6 打印所有系统参数</h2><p><code>jinfo -sysprops &lt;pid&gt;</code></p>
<p>打印所有系统参数</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e4bb4b35ac7fed34239fc2785067e3e7574.png" alt=""></p>
<h1 id="3-jmap-生成内存快照文件"><a href="#3-jmap-生成内存快照文件" class="headerlink" title="3 jmap 生成内存快照文件"></a>3 jmap 生成内存快照文件</h1><p>jmap命令是一个可以输出所有内存中对象的工具，甚至可以将VM 中的heap，以二进制输出成文本。打印出某个java进程（使用pid）内存内的，所有‘对象’的情况（如：产生那些对象，及其数量）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -clstats             to print class loader statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; if not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format&#x3D;b     binary format</span><br><span class="line">                           file&#x3D;&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format&#x3D;b,file&#x3D;heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class="line">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class="line">                         in this mode.</span><br><span class="line">    -h | -help           to print this help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure>

<p>64位机上使用需要使用如下方式：<code>jmap -J-d64 -heap pid</code></p>
<p><strong>格式：<code>jmap [option] &lt;pid&gt;</code> 或 <code>jmap [option] &lt;executable &lt;core&gt;</code> 或 <code>jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</code></strong></p>
<ul>
<li><code>pid</code>：对应jvm的进程id</li>
<li><code>executable core</code>：产生core dump文件</li>
<li><code>remote server IP or hostname</code>：远程调试服务的ip或者hostname</li>
<li><code>server-id</code>：唯一id,假如一台主机上多个远程debug服务;</li>
</ul>
<p>jinfo工具特别强大，有众多的可选命令选项，比如：</p>
<h2 id="3-1-输出hprof二进制格式的heap文件"><a href="#3-1-输出hprof二进制格式的heap文件" class="headerlink" title="3.1 输出hprof二进制格式的heap文件"></a>3.1 输出hprof二进制格式的heap文件</h2><p><code>jmap -dump:live,format=b,file=myjmapfile.txt  &lt;pid&gt;</code><br>或<br><code>jmap -dump:file=myjmapfile.hprof,format=b &lt;pid&gt;</code></p>
<p>使用hprof二进制形式,输出jvm的heap内容到文件，file=可以指定文件存放的目录。live子选项是可选的，假如指定live选项，那么只输出活的对象到文件。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-35d57224bda3c1ce43daa4eed065ae0e0a2.png" alt=""></p>
<h2 id="3-2-打印正等候回收的对象的信息"><a href="#3-2-打印正等候回收的对象的信息" class="headerlink" title="3.2 打印正等候回收的对象的信息"></a>3.2 打印正等候回收的对象的信息</h2><p><code>jmap -finalizerinfo  &lt;pid&gt;</code></p>
<p>打印正等候回收的对象的信息。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f2d9d9dfa286b51df4e3575ae27423cd93e.png" alt=""></p>
<p>Number of objects pending for finalization: 0 表示等候回收的对象为0个</p>
<h2 id="3-3-打印heap的概要信息"><a href="#3-3-打印heap的概要信息" class="headerlink" title="3.3 打印heap的概要信息"></a>3.3 打印heap的概要信息</h2><p><code>jmap -heap  &lt;pid&gt;</code></p>
<p>打印heap的概要信息，GC使用的算法，heap（堆）的配置及JVM堆内存的使用情况。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-992e8f7a9ced2b305f6a16d2184c77a5686.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 2805, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.181-b13</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)   ##GC 方式</span><br><span class="line"></span><br><span class="line">Heap Configuration:  ##堆配置情况，也就是JVM参数配置的结果[平常说的tomcat配置JVM参数，就是在配置这些]</span><br><span class="line">   MinHeapFreeRatio         &#x3D; 0  ##最小堆使用比例</span><br><span class="line">   MaxHeapFreeRatio         &#x3D; 100  ##最大堆可用比例</span><br><span class="line">   MaxHeapSize              &#x3D; 734003200 (700.0MB)  ##最大堆空间大小</span><br><span class="line">   NewSize                  &#x3D; 21495808 (20.5MB)  ##新生代分配大小</span><br><span class="line">   MaxNewSize               &#x3D; 244318208 (233.0MB)  ##最大可新生代分配大小</span><br><span class="line">   OldSize                  &#x3D; 43515904 (41.5MB)  ##老年代大小</span><br><span class="line">   NewRatio                 &#x3D; 2  ##新生代比例</span><br><span class="line">   SurvivorRatio            &#x3D; 8  ##新生代与suvivor的比例</span><br><span class="line">   MetaspaceSize            &#x3D; 21807104 (20.796875MB)  ## 元数据空间大小</span><br><span class="line">   CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)  ## 压缩空间大小</span><br><span class="line">   MaxMetaspaceSize         &#x3D; 17592186044415 MB  ## 最大元数据空间大小</span><br><span class="line">   G1HeapRegionSize         &#x3D; 0 (0.0MB)  ## G1的对region空间大小</span><br><span class="line"></span><br><span class="line">Heap Usage:  ##堆使用情况【堆内存实际的使用情况】</span><br><span class="line">PS Young Generation  ##新生代（伊甸区Eden区 + 幸存区survior(1+2)空间）</span><br><span class="line">Eden Space:   ##伊甸区</span><br><span class="line">   capacity &#x3D; 32505856 (31.0MB)</span><br><span class="line">   used     &#x3D; 0 (0.0MB)</span><br><span class="line">   free     &#x3D; 32505856 (31.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">From Space:  ##survior1区</span><br><span class="line">   capacity &#x3D; 2621440 (2.5MB)</span><br><span class="line">   used     &#x3D; 0 (0.0MB)</span><br><span class="line">   free     &#x3D; 2621440 (2.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:  ##survior2 区</span><br><span class="line">   capacity &#x3D; 4194304 (4.0MB)</span><br><span class="line">   used     &#x3D; 0 (0.0MB)</span><br><span class="line">   free     &#x3D; 4194304 (4.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation  ##老年代使用情况</span><br><span class="line">   capacity &#x3D; 21495808 (20.5MB)</span><br><span class="line">   used     &#x3D; 3738528 (3.565338134765625MB)</span><br><span class="line">   free     &#x3D; 17757280 (16.934661865234375MB)</span><br><span class="line">   17.391893340320124% used</span><br><span class="line"></span><br><span class="line">4524 interned Strings occupying 360168 bytes.</span><br></pre></td></tr></table></figure>

<h2 id="3-4-打印每个class的实例信息"><a href="#3-4-打印每个class的实例信息" class="headerlink" title="3.4 打印每个class的实例信息"></a>3.4 打印每个class的实例信息</h2><p><code>jmap -histo:live &lt;pid&gt;</code><br>或<br><code>jmap -histo: &lt;pid&gt;</code></p>
<p>打印每个class的实例数目，内存占用,类全名信息，VM的内部类名字开头会加上前缀”*”。如果live子参数加上后，只统计活的对象数量</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-67f49e0ba5cdbfe3ac02c26aaa396f42648.png" alt=""></p>
<blockquote>
<p>采用jmap -histo pid&gt;a.log日志将其保存，在一段时间后，使用文本对比工具，可以对比出GC回收了哪些对象。</p>
</blockquote>
<blockquote>
<p>jmap -dump:format=b,file=outfile 3024可以将3024进程的内存heap输出出来到outfile文件里，再配合MAT（内存分析工具）。</p>
</blockquote>
<h2 id="3-5-打印类加载器的数据"><a href="#3-5-打印类加载器的数据" class="headerlink" title="3.5 打印类加载器的数据"></a>3.5 打印类加载器的数据</h2><p><code>jmap -clstats &lt;pid&gt;</code></p>
<p>-clstats是-permstat的替代方案，在JDK8之前，-permstat用来打印类加载器的数据。打印Java堆内存的永久保存区域的类加载器的智能统计信息。</p>
<p>对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印。此外，包含的字符串数量和大小也会被打印。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4f07b6ea610226208c0791082ab70ce0689.png" alt=""></p>
<h2 id="3-6-指定传递给运行jmap的JVM的参数"><a href="#3-6-指定传递给运行jmap的JVM的参数" class="headerlink" title="3.6 指定传递给运行jmap的JVM的参数"></a>3.6 指定传递给运行jmap的JVM的参数</h2><p><code>jmap -J&lt;flag&gt; &lt;pid&gt;</code></p>
<p>指定传递给运行jmap的JVM的参数</p>
<p>如<code>jmap -J-d64 -heap pid</code>表示在64位机上使用<code>jmap -heap</code></p>
<h1 id="4-jstack-输出线程堆栈快照"><a href="#4-jstack-输出线程堆栈快照" class="headerlink" title="4 jstack 输出线程堆栈快照"></a>4 jstack 输出线程堆栈快照</h1><p>jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息（也就是线程），如果是在64位机器上，需要指定选项”-J-d64”，Windows的jstack使用方式只支持以下的这种方式：<code>jstack [-l] pid</code></p>
<p>如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。</p>
<p>另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息，如果现在运行的java程序呈现hung的状态，jstack是非常有用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung)</span><br><span class="line">    -m  to print both java and native frames (mixed mode)</span><br><span class="line">    -l  long listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print this help message</span><br></pre></td></tr></table></figure>

<p><strong>格式：<code>jstack [option] &lt;pid&gt;</code> 或 <code>jstack [option] &lt;executable &lt;core&gt;</code> 或 <code>jstack [option] [server_id@]&lt;remote server IP or hostname&gt;</code></strong></p>
<ul>
<li><code>pid</code>：对应jvm的进程id</li>
<li><code>executable core</code>：产生core dump文件</li>
<li><code>remote server IP or hostname</code>：远程调试服务的ip或者hostname</li>
<li><code>server-id</code>：唯一id,假如一台主机上多个远程debug服务;</li>
</ul>
<p>jstack工具特别强大，有众多的可选命令选项和适用场景，比如：</p>
<h2 id="4-1-程序没有响应时强制打印线程"><a href="#4-1-程序没有响应时强制打印线程" class="headerlink" title="4.1 程序没有响应时强制打印线程"></a>4.1 程序没有响应时强制打印线程</h2><p><code>jstack -F &lt;pid&gt;</code></p>
<p>当pid对应的程序没有响应时，强制打印线程堆栈信息。</p>
<h2 id="4-2-打印完整的堆栈信息"><a href="#4-2-打印完整的堆栈信息" class="headerlink" title="4.2 打印完整的堆栈信息"></a>4.2 打印完整的堆栈信息</h2><p><code>jstack -l &lt;pid&gt;</code></p>
<p>长列表，打印关于锁的附加信息，例如属于java.util.concurrent的ownable synchronizers列表。</p>
<h2 id="4-3-打印java-native框架的所有堆栈"><a href="#4-3-打印java-native框架的所有堆栈" class="headerlink" title="4.3 打印java/native框架的所有堆栈"></a>4.3 打印java/native框架的所有堆栈</h2><p><code>jstack -m &lt;pid&gt;</code></p>
<p>打印java和native c/c++框架的所有栈信息。</p>
<h2 id="4-4-jstack统计线程数"><a href="#4-4-jstack统计线程数" class="headerlink" title="4.4 jstack统计线程数"></a>4.4 jstack统计线程数</h2><p><code>jstack -l 28367 | grep &#39;java.lang.Thread.State&#39; | wc -l</code></p>
<h2 id="4-5-jstack检测死锁"><a href="#4-5-jstack检测死锁" class="headerlink" title="4.5 jstack检测死锁"></a>4.5 jstack检测死锁</h2><p>我们先写个死锁代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class DeathLock &#123;</span><br><span class="line"></span><br><span class="line">    private static Lock lock1 &#x3D; new ReentrantLock();</span><br><span class="line">    private static Lock lock2 &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void deathLock() &#123;</span><br><span class="line">        Thread t1 &#x3D; new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t2 &#x3D; new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock2.lock();</span><br><span class="line">                    TimeUnit.SECONDS.sleep(1);</span><br><span class="line">                    lock1.lock();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t1.setName(&quot;mythread1&quot;);</span><br><span class="line">        t2.setName(&quot;mythread2&quot;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        deathLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个死锁会输出如下日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&quot;mythread2&quot; #12 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x0000000058ef7800 nid&#x3D;0x1ab4 waiting on condition [0x0000000059f8f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000d602d610&gt; (a java.util.concurrent.lock</span><br><span class="line">s.ReentrantLock$NonfairSync)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInt</span><br><span class="line">errupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(A</span><br><span class="line">bstractQueuedSynchronizer.java:870)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Abstrac</span><br><span class="line">tQueuedSynchronizer.java:1199)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLo</span><br><span class="line">ck.java:209)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)</span><br><span class="line"></span><br><span class="line">        at DeathLock$2.run(DeathLock.java:34)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - &lt;0x00000000d602d640&gt; (a java.util.concurrent.locks.ReentrantLock$Nonfa</span><br><span class="line">irSync)</span><br><span class="line"></span><br><span class="line">&quot;mythread1&quot; #11 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x0000000058ef7000 nid&#x3D;0x3e68 waiting on condition [0x000000005947f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000d602d640&gt; (a java.util.concurrent.lock</span><br><span class="line">s.ReentrantLock$NonfairSync)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInt</span><br><span class="line">errupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(A</span><br><span class="line">bstractQueuedSynchronizer.java:870)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Abstrac</span><br><span class="line">tQueuedSynchronizer.java:1199)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLo</span><br><span class="line">ck.java:209)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)</span><br><span class="line"></span><br><span class="line">        at DeathLock$1.run(DeathLock.java:22)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - &lt;0x00000000d602d610&gt; (a java.util.concurrent.locks.ReentrantLock$Nonfa</span><br><span class="line">irSync)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;mythread2&quot;:</span><br><span class="line">  waiting for ownable synchronizer 0x00000000d602d610, (a java.util.concurrent.l</span><br><span class="line">ocks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by &quot;mythread1&quot;</span><br><span class="line">&quot;mythread1&quot;:</span><br><span class="line">  waiting for ownable synchronizer 0x00000000d602d640, (a java.util.concurrent.l</span><br><span class="line">ocks.ReentrantLock$NonfairSync),</span><br><span class="line">  which is held by &quot;mythread2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;mythread2&quot;:</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000d602d610&gt; (a java.util.concurrent.lock</span><br><span class="line">s.ReentrantLock$NonfairSync)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInt</span><br><span class="line">errupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(A</span><br><span class="line">bstractQueuedSynchronizer.java:870)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Abstrac</span><br><span class="line">tQueuedSynchronizer.java:1199)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLo</span><br><span class="line">ck.java:209)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)</span><br><span class="line"></span><br><span class="line">        at DeathLock$2.run(DeathLock.java:34)</span><br><span class="line">&quot;mythread1&quot;:</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000d602d640&gt; (a java.util.concurrent.lock</span><br><span class="line">s.ReentrantLock$NonfairSync)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInt</span><br><span class="line">errupt(AbstractQueuedSynchronizer.java:836)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(A</span><br><span class="line">bstractQueuedSynchronizer.java:870)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(Abstrac</span><br><span class="line">tQueuedSynchronizer.java:1199)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock$NonfairSync.lock(ReentrantLo</span><br><span class="line">ck.java:209)</span><br><span class="line">        at java.util.concurrent.locks.ReentrantLock.lock(ReentrantLock.java:285)</span><br><span class="line"></span><br><span class="line">        at DeathLock$1.run(DeathLock.java:22)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure>


<h2 id="4-6-jstack检测cpu高"><a href="#4-6-jstack检测cpu高" class="headerlink" title="4.6 jstack检测cpu高"></a>4.6 jstack检测cpu高</h2><p><strong>步骤一：查看cpu占用高进程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; top</span><br><span class="line"></span><br><span class="line">Mem:  16333644k total,  9472968k used,  6860676k free,   165616k buffers</span><br><span class="line">Swap:        0k total,        0k used,        0k free,  6665292k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">17850 root      20   0 7588m 112m  11m S 100.7  0.7  47:53.80 java</span><br><span class="line"> 1552 root      20   0  121m  13m 8524 S  0.7  0.1  14:37.75 AliYunDun</span><br><span class="line"> 3581 root      20   0 9750m 2.0g  13m S  0.7 12.9 298:30.20 java</span><br><span class="line">    1 root      20   0 19360 1612 1308 S  0.0  0.0   0:00.81 init</span><br><span class="line">    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      RT   0     0    0    0 S  0.0  0.0   0:00.14 migration&#x2F;0</span><br></pre></td></tr></table></figure>

<p><strong>步骤二：查看cpu占用高线程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; top -H -p 17850</span><br><span class="line"></span><br><span class="line">top - 17:43:15 up 5 days,  7:31,  1 user,  load average: 0.99, 0.97, 0.91</span><br><span class="line">Tasks:  32 total,   1 running,  31 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  3.7%us,  8.9%sy,  0.0%ni, 87.4%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:  16333644k total,  9592504k used,  6741140k free,   165700k buffers</span><br><span class="line">Swap:        0k total,        0k used,        0k free,  6781620k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">17880 root      20   0 7588m 112m  11m R 99.9  0.7  50:47.43 java</span><br><span class="line">17856 root      20   0 7588m 112m  11m S  0.3  0.7   0:02.08 java</span><br><span class="line">17850 root      20   0 7588m 112m  11m S  0.0  0.7   0:00.00 java</span><br><span class="line">17851 root      20   0 7588m 112m  11m S  0.0  0.7   0:00.23 java</span><br><span class="line">17852 root      20   0 7588m 112m  11m S  0.0  0.7   0:02.09 java</span><br><span class="line">17853 root      20   0 7588m 112m  11m S  0.0  0.7   0:02.12 java</span><br><span class="line">17854 root      20   0 7588m 112m  11m S  0.0  0.7   0:02.07 java</span><br></pre></td></tr></table></figure>

<p><strong>步骤三：转换线程ID</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; printf &quot;%x\n&quot; 17880</span><br><span class="line">45d8</span><br></pre></td></tr></table></figure>

<p><strong>步骤四：定位cpu占用线程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">jstack 17850|grep 45d8 -A 30</span><br><span class="line">&quot;pool-1-thread-11&quot; #20 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00007fc860352800 nid&#x3D;0x45d8 runnable [0x00007fc8417d2000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.io.FileOutputStream.writeBytes(Native Method)</span><br><span class="line">        at java.io.FileOutputStream.write(FileOutputStream.java:326)</span><br><span class="line">        at java.io.BufferedOutputStream.flushBuffer(BufferedOutputStream.java:82)</span><br><span class="line">        at java.io.BufferedOutputStream.flush(BufferedOutputStream.java:140)</span><br><span class="line">        - locked &lt;0x00000006c6c2e708&gt; (a java.io.BufferedOutputStream)</span><br><span class="line">        at java.io.PrintStream.write(PrintStream.java:482)</span><br><span class="line">        - locked &lt;0x00000006c6c10178&gt; (a java.io.PrintStream)</span><br><span class="line">        at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)</span><br><span class="line">        at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)</span><br><span class="line">        at sun.nio.cs.StreamEncoder.flushBuffer(StreamEncoder.java:104)</span><br><span class="line">        - locked &lt;0x00000006c6c26620&gt; (a java.io.OutputStreamWriter)</span><br><span class="line">        at java.io.OutputStreamWriter.flushBuffer(OutputStreamWriter.java:185)</span><br><span class="line">        at java.io.PrintStream.write(PrintStream.java:527)</span><br><span class="line">        - eliminated &lt;0x00000006c6c10178&gt; (a java.io.PrintStream)</span><br><span class="line">        at java.io.PrintStream.print(PrintStream.java:597)</span><br><span class="line">        at java.io.PrintStream.println(PrintStream.java:736)</span><br><span class="line">        - locked &lt;0x00000006c6c10178&gt; (a java.io.PrintStream)</span><br><span class="line">        at com.demo.guava.HardTask.call(HardTask.java:18)</span><br><span class="line">        at com.demo.guava.HardTask.call(HardTask.java:9)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">&quot;pool-1-thread-10&quot; #19 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x00007fc860345000 nid&#x3D;0x45d7 waiting on condition [0x00007fc8418d3000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000006c6c14178&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)</span><br></pre></td></tr></table></figure>


<h1 id="5-jstat-收集JVM运行数据"><a href="#5-jstat-收集JVM运行数据" class="headerlink" title="5 jstat 收集JVM运行数据"></a>5 jstat 收集JVM运行数据</h1><p>Jstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，它位于java的bin目录下，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了堆内存各部分的使用量，以及加载类的数量，还有垃圾回收状况的监控。</p>
<p>可见，Jstat是轻量级的、专门针对JVM的工具。</p>
<p><strong>格式：<code>jstat [-命令选项] &lt;pid&gt;</code></strong></p>
<p>jstat工具特别强大，有众多的可选项，详细查看堆内各个部分的使用量，以及加载类的数量。使用时，需加上查看进程的进程id，和所选参数。参考格式如下：</p>
<h2 id="5-1-类加载统计"><a href="#5-1-类加载统计" class="headerlink" title="5.1 类加载统计"></a>5.1 类加载统计</h2><p><code>jstat –class &lt;pid&gt;</code></p>
<p>显示加载class的数量，及所占空间等信息。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2e60bd64a892a063c76037f7fbaa5ceb196.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>Loaded</td>
<td>装载的类的数量</td>
</tr>
<tr>
<td>Bytes</td>
<td>装载类所占用的字节数</td>
</tr>
<tr>
<td>Unloaded</td>
<td>卸载类的数量</td>
</tr>
<tr>
<td>Bytes</td>
<td>卸载类的字节数</td>
</tr>
<tr>
<td>Time</td>
<td>装载和卸载类所花费的时间</td>
</tr>
</tbody></table>
<h2 id="5-2-编译统计"><a href="#5-2-编译统计" class="headerlink" title="5.2 编译统计"></a>5.2 编译统计</h2><p><code>jstat -compiler &lt;pid&gt;</code></p>
<p>显示VM实时编译的数量等信息。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-452f7c3598597bea5efd6a2596c52f13228.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>Compiled</td>
<td>编译任务执行数量</td>
</tr>
<tr>
<td>Failed</td>
<td>编译任务执行失败数量</td>
</tr>
<tr>
<td>Invalid</td>
<td>编译任务执行失效数量</td>
</tr>
<tr>
<td>Time</td>
<td>编译任务消耗时间</td>
</tr>
<tr>
<td>FailedType</td>
<td>最后一个编译失败任务的类型</td>
</tr>
<tr>
<td>FailedMethod</td>
<td>最后一个编译失败任务所在的类及方法</td>
</tr>
</tbody></table>
<h2 id="5-3-垃圾回收统计"><a href="#5-3-垃圾回收统计" class="headerlink" title="5.3 垃圾回收统计"></a>5.3 垃圾回收统计</h2><p><code>jstat -gc &lt;pid&gt;</code></p>
<p>显示gc的信息，查看gc的次数，及时间。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6c7772ec1a693d7702905d45950f2a661d0.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>S0C</td>
<td>年轻代中第一个survivor（幸存区）的容量 (字节)</td>
</tr>
<tr>
<td>S1C</td>
<td>年轻代中第二个survivor（幸存区）的容量 (字节)</td>
</tr>
<tr>
<td>S0U</td>
<td>年轻代中第一个survivor（幸存区）目前已使用空间 (字节)</td>
</tr>
<tr>
<td>S1U</td>
<td>年轻代中第二个survivor（幸存区）目前已使用空间 (字节)</td>
</tr>
<tr>
<td>EC</td>
<td>年轻代中Eden（伊甸区）的容量 (字节)</td>
</tr>
<tr>
<td>EU</td>
<td>年轻代中Eden（伊甸区）目前已使用空间 (字节)</td>
</tr>
<tr>
<td>OC</td>
<td>Old代的容量 (字节)</td>
</tr>
<tr>
<td>OU</td>
<td>Old代目前已使用空间 (字节)</td>
</tr>
<tr>
<td>PC</td>
<td>Perm(持久代)的容量 (字节)</td>
</tr>
<tr>
<td>PU</td>
<td>Perm(持久代)目前已使用空间 (字节)</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时年轻代中gc所用时间(s)</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时old代(full gc)gc次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>从应用程序启动到采样时old代(full gc)gc所用时间(s)</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时gc用的总时间(s)</td>
</tr>
</tbody></table>
<h2 id="5-4-堆内存统计"><a href="#5-4-堆内存统计" class="headerlink" title="5.4 堆内存统计"></a>5.4 堆内存统计</h2><p><code>jstat -gccapacity &lt;pid&gt;</code></p>
<p>显示VM内存中三代（young，old，perm）对象的使用和占用大小</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c3cb2a0c165067a785f1e82eac8e86d5d6a.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>NGCMN</td>
<td>年轻代(young)中初始化(最小)的大小(字节)</td>
</tr>
<tr>
<td>NGCMX</td>
<td>年轻代(young)的最大容量 (字节)</td>
</tr>
<tr>
<td>NGC</td>
<td>年轻代(young)中当前的容量 (字节)</td>
</tr>
<tr>
<td>S0C</td>
<td>年轻代中第一个survivor（幸存区）的容量 (字节)</td>
</tr>
<tr>
<td>S1C</td>
<td>年轻代中第二个survivor（幸存区）的容量 (字节)</td>
</tr>
<tr>
<td>EC</td>
<td>年轻代中Eden（伊甸区）的容量 (字节)</td>
</tr>
<tr>
<td>OGCMN</td>
<td>old代中初始化(最小)的大小 (字节)</td>
</tr>
<tr>
<td>OGCMX</td>
<td>old代的最大容量(字节)</td>
</tr>
<tr>
<td>OGC</td>
<td>old代当前新生成的容量 (字节)</td>
</tr>
<tr>
<td>OC</td>
<td>old代的容量 (字节)</td>
</tr>
<tr>
<td>PGCMN</td>
<td>perm代中初始化(最小)的大小 (字节)</td>
</tr>
<tr>
<td>PGCMX</td>
<td>perm代的最大容量 (字节)</td>
</tr>
<tr>
<td>PGC</td>
<td>perm代当前新生成的容量 (字节)</td>
</tr>
<tr>
<td>PC</td>
<td>Perm(持久代)的容量 (字节)</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时old代(full gc)gc次数</td>
</tr>
</tbody></table>
<h2 id="5-5-新生代垃圾回收统计"><a href="#5-5-新生代垃圾回收统计" class="headerlink" title="5.5 新生代垃圾回收统计"></a>5.5 新生代垃圾回收统计</h2><p><code>jstat -gcnew &lt;pid&gt;</code></p>
<p>统计年轻代对象的信息</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ba28e19bd75231959a868d3fa24644cb3ef.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>S0C</td>
<td>年轻代中第一个survivor（幸存区）的容量 (字节)</td>
</tr>
<tr>
<td>S1C</td>
<td>年轻代中第二个survivor（幸存区）的容量 (字节)</td>
</tr>
<tr>
<td>S0U</td>
<td>年轻代中第一个survivor（幸存区）目前已使用空间 (字节)</td>
</tr>
<tr>
<td>S1U</td>
<td>年轻代中第二个survivor（幸存区）目前已使用空间 (字节)</td>
</tr>
<tr>
<td>TT</td>
<td>持有次数限制</td>
</tr>
<tr>
<td>MTT</td>
<td>最大持有次数限制</td>
</tr>
<tr>
<td>DSS</td>
<td>期望的幸存区大小</td>
</tr>
<tr>
<td>EC</td>
<td>年轻代中Eden（伊甸区）的容量 (字节)</td>
</tr>
<tr>
<td>EU</td>
<td>年轻代中Eden（伊甸区）目前已使用空间 (字节)</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时年轻代中gc所用时间(s)</td>
</tr>
</tbody></table>
<h2 id="5-6-新生代内存统计"><a href="#5-6-新生代内存统计" class="headerlink" title="5.6 新生代内存统计"></a>5.6 新生代内存统计</h2><p><code>jstat -gcnewcapacity &lt;pid&gt;</code></p>
<p>统计年轻代对象的信息及其占用量。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-be84ee14d1f8990973fbfffa1f014827082.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>NGCMN</td>
<td>年轻代(young)中初始化(最小)的大小(字节)</td>
</tr>
<tr>
<td>NGCMX</td>
<td>年轻代(young)的最大容量 (字节)</td>
</tr>
<tr>
<td>NGC</td>
<td>年轻代(young)中当前的容量 (字节)</td>
</tr>
<tr>
<td>S0CMX</td>
<td>年轻代中第一个survivor（幸存区）的最大容量 (字节)</td>
</tr>
<tr>
<td>S0C</td>
<td>年轻代中第一个survivor（幸存区）的容量 (字节)</td>
</tr>
<tr>
<td>S1CMX</td>
<td>年轻代中第二个survivor（幸存区）的最大容量 (字节)</td>
</tr>
<tr>
<td>S1C</td>
<td>年轻代中第二个survivor（幸存区）的容量 (字节)</td>
</tr>
<tr>
<td>ECMX</td>
<td>年轻代中Eden（伊甸区）的最大容量 (字节)</td>
</tr>
<tr>
<td>EC</td>
<td>年轻代中Eden（伊甸区）的容量 (字节)</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时old代(full gc)gc次数</td>
</tr>
</tbody></table>
<h2 id="5-7-老年代垃圾回收统计"><a href="#5-7-老年代垃圾回收统计" class="headerlink" title="5.7 老年代垃圾回收统计"></a>5.7 老年代垃圾回收统计</h2><p><code>jstat -gcold &lt;pid&gt;</code></p>
<p>统计老年代对象的信息</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-44a6d03fa59ee3d179a5352c3f8c17c15b7.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>MC</td>
<td>方法区大小</td>
</tr>
<tr>
<td>MU</td>
<td>方法区使用大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间大小</td>
</tr>
<tr>
<td>CCSU</td>
<td>压缩类空间使用大小</td>
</tr>
<tr>
<td>OC</td>
<td>Old代的容量 (字节)</td>
</tr>
<tr>
<td>OU</td>
<td>Old代目前已使用空间 (字节)</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时old代(full gc)gc次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时年轻代中gc所用时间(s)</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时gc用的总时间(s)</td>
</tr>
</tbody></table>
<h2 id="5-8-老年代内存统计"><a href="#5-8-老年代内存统计" class="headerlink" title="5.8 老年代内存统计"></a>5.8 老年代内存统计</h2><p><code>jstat -gcoldcapacity &lt;pid&gt;</code></p>
<p>统计老年代对象的信息及其占用量</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fcb6eca9c1dd7c229a8833e66412f56fe94.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>OGCMN</td>
<td>old代中初始化(最小)的大小 (字节)</td>
</tr>
<tr>
<td>OGCMX</td>
<td>old代的最大容量(字节)</td>
</tr>
<tr>
<td>OGC</td>
<td>old代当前新生成的容量 (字节)</td>
</tr>
<tr>
<td>OC</td>
<td>Old代的容量 (字节)</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时old代(full gc)gc次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时年轻代中gc所用时间(s)</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时gc用的总时间(s)</td>
</tr>
</tbody></table>
<h2 id="5-9-元数据空间统计"><a href="#5-9-元数据空间统计" class="headerlink" title="5.9 元数据空间统计"></a>5.9 元数据空间统计</h2><p><code>jstat -gcmetacapacity &lt;pid&gt;</code></p>
<p>统计元数据空间容量</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b99529bc7810a586ef2d23f874cc9519a9f.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>MCMN</td>
<td>最小元数据容量</td>
</tr>
<tr>
<td>MCMX</td>
<td>最大元数据容量</td>
</tr>
<tr>
<td>MC</td>
<td>方法区大小</td>
</tr>
<tr>
<td>CCSMN</td>
<td>最小压缩类空间大小</td>
</tr>
<tr>
<td>CCSMX</td>
<td>最大压缩类空间大小</td>
</tr>
<tr>
<td>CCSC</td>
<td>压缩类空间大小</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时old代(full gc)gc次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>从应用程序启动到采样时old代(full gc)gc所用时间(s)</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时gc用的总时间(s)</td>
</tr>
</tbody></table>
<h2 id="5-10-总结垃圾回收统计"><a href="#5-10-总结垃圾回收统计" class="headerlink" title="5.10 总结垃圾回收统计"></a>5.10 总结垃圾回收统计</h2><p><code>jstat -gcutil &lt;pid&gt;</code></p>
<p>统计gc容量占比信息</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e9c3e67acc4d4e817d3c206512b067d181e.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>S0</td>
<td>年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</td>
</tr>
<tr>
<td>S1</td>
<td>年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</td>
</tr>
<tr>
<td>E</td>
<td>年轻代中Eden（伊甸区）已使用的占当前容量百分比</td>
</tr>
<tr>
<td>O</td>
<td>old代已使用的占当前容量百分比</td>
</tr>
<tr>
<td>P</td>
<td>perm代已使用的占当前容量百分比</td>
</tr>
<tr>
<td>YGC</td>
<td>从应用程序启动到采样时年轻代中gc次数</td>
</tr>
<tr>
<td>YGCT</td>
<td>从应用程序启动到采样时年轻代中gc所用时间(s)</td>
</tr>
<tr>
<td>FGC</td>
<td>从应用程序启动到采样时old代(full gc)gc次数</td>
</tr>
<tr>
<td>FGCT</td>
<td>从应用程序启动到采样时old代(full gc)gc所用时间(s)</td>
</tr>
<tr>
<td>GCT</td>
<td>从应用程序启动到采样时gc用的总时间(s)</td>
</tr>
</tbody></table>
<h2 id="5-11-JVM编译方法统计"><a href="#5-11-JVM编译方法统计" class="headerlink" title="5.11 JVM编译方法统计"></a>5.11 JVM编译方法统计</h2><p><code>jstat -printcompilation &lt;pid&gt;</code></p>
<p>统计 JVM编译方法的信息</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-918c3cea79f7a31ccdf12b7a0aa75eb461a.png" alt=""></p>
<table>
<thead>
<tr>
<th>显示列名</th>
<th>具体描述</th>
</tr>
</thead>
<tbody><tr>
<td>Compiled</td>
<td>最近编译方法的数量</td>
</tr>
<tr>
<td>Size</td>
<td>最近编译方法的字节码数量</td>
</tr>
<tr>
<td>Type</td>
<td>最近编译方法的编译类型。</td>
</tr>
<tr>
<td>Method</td>
<td>方法名标识</td>
</tr>
</tbody></table>
<h1 id="6-jhat-堆快照文件可视化工具"><a href="#6-jhat-堆快照文件可视化工具" class="headerlink" title="6 jhat 堆快照文件可视化工具"></a>6 jhat 堆快照文件可视化工具</h1><p>jhat（Java Virtual Machine Heap Analysis Tool）虚拟机堆转储快照分析工具，也是jdk<strong>内置</strong>的工具之一，是个用来分析java堆内存的命令，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果，包括对象的数量，大小等等，并支持对象查询语言（OQL）。</p>
<p>jhat的作用对象是<strong>堆快照文件</strong>，也就是dump文件或者hprof文件，文件生成后，我们再使用jaht进行分析。</p>
<ol>
<li><p>使用jmap命令获取java程序堆快照（生成dump文件）</p>
</li>
<li><p>使用jconsole选项通过<code>HotSpotDiagnosticMXBean</code>从运行时获得堆快照（生成dump文件）</p>
</li>
<li><p>虚拟机启动时如果指定了<code>-XX:+HeapDumpOnOutOfMemoryError</code>选项, 则在抛出OutOfMemoryError时, 会自动执行堆快照（生成dump文件）</p>
</li>
<li><p>使用 hprof 命令获得hprof文件（生成hprof文件）</p>
</li>
</ol>
<p><strong>用法</strong>：<code>jhat [ options ] heap-dump-file</code>，如<code>jhat -J-Xmx512M app.dump</code></p>
<p>option具体选项及作用如下：</p>
<ol>
<li>-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx</li>
<li>-stack false|true 关闭跟踪对象分配调用堆栈。如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.</li>
<li>-refs false|true 关闭对象引用跟踪。默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。</li>
<li>-port port-number 设置 jhat HTTP server 的端口号. 默认值 7000。</li>
<li>-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件。 例如, 如果文件列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。</li>
<li>-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用。</li>
<li>-debug int 设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息。</li>
<li>-version 启动后只显示版本信息就退出。</li>
</ol>
<blockquote>
<p>有时dump出来的堆很大，在启动时会报堆空间不足的错误，可加参数：<code>jhat -J-Xmx512m &lt;heap dump file&gt;</code>。这个内存大小可根据自己电脑进行设置。</p>
</blockquote>
<p>不过实事求是地说，在实际工作中，除非真的没有别的工具可用，否则一般不会去直接使用jhat命令来分析demp文件，主要原因有二：</p>
<ul>
<li>一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件拷贝到其他机器上进行分析，因为分析工作是一个耗时且消耗硬件资源的过程，既然都要在其他机器上进行，就没必要受到命令行工具的限制了；</li>
<li><strong>另外一个原因是jhat的分析功能相对来说很简陋，VisualVM以及专门分析dump文件的Eclipse Memory Analyzer、IBM HeapAnalyzer等工具</strong>，都能实现比jhat更强大更专业的分析功能。</li>
</ul>
<h2 id="6-1-jhat工具的开启"><a href="#6-1-jhat工具的开启" class="headerlink" title="6.1 jhat工具的开启"></a>6.1 jhat工具的开启</h2><ol>
<li>使用jps获取java应用的pid</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">&gt; 17904 -- process information unavailable</span><br><span class="line">&gt; 40836 Jps</span><br><span class="line">&gt; 43228 -- process information unavailable</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>使用jmap获取dump文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -dump:file&#x3D;test.dump,format&#x3D;b 43228</span><br><span class="line">&gt; Dumping heap to D:\projects\i-lupro-app\test.dump ...</span><br><span class="line">&gt; Heap dump file created</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用jhat分析dump文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jhat -J-Xmx512M test.dump</span><br><span class="line">&gt; Reading from test.dump...</span><br><span class="line">&gt; Dump file created Wed Nov 25 18:48:51 CST 2020</span><br><span class="line">&gt; Snapshot read, resolving...</span><br><span class="line">&gt; Resolving 197329 objects...</span><br><span class="line">&gt; Chasing references, expect 39 dots.......................................</span><br><span class="line">&gt; Eliminating duplicate references.......................................</span><br><span class="line">&gt; Snapshot resolved.</span><br><span class="line">&gt; Started HTTP server on port 7000</span><br><span class="line">&gt; Server is ready.</span><br></pre></td></tr></table></figure>
</li>
<li><p>在浏览器打开<code>http://localhost:7000/</code>开启可视化工具</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-6fade6dd6c5d4c22ad5bc240c8b5f9d75e5.png" alt=""></p>
<h2 id="6-2-jhat工具的功能"><a href="#6-2-jhat工具的功能" class="headerlink" title="6.2 jhat工具的功能"></a>6.2 jhat工具的功能</h2><h3 id="6-2-1-显示出堆中所包含的所有的类"><a href="#6-2-1-显示出堆中所包含的所有的类" class="headerlink" title="6.2.1 显示出堆中所包含的所有的类"></a>6.2.1 显示出堆中所包含的所有的类</h3><p><img src="https://oscimg.oschina.net/oscnet/up-c7845203fa9fcefbe17a403fada331d2fe6.png" alt=""></p>
<h3 id="6-2-2-从根集能引用到的对象"><a href="#6-2-2-从根集能引用到的对象" class="headerlink" title="6.2.2 从根集能引用到的对象"></a>6.2.2 从根集能引用到的对象</h3><p><img src="https://oscimg.oschina.net/oscnet/up-e4abad59b62e6227690f0b74c7e63636c9b.png" alt=""></p>
<h3 id="6-2-3-显示平台包括的所有类的实例数量"><a href="#6-2-3-显示平台包括的所有类的实例数量" class="headerlink" title="6.2.3 显示平台包括的所有类的实例数量"></a>6.2.3 显示平台包括的所有类的实例数量</h3><p><img src="https://oscimg.oschina.net/oscnet/up-681a652365cd626166413836fac3559e3ae.png" alt=""></p>
<h3 id="6-2-4-堆实例的分布表"><a href="#6-2-4-堆实例的分布表" class="headerlink" title="6.2.4 堆实例的分布表"></a>6.2.4 堆实例的分布表</h3><p><img src="https://oscimg.oschina.net/oscnet/up-88328e2da155165229e5fe23822dd977f76.png" alt=""></p>
<h3 id="6-2-5-执行对象查询语句（OQL）"><a href="#6-2-5-执行对象查询语句（OQL）" class="headerlink" title="6.2.5 执行对象查询语句（OQL）"></a>6.2.5 执行对象查询语句（OQL）</h3><p><img src="https://oscimg.oschina.net/oscnet/up-c37f0628b26bad0a8400a13f7b86abe91f8.png" alt=""></p>
<p>其输入内容如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询长度大于100的字符串</span><br><span class="line">select s from java.lang.String s where s.count &gt; 100</span><br></pre></td></tr></table></figure>

<p>详细的OQL可点击上图的“OQL help”</p>
<h1 id="7-jconsole-可视化监控控制台"><a href="#7-jconsole-可视化监控控制台" class="headerlink" title="7 jconsole 可视化监控控制台"></a>7 jconsole 可视化监控控制台</h1><p>Jconsole（Java Monitoring and Management Console），一种基于JMX的可视化监视、管理工具。</p>
<h2 id="7-1-启动JConsole"><a href="#7-1-启动JConsole" class="headerlink" title="7.1 启动JConsole"></a>7.1 启动JConsole</h2><ul>
<li>点击JDK/bin 目录下面的jconsole.exe 即可启动</li>
<li>然后会自动自动搜索本机运行的所有虚拟机进程。</li>
<li>选择其中一个进程可开始进行监控</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-f5a52f0eee9f28932af48746f95e3223943.png" alt=""></p>
<h2 id="7-2-JConsole介绍"><a href="#7-2-JConsole介绍" class="headerlink" title="7.2 JConsole介绍"></a>7.2 JConsole介绍</h2><p>JConsole 基本包括以下基本功能：概述、内存、线程、类、VM概要、MBean</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-11772572f99a3f728e6ee1753fafbeea925.png" alt=""></p>
<h3 id="7-2-1-概览"><a href="#7-2-1-概览" class="headerlink" title="7.2.1 概览"></a>7.2.1 概览</h3><p><img src="https://oscimg.oschina.net/oscnet/up-7b3aa6394fca39612e1e574d824e6362663.png" alt=""></p>
<h3 id="7-2-2-内存监控"><a href="#7-2-2-内存监控" class="headerlink" title="7.2.2 内存监控"></a>7.2.2 内存监控</h3><p>内存页签相对于可视化的jstat 命令，用于监视受收集器管理的虚拟机内存。</p>
<p>jconsole可监控的内存有许多，如下图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-acd1b73254618670e43a14991798a3afeb7.png" alt=""></p>
<p>我们以堆内存为例：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3e498652fe610e4a921b1337f8fde118154.png" alt=""></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>堆内存的大小</td>
<td>442032KB</td>
<td></td>
</tr>
<tr>
<td>已使用</td>
<td>249362KB</td>
<td>目前使用的内存量，包括所有对象，可达和不可达占用的内存。</td>
</tr>
<tr>
<td>已提交</td>
<td>442032KB</td>
<td>保证由Java虚拟机使用的内存量。 提交的内存量可能会随时间而改变。 Java虚拟机可能会释放系统内存，并已提交的内存量可能会少于最初启动时分配的内存量。 提交的内存量将始终大于或等于使用的内存量。</td>
</tr>
<tr>
<td>最大值</td>
<td>742400KB</td>
<td>可用于内存管理的最大内存量。 它的价值可能会发生变化，或者是不确定的。 如果Java虚拟机试图增加使用的内存要大于提交的内存，内存分配可能失败，即使使用量小于或等于最大值（例如，当系统上的虚拟内存不足）。</td>
</tr>
<tr>
<td>GC时间</td>
<td>parnew上的 3.487s(73收集)</td>
<td>累计时间花在垃圾收集和调用的总数。 它可能有多个行，其中每一个代表一个垃圾收集器算法在Java虚拟机的总耗时和执行次数</td>
</tr>
<tr>
<td>堆</td>
<td>–</td>
<td>堆内存是运行时数据区域，Java VM的所有类实例和数组分配内存。 可能是固定或可变大小的堆。</td>
</tr>
<tr>
<td>非堆内存</td>
<td>–</td>
<td>非堆内存包括在所有线程和Java虚拟机内部处理或优化所需的共享的方法。 它存储了类的结构，运行常量池，字段和方法数据，以及方法和构造函数的代码，方法区在逻辑上是堆的一部分，看具体实现的方式。根据实现方式的不同，Java虚拟机可能不进行垃圾收集或压缩。 堆内存一样，方法区域可能是一个固定或可变大小。 方法区的内存不需要是连续的。</td>
</tr>
</tbody></table>
<blockquote>
<p>除了方法区，Java虚拟机可能需要进行内部处理或优化，这也属于非堆内存的内存。 例如，实时（JIT）编译器需要内存用于存储从Java虚拟机的高性能的代码翻译的机器码。</p>
</blockquote>
<h3 id="7-2-3-线程监控"><a href="#7-2-3-线程监控" class="headerlink" title="7.2.3 线程监控"></a>7.2.3 线程监控</h3><p>如果上面的“内存”页签相当于可视化的jstat命令的话，<strong>“线程”页签的功能相当于可视化的jstack命令</strong>，遇到线程停顿时可以使用这个页签进行监控分析。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-11dd1568537efa5bfb71e6327e5cd100ab4.png" alt=""></p>
<p>在左下角的“线程”列表列出了所有的活动线程。 如果你输入一个“filter”字段中的字符串，线程列表将只显示其名称中包含你输入字符串线程。 点击一个线程在线程列表的名称，显示该线程的信息的权利，包括线程的名称，状态、阻塞和等待的次数、堆栈跟踪。</p>
<p>如果要检查您的应用程序已经陷入死锁的线程，可以通过点击“检测死锁”按钮检测。线程长时间停顿的主要原因主要有：等待外部资源（数据库连接、网络资源、设备资源等）、死循环、锁等待（活锁和死锁）</p>
<p>我们写个死锁代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.jvm;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 线程死锁验证</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JConsoleThreadLock &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 线程死锁等待演示</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static class SynAddRunalbe implements Runnable &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        public SynAddRunalbe(int a, int b) &#123;</span><br><span class="line">            this.a &#x3D; a;</span><br><span class="line">            this.b &#x3D; b;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (Integer.valueOf(a)) &#123;</span><br><span class="line">                synchronized (Integer.valueOf(b)) &#123;</span><br><span class="line">                    System.out.println(a + b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            new Thread(new SynAddRunalbe(1, 2)).start();</span><br><span class="line">            new Thread(new SynAddRunalbe(2, 1)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段代码开了200个线程去分别计算1+2以及2+1的值，其实for循环是可省略的，两个线程也可能会导致死锁，不过那样概率太小，需要尝试运行很多次才能看到效果。一般的话，带for循环的版本最多运行2～3次就会遇到线程死锁，程序无法结束。</p>
</blockquote>
<blockquote>
<p>造成死锁的原因是Integer.valueOf（）方法基于减少对象创建次数和节省内存的考虑，<code>[-128，127]</code>之间的数字会被缓存，当valueOf（）方法传入参数在这个范围之内，将直接返回缓存中的对象。也就是说，代码中调用了200次Integer.valueOf（）方法一共就只返回了两个不同的对象。假如在某个线程的两个synchronized块之间发生了一次线程切换，那就会出现线程A等着被线程B持有的Integer.valueOf（1），线程B又等着被线程A持有的Integer.valueOf（2），结果出现大家都<br>跑不下去的情景。</p>
</blockquote>
<p>如果检测到任何死锁的线程，这些都显示在一个新的标签，旁边出现的“死锁”标签， 在图所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1832aa910902ad945d0f4c6e7c009541567.png" alt=""></p>
<p>结果描述：显示了线程Thread-53在等待一个被线程Thread-66持有Integer对象，而点击线程Thread-66则显示它也在等待一个Integer对象，被线程Thread-53持有，这样两个线程就互相卡住，都不存在等到锁释放的希望了</p>
<h3 id="7-2-4-类加载信息监控"><a href="#7-2-4-类加载信息监控" class="headerlink" title="7.2.4 类加载信息监控"></a>7.2.4 类加载信息监控</h3><p>类”标签显示关于类加载的信息。</p>
<ul>
<li>红线表示加载的类的总数（包括后来卸载的）</li>
<li>蓝线是当前的类加载数</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-6ee2e744430067f37f21fc733ed06c0d888.png" alt=""></p>
<p>在选项卡底部的详细信息部分显示类的加载，因为Java虚拟机开始的总数，当前加载和卸载的数量。** 跟踪**类加载详细的输出，您可以勾选在顶部的右上角复选框。</p>
<h3 id="7-2-5-VM概要监控"><a href="#7-2-5-VM概要监控" class="headerlink" title="7.2.5 VM概要监控"></a>7.2.5 VM概要监控</h3><p><img src="https://oscimg.oschina.net/oscnet/up-a46f88dfc8f4816f0c090b24eaa5aaef8d5.png" alt=""></p>
<p>在此选项卡中提供的信息包括以下内容。</p>
<ul>
<li>摘要<ul>
<li>运行时间 ：开始以来，Java虚拟机的时间总额。</li>
<li>进程的CPU时间 ：Java VM的开始，因为它消耗的CPU时间总量。</li>
<li>编译总时间 ：累计时间花费在JIT编译。</li>
</ul>
</li>
<li>主题<ul>
<li>活动线程 ：目前现场守护线程，加上非守护线程数量。</li>
<li>峰值 ：活动线程的最高数目，因为Java虚拟机开始。</li>
<li>守护线程 ：当前的活动守护线程数量。</li>
<li>总线程 ：开始自Java虚拟机启动的线程总数，包括非守护进程，守护进程和终止的线程。</li>
</ul>
</li>
<li>类<ul>
<li>当前类装载 ：目前加载到内存中的类数目。</li>
<li>总类加载 ：从Java VM开始加载到内存中的类总和，包括那些后来被卸载的类。</li>
<li>已卸载类总数 ：从Java虚拟机开始从内存中卸载的类的数目。</li>
</ul>
</li>
<li>内存<ul>
<li>当前的堆大小 ：目前所占用的堆的千字节数。</li>
<li>分配的内存 ：堆分配的内存总量。</li>
<li>最大堆最大值 ：堆所占用的千字节的最大数目。</li>
<li>待最后确定的对象：待最后确定的对象的数量。</li>
<li>花在执行GC的垃圾收集器 ：包括垃圾收集，垃圾收集器的名称，进行藏品的数量和总时间的信息。</li>
</ul>
</li>
<li>操作系统<ul>
<li>总物理内存</li>
<li>空闲物理内存</li>
<li>分配的虚拟内存</li>
<li>其他信息</li>
</ul>
</li>
<li>VM参数 ：输入参数的应用程序通过Java虚拟机，不包括的主要方法的参数。<ul>
<li>类路径是由系统类加载器用于搜索类文件的类路径。</li>
<li>库路径 ：加载库时要搜索的路径列表。</li>
<li>引导类路径 ：引导类路径是由引导类加载器用于搜索类文件。</li>
</ul>
</li>
</ul>
<h1 id="8-jvisualvm"><a href="#8-jvisualvm" class="headerlink" title="8 jvisualvm"></a>8 jvisualvm</h1><p>jvisualvm是Netbeans的profile子项目，从JDK6.0 update 7 版本开始自带。jvisualvm同jconsole一样，都是一个基于图形化界面的、可以查看本地及远程的JAVA GUI监控工具，jvisualvm是一个综合性的分析工具，其整合了jstack、jmap、jinfo等众多调试工具的功能，<strong>可以认为jvisualvm是jconsole的升级版</strong>。</p>
<h2 id="8-1-启动jvisualvm"><a href="#8-1-启动jvisualvm" class="headerlink" title="8.1 启动jvisualvm"></a>8.1 启动jvisualvm</h2><p>在<strong>JDK_HOME/bin下双击jvisualvm.exe</strong>，或者<strong>直接在命令行中输入<code>jvisualvm</code></strong> 都可</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dbb2e524e7ef676a8b13536be297b1a1005.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-92d0c7e5219ec32ed45379a2fdea9f78785.png" alt=""></p>
<p>我们可以看到侧边框：</p>
<ul>
<li>本地：如果你本地有java进程启动了，那么在本地这个栏目就会显示。</li>
<li>远程：监控的远程主机</li>
<li>快照：装载dump文件或者hprof文件，进行分析</li>
</ul>
<blockquote>
<p>由于本地和远程展示的监控界面都是相同的，接下来我们直接介绍远程。</p>
</blockquote>
<h2 id="8-2-添加远程监控"><a href="#8-2-添加远程监控" class="headerlink" title="8.2 添加远程监控"></a>8.2 添加远程监控</h2><p>注意，一个主机如果希望支持远程监控，需要在启动时添加以下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-Dcom.sun.management.jmxremote.port&#x3D;1099</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate&#x3D;false</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl&#x3D;false</span><br></pre></td></tr></table></figure>

<p>右击”远程”–&gt;”添加远程主机”，出现界面：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-25b65255824dc5691a94fa27cda8c66b382.png" alt=""></p>
<p>在连接后面添加一个1099，这是远程主机jmx监听的端口号，点击确定，侧边栏变为：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-22396788168496d5121b6acc394d3dbd1af.png" alt=""></p>
<p>点击红色框中的jmx连接，出现以下界面：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3552febc4e82aeb6dbd832dcaa723024e54.png" alt=""></p>
<h2 id="8-3-jvisualvm介绍"><a href="#8-3-jvisualvm介绍" class="headerlink" title="8.3 jvisualvm介绍"></a>8.3 jvisualvm介绍</h2><p>jvisualvm分为四个选项卡：概述、监视、线程、抽样器，下面我们一一介绍：</p>
<h3 id="8-3-1-概述页"><a href="#8-3-1-概述页" class="headerlink" title="8.3.1 概述页"></a>8.3.1 概述页</h3><p>默认显示的就是概述选项卡，其中的信息相当于我们调用了jinfo命令获得，其还包含了两个子选项卡：</p>
<ul>
<li>jvm参数栏：相当于我们调用<code>jinfo -flags &lt;pid&gt;</code>获得</li>
<li>系统属性栏：相当于我们调用<code>jinfo -sysprops &lt;pid&gt;</code>获得</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-ffed656702f8fe2641cb4bb7ae83281b0ee.png" alt=""></p>
<h3 id="8-3-2-监视页"><a href="#8-3-2-监视页" class="headerlink" title="8.3.2 监视页"></a>8.3.2 监视页</h3><p>主要显示了cpu、内存使用、类加载信息、线程信息等，这只是一个概要性的介绍，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e38d18357d6c96ae69b4b9c25766b459c8b.png" alt=""></p>
<p>点击右上角的”堆dump”会在远程主机上，dump一个内存映射文件，之所以不直接dump到本地，主要是因为这个文件通常比较大，直接dump到本地会很慢。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7d9ad6266394309df4e9343655b7f1f6edd.png" alt=""></p>
<p>dump完成之后，可以手工下载这个文件，通过”文件”-&gt;”装入”来进行分析。</p>
<h3 id="8-3-3-线程页"><a href="#8-3-3-线程页" class="headerlink" title="8.3.3 线程页"></a>8.3.3 线程页</h3><p><img src="https://oscimg.oschina.net/oscnet/up-718039e69ea0ad56e389bb512a81ff7ac48.png" alt=""></p>
<p>线程选项卡列出了所有线程的信息，并使用了不同的颜色标记，右下角的颜色表示了不同的状态。</p>
<p>右上角的线程dump会直接把线程信息dump到本地，相当于调用了jstack命令，如：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-03f1bfbcedf2a842dd3d0cb790b8d1287c6.png" alt=""></p>
<h3 id="8-3-4-抽样器页"><a href="#8-3-4-抽样器页" class="headerlink" title="8.3.4 抽样器页"></a>8.3.4 抽样器页</h3><p><img src="https://oscimg.oschina.net/oscnet/up-8aa58a8dfaae014e7527a2014c165f8258c.png" alt=""></p>
<p>主要有”cpu”和”内存”两个按钮，功能类似，只不过一个是抽样线程占用cpu的情况，一个是抽样jvm对象内存的情况。</p>
<ol>
<li>通过设置可以对CPU的采样来源以及内存的刷新时间进行设置；</li>
<li>点击CPU或者Memory即可开始监控，点击Stop则停止采样；</li>
</ol>
<p>我们以分析cpu波动为例，看下如何使用cpu采样器：</p>
<h4 id="8-3-4-1-分析CPU波动问题"><a href="#8-3-4-1-分析CPU波动问题" class="headerlink" title="8.3.4.1 分析CPU波动问题"></a>8.3.4.1 分析CPU波动问题</h4><p>进入抽样器页（Sampler），在CPU波动的时候点击CPU对CPU进行抽样。</p>
<blockquote>
<p>注意线上环境千万不要使用Sampler右边的Profiler</p>
</blockquote>
<p><img src="https://oscimg.oschina.net/oscnet/up-80ed68d547848d4668aab24f61e7f44d698.png" alt=""></p>
<p>抽样进行一段时间后(建议3分钟左右就行了,时间越长生成的snapshot越大)，点击”stop”，然后点击”snapshot”生成快照</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-69e8bee44a52630014339ec455772acf110.png" alt=""></p>
<p>生成快照后按照”Total Time(CPU)”排序，找到那些线程最耗费CPU，从下图中我们看到基本上都是DubboServerHandler，熟悉Dubbo框架的知道这都是我们的业务线程。</p>
<p>那么我们对这些线程进行分析(多分析几个线程，双击指定线程就可以看这个线程的调用栈以及耗时情况)，看看这些线程在哪里比较耗费CPU。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0a126964b1c68919ee1de1a4336be7e0aeb.png" alt=""></p>
<p>通过分析发现，在Dubbo远程调用的时候验证参数的时间比我们处理业务的时间都长(见下图红色方框框起来的方法)。结合Dubbo官方文档得知，Dubbo的参数验证这个特性是比较耗费性能的，而我们的接口参数使用了javax.validation注解来验证参数。所以我们在调用的时候使用validation=”false”禁止使用参数验证这个特性就好了CPU就回归正常了。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e1185e4e6d8c2f03b51ebe8c0cc12795d79.png" alt=""></p>
<p>除此之外，我们也可以动态的观察线程的变化，功能有点类似JProfiler的“Mark Current Values”。我们点击<code>线程CPU时间</code>这个tab。查看每个线程占用cpu时间的增量数据。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d8aa6364c24d1ee6a5d54dca88e268b49e7.png" alt=""></p>
<h4 id="8-3-4-2-内存采样"><a href="#8-3-4-2-内存采样" class="headerlink" title="8.3.4.2 内存采样"></a>8.3.4.2 内存采样</h4><p>和cpu采样一样的，样进行一段时间后(建议3分钟左右就行了,时间越长生成的snapshot越大)，点击”stop”，然后点击”snapshot”生成快照</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-66d559639df230c6c48a70f8bd475f43d63.png" alt=""></p>
<p>点击增量同样可以监控内存的变动情况：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d1b4d0a420cce0835ec4eb2ad4ba03af88d.png" alt=""></p>
<p>点击“执行GC”，则可以手动触发GC；<br>点击“堆Dump”，则可以手动触发dump文件生成；</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5e0e8b3c2b4d94ca3a6b660f1defcec55d5.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/24/%E7%AE%80%E8%BF%B0%E4%BA%8C%E5%8F%89%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/24/%E7%AE%80%E8%BF%B0%E4%BA%8C%E5%8F%89%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" itemprop="url">简述二叉堆和优先级队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-24T21:27:32+08:00">
                2020-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91-%E5%A0%86/" itemprop="url" rel="index">
                    <span itemprop="name">树/堆</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/11/24/%E7%AE%80%E8%BF%B0%E4%BA%8C%E5%8F%89%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/11/24/简述二叉堆和优先级队列/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  13
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-堆和树的区别"><a href="#1-堆和树的区别" class="headerlink" title="1 堆和树的区别"></a>1 堆和树的区别</h1><p>堆是一类特殊的树，就类似一堆东西一样（金字塔结构），按照由大到小（或由小到大）“堆”起来。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0dcba6005c20f21c6a6e966b9f239b7bc91.png" alt=""></p>
<p>其中容易混淆的是二叉堆和二叉树。</p>
<p>二叉堆的特点是双亲结点的值必然小于等于（最小堆）或者大于等于（最大堆）子结点的值，而两个子结点的关键字没有次序规定。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f09402ab0d3a934593287fb73cfe5429a55.png" alt=""></p>
<p>而二叉树中，每个双亲结点的值均大于左子树结点的值，均小于右子树结点的值，也就是说，每个双亲结点的左右子结点的值有次序关系。</p>
<p>从上面各自的结构上的分析可得：二叉树是用来做查找的，而二叉堆是用来做排序的。</p>
<h1 id="2-优先级队列"><a href="#2-优先级队列" class="headerlink" title="2 优先级队列"></a>2 优先级队列</h1><p>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。而在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。</p>
<p>优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现，因为和其他线性结构相比，用堆实现优先级队列的性能最优：</p>
<blockquote>
<p>一般在优先队列里面说“堆”这个词，指的都是二叉堆这种数据结构实现。</p>
</blockquote>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>入队性能</th>
<th>出队性能（取最大/最小元素）</th>
</tr>
</thead>
<tbody><tr>
<td>普通线性结构</td>
<td>O(1)</td>
<td>O(n)</td>
</tr>
<tr>
<td>有序线性结构</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>堆</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
</tbody></table>
<p>可以看到，使用堆来实现优先级队列，它的入队和出队操作性能都比较优秀且平衡。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a9f3ae754e1c9715d10e2ee04988729cf4e.png" alt=""></p>
<p>由于二叉堆具有很明显的规律，所以我们可以用一个数组而不需要用链表来表示。我们设计一个数组来表示上图的“二叉堆”。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f93c241ca040b9c0b720ff7d19a47e9f636.png" alt=""></p>
<p>根据二叉堆的性质，我们可以得到这样的数组来表示一个堆：数组第0位放弃，从第一位开始放入堆的元素。我们看到，在堆中描述的父子结构（颜色标记），在数组中依然得以保留，不过保留的方式变成了：第i个位置上的元素，他的左子结点总是在第2i位置上，右子结点在2i+1的位置上。</p>
<h2 id="2-1-入队操作-add"><a href="#2-1-入队操作-add" class="headerlink" title="2.1 入队操作(add)"></a>2.1 入队操作(add)</h2><p>就像为了保证二叉树的查询效率，我们要时刻维持二叉树的平衡一样。我们每次对堆进行插入操作，都需要保证满足堆的堆序特性。所以很多时候我们在插入之后，不得不调整整个堆的顺序来维持堆的数据结构。</p>
<p>这个在插入时能保证堆继续“平衡”的操作叫做上滤（Sift up），下面以一个最小堆为例：</p>
<ol>
<li>为将一个元素X插入到堆中，我们在下一个可用位置（前序遍历找下一个可用结点）创建一个空穴。</li>
<li>如果X可以放在该空穴中而不破坏堆的序（父结点小于等于子结点），那么可以插入完成。否则，将空穴和父结点交换位置。这个操作叫做上滤。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-918be845ea6b033d23a100225f335d6d44a.png" alt=""></p>
<ol start="3">
<li>以此类推，直到空穴无法再上滤为止（此时的父结点已经小于等于插入的值），插入完成。<br><img src="https://oscimg.oschina.net/oscnet/up-6694fcc88544629fcd8eb52284cb38d5a80.png" alt=""></li>
</ol>
<p>这个操作我们可以通过递归来实现，<strong>平均的时间复杂度是O(logn)</strong>。</p>
<h2 id="2-2-出队操作-poll"><a href="#2-2-出队操作-poll" class="headerlink" title="2.2 出队操作(poll)"></a>2.2 出队操作(poll)</h2><p>根据堆序特性，找到最先元素很简单，就是堆的<strong>根节点</strong>，但是删除它却不容易，删除根节点，必然会破坏树的结构。所以在删除时，我们也要特定操作，来保证堆序继续正确。</p>
<p>这个在删除时能保证堆继续“平衡”的操作叫做下滤（Sift down），下面还是以一个最小堆为例：</p>
<ol>
<li>删除一个元素，我们可以很快找到，根节点元素就是最小的元素。此时根节点变成了空穴。删掉了一个结点，肯定要找一个结点补回来，为了维持完全二叉的特性，我们找堆的最后一个结点（前序遍历）赋值给空穴。也就是下图中标红的31。<br><img src="https://oscimg.oschina.net/oscnet/up-68825d5b5b70cef69ee03230234117009a2.png" alt=""></li>
<li>此时，31成为了根结点是不满足堆序的，所以肯定需要在左右结点中找一个子结点来和根结点做交互，选择哪个呢？根据堆序，肯定选择子结点中较小的那个结点，和空穴交换位置。<br><img src="https://oscimg.oschina.net/oscnet/up-77ba8899d481d3aa3567cbe3940cd79aada.png" alt=""></li>
<li>重复上述操作，直到空穴下沉到最底层为止。下滤操作完成。<br><img src="https://oscimg.oschina.net/oscnet/up-cb40ce0517bf9382105996582f388b5d8ea.png" alt=""></li>
</ol>
<p>这个操作我们可以通过递归来实现，<strong>平均的时间复杂度是O(logn)</strong>。</p>
<h2 id="2-3-构建堆-heapify"><a href="#2-3-构建堆-heapify" class="headerlink" title="2.3 构建堆(heapify)"></a>2.3 构建堆(heapify)</h2><p>将一个任意数组整理成堆，这个操作叫做heapify，构建一个n个元素的最大/最小堆，我们直接执行n次insert方法即可， 因为在设计insert方法时，就已将考虑到将插入到值放到堆的合适位置。输入n项，即可自动生成n大小的堆。此时算法的时间复杂度是O(nlogn)。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-441359605d8880fe13fd9c99c98acecfbe9.png" alt=""></p>
<h2 id="2-4-替换堆中堆顶元素-replace"><a href="#2-4-替换堆中堆顶元素-replace" class="headerlink" title="2.4 替换堆中堆顶元素(replace)"></a>2.4 替换堆中堆顶元素(replace)</h2><p>用一个新的元素，替换堆中优先级最高的元素，可以直接用新元素覆盖堆顶元素，然后执行一次sift down操作即可，时间复杂度为O(logn)。</p>
<h1 id="3-JAVA中PriorityQueue实现"><a href="#3-JAVA中PriorityQueue实现" class="headerlink" title="3 JAVA中PriorityQueue实现"></a>3 JAVA中PriorityQueue实现</h1><p>PriorityQueue在jdk的java.util包下，其本质是一个Object数组，也就是我们前文提到的，使用数组来存放堆的模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Priority queue represented as a balanced binary heap: the two</span><br><span class="line"> * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span><br><span class="line"> * priority queue is ordered by comparator, or by the elements&#39;</span><br><span class="line"> * natural ordering, if comparator is null: For each node n in the</span><br><span class="line"> * heap and each descendant d of n, n &lt;&#x3D; d.  The element with the</span><br><span class="line"> * lowest value is in queue[0], assuming the queue is nonempty.</span><br><span class="line"> *&#x2F;</span><br><span class="line">transient Object[] queue; &#x2F;&#x2F; non-private to simplify nested class access</span><br></pre></td></tr></table></figure>

<h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><p>优先级队列，java的实现默认是小顶堆的实现，默认调用Object的compareTo方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue queue &#x3D; new PriorityQueue();</span><br></pre></td></tr></table></figure>

<p>我们可以使用它的另一个构造方法，手动传入指定的comparator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator comparator &#x3D; new Comparator() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public int compare(Object o1, Object o2) &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">PriorityQueue queue &#x3D; new PriorityQueue(capacity,comparator);</span><br></pre></td></tr></table></figure>


<h2 id="3-2-添加元素"><a href="#3-2-添加元素" class="headerlink" title="3.2 添加元素"></a>3.2 添加元素</h2><p>add()和offer()都是用来做入队操作的方法，add(E e)和offer(E e)的语义相同，都是向优先队列中插入元素，只是Queue接口规定二者对插入失败时的处理不同。</p>
<p>add()在插入失败时抛出异常，offer()则会返回false。对于PriorityQueue，这两个方法其实没什么差别。新加入的元素可能会破坏堆的堆序性质，因此需要进行必要的调整。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-51a52c2908df680a83954408ac3ee577c7f.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean offer(E var1) &#123;</span><br><span class="line">	if (var1 &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;不允许放入null元素</span><br><span class="line">		throw new NullPointerException();</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		++this.modCount;</span><br><span class="line">		int var2 &#x3D; this.size;</span><br><span class="line">		if (var2 &gt;&#x3D; this.queue.length) &#123;</span><br><span class="line">			this.grow(var2 + 1);&#x2F;&#x2F;自动扩容</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this.size &#x3D; var2 + 1;</span><br><span class="line">		if (var2 &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;队列原来为空，这是插入的第一个元素</span><br><span class="line">			this.queue[0] &#x3D; var1;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			this.siftUp(var2, var1);&#x2F;&#x2F;调整</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，扩容函数grow()类似于ArrayList里的grow()函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是siftUp(int k, E x)方法，该方法用于插入元素x并维持堆的特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void siftUp(int var1, E var2) &#123;</span><br><span class="line">	if (this.comparator !&#x3D; null) &#123;</span><br><span class="line">		this.siftUpUsingComparator(var1, var2);&#x2F;&#x2F; 元素类型是无法直接比较，要借用比较器的场景</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		this.siftUpComparable(var1, var2);&#x2F;&#x2F; 元素类型是可以直接比较，不需要借用比较器的场景</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两者代码大同小异，我们看其中一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void siftUpUsingComparator(int var1, E var2) &#123;&#x2F;&#x2F; var1是size</span><br><span class="line">	while(true) &#123;</span><br><span class="line">		if (var1 &gt; 0) &#123;</span><br><span class="line">			int var3 &#x3D; var1 - 1 &gt;&gt;&gt; 1;&#x2F;&#x2F; val3是parent的下标，parentNo &#x3D; (nodeNo-1)&#x2F;2</span><br><span class="line">			Object var4 &#x3D; this.queue[var3]; &#x2F;&#x2F; val4是parent元素</span><br><span class="line">			if (this.comparator.compare(var2, var4) &lt; 0) &#123;</span><br><span class="line">				this.queue[var1] &#x3D; var4;&#x2F;&#x2F; 如果var2优先级较高，和parent交换下标</span><br><span class="line">				var1 &#x3D; var3;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this.queue[var1] &#x3D; var2;&#x2F;&#x2F; 交换完下标，最后赋值，var2赋值到它应该去的地方。</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-获取队首元素"><a href="#3-3-获取队首元素" class="headerlink" title="3.3 获取队首元素"></a>3.3 获取队首元素</h2><p>element()和peek()的语义完全相同，都是获取但不删除队首元素，也就是队列中权值优先级最高的那个元素。</p>
<p>二者唯一的区别是当方法失败时element()抛出异常，peek()返回null。</p>
<p>由于堆用数组表示，根据下标关系，0下标处的那个元素就是堆顶元素。所以直接返回数组0下标处的那个元素即可。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0377b0f90c466ff3e5dfadb944b604551e4.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public E peek() &#123;</span><br><span class="line">	return (size &#x3D;&#x3D; 0) ? null : (E) queue[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-删除队首元素"><a href="#3-4-删除队首元素" class="headerlink" title="3.4 删除队首元素"></a>3.4 删除队首元素</h2><p>remove()和poll()的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时remove()抛出异常，poll()返回null。由于删除操作会改变队列的结构，为维护堆的堆序性质，需要进行必要的调整。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c39672a750a980326821896a222424aef7f.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public E poll() &#123;</span><br><span class="line">	if (size &#x3D;&#x3D; 0)</span><br><span class="line">		return null;</span><br><span class="line">	int s &#x3D; --size;&#x2F;&#x2F;size减小</span><br><span class="line">	modCount++;</span><br><span class="line">	E result &#x3D; (E) queue[0];&#x2F;&#x2F;0下标处的那个元素就是堆顶元素</span><br><span class="line">	E x &#x3D; (E) queue[s];</span><br><span class="line">	queue[s] &#x3D; null;</span><br><span class="line">	if (s !&#x3D; 0)</span><br><span class="line">		siftDown(0, x);&#x2F;&#x2F;调整</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码首先记录0下标处的元素，并用最后一个元素替换0下标位置的元素，之后调用siftDown()方法对堆进行调整，最后返回原来0下标处的那个元素（也就是最小的那个元素）</p>
<p>重点是siftDown(int k, E x)方法，该方法的作用是从k指定的位置开始，将x逐层向下与当前点的左右孩子中较小的那个交换，直到x小于或等于左右孩子中的任何一个为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">	if (comparator !&#x3D; null)</span><br><span class="line">		siftDownUsingComparator(k, x);&#x2F;&#x2F; 元素类型是无法直接比较，要借用比较器的场景</span><br><span class="line">	else</span><br><span class="line">		siftDownComparable(k, x);&#x2F;&#x2F; 元素类型是可以直接比较，不需要借用比较器的场景</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两者代码大同小异，我们看其中一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">	int half &#x3D; size &gt;&gt;&gt; 1;</span><br><span class="line">	while (k &lt; half) &#123;</span><br><span class="line">		&#x2F;&#x2F; 首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span><br><span class="line">		int child &#x3D; (k &lt;&lt; 1) + 1;&#x2F;&#x2F;leftNo &#x3D; parentNo*2+1</span><br><span class="line">		Object c &#x3D; queue[child];</span><br><span class="line">		int right &#x3D; child + 1;</span><br><span class="line">		if (right &lt; size &amp;&amp;</span><br><span class="line">			comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">			c &#x3D; queue[child &#x3D; right];</span><br><span class="line">		if (comparator.compare(x, (E) c) &lt;&#x3D; 0)</span><br><span class="line">			break;&#x2F;&#x2F; 如果parent已经比子结点小了，跳出循环</span><br><span class="line">		queue[k] &#x3D; c;&#x2F;&#x2F; 否则，用较小的子结点替换parent，继续循环</span><br><span class="line">		k &#x3D; child;</span><br><span class="line">	&#125;</span><br><span class="line">	queue[k] &#x3D; x;最后将x赋值在他适合的位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-删除特定元素"><a href="#3-5-删除特定元素" class="headerlink" title="3.5 删除特定元素"></a>3.5 删除特定元素</h2><p>remove(Object o)方法用于删除队列中跟o相等的某一个元素（如果有多个相等，只删除一个），该方法不是Queue接口内的方法，而是Collection接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。</p>
<p>具体来说，remove(Object o)可以分为2种情况：</p>
<ol>
<li>删除的是最后一个元素。直接删除即可，不需要调整。</li>
<li><ol start="2">
<li>删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次siftDown()即可。此处不再赘述。</li>
</ol>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-7323160fb1baf028a89aedda88d40971ce1.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">	int i &#x3D; indexOf(o); &#x2F;&#x2F;通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span><br><span class="line">	if (i &#x3D;&#x3D; -1)</span><br><span class="line">		return false;&#x2F;&#x2F; 找不到下标，就返回</span><br><span class="line">	else &#123;</span><br><span class="line">		removeAt(i);&#x2F;&#x2F; 调用removeAt</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private E removeAt(int i) &#123;</span><br><span class="line">	&#x2F;&#x2F; assert i &gt;&#x3D; 0 &amp;&amp; i &lt; size;</span><br><span class="line">	modCount++;</span><br><span class="line">	int s &#x3D; --size;</span><br><span class="line">	if (s &#x3D;&#x3D; i) &#x2F;&#x2F; removed last element</span><br><span class="line">		queue[i] &#x3D; null;&#x2F;&#x2F; &#x2F;&#x2F;情况1，也就是要删的地方是堆的最后一个，则直接删除</span><br><span class="line">	else &#123;</span><br><span class="line">		E moved &#x3D; (E) queue[s];&#x2F;&#x2F; 将堆最后一个元素赋给moved</span><br><span class="line">		queue[s] &#x3D; null;</span><br><span class="line">		siftDown(i, moved);&#x2F;&#x2F; 情况2，则用moved来替换被删除的位置，接着执行siftDown方法，</span><br><span class="line">		if (queue[i] &#x3D;&#x3D; moved) &#123;&#x2F;&#x2F; 如果调用完siftDown，但moved还在原位没有下沉，那么可能说明moved应该上滤</span><br><span class="line">			siftUp(i, moved);&#x2F;&#x2F; 调用siftUp，尝试让moved上滤</span><br><span class="line">			if (queue[i] !&#x3D; moved)&#x2F;&#x2F; moved终于不在原地了</span><br><span class="line">				return moved;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-应用"><a href="#4-应用" class="headerlink" title="4 应用"></a>4 应用</h1><h2 id="4-1-在n个元素中找到前k项"><a href="#4-1-在n个元素中找到前k项" class="headerlink" title="4.1 在n个元素中找到前k项"></a>4.1 在n个元素中找到前k项</h2><p>维护一个size=k的优先级队列，优先级的逻辑为题目中要求的逻辑，如题目要是找出最小的k项，那实现就是值越大的项优先级越高。</p>
<p>遍历一次n个元素，每次遍历中，都将当前元素入队，同时出队一个元素，保证队列的长度为k。</p>
<p>这样一次完整的遍历后，队列中的元素即为结果，时间复杂度为n*(logk+logk)，即O(nlogk)。</p>
<blockquote>
<p>不过该题使用不完整快排（即快排到前k项即可，其他的操作都不用做）会更快，可以达到O(n)。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/" itemprop="url">分布式事务的概念论述和方案总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-19T21:27:25+08:00">
                2020-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分布式算法&理论</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务和数据一致性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/11/19/分布式事务的概念论述和方案总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  13k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  45
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-分布式事务的概念"><a href="#1-分布式事务的概念" class="headerlink" title="1 分布式事务的概念"></a>1 分布式事务的概念</h1><p>事务在分布式计算领域也得到了广泛的应用。在单机数据库中，我们很容易能够实现一套满足ACID特性的事务处理系统，但是在分布式数据库中，数据分散在各台不同的机器上，如何对这些数据进行分布式事务处理具有非常大的挑战。</p>
<p>分布式事务的分布式，是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。通常一个分布式事务会涉及对多个数据源或业务系统的操作。</p>
<p>一个最典型的分布式事务场景是跨行的转账操作。该操作涉及调用两个异地的银行服务。其中一个是本地银行提供的取款服务，另一个是目标银行提供的存款服务，这两个服务本身是无状态且相互独立的，共同构成了一个完整的分布式事务。取款和存款两个步骤要么都执行，要么都不执行。否则，如果从本地银行取款成功，但是因为某种原因存款服务失败了，那么必须回滚到取款之前的状态，否则就会导致数据不一致。</p>
<p>从上面的例子可以看出，一个分布式事务可以看作是由多个分布式操作序列组成的，例如上面例子中的取款服务和存款服务，通常可以把这一系列分布式的操作序列称为<strong>子事务</strong>。由于分布式事务中，各个子事务的执行是分布式的，因此要实现一种能够保证ACID特性的分布式事务处理系统就显得格外复杂。</p>
<p>分布式事务=分布式+事务，这是分布式事务本身最直观，也最重要的标签。我们要想理解分布式事务的理论基础，就要首先从这两个角度来解读：</p>
<h2 id="1-1-分布式事务是个事务"><a href="#1-1-分布式事务是个事务" class="headerlink" title="1.1 分布式事务是个事务"></a>1.1 分布式事务是个事务</h2><p>首先，分布式事务是个事务，既然是事务，那么我们会希望它能够满足传统事务的ACID四个特性：</p>
<h3 id="1-1-1-传统事务要拥有ACID特性"><a href="#1-1-1-传统事务要拥有ACID特性" class="headerlink" title="1.1.1 传统事务要拥有ACID特性"></a>1.1.1 传统事务要拥有ACID特性</h3><ul>
<li><p>Atomic（原子性）</p>
<ul>
<li>事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，要么全部执行，要么全部不执行。</li>
<li>任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚。只有所有的操作全部成功，整个事务才算是成功完成。</li>
</ul>
</li>
<li><p>Consistency（一致性）</p>
<ul>
<li>事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行前后，数据库都必须处于一致性状态。换句话说，事务的执行结果必须是使数据库从一个一致性状态转变到另一个一致性状态。</li>
<li>假设银行的转账操作就是一个事务。假设A和B原来账户都有100元。此时A转账给B50元，转账结束后，应该是A账户减去50元变成50元，B账户增加50元变成150元。A、B的账户总和还是200元。转账前后，数据库就是从一个一致性状态（A100元，B100元，A、B共200元）转变到另一个一致性状态（A50元，B150元，A、B共200元）。假设转账结束后只扣了A账户，没有增加B账户，这时数据库就处于不一致的状态。</li>
</ul>
</li>
<li><p>Isolation（隔离性）</p>
<ul>
<li><p>事务的隔离性是指在并发环境中，并发的事务是相互隔离的，事务之间互不干扰。</p>
</li>
<li><p>在标准的SQL规范中，定义的4个事务隔离级别，不同隔离级别对事务的处理不同。4个隔离级别分别是：读未提交、读已提交、可重复读和串行化。</p>
<p><img src="https://oscimg.oschina.net/oscnet/e21672a1348914a88a48ad986f9cd5457ce.jpg" alt=""></p>
</li>
<li><p>事务隔离级别越高，就越能保证数据的完整性和一致性，但同时对并发性能的影响也越大。</p>
</li>
<li><p>通常，对于绝大多数的应用来说，可以优先考虑将数据库系统的隔离级别设置为授权读取，这能够在避免脏读的同时保证较好的并发性能。尽管这种事务隔离级别会导致不可重复读、幻读和第二类丢失更新等并发问题，但较为科学的做法是在可能出现这类问题的个别场合中，由应用程序主动采用悲观锁或乐观锁来进行事务控制。</p>
</li>
</ul>
</li>
<li><p>Durability（持久性）</p>
<ul>
<li>事务的持久性又称为永久性，是指一个事务一旦提交，对数据库中对应数据的状态变更就应该是永久性的。即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。</li>
</ul>
</li>
</ul>
<h2 id="1-2-分布式事务是分布式的"><a href="#1-2-分布式事务是分布式的" class="headerlink" title="1.2 分布式事务是分布式的"></a>1.2 分布式事务是分布式的</h2><p>其次，分布式事务是分布式的，既然是分布式的系统，那么它必然无可避免的要收到CAP理论的约束：</p>
<h3 id="1-2-1-分布式系统要受CAP理论约束"><a href="#1-2-1-分布式系统要受CAP理论约束" class="headerlink" title="1.2.1 分布式系统要受CAP理论约束"></a>1.2.1 分布式系统要受CAP理论约束</h3><p>CAP理论：一个分布式系统不可能同时满足一致性（C:Consistency）、可用性（A:Availability）和分区容错性（P:Partition tolerance）这三个基本要求，最多只能满足其中的两项。</p>
<ul>
<li>一致性<ul>
<li>在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性（这点跟ACID中的一致性含义不同）。</li>
<li>对于一个将数据副本分布在不同节点上的分布式系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是更新前的数据（称为脏数据），这就是典型的分布式数据不一致情况。</li>
<li>在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都能读取到最新的值，那么这样的系统就被认为具有强一致性（或严格的一致性）。</li>
</ul>
</li>
<li>可用性<ul>
<li>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果，如果超过了这个时间范围，那么系统就被认为是不可用的。</li>
<li>『有限的时间内』是一个在系统设计之初就设定好的运行指标，不同的系统会有很大的差别。比如对于一个在线搜索引擎来说，通常在0.5秒内需要给出用户搜索关键词对应的检索结果。而对应Hive来说，一次正常的查询时间可能在20秒到30秒之间。</li>
<li>『返回结果』是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出对请求的处理结果，及成功或失败，而不是一个让用户感到困惑的返回结果。</li>
<li>让我们再来看看上面提到的在线搜索引擎的例子，如果用户输入指定的搜索关键词后，返回的结果是一个系统错误，比如”OutOfMemoryErroe”或”System Has Crashed”等提示语，那么我们认为此时系统是不可用的。</li>
</ul>
</li>
<li>分区容错性<ul>
<li>分区容错性要求一个分布式系统需要具备如下特性：分布式系统在遇到任何网络分区故障的时候，仍然能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li>
<li>网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络等）中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。</li>
</ul>
</li>
</ul>
<p>需要明确的一点是：<strong>对于一个分布式系统而言，分区容错性可以说是一个最基本的要求</strong>。因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓的分布式系统了，因此必然出现子网络。</p>
<p>而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。<strong>因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡</strong>。</p>
<p>比如Cassandra、Dynamo等中间件，他们的实现默认优先选择AP，弱化C；</p>
<p>而HBase、MongoDB等中间件，他们的实现默认优先选择CP，弱化A。</p>
<h3 id="1-2-2-一致性和可用性权衡的总结——BASE理论"><a href="#1-2-2-一致性和可用性权衡的总结——BASE理论" class="headerlink" title="1.2.2 一致性和可用性权衡的总结——BASE理论"></a>1.2.2 一致性和可用性权衡的总结——BASE理论</h3><p>BASE是Basically Available(基本可用）、Soft state(软状态）和Eventually consistent(最终一致性）三个短语的简写，由eBay架构师Dan Pritchett提出的，是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网分布式系统实践的总结，是基于CAP定律逐步演化而来。</p>
<p>BASE理论核心思想是：<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</strong>。</p>
<ul>
<li>基本可用<ul>
<li>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。比如<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li>
<li>功能上的损失：正常情况下，在一个电子商务网站（比如淘宝）上购物，消费者几乎能够顺利地完成每一笔订单。但在一些节日大促购物高峰的时候（比如双十一、双十二），由于消费者的购物行为激增，为了保护系统的稳定性（或者保证一致性），部分消费者可能会被引导到一个降级页面</li>
</ul>
</li>
</ul>
</li>
<li>弱状态<ul>
<li>弱状态是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同的数据副本之间进行数据同步的过程存在延时。</li>
</ul>
</li>
<li>最终一致性<ul>
<li>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
<li>最终一致性是一种特殊的弱一致性：系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问都能够获取到最新的值。同时，在没有发生故障的前提下，数据到达一致状态的时间延迟，取决于网络延迟、系统负载和数据复制方案设计等因素。</li>
<li>在实际工程实践中，最终一致性存在以下五类主要的变种：<ul>
<li>因果一致性(Causal consistency)<ul>
<li>如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问遵守一般的最终一致性规则。</li>
</ul>
</li>
<li>读己之所写(Read your writes)<ul>
<li>当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。</li>
</ul>
</li>
<li>会话一致性(Session consistency)<ul>
<li>这是上一个模型的实用版本，它把访问存储系统的进程放到会话的上下文中。只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统的保证不会延续到新的会话。</li>
</ul>
</li>
<li>单调读一致性(Monotonic read consistency)<ul>
<li>如果某个进程已经看到过数据对象的某个值，那么该进程任何后续访问都不会返回在那个值之前的值。</li>
</ul>
</li>
<li>单调写一致性(Monotonic write consistency)<ul>
<li>系统保证来自同一个进程的写操作顺序执行。要是系统不能保证这种程度的一致性，就非常难以编程了。<blockquote>
<p>以上就是最终一致性的五种常见的变种，在实际系统实践中，可以将其中的若干个变种互相结合起来，以构建一个具有最终一致性特性的分布式系统。<br>事实上，最终一致性并不是只有那些大型分布式系统才涉及的特性，许多现代的关系型数据库都采用了最终一致性模型。在现代关系型数据库中（比如MySQL和PostgreSQL），大多都会采用同步或异步方式来实现主备数据复制技术。在同步方式中，数据的复制过程通常是更新事务的一部分，因此在事务完成后，主备数据库的数据就会达到一致。而在异步方式中，备库的更新往往会存在延时，这取决于事务日志在主备数据库之间传输的时间长短。如果传输时间过长或者甚至在日志传输过程中出现异常导致无法及时将事务应用到备库上，那么很显然，从备库中读取的数据将是旧的，因此就出现了数据不一致的情况。<br>当然，无论是采用多次重试还是人为数据订正，关系型数据库还是能够保证最终数据达到一致，这就是系统提供最终一致性保证的经典案例。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-ACID和CAP妥协下的柔性事务"><a href="#1-3-ACID和CAP妥协下的柔性事务" class="headerlink" title="1.3 ACID和CAP妥协下的柔性事务"></a>1.3 ACID和CAP妥协下的柔性事务</h2><p>可以看到，ACID特性和CAP理论，在关于一致性问题上都有论述，只不过</p>
<ul>
<li>ACID中的C论述的是：一个事务在执行前后，数据库的数据都必须处于一致性状态，如转账过程，金钱总量应该保持不变。</li>
<li>CAP中的C论述的是：同一个数据在多个分布式副本之间是否能够保持一致，如某个用户的余额，在各个副本之间值应该一致。</li>
</ul>
<p>我们需要注意到他们论述的点其实是不同的。</p>
<p>同时，我们还要注意到，虽然分布式系统受限于CAP理论而时常要在A和C中做取舍，但对于分布式事务系统来说，C的重要性是高于A的，故而市面上成熟的分布式事务解决方案，都是在努力事务ACID特性的基础上，尽量在分布式的情况下（也就是满足分区容错性的情况下）达到较好的数据一致性。</p>
<p>我们一般来说，根据数据一致性的实效，以及ACID/CAP取舍的类型，可将事务分为：</p>
<ol>
<li>刚性事务：遵循ACID原则，强一致性。本地事务，基本都是刚性事务。</li>
<li>柔性事务：遵循BASE理论，最终一致性；与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。</li>
</ol>
<p><strong>受限于分布式的局限，分布式事务的实现目前都是柔性事务，换句话说，我们还无法实现完全满足ACID强一致性的分布式事务</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bc8190a25a113f5ff762e31d155104cf761.png" alt=""></p>
<h1 id="2-分布式事务的解决方案"><a href="#2-分布式事务的解决方案" class="headerlink" title="2 分布式事务的解决方案"></a>2 分布式事务的解决方案</h1><p>经过上文的论述，我们有了一定的理论基础，明确了我们希望的分布式事务应该是什么样的。我们往往为了可用性和分区容错性，忍痛放弃强一致支持的刚性事务，转而追求最终一致性的柔性事务。</p>
<p>那么如何实现能够<strong>基本满足</strong>ACID特性和CAP理论的分布式事务呢？我们接下来介绍几种成熟的柔性事务实现。</p>
<ol>
<li><strong>XA协议</strong>：更偏向于在数据库层面解决数据库之间的分布式事务<ul>
<li>1.1 2PC（两段式提交）</li>
<li>1.2 3PC（三段式提交）</li>
</ul>
</li>
<li><strong>TCC两阶段补偿型事务</strong>：更偏向于在应用层面解决分布式系统中的补偿形分布式事务</li>
<li><strong>最大努力通知</strong>：最简单的一种柔性事务，适用于一些最终一致性时间敏感度低，且被动方处理结果<strong>不影响</strong>主动方的处理结果的业务。</li>
<li><strong>本地消息表</strong>：将分布式事务拆分成本地事务进行处理的一种思路</li>
<li>半消息/最终一致性（RocketMQ）</li>
</ol>
<p>TCC、Saga、事务消息、最大努力事务</p>
<h2 id="2-1-XA协议"><a href="#2-1-XA协议" class="headerlink" title="2.1 XA协议"></a>2.1 XA协议</h2><p>在分布式系统中，每个节点都能明确知道自身事务操作结果，但无法直接获取到其他分布式节点的操作结果。所以当一个事务要横跨多个节点时，为了保证事务处理的ACID特性而引入了协调者组件来统一调度所有分布式节点（参与者）的执行逻辑，协调者调度参与者的行为并最终决定是否把参与者的事务进行真正的提交。</p>
<p>XA协议是体现和贯彻协调者角色的一种很经典分布式事务协议，由Tuxedo提出，XA的目的是保证分布式事务的ACID特性，就像本地事务一样。</p>
<p>XA大致分为两部分：事务管理器（<strong>协调者角色</strong>）和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-30f12d658476ab1e33f5927ccfd6b141604.png" alt=""></p>
<p>XA协议为了保证分布式事务能够在保持ACID特性的同时保证分布式系统之间的数据一致性，提供了两种分布式事务的实现：2PC和3PC协议。</p>
<h3 id="2-1-1-2PC"><a href="#2-1-1-2PC" class="headerlink" title="2.1.1 2PC"></a>2.1.1 2PC</h3><h4 id="2-1-1-1-简介"><a href="#2-1-1-1-简介" class="headerlink" title="2.1.1.1 简介"></a>2.1.1.1 简介</h4><ul>
<li>2PC（Two-Phase Commit 两阶段提交）：完成参与者的协调，统一决定事务的提交或回滚，使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和数据一致性。</li>
<li>目前绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的。</li>
</ul>
<hr>
<h4 id="2-1-1-2-协议内容"><a href="#2-1-1-2-协议内容" class="headerlink" title="2.1.1.2 协议内容"></a>2.1.1.2 协议内容</h4><ol>
<li><p><strong>投票，尝试让协调者们提交事务</strong></p>
<ul>
<li>事务询问：协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，等待响应</li>
<li>执行事务：参与者节点执行事务操作，并记录Undo和Redo信息到事务日志</li>
<li>参与者响应：若参与者成功执行事务，则向协调者反馈Yes响应，否则反馈No响应</li>
</ul>
</li>
<li><p><strong>根据协调者反馈决定事务执行结果</strong></p>
<ol start="21">
<li>如果所有参与者的反馈都是Yes响应，那么执行事务提交<ul>
<li>发送提交请求：协调者向所有参与者发送Commit请求 </li>
<li>事务提交：参与者接受到Commit请求后执行事务提交操作并释放占用的事务资源 </li>
<li>反馈事务提交结果：参与者完成事务提交后向协调者发送Ack消息 </li>
<li>完成事务：协调者收到所有参与者的Ack响应后，完成事务提交</li>
</ul>
</li>
</ol>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/4468f39b5d7567570812b28447e0fb3346b.jpg" alt=""></li>
</ul>
<ol start="22">
<li>如果任何一个参与者返回了N响应或者协调者等待超时后就会中断事务<ul>
<li>发送回滚请求：协调者向所有参与者发送Rollback请求 </li>
<li>事务回滚：参与者受到请求后通过Undo信息执行事务回滚操作并释放占用的事务资源 </li>
<li>反馈事务回滚结果：参与者回滚事务后向协调者发送Ack消息 </li>
<li>中断事务：协调者接收到所有参与者的Ack响应后，完成事务中断</li>
</ul>
</li>
</ol>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/2d9e49af734e01cd1514beebdbf8b2c5aeb.jpg" alt=""></li>
</ul>
<hr>
<h4 id="2-1-1-3-优缺点"><a href="#2-1-1-3-优缺点" class="headerlink" title="2.1.1.3 优缺点"></a>2.1.1.3 优缺点</h4></li>
</ol>
<ul>
<li>优点<ul>
<li>原理简单，实现方便，有许多现成的实现框架</li>
</ul>
</li>
<li>缺点<ul>
<li>同步阻塞：在阶段二事务提交过程中，所有参与者的操作逻辑都处于阻塞状态，等待其他参与者响应，协调者请求</li>
<li>单点问题：一旦协调者出现问题，阶段二提交流程无法运转，并且参与者会一直处于锁定事务资源的状态，无法继续事务操作</li>
<li>太过保守：任何一个参与节点的失败使得协调者无法获取所有参与者的响应信息都会导致整个事务的失败<h3 id="2-1-2-3PC"><a href="#2-1-2-3PC" class="headerlink" title="2.1.2 3PC"></a>2.1.2 3PC</h3><h4 id="2-1-2-1-简介"><a href="#2-1-2-1-简介" class="headerlink" title="2.1.2.1 简介"></a>2.1.2.1 简介</h4></li>
</ul>
</li>
<li>3PC（Three-Phase Commit 三阶段提交）将二阶段提交的提交事务请求过程一分为二，形成CanCommit、PreCommit、doCommit三个阶段</li>
<li><img src="https://oscimg.oschina.net/oscnet/7a6cf90924d8b6ef9e4e6190be693612419.jpg" alt=""><h4 id="2-1-2-2-内容"><a href="#2-1-2-2-内容" class="headerlink" title="2.1.2.2 内容"></a>2.1.2.2 内容</h4></li>
</ul>
<ol>
<li>CanCommit<ul>
<li>事务询问：协调者向所有参与者发送包含事务内容的CanCommit请求，询问是否可以执行事务提交操作，等待响应 </li>
<li>参与者响应：参与者接收到CanCommit请求后判断自身能够顺利执行事务，能则返回Yes响应并进入预备状态，否则返回No响应</li>
</ul>
</li>
<li>PreCommit<ol start="21">
<li>如果所有参与者反馈都为Yes响应，则执行事务预提交<ul>
<li>发送预提交请求：协调者向所有参与者节点发出PreCommit请求，并进入Prepared阶段 </li>
<li>事务预提交：参与者接收到PreCommit请求后预执行事务操作（还未提交），并记录Undo和Redo信息到事务日志中 </li>
<li>参与者响应事务执行结果：若参与者成功执行事务后则返回Ack响应给协调者，等待最终命令，提交（commit）或者中断（abort）</li>
</ul>
</li>
<li>如果任何一个参与者反馈了No响应或者<strong>协调者等待所有协调者的响应超时</strong>则中断事务<ul>
<li>发送中断请求：协调者向所有参与者节点发出Abort请求 </li>
<li>中断事务：无论收到Abort请求或者等待协调者请求超时，参与者都会中断事务</li>
</ul>
</li>
</ol>
</li>
<li>DoCommit<ol start="31">
<li>执行提交<ul>
<li>发送提交请求：当协调者收到所有参与者反馈的Ack响应，向所有参与者发送DoCommit请求，从预提交状态转到提交状态 </li>
<li>事务提交：参与者接收到DoCommit请求后，正式执行事务提交操作，并释放占用的事务资源 </li>
<li>反馈事务提交结果：参与者完成事务提交后向协调者发送Ack消息</li>
<li>完成事务：协调者接受到所有参与者反馈的Ack响应后，完成事务</li>
</ul>
</li>
<li>中断事务<ul>
<li>发送中断请求：协调者向所有参与者节点发出Abort请求 </li>
<li>事务回滚：参与者接收到Abort请求后，利用Undo信息执行事务回滚操作，并释放占用的事务资源 </li>
<li>反馈事务回滚结果：参与者完成事务回滚后向协调者发送Ack消息 </li>
<li>中断事务：协调者接收到所有参与者反馈的Ack响应后，中断事务<blockquote>
<p>ps1.需要注意的是，在这一阶段，可能发生两种故障，协调者工作异常，或者协调者与参与者之间网络异常。无论出现何种情况，都会导致参与者无法及时接收到协调者发送的doCommit或者Abort请求，针对这样的异常，参与者在等待超时后，继续进行事务提交。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="2-1-2-3-优缺点"><a href="#2-1-2-3-优缺点" class="headerlink" title="2.1.2.3 优缺点"></a>2.1.2.3 优缺点</h4><ul>
<li>优点<ul>
<li>降低参与者的阻塞范围，能够在出现单点故障后继续达成一致</li>
</ul>
</li>
<li>缺点<ul>
<li>接受者接收到PreCommit消息后，如果出现网络分区导致协调者和参与者无法正常通信，这时参与者仍会进行事务提交，造成数据的不一致</li>
</ul>
</li>
</ul>
<h3 id="2-1-3-2PC和3PC的区别总结"><a href="#2-1-3-2PC和3PC的区别总结" class="headerlink" title="2.1.3 2PC和3PC的区别总结"></a>2.1.3 2PC和3PC的区别总结</h3><ul>
<li><p>2PC图示</p>
<ul>
<li>提交成功<br><img src="https://oscimg.oschina.net/oscnet/c0085259e239f6951bd1a2ea157c3adf752.jpg" alt=""></li>
<li>中断事务<br><img src="https://oscimg.oschina.net/oscnet/6c004cf1642872088d024f6a27fd97eca93.jpg" alt=""></li>
</ul>
</li>
<li><p>3PC 图示<br><img src="https://oscimg.oschina.net/oscnet/b77e43933901bccaeef41c088534d616695.jpg" alt=""></p>
</li>
<li><p>与两阶段提交不同的是，三阶段提交有如下改动点。</p>
<ul>
<li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li>
<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li>
<li>3PC的第三阶段，参与者等待协调者反馈超时时，会默认执行。</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。</li>
<li>默认执行其实是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。</li>
</ul>
</li>
</ul>
<h2 id="2-2-TCC两阶段补偿型事务"><a href="#2-2-TCC两阶段补偿型事务" class="headerlink" title="2.2 TCC两阶段补偿型事务"></a>2.2 TCC两阶段补偿型事务</h2><h3 id="2-2-1-简介"><a href="#2-2-1-简介" class="headerlink" title="2.2.1 简介"></a>2.2.1 简介</h3><p>TCC方案是可能是目前最火的一种柔性事务方案了。关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。在该论文中，TCC还是以Tentative-Confirmation-Cancellation命名。正式以Try-Confirm-Cancel作为名称的是Atomikos公司，其注册了TCC商标。</p>
<p>国内最早关于TCC的报道，应该是InfoQ上对阿里程立博士的一篇采访。经过程博士的这一次传道之后，TCC在国内逐渐被大家广为了解并接受。</p>
<p>Atomikos公司在商业版本事务管理器ExtremeTransactions中提供了TCC方案的实现，但是由于其是收费的，因此相应的很多的开源实现方案也就涌现出来，如：TCC-transaction、ByteTCC、spring-cloud-rest-tcc、ByteTCC、Himly。</p>
<h3 id="2-2-2-内容"><a href="#2-2-2-内容" class="headerlink" title="2.2.2 内容"></a>2.2.2 内容</h3><p>TCC是三个英文单词的首字母缩写而来。没错，TCC分别对应Try、Confirm和Cancel三种操作，这三种操作的业务含义如下：</p>
<ol>
<li>Try：预留业务资源</li>
<li>Confirm：确认执行业务操作</li>
<li>Cancel：取消执行业务操作</li>
</ol>
<p>我们以一个经典电商系统下的支付订单场景为例：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f40b616bc3819ac5b3843c49ca268d98f23.png" alt=""></p>
<p>那对一个订单支付之后，我们需要做下面的步骤：</p>
<ol>
<li>更改订单的状态为“已支付”</li>
<li>扣减商品库存</li>
<li>给会员增加积分</li>
<li>创建销售出库单通知仓库发货</li>
</ol>
<p>上述这几个步骤，要么一起成功，要么一起失败，必须是一个整体性的事务。</p>
<p>那么TCC如何实现呢？</p>
<h4 id="2-2-2-1-Try"><a href="#2-2-2-1-Try" class="headerlink" title="2.2.2.1 Try"></a>2.2.2.1 Try</h4><p>Try操作的核心是<strong>预留业务资源</strong>，比如</p>
<ol>
<li>别直接把订单状态修改为已支付，可以先把订单状态修改为 UPDATING，也就是修改中的意思。</li>
<li>库存服务也别直接扣减库存啊，而改为冻结掉库存。你可以把可销售的库存：100-2=98，设置为98没问题，然后在一个单独的冻结库存的字段里，设置一个2，也就是说，有2个库存是给冻结了。</li>
<li>同理，别直接给用户增加会员积分，可以先在积分表里的一个预增加积分字段加入积分。</li>
<li>销售出库单可以创建，但是也设置一个中间状态“UNKNOWN”表示未确认。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-e47473f4956006c79ea5baa78b1569cbd02.png" alt=""></p>
<h4 id="2-2-2-2-Confirm"><a href="#2-2-2-2-Confirm" class="headerlink" title="2.2.2.2 Confirm"></a>2.2.2.2 Confirm</h4><p>完成了Try操作后，接下来就分成两种情况了，第一种情况是比较理想的，那就是各个服务执行自己的Try操作都成功了，那么紧接着进入Confirm阶段。</p>
<p>订单，库存，积分，出库四个模块都感知到了try操作的成功，这是confirm操作执行：</p>
<ol>
<li>正式把订单的状态设置为“已支付”。</li>
<li>冻结库存字段的2个库存扣掉变为0。</li>
<li>将预增加字段的10个积分扣掉，然后加入实际的会员积分字段中。</li>
<li>将销售出库单的状态正式修改为“已创建”，可以供仓储管理人员查看和使用，而不是停留在之前的中间状态“UNKNOWN”了。</li>
</ol>
<blockquote>
<p>这里简单提一句，如果你要玩TCC分布式事务，必须引入一款TCC分布式事务框架，比如国内开源的 ByteTCC、Himly、TCC-transaction。否则的话，感知各个阶段的执行情况以及推进执行下一个阶段的这些事情，不太可能自己手写实现，太复杂了。</p>
</blockquote>
<p><img src="https://oscimg.oschina.net/oscnet/up-4cd001fd41b9ecb4c12147fb532184a5bca.png" alt=""></p>
<h4 id="2-2-2-3-Cancel"><a href="#2-2-2-3-Cancel" class="headerlink" title="2.2.2.3 Cancel"></a>2.2.2.3 Cancel</h4><p>Confirm是try都成功后的操作，那么cancel就是try操作异常后才会进入的阶段。如积分服务吧，它执行出错了，订单服务内的TCC事务框架是可以感知到的，然后它会决定对整个TCC分布式事务进行回滚。</p>
<ol>
<li>将订单的状态设置为“CANCELED”，也就是这个订单的状态是已取消。</li>
<li>将冻结库存扣减掉2，加回到可销售库存里去，98 + 2 = 100。</li>
<li>将预增加积分字段的10个积分扣减掉。</li>
<li>将销售出库单的状态修改为“CANCELED”，即已取消。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-fb93fc3b5207a8f22f8bf39b323746421d1.png" alt=""></p>
<h3 id="2-2-3-TCC是补偿形事务"><a href="#2-2-3-TCC是补偿形事务" class="headerlink" title="2.2.3 TCC是补偿形事务"></a>2.2.3 TCC是补偿形事务</h3><p>TCC中的两阶段提交（try+confirm或者try+cancel）并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在。如上述案例：在第一阶段，相关模块需要提供try接口，为积分库存等预留字段分配资源。在第二阶段，各模块需要提供confirm/cancel接口(确认/取消预留)。开发者明显的感知到了两阶段提交过程的存在。try、confirm/cancel在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的ACID特性。其中：</p>
<ol>
<li><p>try过程的本地事务，是保证资源预留的业务逻辑的正确性。</p>
</li>
<li><p>confirm/cancel执行的本地事务逻辑确认/取消预留资源，以保证最终一致性，也就是所谓的补偿型事务(Compensation-Based Transactions)。</p>
</li>
</ol>
<p>由于是多个独立的本地事务，因此不会对资源一直加锁。</p>
<p>另外，这里提到confirm/cancel执行的本地事务是补偿性事务，关于什么事补偿性事务，atomikos 官网上有以下描述：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-91703711c3e922fbf2aa3a584ab318c9a44.png" alt=""></p>
<p>红色框中的内容，是对补偿性事务的解释。大致含义是，”<strong>补偿是一个独立的支持ACID特性的本地事务，用于在逻辑上取消服务提供者上一个ACID事务造成的影响，对于一个长事务(long-running transaction)，与其实现一个巨大的分布式ACID事务，不如使用基于补偿性的方案，把每一次服务调用当做一个较短的本地ACID事务来处理，执行完就立即提交</strong>”。</p>
<p>在这里，笔者理解为confirm和cancel就是补偿事务，用于取消try阶段本地事务造成的影响。因为第一阶段try只是预留资源，之后必须要明确的告诉服务提供者，这个资源你到底要不要，对应第二阶段的confirm/cancel。</p>
<p>现在应该明白为什么把TCC叫做两阶段补偿性事务了，提交过程分为2个阶段，第二阶段的confirm/cancel执行的事务属于补偿事务。</p>
<h3 id="2-2-4-优缺点"><a href="#2-2-4-优缺点" class="headerlink" title="2.2.4 优缺点"></a>2.2.4 优缺点</h3><ul>
<li>优点<ul>
<li>解决了跨应用业务操作的原子性问题，在诸如组合支付、账务拆分场景非常实用。</li>
<li>TCC实际上把数据库层的二阶段提交上提到了应用层来实现，对于数据库来说是一阶段提交，规避了数据库层的2PC性能低下问题。</li>
</ul>
</li>
<li>缺点<ul>
<li>TCC的Try、Confirm和Cancel操作功能需业务提供，开发成本高。</li>
</ul>
</li>
</ul>
<h2 id="2-3-最大努力通知"><a href="#2-3-最大努力通知" class="headerlink" title="2.3 最大努力通知"></a>2.3 最大努力通知</h2><h3 id="2-3-1-简介"><a href="#2-3-1-简介" class="headerlink" title="2.3.1 简介"></a>2.3.1 简介</h3><p>最大努力通知型( Best-effort delivery)是最简单的一种柔性事务，适用于一些最终一致性时间敏感度低的业务，且被动方处理结果不影响主动方的处理结果。典型的使用场景如银行通知、商户通知等。</p>
<p>最大努力通知型的实现方案，一般符合以下特点：</p>
<ol>
<li>不可靠消息：业务活动执行方，在完成业务处理之后，向业务活动的触发方发送消息，直到通知N次后不再通知，允许消息丢失(不可靠消息)。</li>
<li>定期校对：业务活动的触发方，根据定时策略，向业务活动执行方查询(执行方提供查询接口)，恢复丢失的业务消息。</li>
</ol>
<h3 id="2-3-2-内容"><a href="#2-3-2-内容" class="headerlink" title="2.3.2 内容"></a>2.3.2 内容</h3><p>举例来说：设计一个短信发送平台，背景是公司内部有多个业务都有发送短信的需求，如果每个业务独立实现短信发送功能，存在功能实现上的重复。因此专门做了一个短信平台项目，所有的业务方都接入这个短信平台，来实现发送短信的功能。简化后的架构如下所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-78aa56176a8aaa9ed89d8b12928de541e9a.png" alt=""></p>
<p>短信发送流程如下：</p>
<ol>
<li>业务方将短信发送请求提交给短信平台</li>
<li>短信平台接收到要发送的短信，记录到数据库中，并标记其状态为”已接收”</li>
<li>短信平台调用外部短信发送供应商的接口，发送短信。外部供应商的接口也是异步将短信发送到用户手机上，因此这个接口调用后，立即返回，进入第4步。</li>
<li>更新短信发送状态为”已发送”</li>
<li>短信发送供应商异步通知短信平台短信发送结果。而通知可能失败，因此最多只会通知N次。</li>
<li>短信平台接收到短信发送结果后，更新短信发送状态，可能是成功，也可能失败(如手机欠费)。到底是成功还是失败并不重要，重要的是我们知道了这调短信发送的最终结果</li>
<li>如果最多只通知N次，如果都失败了的话，那么短信平台将不知道短信到底有没有成功发送。因此短信发送供应商需要提供一个查询接口，以方便短信平台驱动的去查询，进行定期校对。</li>
</ol>
<p>在这个案例中，<strong>短信发送供应商通知短信平台短信发送结果的过程中，就是最典型的最大努力通知型方案</strong>，尽最大的努力通知了N次就不再通知。通过提供一个短信结果查询接口，让短信平台可以进行定期的校对。而由于短信发送业务的时间敏感度并不高，比较适合采用这个方案。</p>
<p>需要注意的是，定期校对的步骤很重要，短信结果查询接口很重要，必须要进行定期校对。因为后期要进行对账，比如一个月的短信发送总量在高峰期可以达到1亿条左右，即使一条短信只要5分钱，一个月就有500W。</p>
<h3 id="2-3-3-优缺点"><a href="#2-3-3-优缺点" class="headerlink" title="2.3.3 优缺点"></a>2.3.3 优缺点</h3><ul>
<li>优点<ul>
<li>原理简单，实现方便，目前也有现成的实现框架</li>
</ul>
</li>
<li>缺点<ul>
<li>即便柔性事务都只能保证数据的最终一致性，最大努力通知模型的最终时间也可能是最长的，因为消息发送的不确定性，可能会导致通知迟迟无法被消费，只适用于最终一致性时间敏感度低的业务。</li>
<li>回滚逻辑需要业务编写补偿逻辑来实现，比较费力。</li>
</ul>
</li>
</ul>
<h2 id="2-4-本地消息表"><a href="#2-4-本地消息表" class="headerlink" title="2.4 本地消息表"></a>2.4 本地消息表</h2><p>在描述本地消息表之前，我们要先了解一个概念：</p>
<p><strong>消息发送一致性</strong>：是指产生消息的业务动作与消息发送的一致，本地业务逻辑执行与消息发送是原子性的。也就是说，如果业务操作成功，那么由这个业务操作所产生的消息一定要成功投递出去(一般是发送到kafka、rocketmq、rabbitmq等消息中间件中)，否则就丢消息。</p>
<p>以购物场景为例，张三购买物品，账户扣款100元的同时，需要保证在下游的会员服务中给该账户增加100积分。如果扣款100元的业务逻辑执行失败了，但是通知增加积分的消息却没有回滚，而是发送出去了，那就会导致积分无故增加。同样的，如果扣款成功了，但是消息通知失败了，扣款却没有回滚的话，也会导致该增加的积分没有增加。</p>
<h3 id="2-4-1-简介"><a href="#2-4-1-简介" class="headerlink" title="2.4.1 简介"></a>2.4.1 简介</h3><p>本地消息表这种实现方式应该是业界使用最多的，这种实现方式的思路，其实是源于 ebay，后来通过支付宝等公司的布道，在业内广泛使用。其基本的设计思想是将远程分布式事务拆分成一系列的本地事务。如果不考虑性能及设计优雅，借助关系型数据库中的表即可实现。</p>
<h3 id="2-4-2-内容"><a href="#2-4-2-内容" class="headerlink" title="2.4.2 内容"></a>2.4.2 内容</h3><p>我们可以从下面的流程图中看出其中的一些细节：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-62f232513ca7f0682e8e52b0fc796a354ed.png" alt=""></p>
<p>举例说明：下单购买商品</p>
<ol>
<li><p>支付服务器：前提是有个本地消息表A</p>
<ul>
<li>1.1  当你支付的时候，你需要把你支付的金额扣减，并且把消息落到本地消息表A，这两个操作要放入同一个事务(依靠数据库本地事务保证一致性）。</li>
<li>1.2 消息落表后，发送MQ通知到商品库存服务器，发送成功后，更新表A中的状态。</li>
<li>1.3 除此之外，支付服务器还有一个定时任务去轮询这个本地事务表A，把没有发送的消息，重试发送给商品库存服务器。</li>
</ul>
</li>
<li><p>商品库存服务器：前提是有个本地消息表B</p>
<ul>
<li>2.1 MQ到达商品服务器之后，将接收的消息写入这个服务器的本地消息表B，然后进行扣减库存这两个操作要放入同一个事务(依靠数据库本地事务保证一致性）。扣减成功后，更新事务表B中的状态。</li>
<li>2.2 发送反馈消息给支付服务器，如果执行成功了，就反馈成功消息。如果执行失败，则反馈失败消息。</li>
<li>2.3 除此之外，商品库存服务器还有一个定时任务去轮询这个本地事务表B，把没有发送的消息，重试发送给支付服务器。</li>
</ul>
</li>
</ol>
<p>如果支付服务器接收到成功的回馈，那么事务成功。如果接收到失败的反馈，则执行回滚操作，即调用补偿接口进行反向操作。</p>
<p>本地消息表模型，<strong>通过将业务和消息落表的操作放入同一个本地事务，利用本地事务的ACID特性，来确保发送方/接收方的自身业务逻辑的连贯性和紧密型</strong>。</p>
<p>换句话说，只有发送方的业务逻辑执行成功，发送方才会将消息落表，以及发出通知，因为这些步骤在一个本地事务里面，要么都失败，要么都成功。</p>
<p>同理，接收方的业务逻辑执行，接收消息的落表，以及消息表状态的翻转，也都在一个本地事务里面，所以如果接收方发出了通知，那证明接收方的业务逻辑肯定已经执行了。</p>
<p>当两端自身的逻辑都具有连贯性和紧密型，那剩下的只要确保消息可靠就行了。mq的重试机制，以及两方的定时校验机制，都是这种可靠性的保障。</p>
<h3 id="2-4-3-优缺点"><a href="#2-4-3-优缺点" class="headerlink" title="2.4.3 优缺点"></a>2.4.3 优缺点</h3><ul>
<li>优点<ul>
<li>一种非常经典的实现，将整个分布式事务分割成多个端的本地事务，利用本地事务的可靠性来保证分布式事务在各个端的可靠性，从而使我们的精力只要集中要消息通知和校检上。</li>
</ul>
</li>
<li>缺点<ul>
<li>消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</li>
<li>回滚逻辑需要业务编写补偿逻辑来实现，比较费力。</li>
</ul>
</li>
</ul>
<h2 id="2-5-事务消息机制"><a href="#2-5-事务消息机制" class="headerlink" title="2.5 事务消息机制"></a>2.5 事务消息机制</h2><h3 id="2-5-1-简介"><a href="#2-5-1-简介" class="headerlink" title="2.5.1 简介"></a>2.5.1 简介</h3><p>前文讨论本地消息表的时候，我们提到了<strong>消息发送一致性</strong>，使用本地消息表，将业务逻辑和本地消息表的读写用本地事务来保证，这确实是一个办法。但这种办法需要额外建消息表，还需要手动编写落表逻辑和业务逻辑绑定的代码，耦合较重。有什么更优雅的，但同样能保证消息发送一致性的实现吗？答案就是本章讨论的事务消息机制。</p>
<p>从Apache RocketMQ发布的4.3版本开始，RocketMQ开源了社区最为关心的分布式事务消息，而且实现了对外部组件的零依赖。</p>
<p>RocketMQ事务消息设计则主要是为了解决Producer端的消息发送与本地事务执行的原子性问题，RocketMQ的设计中broker与producer端的双向通信能力，使得broker天生可以作为一个事务协调者存在；而RocketMQ本身提供的存储机制，则为事务消息提供了持久化能力；RocketMQ的高可用机制以及可靠消息设计，则为事务消息在系统在发生异常时，依然能够保证事务的最终一致性达成。</p>
<h3 id="2-5-2-内容"><a href="#2-5-2-内容" class="headerlink" title="2.5.2 内容"></a>2.5.2 内容</h3><p><img src="https://oscimg.oschina.net/oscnet/up-cc069006f772837fad8ab9a113e0dad68bc.png" alt=""></p>
<p>事务消息的逻辑，是由发送端Producer进行保证(消费端无需考虑)</p>
<ol>
<li>首先，发送一个事务消息，这个时候，RocketMQ将消息状态标记为Prepared，注意此时这条消息消费者是无法消费到的。</li>
<li>接着，执行业务代码逻辑，可能是一个本地数据库事务操作</li>
<li>最后，确认发送消息，根据本地业务执行结果返回commit或者是rollback。<ul>
<li>3.1 如果本地业务执行成功，消息是commit，这个时候，RocketMQ将消息状态标记为可消费，这个时候消费者，才能真正的保证消费到这条数据。</li>
<li>3.2 如果消息是rollback，RocketMQ将删除该prepare消息不进行下发。</li>
</ul>
</li>
</ol>
<p>如果发送端发送的确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事务消息，如果发现了Prepared消息，它会向消息发送端(生产者)确认。RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<p>消费端的消费成功机制由RocketMQ保证。如果发送的消息消费超时了就一直重试。</p>
<blockquote>
<p>但值得注意的是，如果消费端接到通知，然后执行消费端业务逻辑失败了的话，阿里提供给我们的解决方法是：人工解决。也就是说，两端之间的原子性，需要人工做补偿逻辑，该机制无法保证。</p>
</blockquote>
<h3 id="2-5-3-优缺点"><a href="#2-5-3-优缺点" class="headerlink" title="2.5.3 优缺点"></a>2.5.3 优缺点</h3><ul>
<li>优点<ul>
<li>依靠成熟的消息中间件的事务消息机制，不用耦合太多其他逻辑在业务逻辑中，就可以保证消息发送一致性，实现简单。</li>
</ul>
</li>
<li>缺点<ul>
<li>发送端和消费端之间的原子性无法保证，如果发送回滚，需要人工介入。</li>
</ul>
</li>
</ul>
<h2 id="2-6-Saga事务模型"><a href="#2-6-Saga事务模型" class="headerlink" title="2.6 Saga事务模型"></a>2.6 Saga事务模型</h2><h3 id="2-6-1-简介"><a href="#2-6-1-简介" class="headerlink" title="2.6.1 简介"></a>2.6.1 简介</h3><p>Saga事务模型又叫做长时间运行的事务（Long-running-transaction）, 它是由普林斯顿大学的H.Garcia-Molina等人于1987年提出，是一种异步的分布式事务解决方案，其理论基础在于，其假设所有事件按照顺序推进，总能达到系统的最终一致性，因此saga需要服务分别定义提交接口以及补偿接口，当某个事务分支失败时，调用其它的分支的补偿接口来进行回滚。</p>
<h3 id="2-6-2-内容"><a href="#2-6-2-内容" class="headerlink" title="2.6.2 内容"></a>2.6.2 内容</h3><p>saga的具体实现分为两种：Choreography以及Orchestration：</p>
<p><strong>Choreography</strong>：更接近Saga模型的初衷的一种实现：所有事件按照顺序推进，总能达到系统的最终一致性</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bb00065fb50b0d891f51e4876d58bfeb3eb.png" alt=""></p>
<p>这种模式下不存在协调器的概念，每个节点均对自己的上下游负责，在监听处理上游节点事件的同时，对下游节点发布事件。</p>
<p><strong>Orchestration</strong>：存在中心节点的模式</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5808d06acd0f587367c8d0b7dcbb18469cc.png" alt=""></p>
<p>该中心节点，即协调器知道整个事务的分布状态，相比于无中心节点方式，该方式有着许多优点：</p>
<ol>
<li>能够避免事务之间的循环依赖关系，由协调器来管理整个事务链条。</li>
<li>参与者只需要执行命令/回复(其实回复消息也是一种事件消息)，无需关心和维护自己的上下游是谁，降低参与者的复杂性。</li>
<li>开发测试门槛低。</li>
<li>扩展性好，在添加新步骤时，事务复杂性保持线性，回滚更容易管理。</li>
</ol>
<p>基于上述优势，因此大多数saga模型实现均采用了这种思路。</p>
<h3 id="2-6-3-优缺点"><a href="#2-6-3-优缺点" class="headerlink" title="2.6.3 优缺点"></a>2.6.3 优缺点</h3><ul>
<li>优点<ul>
<li>降低了事务粒度，使得事务扩展更加容易，同时采用了异步化方式提升性能。</li>
</ul>
</li>
<li>缺点<ul>
<li>很多时候很难定义补偿接口，回滚代价高，而且由于在执行过程中采用了先提交后补偿的思路进行操作，所以单个子事务在并发提交时的隔离性很难保证。</li>
</ul>
</li>
</ul>
<h1 id="3-分布式事务解决方案总结"><a href="#3-分布式事务解决方案总结" class="headerlink" title="3 分布式事务解决方案总结"></a>3 分布式事务解决方案总结</h1><h2 id="3-1-XA协议和TCC的区别"><a href="#3-1-XA协议和TCC的区别" class="headerlink" title="3.1 XA协议和TCC的区别"></a>3.1 XA协议和TCC的区别</h2><p>作为最热门的两种解决方案，XA协议和TCC的区别我们需要重点知晓。</p>
<p>TCC与XA两阶段提交有着异曲同工之妙，下图列出了二者之间的对比：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b4a7a054ce913a80fc6df3267a1b7d1fb82.png" alt=""></p>
<ol>
<li><p>在阶段1：</p>
<ul>
<li>在XA中，各个RM准备提交各自的事务分支，事实上就是准备提交资源的更新操作(insert、delete、update等)；而在TCC中，是主业务活动请求(try)各个从业务服务预留资源。</li>
</ul>
</li>
<li><p>在阶段2：</p>
<ul>
<li>XA根据第一阶段每个RM是否都prepare成功，判断是要提交还是回滚。如果都prepare成功，那么就commit每个事务分支，反之则rollback每个事务分支。</li>
</ul>
</li>
</ol>
<p>TCC中，如果在第一阶段所有业务资源都预留成功，那么confirm各个从业务服务，否则取消(cancel)所有从业务服务的资源预留请求。</p>
<p>TCC两阶段提交与XA两阶段提交的区别是：</p>
<ol>
<li>XA是资源层面的分布式事务，<strong>强一致性</strong>，在两阶段提交的整个过程中，<strong>一直会持有资源的锁</strong>。<ul>
<li>XA事务中的两阶段提交内部过程是对开发者屏蔽的，回顾我们之前讲解JTA规范时，通过UserTransaction的commit方法来提交全局事务，这只是一次方法调用，其内部会委派给TransactionManager进行真正的两阶段提交，因此开发者从代码层面是感知不到这个过程的。</li>
<li>而事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的。如果有其他人需要更新这两条记录，那么就必须等待锁释放。</li>
</ul>
</li>
</ol>
<ol start="2">
<li>TCC是业务层面的分布式事务，<strong>最终一致性</strong>，在TCC整个过程中，<strong>不会一直持有资源的锁</strong>。<ul>
<li>TCC中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在。如上述航班预定案例：在第一阶段，航空公司需要提供try接口(机票资源预留)。</li>
<li>在第二阶段，航空公司提需要提供confirm/cancel接口(确认购买机票/取消预留)。开发者明显的感知到了两阶段提交过程的存在。try、confirm/cancel在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的ACID特性。其中：<ol>
<li>try过程的本地事务，是保证资源预留的业务逻辑的正确性。</li>
<li>confirm/cancel执行的本地事务逻辑确认/取消预留资源，以保证最终一致性，也就是所谓的补偿型事务(Compensation-Based Transactions)。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="3-2-最大努力通知和本地消息表的区别"><a href="#3-2-最大努力通知和本地消息表的区别" class="headerlink" title="3.2 最大努力通知和本地消息表的区别"></a>3.2 最大努力通知和本地消息表的区别</h2><p>虽然都是利用mq，但是本地消息表利用本地事务来绑定业务逻辑和消息发送，使得mq两端的操作（发送前和接收后）是绝对可靠的，原子的。保证了消息发送一致性。</p>
<p>而最大努力通知模型，业务逻辑和发送消息之间没有这种紧密的可靠性保证，一切只能在业务上自己去实现代码来保证可靠。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/14/JAVA%E5%86%85%E7%BD%AE%E6%8E%92%E5%BA%8FArrays-sort%E5%AE%9E%E7%8E%B0%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/14/JAVA%E5%86%85%E7%BD%AE%E6%8E%92%E5%BA%8FArrays-sort%E5%AE%9E%E7%8E%B0%E7%AE%80%E8%BF%B0/" itemprop="url">JAVA内置排序Arrays.sort实现简述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-14T21:29:28+08:00">
                2020-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E5%AE%9E%E7%8E%B0%E6%88%96%E7%89%B9%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA实现或特性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/10/14/JAVA%E5%86%85%E7%BD%AE%E6%8E%92%E5%BA%8FArrays-sort%E5%AE%9E%E7%8E%B0%E7%AE%80%E8%BF%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/10/14/JAVA内置排序Arrays-sort实现简述/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在JAVA开发中，我们经常需要操作数组和集合，其中数组和链表的排序是重中之重。</p>
<p>Arrays.sort方法用来对数组排序。Collections.sort()方法用来对链表排序，而Collections.sort()的底层，其实使用的也是Arrays.sort方法。</p>
<p>所以JAVA内置排序的核心类，都在于Arrays工具类，接下来我们也重点剖析该类。</p>
<h1 id="1-Arrays工具类"><a href="#1-Arrays工具类" class="headerlink" title="1. Arrays工具类"></a>1. Arrays工具类</h1><p>我们先来看下Arrays工具类对外暴露的sort方法列表。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-53f7ef7792c0b7ceae71ba767016263106b.png" alt=""></p>
<p><strong>A：从排序范围角度划分，sort方法分为了</strong></p>
<ol>
<li>针对数组的整体做排序的方法，如<ul>
<li><code>sort(int[] a)</code></li>
<li><code>sort(Object[] a)</code></li>
<li><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></li>
</ul>
</li>
<li>针对数组的局部做排序的方法，如<ul>
<li><code>sort(int[] a, int fromIndex, int toIndex)</code></li>
<li><code>sort(Object[] a , int fromIndex, int toIndex)</code></li>
<li><code>sort(T[] a, int fromIndex, int toIndex,Comparator&lt;? super T&gt; c)</code></li>
</ul>
</li>
</ol>
<p><strong>B：从排序类型角度划分，sort方法分为了</strong></p>
<ol>
<li>对数组按照默认升序的方式进行排序的方法，如<ul>
<li><code>sort(int[] a)</code></li>
<li><code>sort(Object[] a)</code></li>
<li><code>sort(int[] a, int fromIndex, int toIndex)</code></li>
<li><code>sort(Object[] a , int fromIndex, int toIndex)</code></li>
</ul>
</li>
<li>对数组按照自定义排序类型进行排序的方法，如<ul>
<li><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></li>
<li><code>sort(T[] a, int fromIndex, int toIndex,Comparator&lt;? super T&gt; c)</code></li>
</ul>
</li>
</ol>
<p><strong>C：从操作对象角度划分，sort方法分为了</strong></p>
<ol>
<li>对基本类型（byte，int，char等）数组操作的方法<ul>
<li><code>sort(int[] a)</code></li>
<li><code>sort(int[] a, int fromIndex, int toIndex)</code></li>
</ul>
</li>
<li>对对象类型（object）数组操作的方法<ul>
<li><code>sort(Object[] a)</code></li>
<li><code>sort(Object[] a , int fromIndex, int toIndex)</code></li>
<li><code>sort(T[] a, Comparator&lt;? super T&gt; c)</code></li>
<li><code>sort(T[] a, int fromIndex, int toIndex,Comparator&lt;? super T&gt; c)</code></li>
</ul>
</li>
</ol>
<p>这里最重要的划分是C：从操作对象角度划分，因为JAVA对不同类型的数组，定义了不同的实现方法（以常用的JDK 1.8版本为例），我们先来开门见山的总结一下：</p>
<h1 id="2-基本类型数组的排序"><a href="#2-基本类型数组的排序" class="headerlink" title="2. 基本类型数组的排序"></a>2. 基本类型数组的排序</h1><p>对于基本数据类型的数组，假设数组长度为length：</p>
<ol>
<li>如果length&lt;47，那么采用<strong>插入排序算法</strong>。</li>
<li>如果47&lt;=length&lt;286，或者286&lt;=length，但数组不具备特定结构，那么使用<strong>快速排序的一种优化形式：双轴快排算法</strong>。</li>
<li>如果286&lt;=length，并且数组具备特定结构，那么使用<strong>归并排序算法</strong>。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-205a0fbd3c9218e765bbbd1a17947a400d9.png" alt=""></p>
<h2 id="2-1-数组是否具备特定结构"><a href="#2-1-数组是否具备特定结构" class="headerlink" title="2.1 数组是否具备特定结构"></a>2.1 数组是否具备特定结构</h2><p>在判断是否使用归并排序前，要先判断数组是否具备特定结构，这是一个什么意思呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Check if the array is nearly sorted</span><br><span class="line">    for (int k &#x3D; left; k &lt; right; run[count] &#x3D; k) &#123;        if (a[k] &lt; a[k + 1]) &#123; &#x2F;&#x2F; ascending</span><br><span class="line">            while (++k &lt;&#x3D; right &amp;&amp; a[k - 1] &lt;&#x3D; a[k]);</span><br><span class="line">        &#125; else if (a[k] &gt; a[k + 1]) &#123; &#x2F;&#x2F; descending</span><br><span class="line">            while (++k &lt;&#x3D; right &amp;&amp; a[k - 1] &gt;&#x3D; a[k]);            for (int lo &#x3D; run[count] - 1, hi &#x3D; k; ++lo &lt; --hi; ) &#123;                int t &#x3D; a[lo]; a[lo] &#x3D; a[hi]; a[hi] &#x3D; t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; equal</span><br><span class="line">            for (int m &#x3D; MAX_RUN_LENGTH; ++k &lt;&#x3D; right &amp;&amp; a[k - 1] &#x3D;&#x3D; a[k]; ) &#123;                if (--m &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    sort(a, left, right, true);                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        &#x2F;*</span><br><span class="line">         * The array is not highly structured,</span><br><span class="line">         * use Quicksort instead of merge sort.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (++count &#x3D;&#x3D; MAX_RUN_COUNT) &#123;</span><br><span class="line">            sort(a, left, right, true);            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里主要作用是看他数组具不具备结构：实际逻辑是分组排序，每个降序序列为一个组，像1,9,8,7,6,8。9到6是降序，为一个组，然后把降序的一组排成升序：1,6,7,8,9,8。然后再从最后的8开始继续往后面找。</p>
<p>每遇到这样一个降序组，++count，当count大于<code>MAX_RUN_COUNT（67）</code>，被判断为这个数组不具备结构，也就是说这数据时而升时而降，波峰波谷太多，排列太过陡峭，说明不适合采用归并排序，还是使用快速排序为宜。</p>
<p>如果count少于MAX_RUN_COUNT（67）的，说明这个数组还有点结构，就继续往下走下面的归并排序。</p>
<h2 id="2-2-双轴快排"><a href="#2-2-双轴快排" class="headerlink" title="2.2 双轴快排"></a>2.2 双轴快排</h2><p>双轴快排（DualPivotQuickSort）是快排的一种优化版本。双轴快速排序，顾名思义，取两个中心点pivot1，pivot2，且pivot≤pivot2，可将序列分成三段：x&lt;pivot1、pivot1≤x≤pivot2，x&lt;pivot2，然后分别对三段进行递归。基本过程如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b5a42087e1f49243697d3cd080bdfb1b949.png" alt=""></p>
<p>具体详细内容可见博客<a href="https://blog.csdn.net/Holmofy/article/details/71168530" target="_blank" rel="noopener" title="单轴快排（SinglePivotQuickSort）和双轴快排（DualPivotQuickSort）及其JAVA实现">单轴快排（SinglePivotQuickSort）和双轴快排（DualPivotQuickSort）及其JAVA实现</a></p>
<h1 id="3-对象类型数组的排序"><a href="#3-对象类型数组的排序" class="headerlink" title="3. 对象类型数组的排序"></a>3. 对象类型数组的排序</h1><p>对于对象类型的数组，假设数组长度为length：</p>
<ul>
<li><ol>
<li>如果length&lt;32，那么采用<strong>不包含合并操作的mini-TimSort算法</strong>。</li>
</ol>
</li>
<li><ol start="2">
<li>如果32&lt;=length，那么采用<strong>完整TimSort排序算法（一种结合了归并排序和插入排序的算法）</strong>。</li>
</ol>
</li>
</ul>
<h2 id="3-1-TimSort"><a href="#3-1-TimSort" class="headerlink" title="3.1 TimSort"></a>3.1 TimSort</h2><p>TimSort算法是一种起源于归并排序和插入排序的混合排序算法，设计初衷是为了在真实世界中的各种数据中可以有较好的性能。</p>
<p>基本工作过程是：</p>
<ol>
<li>扫描数组，确定其中的单调上升段和严格单调下降段，将严格下降段反转。我们将这样的段称之为run。 </li>
<li>定义最小run长度，短于此的run通过插入排序合并为长度高于最小run长度； </li>
<li>反复归并一些相邻run，过程中需要避免归并长度相差很大的run，直至整个排序完成； </li>
<li>如何避免归并长度相差很大run呢， 依次将run压入栈中，若栈顶run X，run Y，run Z 的长度违反了X&gt;Y+Z 或 Y&gt;Z 则Y run与较小长度的run合并，并再次放入栈中。 依据这个法则，能够尽量使得大小相同的run合并，以提高性能。注意Timsort是稳定排序故只有相邻的run才能归并。</li>
<li>Merge操作还可以辅之以galloping，具体细节可以自行研究。</li>
</ol>
<p>总之，timsort是工业级算法，其混用插入排序与归并排序，二分搜索等算法，亮点是充分利用待排序数据可能部分有序的事实，并且依据待排序数据内容动态改变排序策略——选择性进行归并以及galloping。</p>
<p>具体内容我们不展开，可详见<a href="https://www.imooc.com/article/257268" target="_blank" rel="noopener" title="Collections.sort()源码分析(基于JAVA8)">Collections.sort()源码分析(基于JAVA8)</a></p>
<h1 id="4-为什么要采用不同的算法？"><a href="#4-为什么要采用不同的算法？" class="headerlink" title="4. 为什么要采用不同的算法？"></a>4. 为什么要采用不同的算法？</h1><p>对于长度较小的数组使用插入排序这很好理解，虽然插入排序的时间复杂度为O(n^2)，但在n较小的情况下，插入排序性能要高于快速排序。</p>
<p>其次我们要知道，在n的数量较大时，归并排序和快速排序，都是性能最优的排序算法，他们的时间复杂度平均都在O(nlogn)左右，只不过区别在于归并排序是稳定的，快速排序是不稳定的。</p>
<blockquote>
<p>稳定是指相等的数据在排序之后仍然按照排序之前的前后顺序排列。</p>
</blockquote>
<p>对于基本数据类型，稳定性没有意义，所以它可以使用不稳定的快排（当然它也使用了归并排序）</p>
<p>而对于对象类型，稳定性是比较重要的，因为对象相等的判断比较复杂，我们无法寄希望于每个程序员都会重写准确的equal方法，故而稳妥起见，最好相等对象尽量保持排序前的顺序，故而我们使用都是稳定算法的<strong>归并排序和插入排序结合而成的TimSort算法</strong>。</p>
<p>另外一个原因是归并排序的比较次数比快排少，移动（对象引用的移动）次数比快排多，而对于对象来说，比较是相对耗时的操作，所以它不适合使用快排。</p>
<p>而对于基本数据类型来说，比较和移动都不怎么耗时，所以它用归并或者快排都可以</p>
<p>总结：</p>
<ol>
<li><p>基本数据类型数组使用快排+归并是因为：</p>
<ul>
<li>基本数据类型无所谓稳定性，可以采用非稳定的快排。</li>
<li>对于基本数据类型来说，比较和移动都不怎么耗时，所以它用归并或者快排都可以。</li>
</ul>
</li>
<li><p>对象数据类型数组使用TimSort排序是因为（或者换句话说，对象数据类型不使用快排是因为）：</p>
<ul>
<li>对象数据类型要求稳定性，需要采用稳定的归并+插入。</li>
<li>对于对象来说，比较操作相对耗时，所以用比较操作较少的归并排序可以扬长避短。</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/30/MySQL%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/30/MySQL%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/" itemprop="url">MySQL日志体系详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-30T23:44:48+08:00">
                2020-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/30/MySQL%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/09/30/MySQL日志体系详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  8.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  34
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>日志是MySQL数据库的重要组成部分。日志文件中记录着MySQL数据库运行期间发生的变化；也就是说用来记录MySQL数据库的客户端连接状况、SQL语句的执行情况和错误信息等。当数据库遭到意外的损坏时，可以通过日志查看文件出错的原因，并且可以通过日志文件进行数据恢复。</p>
<p>MySQL的日志体系有如下几种分类：</p>
<ol>
<li>错误日志</li>
<li>查询日志</li>
<li>慢查询日志</li>
<li><strong>事务日志(Redo log/undo log)</strong></li>
<li><strong>二进制日志</strong></li>
<li>中继日志</li>
</ol>
<p>其中标粗的事务日志和二进制日志，是重中之重。</p>
<h1 id="1-错误日志"><a href="#1-错误日志" class="headerlink" title="1 错误日志"></a>1 错误日志</h1><p>在默认情况下，MySQL的错误日志是开启的，且无法被禁止。在没有指定的情况下，它一般是存储在数据库的数据文件目录中，名称为hostname.err，其中，hostname为服务器主机名。</p>
<h2 id="1-1-错误日志的内容"><a href="#1-1-错误日志的内容" class="headerlink" title="1.1 错误日志的内容"></a>1.1 错误日志的内容</h2><ol>
<li>服务器启动和关闭过程中的信息，未必是错误信息，比如mysql是如何去初始化存储引擎的过程记录在错误日志里等等</li>
<li>服务器运行过程中的错误信息（或者告警信息），比如sock文件找不到，无法加载mysql数据库的数据文件，如果忘记初始化mysql或data dir路径找不到，或权限不正确等 都会记录在此</li>
<li>事件调度器运行一个事件时产生的信息，一旦mysql调度启动一个计划任务（event scheduler）的时候，它也会将相关信息记录在错误日志中</li>
<li>在从服务器上启动从服务器进程时产生的信息，在复制环境下，从服务器进程的信息也会被记录进错误日志</li>
</ol>
<h2 id="1-2-配置相关"><a href="#1-2-配置相关" class="headerlink" title="1.2 配置相关"></a>1.2 配置相关</h2><h3 id="1-2-1-开启错误日志"><a href="#1-2-1-开启错误日志" class="headerlink" title="1.2.1 开启错误日志"></a>1.2.1 开启错误日志</h3><ol>
<li><p>在/etc/my.cnf配置文件中设置：</p>
<ul>
<li>如果需要手动指定错误日志路径的话只需要在<code>[mysqld]</code>字段中增加相关配置：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-cecfbe4ae32adc82200e726bfcee974be9f.png" alt=""></li>
</ul>
</li>
<li><p>如果没有在my.cnf配置文件中指定错误日志</p>
<ul>
<li>MySQL会自动将错误日志文件存放在datadir（数据目录）下，名为hostname.err（hostname根据实际主机名变化）。</li>
</ul>
</li>
<li><p>如果是通过YUM源进行安装</p>
<ul>
<li>错误日志会被配置在/var/log/mysqld.log中，这个也是由自动创建出的/etc/my.cnf所指定的。</li>
</ul>
</li>
</ol>
<h3 id="1-2-2-设置错误日志时区"><a href="#1-2-2-设置错误日志时区" class="headerlink" title="1.2.2 设置错误日志时区"></a>1.2.2 设置错误日志时区</h3><p>错误日志默认是使用utc时间，可以修改为系统时间方便查看</p>
<p><code>mysql &gt; set global log_timestamps=&#39;SYSTEM&#39;`</code></p>
<h3 id="1-2-3-删除错误日志"><a href="#1-2-3-删除错误日志" class="headerlink" title="1.2.3 删除错误日志"></a>1.2.3 删除错误日志</h3><p>在mysql5.5.7之前：数据库管理员可以删除很长时间之前的错误日志，以保证mysql服务器上的硬盘空间。mysql数据库中，可以使用mysqladmin命令开启新的错误日志。mysqladmin命令的语法如下：</p>
<p><code>mysqladmin –u root –pflush-logs</code></p>
<p>也可以使用登录mysql数据库中使用FLUSHLOGS语句来开启新的错误日志。</p>
<p>在mysql5.5.7之后：服务器将关闭此项功能。只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的：方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@stu18 data]<span class="comment"># mv stu18.magedu.com.err  stu18.magedu.com.err.old</span></span><br><span class="line">[root@stu18 data]<span class="comment">#  mysqladmin flush-logs</span></span><br><span class="line">[root@stu18 data]<span class="comment"># ls</span></span><br><span class="line">hellodb  myclass  mysql-bin.000003  mysql-bin.index           stu18.magedu.com.pid     ibda</span><br></pre></td></tr></table></figure>

<p>或者手动清理掉错误日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &gt; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure>

<h2 id="1-3-查看错误日志和配置"><a href="#1-3-查看错误日志和配置" class="headerlink" title="1.3 查看错误日志和配置"></a>1.3 查看错误日志和配置</h2><p>查看log_error的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_error&#39;;</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">| Variable_name | Value               |</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">| log_error     | &#x2F;var&#x2F;log&#x2F;mysqld.log |</span><br><span class="line">+---------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>查看错误日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost mysql]# tailf &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line">130813  15:30:50  InnoDB: Starting shutdown...</span><br><span class="line">130813  15:30:51  InnoDB: Shutdown completed;  log sequence number 1630920</span><br><span class="line">130813 15:30:51  [Note] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld: Shutdown complete</span><br><span class="line">130813 15:30:52  mysqld_safe mysqld from pid file &#x2F;mydata&#x2F;data&#x2F;stu18.magedu.com.pid ended</span><br><span class="line">130813 15:30:53  mysqld_safe Starting mysqld daemon with databases from &#x2F;mydata&#x2F;data</span><br><span class="line">130813 15:30:54  InnoDB: The InnoDB memory heap is disabled     #禁用了InnoDB memory的堆功能。</span><br><span class="line">130813 15:30:54  InnoDB: Mutexes and rw_locks use GCC atomic builtins #Mutexes（互斥量）和rw_locks（行级锁）是GCC编译的是InnoDB内置的。</span><br><span class="line">130813 15:30:54  InnoDB: Compressed tables use zlib 1.2.3     #默认压缩工具是zlib</span><br><span class="line">130813 15:30:55  InnoDB: Initializing buffer pool, size &#x3D; 128.0M    #InnoDB引擎的缓冲池（buffer pool）的值大小</span><br><span class="line">130813 15:30:55  InnoDB: Completed initialization of buffer pool</span><br><span class="line">130813 15:30:55  InnoDB: highest supported file format is Barracuda.</span><br><span class="line">130813  15:30:57  InnoDB: Waiting for the  background threads to start</span><br><span class="line">130813 15:30:58  InnoDB: 5.5.33 started; log sequence number 1630920</span><br><span class="line">130813 15:30:58  [Note] Server hostname (bind-address): &#39;0.0.0.0&#39;; port: 3306</span><br><span class="line">130813 15:30:58  [Note]   - &#39;0.0.0.0&#39; resolves to  &#39;0.0.0.0&#39;;  #0.0.0.0会反解主机名，这里反解失败</span><br><span class="line">130813 15:30:58  [Note] Server socket created on IP: &#39;0.0.0.0&#39;.</span><br><span class="line">130813 15:30:58  [Note] Event Scheduler: Loaded 0 events    #事件调度器没有任何事件，因为没有装载。</span><br><span class="line">130813 15:30:58  [Note] &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysqld: ready for connections. #mysql启动完成等待客户端的请求。</span><br><span class="line">Version:  &#39;5.5.33-log&#39;  socket:  &#39;&#x2F;tmp&#x2F;mysql.sock&#39;  port: 3306  Source distribution  #创建一个本地sock用于本地连接。</span><br></pre></td></tr></table></figure>

<h1 id="2-查询日志"><a href="#2-查询日志" class="headerlink" title="2 查询日志"></a>2 查询日志</h1><p>查询日志在MySQL中被称为general log(通用日志)，查询日志里的内容不要被”查询日志”误导，认为里面只存储select语句，其实不然，查询日志里面记录了数据库执行的<strong>所有命令</strong>，不管语句是否正确，都会被记录，因为本质上insert/update/delete语句中，都包含了查询操作:</p>
<ul>
<li>insert的查询是为了避免数据冲突，如果此前插入过数据，当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错</li>
<li>update时也会查询，因为更新的时候是更新某一块数据，要先根据where定位到更新的记录。</li>
<li>delete查询，只删除符合条件的数据，同样是根据where定位。</li>
</ul>
<p>因此增删改查都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致IO非常大，影响MySQL性能，因此如果不是在调试环境下，是不建议开启查询日志功能的。</p>
<p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的select语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，所以，我们可以根据自己的实际情况来决定是否开启查询日志。</p>
<h2 id="2-1-查询日志配置相关"><a href="#2-1-查询日志配置相关" class="headerlink" title="2.1 查询日志配置相关"></a>2.1 查询日志配置相关</h2><h3 id="2-1-1-查看配置"><a href="#2-1-1-查看配置" class="headerlink" title="2.1.1 查看配置"></a>2.1.1 查看配置</h3><p>所以如果你要判断MySQL数据库是否开启了查询日志，可以使用下面命令。general_log为ON表示开启查询日志，OFF表示关闭查询日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%general_log%&#39; or variables like &#39;%log_output%&#39;;</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| Variable_name    | Value                        |</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| general_log      | OFF                          |</span><br><span class="line">| general_log_file | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;DB-Server.log |</span><br><span class="line">| log_output       | FILE                         |</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>参数general_log用来控制开启、关闭MySQL查询日志</li>
<li>参数general_log_file用来控制查询日志的位置</li>
<li>如果开启了查询日志，参数log_output控制着查询日志的存储方式，log_output可以设置为以下4种值:<ol>
<li>FILE : 表示日志存储在文件中</li>
<li>TABLE : 表示日志存储在mysql库中的general_log表中</li>
<li>FILE, TABLE : 表示将日志同时存储在文件和general_log表中，改值会徒增很多IO压力，一般不会这样设置</li>
<li>NONE : 表示不记录日志，即使general_log设置为ON， 如果log_output设置为NONE，也不会记录查询日志</li>
</ol>
</li>
</ul>
<blockquote>
<p>log_output不仅控制查询日志的输出，也控制着慢查询日志的输出，即: log_output设置为FILE，就表示查询日志和慢查询日志都存放在文件中，设置为TABLE，查询日志和慢查询日志都存放在mysql库中的general_log表中</p>
</blockquote>
<h3 id="2-1-2-开启或关闭查询日志"><a href="#2-1-2-开启或关闭查询日志" class="headerlink" title="2.1.2 开启或关闭查询日志"></a>2.1.2 开启或关闭查询日志</h3><ul>
<li>方法1: 在配置文件中设置(不推荐)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#可以在my.cnf里添加,1开启（0关闭）,当然了,这样要重启才能生效,有点多余了</span><br><span class="line">general-log &#x3D; 1</span><br><span class="line">log_output&#x3D;&#39;table&#39;</span><br></pre></td></tr></table></figure>

<p>然后重启MySQL实例</p>
<ul>
<li>方法2 : 通过命令设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#也可以设置变量那样更改,1开启（0关闭）,即时生效,不用重启,首选当然是这样的了</span><br><span class="line">set global general_log&#x3D;1</span><br><span class="line">set global log_output&#x3D;&#39;table&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过该方式设置，MySQL实例重启后，相关配置又恢复到默认值。如果只是短暂时间内使用，推荐使用命令行方式</p>
</blockquote>
<h3 id="2-1-3-修改查询日志名称或位置"><a href="#2-1-3-修改查询日志名称或位置" class="headerlink" title="2.1.3 修改查询日志名称或位置"></a>2.1.3 修改查询日志名称或位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;general_log%&#39;;</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| Variable_name    | Value                        |</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">| general_log      | ON                           |</span><br><span class="line">| general_log_file | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;DB-Server.log |</span><br><span class="line">+------------------+------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global general_log&#x3D;&#39;OFF&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global general_log_file&#x3D;&#39;&#x2F;u02&#x2F;mysql_log.log&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global general_log&#x3D;&#39;ON&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<h2 id="2-2-查询日志的查看"><a href="#2-2-查询日志的查看" class="headerlink" title="2.2 查询日志的查看"></a>2.2 查询日志的查看</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from mysql.general_log;</span><br><span class="line">+---------------------+---------------------------+-----------+-----------+--------------+----------------------------------+</span><br><span class="line">| event_time          | user_host                 | thread_id | server_id | command_type | argument                         |</span><br><span class="line">+---------------------+---------------------------+-----------+-----------+--------------+----------------------------------+</span><br><span class="line">| 2017-07-06 12:32:05 | root[root] @ localhost [] |         1 |         1 | Query        | show variables like &#39;general%&#39;   |</span><br><span class="line">| 2017-07-06 12:32:28 | root[root] @ localhost [] |         1 |         1 | Query        | show variables like &#39;log_output&#39; |</span><br><span class="line">| 2017-07-06 12:32:41 | root[root] @ localhost [] |         1 |         1 | Query        | select * from MyDB.test          |</span><br><span class="line">| 2017-07-06 12:34:36 | [root] @ localhost []     |         3 |         1 | Connect      | root@localhost on                |</span><br><span class="line">| 2017-07-06 12:34:36 | root[root] @ localhost [] |         3 |         1 | Query        | KILL QUERY 1                     |</span><br><span class="line">| 2017-07-06 12:34:36 | root[root] @ localhost [] |         3 |         1 | Quit         |                                  |</span><br><span class="line">| 2017-07-06 12:34:51 | root[root] @ localhost [] |         1 |         1 | Query        | select * from mysql.general_log  |</span><br><span class="line">+---------------------+---------------------------+-----------+-----------+--------------+----------------------------------+</span><br><span class="line">7 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-查询日志的归档"><a href="#2-3-查询日志的归档" class="headerlink" title="2.3 查询日志的归档"></a>2.3 查询日志的归档</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; system mv &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;DB-Server.log  &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;DB-Server.log.20170706</span><br><span class="line"></span><br><span class="line">mysql&gt; system mysqladmin flush-logs -p</span><br><span class="line"></span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure>

<p>或者你在shell中执行下面命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@DB-Server mysql]# mv &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;DB-Server.log  &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;DB-Server.log.20170706</span><br><span class="line"></span><br><span class="line">[root@DB-Server mysql]# mysqladmin flush-logs -p</span><br><span class="line"></span><br><span class="line">Enter password:</span><br></pre></td></tr></table></figure>

<h1 id="3-慢查询日志"><a href="#3-慢查询日志" class="headerlink" title="3 慢查询日志"></a>3 慢查询日志</h1><p>慢查询会导致CPU，IOPS，内存消耗过高。当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。 开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。</p>
<p>慢查询日志记录的慢查询不仅仅是执行比较慢的SELECT语句，还有INSERT，DELETE，UPDATE，CALL等DML操作，只要超过了指定时间，都可以称为”慢查询”，被记录到慢查询日志中。</p>
<p>默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。</p>
<h2 id="3-1-慢查询日志配置相关"><a href="#3-1-慢查询日志配置相关" class="headerlink" title="3.1 慢查询日志配置相关"></a>3.1 慢查询日志配置相关</h2><h3 id="3-1-1-查看配置"><a href="#3-1-1-查看配置" class="headerlink" title="3.1.1 查看配置"></a>3.1.1 查看配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%slow%&quot; or variables like &quot;%log_queries_not_using_indexes%&quot;;</span><br><span class="line">+-------------------------------+-------------------------------------------------+</span><br><span class="line">| Variable_name                 | Value                                           |</span><br><span class="line">+-------------------------------+-------------------------------------------------+</span><br><span class="line">| log_slow_admin_statements     | OFF                                             |</span><br><span class="line">| log_slow_slave_statements     | OFF                                             |</span><br><span class="line">| slow_launch_time              | 2                                               |</span><br><span class="line">| slow_query_log                | OFF                                             |</span><br><span class="line">| slow_query_log_file           | &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;iz2zeaf3cg1099kiidi06mz-slow.log |</span><br><span class="line">| log_queries_not_using_indexes | ON                                              |</span><br><span class="line">+-------------------------------+-------------------------------------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>其中</p>
<ul>
<li>slow_query_log：慢查询开关，表示是否打开慢查询日志</li>
<li>long_query_time：慢查询指定时间设置，表示”多长时间的查询”被认定为”慢查询”，单位是秒(s)，默认是10s，即超过10s的查询都被认定为慢查询。</li>
<li>log_queries_not_using_indexes：表示如果运行的SQL语句没有使用到索引，是否也被当作慢查询语句记录到慢查询记录中，OFF表示不记录，ON表示记录。</li>
<li>如果开启了查询日志，参数log_output控制着查询日志的存储方式，log_output可以设置为以下4种值:<ol>
<li>FILE : 表示日志存储在文件中</li>
<li>TABLE : 表示日志存储在mysql库中的general_log表中</li>
<li>FILE, TABLE : 表示将日志同时存储在文件和general_log表中，改值会徒增很多IO压力，一般不会这样设置</li>
<li>NONE : 表示不记录日志，即使general_log设置为ON， 如果log_output设置为NONE，也不会记录查询日志</li>
</ol>
</li>
<li>slow_query_log_file：当使用文件存储慢查询日志时(log_output设置为”FILE”或者”FILE,TABLE”时)，制定慢查询日志存储在哪个文件中，默认的文件名是”主机名-slow.log”，存储目录为数据目录</li>
<li>log_throttle_queries_not_using_indexes: MySQL5.6.5版本新引入的参数，用来限制没有使用索引的语句每分钟记录到慢查询日志中的次数。在生产环境中，有可能有很多没有使用索引的语句，可能会导致慢查询日志快速增长。</li>
</ul>
<blockquote>
<p>log_output不仅控制查询日志的输出，也控制着慢查询日志的输出，即: log_output设置为FILE，就表示查询日志和慢查询日志都存放在文件中，设置为TABLE，查询日志和慢查询日志都存放在mysql库中的general_log表中</p>
</blockquote>
<h3 id="3-1-2-开启或关闭慢查询日志"><a href="#3-1-2-开启或关闭慢查询日志" class="headerlink" title="3.1.2 开启或关闭慢查询日志"></a>3.1.2 开启或关闭慢查询日志</h3><ul>
<li>方法1: 在配置文件中设置(不推荐)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#可以在my.cnf里添加,1开启（0关闭）,当然了,这样要重启才能生效,有点多余了</span><br><span class="line">slow_query_log&#x3D;1</span><br></pre></td></tr></table></figure>

<p>然后重启MySQL实例</p>
<ul>
<li>方法2 : 通过命令设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#也可以设置变量那样更改,ON开启（OFF关闭）,即时生效,不用重启,首选当然是这样的了</span><br><span class="line">mysql&gt; set global slow_query_log&#x3D;&#39;ON&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 设置慢查询时间</span><br><span class="line">mysql&gt; set global long_query_time&#x3D;0.05;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 关闭慢查询</span><br><span class="line">mysql&gt; set global slow_query_log&#x3D;&#39;OFF&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过该方式设置，MySQL实例重启后，相关配置又恢复到默认值。如果只是短暂时间内使用，推荐使用命令行方式</p>
</blockquote>
<blockquote>
<p>设置long_query_time这个阈值之后，MySQL数据库会记录运行时间超过该值的所有SQL语句，但对于运行时间正好等于 long_query_time 的情况，并不会被记录下。可以设置 long_query_time为0来捕获所有的查询</p>
</blockquote>
<h3 id="3-1-3-查看当前有多少条慢日志"><a href="#3-1-3-查看当前有多少条慢日志" class="headerlink" title="3.1.3 查看当前有多少条慢日志"></a>3.1.3 查看当前有多少条慢日志</h3><p>如果你想查询有多少条慢查询记录，可以使用系统变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like &#39;%slow_queries%&#39;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Slow_queries  | 0     |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; &#96;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-慢查询日志分析工具pt-query-digest"><a href="#3-2-慢查询日志分析工具pt-query-digest" class="headerlink" title="3.2 慢查询日志分析工具pt-query-digest"></a>3.2 慢查询日志分析工具pt-query-digest</h2><h3 id="3-2-1-pt-query-digest的使用"><a href="#3-2-1-pt-query-digest的使用" class="headerlink" title="3.2.1 pt-query-digest的使用"></a>3.2.1 pt-query-digest的使用</h3><p>pt-query-digest 是分析MySQL查询日志最有力的工具，该工具功能强大，它可以分析binlog，Generallog，slowlog，也可以通过show processlist或者通过 tcpdump 抓取的MySQL协议数据来进行分析，比 mysqldumpslow 更具体，更完善。</p>
<p>下载安装 <a href="https://www.percona.com/downloads/percona-toolkit/LATEST/" target="_blank" rel="noopener">https://www.percona.com/downloads/percona-toolkit/LATEST/</a></p>
<p>在windows下，下载tar.gz包，解压之后，使用perl命令运行</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9f38776eb1af0452f182405bcc051088b47.png" alt=""></p>
<p>其命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pt-query-digest [OPTIONS] [FILES] [DSN]</span><br><span class="line">--create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span><br><span class="line">--create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span><br><span class="line">--filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span><br><span class="line">--limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span><br><span class="line">--host  mysql服务器地址</span><br><span class="line">--user  mysql用户名</span><br><span class="line">--password  mysql用户密码</span><br><span class="line">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span><br><span class="line">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span><br><span class="line">--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span><br><span class="line">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span><br><span class="line">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-pt-query-digest的结果"><a href="#3-2-2-pt-query-digest的结果" class="headerlink" title="3.2.2 pt-query-digest的结果"></a>3.2.2 pt-query-digest的结果</h3><p>输出结果分为三部分</p>
<ol>
<li>总体统计结果</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 该工具执行日志分析的用户时间，系统时间，物理内存占用大小，虚拟内存占用大小</span><br><span class="line"># 343ms user time, 78ms system time, 0 rss, 0 vsz</span><br><span class="line"># 工具执行时间</span><br><span class="line"># Current date: Thu Mar 29 15:51:38 2018</span><br><span class="line"># 运行分析工具的主机名</span><br><span class="line"># Hostname: NB2015041602</span><br><span class="line"># 被分析的文件名</span><br><span class="line"># Files: &#x2F;d&#x2F;xampp&#x2F;mysql&#x2F;data&#x2F;NB2015041602-slow.log</span><br><span class="line"># 语句总数量，唯一的语句数量，QPS，并发数</span><br><span class="line"># Overall: 5 total, 3 unique, 0.00 QPS, 0.05x concurrency ________________</span><br><span class="line"># 日志记录的时间范围</span><br><span class="line"># Time range: 2018-03-28 14:02:06 to 14:22:10</span><br><span class="line"># 属性               总计      最小    最大    平均    95%  标准    中等</span><br><span class="line"># Attribute          total     min     max     avg     95%  stddev  median</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;     &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># 语句执行时间</span><br><span class="line"># Exec time            60s     10s     17s     12s     17s      3s     11s</span><br><span class="line"># 锁占用时间</span><br><span class="line"># Lock time            1ms       0   500us   200us   490us   240us       0</span><br><span class="line"># 发送到客户端的行数</span><br><span class="line"># Rows sent             50      10      10      10      10       0      10</span><br><span class="line"># select语句扫描行数</span><br><span class="line"># Rows examine     629.99k  45.43k 146.14k 126.00k 143.37k  39.57k 143.37k</span><br><span class="line"># 查询的字符数</span><br><span class="line"># Query size         2.81k     235   1.36k  575.40   1.33k  445.36  234.30</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询分组统计结果</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># rank：所有语句的排序，默认按照查询时间降序排序，通过--order-by指定</span><br><span class="line"># # query id：语句的id，（去掉多余空格和文本字符，计算hash值）</span><br><span class="line"># response：总的响应时间</span><br><span class="line"># time：该查询在本次分析中总的时间占比</span><br><span class="line"># calls：执行次数，即本次分析总共有多少条这种类型的查询语句</span><br><span class="line"># r&#x2F;call：平均每次执行的响应时间</span><br><span class="line"># v&#x2F;m：响应时间variance-to-mean的比率</span><br><span class="line"># item：查询对象</span><br><span class="line"></span><br><span class="line"># Profile</span><br><span class="line"># Rank Query ID           Response time Calls R&#x2F;Call  V&#x2F;M   Item</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">#    1 0x96112A601F7BCCC0 32.9042 55.0%     3 10.9681  0.01 SELECT affiliatemerchant_list user_list</span><br><span class="line">#    2 0x70885F9703A0E38D 17.2162 28.8%     1 17.2162  0.00 SELECT normalmerchant merchant_mapping normalmerchant_addinfo merchant_search_filter affiliatemerchant_list user_list</span><br><span class="line">#    3 0x43D8527285567FC4  9.7367 16.3%     1  9.7367  0.00 SELECT affiliatemerchant_list user_list affiliatemerchant_list user_list</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>每一种查询的详细统计结果</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># id：查询的id号，和上面的query id对应</span><br><span class="line"># # databases：数据库名</span><br><span class="line"># users：各个用户执行的次数（占比）</span><br><span class="line"># query_time_distribution：查询时间分布，长短体现区间占比</span><br><span class="line"># tables：查询中设计到的表</span><br><span class="line"># explain：sql语句</span><br><span class="line"></span><br><span class="line"># Query 1: 0.00 QPS, 0.03x concurrency, ID 0x96112A601F7BCCC0 at byte 2647</span><br><span class="line"># This item is included in the report because it matches --limit.</span><br><span class="line"># Scores: V&#x2F;M &#x3D; 0.01</span><br><span class="line"># Time range: 2018-03-28 14:03:31 to 14:19:54</span><br><span class="line"># Attribute    pct   total     min     max     avg     95%  stddev  median</span><br><span class="line"># &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Count         60       3</span><br><span class="line"># Exec time     54     33s     11s     11s     11s     11s   243ms     11s</span><br><span class="line"># Lock time     50   500us       0   500us   166us   490us   231us       0</span><br><span class="line"># Rows sent     60      30      10      10      10      10       0      10</span><br><span class="line"># Rows examine  69 438.42k 146.14k 146.14k 146.14k 146.14k       0 146.14k</span><br><span class="line"># Query size    24     707     235     236  235.67  234.30       0  234.30</span><br><span class="line"># String:</span><br><span class="line"># Databases    database_base</span><br><span class="line"># Hosts        localhost</span><br><span class="line"># Users        root</span><br><span class="line"># Query_time distribution</span><br><span class="line">#   1us</span><br><span class="line">#  10us</span><br><span class="line"># 100us</span><br><span class="line">#   1ms</span><br><span class="line">#  10ms</span><br><span class="line"># 100ms</span><br><span class="line">#    1s</span><br><span class="line">#  10s+  ################################################################</span><br><span class="line"># Tables</span><br><span class="line">#    SHOW TABLE STATUS FROM &#96;database_base&#96; LIKE &#39;table_list1&#39;\G</span><br><span class="line">#    SHOW CREATE TABLE &#96;database_base&#96;.&#96;table_list1&#96;\G</span><br><span class="line">#    SHOW TABLE STATUS FROM &#96;database_base&#96; LIKE &#39;user_list&#39;\G</span><br><span class="line">#    SHOW CREATE TABLE &#96;database_base&#96;.&#96;user_list&#96;\G</span><br><span class="line"># EXPLAIN &#x2F;*!50100 PARTITIONS*&#x2F;</span><br><span class="line">select SQL_CALC_FOUND_ROWS al.*, ul.Alias as userName</span><br><span class="line">        FROM table_list1 al</span><br><span class="line">        LEFT JOIN user_list ul ON ul.ID &#x3D; al.UserId</span><br><span class="line">         WHERE TRUE  AND (al.SupportCountrys LIKE &#39;%%&#39;)</span><br><span class="line">         limit 80, 10\G</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-pt-query-digest的命令"><a href="#3-2-3-pt-query-digest的命令" class="headerlink" title="3.2.3 pt-query-digest的命令"></a>3.2.3 pt-query-digest的命令</h3><p>以下是使用pt-query-digest的示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接分析慢查询文件</span><br><span class="line">pt-query-digest  slow.log &gt; slow_report.log</span><br><span class="line"></span><br><span class="line">分析最近12小时内的查询</span><br><span class="line">pt-query-digest  --since&#x3D;12h  slow.log &gt; slow_report2.log</span><br><span class="line"></span><br><span class="line">分析指定时间范围内的查询</span><br><span class="line">pt-query-digest slow.log --since &#39;2017-01-07 09:30:00&#39; --until &#39;2017-01-07 10:00:00&#39;&gt; &gt; slow_report3.log</span><br><span class="line"></span><br><span class="line">分析含有select语句的慢查询</span><br><span class="line">pt-query-digest --filter &#39;$event-&gt;&#123;fingerprint&#125; &#x3D;~ m&#x2F;^select&#x2F;i&#39; slow.log&gt; slow_report4.log</span><br><span class="line"></span><br><span class="line">针对某个用户的慢查询</span><br><span class="line">pt-query-digest --filter &#39;($event-&gt;&#123;user&#125; || &quot;&quot;) &#x3D;~ m&#x2F;^root&#x2F;i&#39; slow.log&gt; slow_report5.log</span><br><span class="line"></span><br><span class="line">查询所有全表扫描或full join的慢查询</span><br><span class="line">pt-query-digest --filter &#39;(($event-&gt;&#123;Full_scan&#125; || &quot;&quot;) eq &quot;yes&quot;) ||(($event-&gt;&#123;Full_join&#125; || &quot;&quot;) eq &quot;yes&quot;)&#39; slow.log&gt; slow_report6.log</span><br><span class="line"></span><br><span class="line">把查询保存到query_review表</span><br><span class="line">pt-query-digest --user&#x3D;root –password&#x3D;abc123 --review  h&#x3D;localhost,D&#x3D;test,t&#x3D;query_review--create-review-table  slow.log</span><br><span class="line"></span><br><span class="line">把查询保存到query_history表</span><br><span class="line">pt-query-digest  --user&#x3D;root –password&#x3D;abc123 --review  h&#x3D;localhost,D&#x3D;test,t&#x3D;query_history--create-review-table  slow.log_0001</span><br><span class="line">pt-query-digest  --user&#x3D;root –password&#x3D;abc123 --review  h&#x3D;localhost,D&#x3D;test,t&#x3D;query_history--create-review-table  slow.log_0002</span><br><span class="line"></span><br><span class="line">通过tcpdump抓取的tcp协议数据，然后分析</span><br><span class="line">tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &gt; mysql.tcp.txt</span><br><span class="line">pt-query-digest --type tcpdump mysql.tcp.txt&gt; slow_report9.log</span><br><span class="line"></span><br><span class="line">分析biglog</span><br><span class="line">mysqlbinlog mysql-bin.000093 &gt; mysql-bin000093.sql</span><br><span class="line">pt-query-digest  --type&#x3D;binlog  mysql-bin000093.sql &gt; slow_report10.log</span><br><span class="line"></span><br><span class="line">分析general log</span><br><span class="line">pt-query-digest  --type&#x3D;genlog  localhost.log &gt; slow_report11.log</span><br></pre></td></tr></table></figure>

<p>该工具可以将查询的剖析报告打印出来，可以分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间，次数，占比等，可以借助分析结果找出问题进行优化。</p>
<h2 id="3-3-慢查询日志分析工具mysqldumpslow"><a href="#3-3-慢查询日志分析工具mysqldumpslow" class="headerlink" title="3.3 慢查询日志分析工具mysqldumpslow"></a>3.3 慢查询日志分析工具mysqldumpslow</h2><p>mysqldumpslow是mysql自身提供的日志分析工具，一般在mysql的bin目录下</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4485cce5b262eea9f252ec10f4ce6b93f8b.png" alt=""></p>
<p>帮助信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ mysqldumpslow.pl --help</span><br><span class="line">Usage: mysqldumpslow [ OPTS... ] [ LOGS... ]</span><br><span class="line"></span><br><span class="line">Parse and summarize the MySQL slow query log. Options are</span><br><span class="line"></span><br><span class="line">  --verbose    verbose</span><br><span class="line">  --debug      debug</span><br><span class="line">  --help       write this text to standard output</span><br><span class="line"></span><br><span class="line">  -v           verbose</span><br><span class="line">  -d           debug</span><br><span class="line"></span><br><span class="line"> -s, 是表示按照何种方式排序</span><br><span class="line">    c: 访问计数</span><br><span class="line"></span><br><span class="line">    l: 锁定时间</span><br><span class="line"></span><br><span class="line">    r: 返回记录</span><br><span class="line"></span><br><span class="line">    t: 查询时间</span><br><span class="line"></span><br><span class="line">    al:平均锁定时间</span><br><span class="line"></span><br><span class="line">    ar:平均返回记录数</span><br><span class="line"></span><br><span class="line">    at:平均查询时间</span><br><span class="line"></span><br><span class="line">-t, 是top n的意思，即为返回前面多少条的数据；</span><br><span class="line">-g, 后边可以写一个正则匹配模式，大小写不敏感的；</span><br><span class="line"></span><br><span class="line">比如:</span><br><span class="line">得到返回记录集最多的10个SQL。</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;database&#x2F;mysql&#x2F;mysql06_slow.log</span><br><span class="line"></span><br><span class="line">得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 &#x2F;database&#x2F;mysql&#x2F;mysql06_slow.log</span><br><span class="line"></span><br><span class="line">得到按照时间排序的前10条里面含有左连接的查询语句。</span><br><span class="line">mysqldumpslow -s t -t 10 -g “left join” &#x2F;database&#x2F;mysql&#x2F;mysql06_slow.log</span><br><span class="line"></span><br><span class="line">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。</span><br><span class="line">mysqldumpslow -s r -t 20 &#x2F;mysqldata&#x2F;mysql&#x2F;mysql06-slow.log | more</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不能执行，可以先安装perl，然后通过perl mysqldumpslow xxx.log</p>
</blockquote>
<h1 id="4-事务日志"><a href="#4-事务日志" class="headerlink" title="4 事务日志"></a>4 事务日志</h1><p>事务日志包括redo log和undo log，在阐述二者之前，我们必须明确，redo log是InnoDB引擎的一类日志，而不是MySQL服务端的日志。它是InnoDB实现事务的重要机制。</p>
<p>具体内容详见本博客文章《【InnoDB详解四】redo log和undo log》</p>
<h1 id="5-二进制日志"><a href="#5-二进制日志" class="headerlink" title="5 二进制日志"></a>5 二进制日志</h1><p>MySQL的二进制日志（binary log，简称binlog）是一个二进制文件，主要记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的所有操作。二进制日志（binary log）中记录了对MySQL数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其它额外信息，但是它不记录SELECT、SHOW等那些不修改数据的SQL语句。</p>
<p>它和InnoDB的redo log很像，但注意redo log是InnoDB的，是引擎级别的，binlog是MySQL级别的，换言之，不论MySQL使用什么存储引擎，它都会产生binlog。</p>
<h2 id="5-1-binlog的作用"><a href="#5-1-binlog的作用" class="headerlink" title="5.1 binlog的作用"></a>5.1 binlog的作用</h2><ol>
<li><p>恢复（recovery）：某些数据的恢复需要二进制日志。例如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行point-in-time的恢复。</p>
</li>
<li><p>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的MySQL数据库（一般称为slave或者standby）与一台MySQL数据库（一般称为master或者primary）进行实时同步。</p>
</li>
<li><p>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</p>
</li>
</ol>
<p>除了上面介绍的几个作用外，binlog对于事务存储引擎的崩溃恢复也有非常重要的作用。</p>
<p>在开启binlog的情况下，为了保证binlog与redo的一致性，MySQL将采用事务的两阶段提交协议。当MySQL系统发生崩溃时，事务在存储引擎内部的状态可能为prepared和commit两种。对于prepared状态的事务，是进行提交操作还是进行回滚操作，这时需要参考binlog：如果事务在binlog中存在，那么将其提交；如果不在binlog中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p>
<h2 id="5-2-binlog的存储"><a href="#5-2-binlog的存储" class="headerlink" title="5.2 binlog的存储"></a>5.2 binlog的存储</h2><p>为了管理所有的binlog文件，MySQL额外创建了一个base-name.index文件，它按顺序记录了MySQL使用的所有binlog文件。如果你想自定义index文件的名称，可以设置log_bin_index=file参数。千万不要在mysqld运行的时候手动修改index文件的内容，这样会使mysqld产生混乱。</p>
<h2 id="5-3-binlog的开启"><a href="#5-3-binlog的开启" class="headerlink" title="5.3 binlog的开启"></a>5.3 binlog的开启</h2><p>binlog默认关闭，如果想开启binlog，可以在MySQL配置文件中通过配置参数<code>log-bin = [base-name]</code>启动二进制日志。如果不指定base-name，则默认以主机名为二进制日志的文件名，并以自增的数字作为后缀，例如<code>mysql-bin.000001</code>，所在目录为数据库所在目录（datadir）。</p>
<p>顺序说一下，对于二进制文件当满足下面三种情况时会创建新的文件，文件后缀会自增。</p>
<ol>
<li>文件大小达到<code>max_binlog_size</code>参数设置值时。</li>
<li>执行flush logs命令。</li>
<li>重启mysqld进程。</li>
</ol>
<blockquote>
<p>你可能会有顾虑，当文件后缀从000001增长到999999时会怎样？有网友测试过，当文件达到999999时又会回到000001，并不会有什么异常。</p>
</blockquote>
<h2 id="5-4-binlog格式"><a href="#5-4-binlog格式" class="headerlink" title="5.4 binlog格式"></a>5.4 binlog格式</h2><p>binlog格式分为: STATEMENT、ROW和MIXED三种，详情如下:</p>
<ol>
<li><p>STATEMENT</p>
<ul>
<li>STATEMENT格式的binlog记录的是数据库上执行的原生SQL语句。</li>
<li>这种方式有好处：<ul>
<li>好处就是相当简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的SQL语句，在从服务器上执行同样的语句。</li>
<li>另一个好处是二进制日志里的时间更加紧凑，所以相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间。并且通过mysqlbinlog工具容易读懂其中的内容。</li>
</ul>
</li>
<li>这种方式也有坏处：<ul>
<li>坏处就是同一条SQL在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。<ul>
<li>即便如此，还存在着一些无法被正确复制的SQL。例如，使用INSERT INTO TB1 VALUE(CUURENT_DATE())这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化。存储过程和触发器在使用基于语句的复制模式时也可能存在问题。</li>
<li>另外一个问题就是基于语句的复制必须是串行化的。这要求大量特殊的代码，配置，例如InnoDB的next-key锁等。并不是所有的存储引擎都支持基于语句的复制。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ROW</p>
<ul>
<li>从MySQL5.1开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中。</li>
<li>这种方式有好处：<ul>
<li>最大的好处是可以正确地复制每一行数据。一些语句可以被更加有效地复制</li>
<li>另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的SQL构造、触发器、存储过程等都能正确执行。</li>
</ul>
</li>
<li>这种方式也有坏处：<ul>
<li>主要的缺点就是二进制日志可能会很大，而且不直观，所以，你不能使用mysqlbinlog来查看二进制日志。也无法通过看二进制日志判断当前执行到那一条SQL语句了。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>现在对于ROW格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点。并且由于ROW格式记录行数据，所以可以基于这种模式做一些DBA工具，比如数据恢复，不同数据库之间数据同步等。</p>
</blockquote>
<ol start="3">
<li><p>MIXED</p>
<ul>
<li>MIXED也是MySQL默认使用的二进制日志记录方式，但MIXED格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到UUID()、USER()、CURRENT_USER()、ROW_COUNT()等无法确定的函数。</li>
</ul>
</li>
</ol>
<h1 id="6-中继日志"><a href="#6-中继日志" class="headerlink" title="6 中继日志"></a>6 中继日志</h1><p>relay log是复制过程中产生的日志，很多方面都跟binary log差不多，区别是: relay log是从库服务器I/O线程将<strong>主库服务器</strong>的二进制日志读取过来记录到<strong>从库服务器</strong>本地文件，然后<strong>从库</strong>的SQL线程会读取relay-log日志的内容并应用到<strong>从库服务器</strong>上。</p>
<h2 id="6-1-中继日志参数"><a href="#6-1-中继日志参数" class="headerlink" title="6.1 中继日志参数"></a>6.1 中继日志参数</h2><ul>
<li><p>max_relay_log_size<br>标记relay log 允许的最大值，如果该值为0，则默认值为max_binlog_size(1G)；如果不为0，则max_relay_log_size则为最大的relay_log文件大小；</p>
</li>
<li><p>relay_log<br>定义relay_log的位置和名称，如果值为空，则默认位置在数据文件的目录，文件名为host_name-relay-bin.nnnnnn（By default, relay log file names have the form host_name-relay-bin.nnnnnn in the data directory）；</p>
</li>
<li><p>relay_log_index<br>同relay_log，定义relay_log的位置和名称；</p>
</li>
<li><p>relay_log_info_file<br>设置<code>http://relay-log.info</code>的位置和名称（<a href="http://relay-log.info记录MASTER的binary_log的恢复位置和relay_log的位置）" target="_blank" rel="noopener">http://relay-log.info记录MASTER的binary_log的恢复位置和relay_log的位置）</a></p>
</li>
<li><p>relay_log_purge<br>是否自动清空不再需要中继日志时。默认值为1(启用)。</p>
</li>
<li><p>relay_log_recovery<br>当slave从库宕机后，假如relay-log损坏了，导致一部分中继日志没有处理，则自动放弃所有未执行的relay-log，并且重新从master上获取日志，这样就保证了relay-log的完整性。默认情况下该功能是关闭的，将relay_log_recovery的值设置为 1时，可在slave从库上开启该功能，建议开启。</p>
</li>
<li><p>relay_log_space_limit<br>防止中继日志写满磁盘，这里设置中继日志最大限额。但此设置存在主库崩溃，从库中继日志不全的情况，不到万不得已，不推荐使用；</p>
</li>
<li><p>sync_relay_log<br>这个参数和sync_binlog是一样的，当设置为1时，slave的I/O线程每次接收到master发送过来的binlog日志都要写入系统缓冲区，然后刷入relay log中继日志里，这样是最安全的，因为在崩溃的时候，你最多会丢失一个事务，但会造成磁盘的大量I/O。当设置为0时，并不是马上就刷入中继日志里，而是由操作系统决定何时来写入，虽然安全性降低了，但减少了大量的磁盘I/O操作。这个值默认是0，可动态修改。</p>
</li>
<li><p>sync_relay_log_info<br>这个参数和sync_relay_log参数一样，当设置为1时，slave的I/O线程每次接收到master发送过来的binlog日志都要写入系统缓冲区，然后刷入<code>http://relay-log.info</code>里，这样是最安全的，因为在崩溃的时候，你最多会丢失一个事务，但会造成磁盘的大量I/O。当设置为0时，并不是马上就刷入<code>http://relay-log.info</code> 里，而是由操作系统决定何时来写入，虽然安全性降低了，但减少了大量的磁盘I/O操作。这个值默认是0，可动态修改。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/27/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E5%9B%9B%E3%80%91redo-log%E5%92%8Cundo-log/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/27/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E5%9B%9B%E3%80%91redo-log%E5%92%8Cundo-log/" itemprop="url">【InnoDB详解四】redo log和undo log</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-27T23:36:33+08:00">
                2020-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/09/27/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E5%9B%9B%E3%80%91redo-log%E5%92%8Cundo-log/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/09/27/【InnoDB详解四】redo-log和undo-log/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  12.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  45
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-redo-log"><a href="#1-redo-log" class="headerlink" title="1 redo log"></a>1 redo log</h1><p>首先我们先明确一下InnoDB的修改数据的基本流程，当我们想要修改DB上某一行数据的时候，InnoDB是把数据从磁盘读取到内存的缓冲池上进行修改。这个时候数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为脏页。</p>
<p>InnoDB对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，<strong>这样会产生海量的IO操作，严重影响InnoDB的处理性能</strong>。对于此，InnoDB有一套完善的处理策略，与我们这次主题关系不大，表过不提。既然脏页与磁盘中的数据存在差异，那么如果在这期间DB出现故障就会造成数据的丢失（持久性问题产生了）。为了解决这个问题，redo log就应运而生了。</p>
<h2 id="1-1-redo-log的特点"><a href="#1-1-redo-log的特点" class="headerlink" title="1.1 redo log的特点"></a>1.1 redo log的特点</h2><ul>
<li><p>redo log在<strong>数据库重启恢复的时候被使用</strong>。</p>
</li>
<li><p>redo日志占用的空间非常小，存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的。</p>
</li>
<li><p>redo log属于物理日志，他可以将已提交事务修改的记录记录下来，即某个表空间中某页的某个偏移量的值更新为多少。因为其属于<strong>物理日志</strong>的特性，恢复速度远快于逻辑日志。而我们下文即将介绍的binlog和undo log就属于典型的逻辑日志。</p>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-e43816535e5b18dcd0b5bb54be94f21344a.png" alt=""></p>
<ul>
<li><p>redo日志不止记录索引插入/更新记录等操作，还有执行这个操作影响到的其他动作，如页分裂新增目录项记录，修改页信息等对数据页做的任何修改等等。</p>
</li>
<li><p>redo日志记录的是物理页的情况，它具有幂等性，因此记录日志的方式极其简练。幂等性的意思是多次操作前后状态是一样的，例如新插入一行后又删除该行，前后状态没有变化。</p>
</li>
<li><p>redo日志是顺序写入磁盘的，在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO，这比随机IO的性能要高得多。</p>
</li>
</ul>
<h2 id="1-2-redo-log的工作机制简述"><a href="#1-2-redo-log的工作机制简述" class="headerlink" title="1.2 redo log的工作机制简述"></a>1.2 redo log的工作机制简述</h2><p>redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的，并且事务的记录是顺序追加的，性能非常高(磁盘的<strong>顺序写</strong>性能比内存的写性能差不了太多)。</p>
<p>InnoDB使用日志+缓存的策略来减少提交事务时的开销。因为日志中已经记录了事务，所以就无须为了保证持久性而在每个事务提交时都把缓冲池的脏数据刷新(flush)到磁盘中。</p>
<p>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机IO。InnoDB假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p>
<p>InnoDB用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。</p>
<p>为了确保每次日志数据都能写入到磁盘的事务日志文件中，在每次将log buffer中的日志写入日志文件的过程中都会调用一次操作系统的fsync操作(即fsync()系统调用)。</p>
<p>因为MySQL是工作在用户空间的，MySQL的log buffer处于用户空间的内存中。要写入到磁盘上的log file中(也就是redo的ib_logfileN文件，undo的share tablespace或.ibd文件，后面讲undo log时会讲到)，中间还要经过操作系统内核空间的os buffer，调用fsync()的作用就是将OS buffer中的日志刷到磁盘上的log file中。</p>
<p>也就是说，从redo log buffer写日志到磁盘的redo log file中，过程如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c1152ce0028d1f668da73cbc4b28b1794a3.png" alt=""></p>
<h2 id="1-3-redo-log的数据结构（log-block）"><a href="#1-3-redo-log的数据结构（log-block）" class="headerlink" title="1.3 redo log的数据结构（log block）"></a>1.3 redo log的数据结构（log block）</h2><p>InnoDB存储引擎中，redo log以块为单位进行存储的，每个块占512字节（同磁盘扇区大小一致，可以保证块的写入是原子操作。），这称为redo log block。<strong>所以不管是log buffer中还是os buffer中以及redo log file on disk中，都是这样以512字节的块存储的</strong>。</p>
<p>每个redo log block由3部分组成：header、tailer和body。其中日志块头header占用12字节，日志块尾tailer占用8字节，所以每个redo log block的日志主体部分body只有512-12-8=492字节。</p>
<p>因为redo log记录的是数据页的变化，当一个数据页产生的变化需要使用超过492字节的redo log来记录，那么就会使用多个redo log block来记录该数据页的变化。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c6ca3a15d7c42bf5fa449dbe802b692605b.png" alt=""></p>
<p>上面所说的是一个日志块的内容，在redo log buffer或者redo log file on disk中，由很多log block组成。如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e7ea51e63422a5719c70835176b989e073e.png" alt=""></p>
<h3 id="1-3-1-block-header"><a href="#1-3-1-block-header" class="headerlink" title="1.3.1 block header"></a>1.3.1 block header</h3><p>header包含4部分：</p>
<ul>
<li>log_block_hdr_no：(4字节)该日志块在redo log buffer/os buffer/log file中的位置ID。log buffer/redo log file on disk是由log block组成，在log buffer内部就好似一个数组，因此LOG_BLOCK HDR_NO用来标记这个数组中的位置。其是递增并且循环使用的。</li>
<li>log_block_hdr_data_len：(2字节)该log block中<strong>已记录</strong>的log大小。写满该log block时为0x200，表示512字节。</li>
<li>log_block_first_rec_group：(2字节)该log block中新的数据页对应的log的开始偏移位置。</li>
<li>lock_block_checkpoint_no：(4字节)写入checkpoint信息的位置。</li>
</ul>
<p>关于log block块头的第三部分<code>log_block_first_rec_group</code>，因为有时候一个数据页产生的日志量<strong>超出了一个日志块</strong>，这时需要用多个日志块来记录该页的相关日志。</p>
<p>例如，某一T1事务产生了792个字节的日志量，那么需要占用两个日志块，第一个日志块占用492字节，第二个日志块需要占用270个字节，那么对于第二个日志块来说，它记录的关于下一个数据页B的第一个log的开始位置就是282字节(270+12)。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fa477acf42ce4e51969e8127c867d22560e.png" alt=""></p>
<p>如果<code>log_block_first_rec_group</code>的值和<code>log_block_hdr_data_len</code>相等，则说明该log block中没有新开始记录下一个数据页的日志，即<strong>表示该日志块用来延续前一个日志块</strong>。</p>
<h3 id="1-3-2-block-tailer"><a href="#1-3-2-block-tailer" class="headerlink" title="1.3.2 block tailer"></a>1.3.2 block tailer</h3><p>tailer只有一个部分：</p>
<ul>
<li><code>log_block_trl_no</code> ，该值和块头的 <code>log_block_hdr_no</code> 相等。</li>
</ul>
<h3 id="1-3-3-block-body"><a href="#1-3-3-block-body" class="headerlink" title="1.3.3 block body"></a>1.3.3 block body</h3><p>因为innodb存储引擎存储数据的单元是页(和SQL Server中一样)，所以redo log也是基于页的格式来存放的。默认情况下，innodb的页大小是16KB(由<code>innodb_page_size</code>变量控制)，一个页内可以存放非常多的log block(每个512字节)，而log block中记录的又是数据页的变化。</p>
<p>其中log block中492字节的部分是block body，<strong>block body存储了很多条的redo日志，每条redo日志的格式分为4部分</strong>：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-952af4bd6ec616062dc8b8ce0a9ec050c1d.png" alt=""></p>
<ul>
<li><p>type：占用1个字节，8bit，其中高位的一个bit另做它用，剩下7个bit表示redo log的日志类型，其值有很多，在MySQL 5.7.21这个版本中，InnoDB一共为redo日志设计了53种不同的类型，下文将详细分析。</p>
</li>
<li><p>space ID：表示表空间的ID，采用压缩的方式后，占用的空间可能小于4字节。</p>
</li>
<li><p>page number：表示页的偏移量，同样是压缩过的。</p>
</li>
<li><p>data：表示每个redo日志的数据部分，恢复时会调用相应的函数进行解析。例如insert语句和delete语句写入redo log的内容是不一样的。</p>
</li>
</ul>
<h3 id="1-3-4-redo-log的类型"><a href="#1-3-4-redo-log的类型" class="headerlink" title="1.3.4 redo log的类型"></a>1.3.4 redo log的类型</h3><p>type字段的低位7个bit用来区分redo log的日志类型，我们来看下简单的场景和复杂的场景下，redo日志的不同类型。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c6af77a689edc02a3cafabd97c02942128c.png" alt=""></p>
<h4 id="1-3-4-1-简单的redo日志类型"><a href="#1-3-4-1-简单的redo日志类型" class="headerlink" title="1.3.4.1 简单的redo日志类型"></a>1.3.4.1 简单的redo日志类型</h4><p>我们前边介绍InnoDB的记录行格式的时候说过，如果我们没有为某个表显式的定义主键，并且表中也没有定义Unique键，那么InnoDB会自动的为表添加一个称之为row_id的隐藏列作为主键。</p>
<p>这时服务器会在内存中维护一个全局变量，每当向某个包含隐藏的row_id列的表中插入一条记录时，就会把该变量的当前值当作新记录的row_id列的值，并且把该变量自增1。</p>
<p>每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为7的页中一个称之为Max Row ID的属性处。</p>
<p>这是Max Row ID的持久化，即Max Row ID每增加256，就持久化一次，如果期间发生了系统宕机，那么重新启动后，服务器会将持久化的最大的Max Row ID取出，并加上256，当做新的Max Row ID。</p>
<blockquote>
<p>比如Max Row ID自增到800的时候，系统已经持久化了Max Row ID的三个值256，512，768。这时，系统崩溃了，重新启动后，系统取出了最新的768，但不能直接从768开始用，为了防止重复，新的Max Row ID=768+256=1024。</p>
</blockquote>
<p>这个Max Row ID属性占用的存储空间是8个字节，当某个事务向某个包含row_id隐藏列的表插入一条记录，并且为该记录分配的row_id值刚好为256的倍数时，就会向系统表空间页号为7的页面的相应偏移量处写入8个字节的值。</p>
<p>但是我们要知道，这个写入实际上是在Buffer Pool中完成的，我们需要为这个页的修改记录一条redo日志，以便在系统奔溃后能将已经提交的该事务对该页面所做的修改恢复出来。这种情况下对页的修改是极其简单的，<strong>redo日志中只需要记录一下页号为7的页面的某个偏移量处修改了几个字节的值，以及具体被修改的内容是啥就好了</strong>。</p>
<p>这种简单的redo日志，InnoDB定义了如下的type的值，来表示对应字节的redo日志的产生。</p>
<ul>
<li>MLOG_1BYTE(type字段对应的⼗进制数字为1)：表示在⻚⾯的某个偏移量处写⼊1个字节的redo⽇志类型。</li>
<li>MLOG_2BYTE(type字段对应的⼗进制数字为2)：表示在⻚⾯的某个偏移量处写⼊2个字节的redo⽇志类型。</li>
<li>MLOG_4BYTE(type字段对应的⼗进制数字为4)：表示在⻚⾯的某个偏移量处写⼊4个字节的redo⽇志类型。</li>
<li>MLOG_8BYTE(type字段对应的⼗进制数字为8)：表示在⻚⾯的某个偏移量处写⼊8个字节的redo⽇志类型。</li>
<li>MLOG_WRITE_STRING(type字段对应的⼗进制数字为30)：表示在⻚⾯的某个偏移量处写⼊⼀串数据。</li>
</ul>
<p>我们上边提到的Max Row ID属性实际占用8个字节的存储空间，所以在修改页面中的该属性时，会记录一条类型为MLOG_8BYTE的redo日志，MLOG_8BYTE的redo日志结构如下所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c32188a1f15479176b8ec9188c67c622f21.png" alt=""></p>
<p>其余MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE类型的redo日志结构和MLOG_8BYTE的类似，只不过具体数据中包含对应个字节的数据罢了。MLOG_WRITE_STRING类型的redo日志表示写入一串数据，但是因为不能确定写入的具体数据占用多少字节，所以需要在日志结构中添加一个len字段：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-554313fb140cc3234089d0f76ff3c927c36.png" alt=""></p>
<blockquote>
<p>其实只要将MLOG_WRITE_STRING类型的redo日志的len字段填充上1、2、4、8这些数字，就可以分别替代MLOG_1BYTE、MLOG_2BYTE、MLOG_4BYTE、MLOG_8BYTE这些类型的redo日志，为啥还要多此一举设计这么多类型呢？还不是因为省空间啊，能不写len字段就不写len字段，省一个字节算一个字节。</p>
</blockquote>
<h4 id="1-3-4-2-复杂的redo日志类型"><a href="#1-3-4-2-复杂的redo日志类型" class="headerlink" title="1.3.4.2 复杂的redo日志类型"></a>1.3.4.2 复杂的redo日志类型</h4><p>有时候执行一条语句会修改非常多的页面，包括系统数据页面（比如上文提到的全局变量Max Row ID的更新）和用户数据页面（用户数据指的就是聚簇索引和二级索引对应的B+树）。</p>
<p>以一条INSERT语句为例，它除了要向B+树的页面中插入数据，也可能更新系统数据Max Row ID的值，不过对于我们用户来说，平时更关心的是语句对B+树所做更新：</p>
<ul>
<li>表中包含多少个索引，一条INSERT语句就可能更新多少棵B+树。</li>
<li>针对某一棵B+树来说，既可能更新叶子节点页面，也可能更新内节点页面，也可能创建新的页面（在该记录插入的叶子节点的剩余空间比较少，不足以存放该记录时，会进行页面的分裂）。</li>
<li>对于B+树上的页来说，新的行被插入，页中的<code>Page Directory</code>的槽信息、<code>Page Header</code>中的各种统计信息，行记录链表的后驱<code>next_record</code>等都要随之更新。</li>
</ul>
<p>画一个简易的示意图就像是这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3371ed59e2f4a43841d84d37c5e6f0d35c5.png" alt=""></p>
<p>说了这么多，就是想表达：把一条记录插入到一个页面时需要更改的地方非常多。这时我们如果使用上边介绍的简单的物理redo日志来记录这些修改时，可以有两种解决方案：</p>
<ul>
<li><p>方案一：在每个修改的地方都记录一条redo日志。</p>
<ul>
<li>也就是如上图所示，有多少个加粗的块，就写多少条物理redo日志。这样子记录redo日志的缺点是显而易见的，因为被修改的地方是在太多了，可能记录的redo日志占用的空间都比整个页面占用的空间都多了。</li>
</ul>
</li>
<li><p>方案二：将整个页面的第一个被修改的字节到最后一个修改的字节之间所有的数据当成是一条物理redo日志中的具体数据。</p>
<ul>
<li>从图中也可以看出来，第一个被修改的字节到最后一个修改的字节之间仍然有许多没有修改过的数据，我们把这些没有修改的数据也加入到redo日志中去岂不是太浪费了。</li>
</ul>
</li>
</ul>
<p>正因为上述两种使用物理redo日志的方式来记录某个页面中做了哪些修改比较浪费，InnoDB的设计者本着勤俭节约的初心，提出了一些新的redo日志类型，比如：</p>
<ul>
<li>MLOG_REC_INSERT(type字段对应的十进制数字为9)：表示插入一条使用非紧凑行格式记录时的redo日志类型（如redundant）</li>
<li>MLOG_COMP_REC_INSERT(type字段对应的十进制数字为38)：表示插入一条使用紧凑行格式记录时的redo日志类型（如compact/dynamic/compressed）</li>
<li>MLOG_COMP_PAGE_CREATE（type字段对应的十进制数字为58）：表示创建一个存储紧凑行格式记录的页面的redo日志类型。</li>
<li>MLOG_COMP_REC_DELET(type字段对应的十进制数字为42)：表示删除一条使用紧凑行格式记录的redo日志类型</li>
<li>MLOG_COMP_LIST_START_DELETE（type字段对应的十进制数字为44）：表示从某条给定记录开始删除页面中的一系列使用紧凑行格式记录的redo日志类型。</li>
<li>MLOG_ZIP_PAGE_COMPRESS（type字段对应的十进制数字为51）：表示压缩一个数据页的redo日志类型。</li>
<li>MLOG_COMP_LIST_END_DELETE（type字段对应的十进制数字为43）：与MLOG_COMP_LIST_START_DELETE类型的redo日志呼应，表示删除一系列记录直到MLOG_COMP_LIST_END_DELETE类型的redo日志对应的记录为止。</li>
</ul>
<p>那这些新类型和旧的类型有什么区别呢？如果还是简单的把所有的物理层面的数据变动都记录下来，那岂不是没什么区别？</p>
<p>区别就是，新的日志类型，除了能体现物理层面的变动，还包含了逻辑层面的变动，它主要是搭配系统恢复的函数的来使用的。</p>
<ol>
<li>物理层面：修改的是哪个表空间，哪个页，以及页的偏移量。</li>
<li>逻辑层面：是插入操作还是删除操作；操作对象是行记录还是其他？如果是行记录，那是什么格式的行记录？紧凑的还是非紧凑的。</li>
</ol>
<p>这样有什么好处呢？？我们以插入一条使用紧凑行格式的记录时的redo日志（MLOG_COMP_REC_INSERT）为例，直接看一下这个类型为<code>MLOG_COMP_REC_INSERT</code>的redo日志的结构，橙色部分都是block body：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-eda1ea874ed13e2c18c96c51b3c426d2bac.png" alt=""></p>
<p>这个类型为<code>MLOG_COMP_REC_INSERT</code>的redo日志结构有几个地方需要大家注意：</p>
<ol>
<li>在一个数据页里，行记录都是按照索引列从小到大的顺序排序的。对于二级索引来说，当索引列的值相同时，记录还需要按照主键值进行排序。图中n_uniques的值的含义是在一条记录中，需要几个字段的值才能确保记录的唯一性，这样当插入一条记录时就可以按照记录的前n_uniques个字段进行排序。对于聚簇索引来说，n_uniques的值为主键的列数，对于其他二级索引来说，该值为索引列数+主键列数。这里需要注意的是，唯一二级索引的值可能为NULL，所以该值仍然为索引列数+主键列数。</li>
<li>field1_len ~ fieldn_len代表着该记录若干个字段占用存储空间的大小，需要注意的是，这里不管该字段的类型是固定长度大小的（比如INT），还是可变长度大小（比如VARCHAR(M)）的，该字段占用的大小始终要写入redo日志中。</li>
<li>offset代表的是该记录的前一条记录在页面中的地址。为啥要记录前一条记录的地址呢？这是因为每向数据页插入一条记录，都需要修改该页面中维护的记录链表，每条记录的记录头信息中都包含一个称为next_record的属性，所以在插入新记录时，需要修改前一条记录的next_record属性。</li>
</ol>
<p>很显然这个类型为<code>MLOG_COMP_REC_INSERT</code>的redo日志并没有记录PAGE_N_DIR_SLOTS的值修改为了啥，PAGE_HEAP_TOP的值修改为了啥，PAGE_N_HEAP的值修改为了啥等等这些信息，<strong>而只是把在本页面中插入一条记录所有必备的要素记了下来</strong>，之后系统奔溃重启时，<strong>服务器会调用相关向某个页面插入一条记录的那个函数，而redo日志中的那些数据就可以被当成是调用这个函数所需的参数</strong>，在调用完该函数后，页面中的PAGE_N_DIR_SLOTS、PAGE_HEAP_TOP、PAGE_N_HEAP等等的值也就都被恢复到系统奔溃前的样子了。这就是所谓的逻辑日志的意思。</p>
<p>如下图，分别是insert和delete大致的记录方式。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1c95c4a1e07f6afdf1f7f9bdb9c5cfa80c2.png" alt=""></p>
<h2 id="1-4-redo日志的原子性（Mini-Transaction）"><a href="#1-4-redo日志的原子性（Mini-Transaction）" class="headerlink" title="1.4  redo日志的原子性（Mini-Transaction）"></a>1.4  redo日志的原子性（Mini-Transaction）</h2><p>前文说到执行一条INSERT的SQL语句，InnoDB在向某个B+树中插入新的记录的过程，会产生许多条的redo日志，因为可能涉及页的分裂，各种段的修改、区的统计信息，各种链表的统计信息等等。</p>
<p>我们知道向某个索引对应的B+树中插入一条记录的这个过程必须是原子的，不能说插了一半之后就停止了。在B+树上插入一个新的行，触发的页的分裂，这时新的页面已经分配好了，数据也复制过去了，新的记录也插入到页面中了，可是没有向数据节点中插入一条目录项记录，那么这个插入过程就是不完整的，这样会形成一棵不正确的B+树。</p>
<p>我们知道redo日志是为了在系统奔溃重启时恢复崩溃前的状态，如果在INSERT的过程中只记录了一部分redo日志，那么在系统奔溃重启时会将索引对应的B+树恢复成一种不正确的状态，这是InnoDB设计者们所不能忍受的。</p>
<p>MySQL把这种<strong>不容许分割的，对底层页面中的一次原子操作的过程</strong>称之为一个<strong>Mini-Transaction</strong>，简称mtr，比如上边所说的修改一次Max Row ID的值算是一个Mini-Transaction，向某个索引对应的B+树中插入一条记录的过程也算是一个Mini-Transaction。</p>
<p>一个mtr可能产生单条或者多条redo日志，就像对redo日志进行编组一样，在进行奔溃恢复时这一组redo日志将作为一个不可分割的整体，要么一起恢复，要么都不恢复。</p>
<blockquote>
<p>一个事务可以包含若干条语句，每一条语句其实是由若干个mtr组成，每一个mtr又可以包含若干条redo日志，画个图表示它们的关系就是这样：</p>
</blockquote>
<p><img src="https://oscimg.oschina.net/oscnet/up-391c80e95bda8d4ae7b97e571b2a5a77e33.png" alt=""></p>
<p>那么如何对一个mtr产生的redo日志进行编组呢？这得分情况讨论：</p>
<ol>
<li>有的操作会生成多条redo日志，比如向某个索引对应的B+树中进行一次插入就需要生成许多条redo日志。</li>
<li>有的需要保证原子性的操作只生成一条redo日志，比如更新全局变量Max Row ID属性的操作就只会生成一条redo日志。</li>
</ol>
<h3 id="1-4-1-原子操作生成多条redo日志"><a href="#1-4-1-原子操作生成多条redo日志" class="headerlink" title="1.4.1 原子操作生成多条redo日志"></a>1.4.1 原子操作生成多条redo日志</h3><p><strong>针对第一种情况</strong>，InnoDB定义了一种新的类型（<code>MLOG_MULTI_REC_END</code>，type字段对应的十进制数字为31）的redo log结构：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-020bd4a48f5f5c3000bd25452a3b8c4a5cb.png" alt=""></p>
<p>所以某个需要保证原子性的操作产生的一系列redo日志必须要以一个类型为<code>MLOG_MULTI_REC_END</code>结尾，就像这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b10b12fd333ba38b1faf25732f1669596a2.png" alt=""></p>
<p>这样在系统奔溃重启进行恢复时，只有当解析到类型为MLOG_MULTI_REC_END的redo日志，才认为解析到了一组完整的redo日志，才会进行恢复。否则的话直接放弃前边解析到的不完整部分的redo日志。</p>
<h3 id="1-4-2-原子操作生成单条redo日志"><a href="#1-4-2-原子操作生成单条redo日志" class="headerlink" title="1.4.2 原子操作生成单条redo日志"></a>1.4.2 原子操作生成单条redo日志</h3><p><strong>针对第二种情况</strong>，其实在一条日志后边跟一个类型为MLOG_MULTI_REC_END的redo日志也是可以的，但这比较浪费。</p>
<p>别忘了虽然redo日志的类型比较多，但撑死了也就是几十种，是小于127这个数字的，也就是说我们用7个比特位就足以包括所有的redo日志类型，而type字段其实是占用1个字节8比特位的，也就是说我们可以省出来一个比特位用来表示该需要保证原子性的操作只产生单一的一条redo日志，示意图如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c6af77a689edc02a3cafabd97c02942128c.png" alt=""></p>
<p>如果type字段的第一个比特为为1，代表该需要保证原子性的操作只产生了单一的一条redo日志，否则表示该需要保证原子性的操作产生了一系列的redo日志。</p>
<h2 id="1-5-redo日志的写入"><a href="#1-5-redo日志的写入" class="headerlink" title="1.5 redo日志的写入"></a>1.5 redo日志的写入</h2><p>我们前边说过，InnoDB为了解决磁盘速度过慢的问题而引入了Buffer Pool。同理，写入redo日志时也不能直接直接写到磁盘上，实际上在服务器启动时就向操作系统申请了一大片称之为redo log buffer的连续内存空间，翻译成中文就是redo日志缓冲区，我们也可以简称为log buffer。这片内存空间被划分成若干个连续的redo log block，就像这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3166883a72a3121c950bc3e38a1ad5ac71c.png" alt=""></p>
<p>向log buffer中写入redo日志的过程是顺序的，也就是先往前边的block中写，当该block的空闲空间用完之后再往下一个block中写。当我们想往log buffer中写入redo日志时，第一个遇到的问题就是应该写在哪个block的哪个偏移量处，所以InnoDB特意提供了一个称之为<code>buf_free</code>的全局变量，该变量指明后续写入的redo日志应该写入到log buffer中的哪个位置，如图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-34ddf107ece3e7f268d7097b01a4bc312f8.png" alt=""></p>
<p>我们前边说过一个mtr执行过程中可能产生若干条redo日志，这些redo日志是一个不可分割的组，所以其实并不是每生成一条redo日志，就将其插入到log buffer中，<strong>而是每个mtr运行过程中产生的日志先暂时存到一个地方，当该mtr结束的时候，将过程中产生的一组redo日志再全部复制到log buffer中（所以同一mtr的一组log都是一起连续出现）</strong>。</p>
<p>我们现在假设有两个名为T1、T2的事务，每个事务都包含2个mtr，每个mtr都产生若干个redo log：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-19d955d351169129ad49610058aa3f07fcd.png" alt=""></p>
<p>不同的事务可能是并发执行的，所以T1、T2之间的mtr可能是交替执行的。</p>
<p>每当一个mtr执行完成时，伴随该mtr生成的一组redo日志就需要被复制到log buffer中，也就是说不同事务的mtr可能是交替写入log buffer的，我们画个示意图（为了美观，我们把一个mtr中产生的所有的redo日志当作一个整体来画）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-687b270013902ff1f4d3d65701700de0ef5.png" alt=""></p>
<p>从示意图中我们可以看出来，不同的mtr产生的一组redo日志占用的存储空间可能不一样，有的mtr产生的redo日志量很少，比如mtr_t1_1、mtr_t2_1就被放到同一个block中存储，有的mtr产生的redo日志量非常大，比如mtr_t1_2产生的redo日志甚至占用了3个block来存储。</p>
<h2 id="1-6-redo日志的持久化"><a href="#1-6-redo日志的持久化" class="headerlink" title="1.6 redo日志的持久化"></a>1.6 redo日志的持久化</h2><p>前面我们说过，和InnoDB的数据修改一样，redo log也是借助了日志缓冲区来调节磁盘和CPU的矛盾，提升了性能。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0c9e8dfa4efc1da25a6055de1a9232833db.png" alt=""></p>
<h3 id="1-6-1-redo日志的持久化文件"><a href="#1-6-1-redo日志的持久化文件" class="headerlink" title="1.6.1 redo日志的持久化文件"></a>1.6.1 redo日志的持久化文件</h3><p>我们知道数据页持久化后，是保存在ibdata1（没有开启<code>innodb_file_per_table</code>时的共享表空间文件）或者.ibd（开启 <code>innodb_file_per_table</code>时）文件中的。</p>
<p>InnoDB定义了一个组（log group）的概念，一个组内由多个<strong>大小完全相同</strong>的redo log file组成。组内redo log file的数量由变量<code>innodb_log_files_group</code>决定，默认值为2，即两个redo log file。</p>
<blockquote>
<p>log group为redo日志组，其中有多个redo log file。虽然源码中已支持log group 的镜像功能，但是在ha_innobase.cc 文件中禁止了该功能。因此InnoDB存储引擎实际只有一个log group。</p>
</blockquote>
<p>这个组是一个逻辑的概念，并没有真正的文件来表示这是一个组，但是可以通过变量<code>innodb_log_group_home_dir</code>来定义组的目录，redo log file都放在这个目录下，默认是在datadir下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like &quot;innodb_log%&quot;;</span><br><span class="line">+-----------------------------+----------+</span><br><span class="line">| Variable_name               | Value    |</span><br><span class="line">+-----------------------------+----------+</span><br><span class="line">| innodb_log_buffer_size      | 8388608  |</span><br><span class="line">| innodb_log_compressed_pages | ON       |</span><br><span class="line">| innodb_log_file_size        | 50331648 |</span><br><span class="line">| innodb_log_files_in_group   | 2        |</span><br><span class="line">| innodb_log_group_home_dir   | .&#x2F;       |</span><br><span class="line">+-----------------------------+----------+</span><br><span class="line">[root@xuexi data]# ll &#x2F;mydata&#x2F;data&#x2F;ib*</span><br><span class="line">-rw-rw---- 1 mysql mysql 79691776 Mar 30 23:12 &#x2F;mydata&#x2F;data&#x2F;ibdata1</span><br><span class="line">-rw-rw---- 1 mysql mysql 50331648 Mar 30 23:12 &#x2F;mydata&#x2F;data&#x2F;ib_logfile0</span><br><span class="line">-rw-rw---- 1 mysql mysql 50331648 Mar 30 23:12 &#x2F;mydata&#x2F;data&#x2F;ib_logfile1</span><br></pre></td></tr></table></figure>
<p>可以看到在默认的数据目录下，有两个ib_logfile开头的文件，它们就是log group中的redo log file，而且它们的大小完全一致且等于变量<code>innodb_log_file_size</code>定义的值。</p>
<p>在innodb将log buffer中的redo log block刷到这些log file中时，会以追加写入的方式循环轮训写入。即先在ib_logfile0的尾部追加写，直到满了之后向ib_logfile1追加写。<strong>当ib_logfile1满了，则又重新向ib_logfile0进行覆盖写</strong>。</p>
<p>由于是将log buffer中的日志刷到log file，所以在log file中记录日志的方式也是log block的方式。在每个组的第一个redo log file中，前2KB负责记录4个特定的部分，从2KB之后才开始记录log block。除了第一个redo log file中会记录这2KB的部分外，<strong>log group中的其他log file不会记录这2KB，但是却会腾出这2KB的空间</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0e974f07531a01ac0003212eab079cea38b.png" alt=""></p>
<blockquote>
<p>redo log file的大小对innodb的性能影响非常大，设置的太大，恢复的时候就会时间较长，设置的太小，就会导致在写redo log的时候循环切换redo log file。</p>
</blockquote>
<h3 id="1-6-1-redo日志的持久化策略"><a href="#1-6-1-redo日志的持久化策略" class="headerlink" title="1.6.1 redo日志的持久化策略"></a>1.6.1 redo日志的持久化策略</h3><p>那么，log buffer里面的日志，什么时候刷到log file中呢？</p>
<ol>
<li>事务提交时</li>
<li>当log buffer中有一半的内存空间已经被使用时</li>
<li>log checkpoint 时</li>
</ol>
<p>其中<code>1. 事务提交时</code>是InnoDB事务的持久性的保证，但就像我们在《【InnoDB详解三】锁和事务》一文中介绍的那样，为了性能，InnoDB允许牺牲一定的持久性，允许执行不同的redo日志持久化策略。</p>
<p>MySQL支持用户自定义在事务提交时是否将log buffer中的日志刷log file中。这种控制通过变量 <code>innodb_flush_log_at_trx_commit</code> 的值来决定。该变量有3种值：0、1、2，默认为1。</p>
<ul>
<li>当设置为0的时候，<strong>事务提交时</strong>不会将log buffer中日志写入到os buffer。那什么时候写入呢？由master thread通过每秒一次的频率来异步写入。该值为0时性能较好，但是会丢失掉master thread还没刷新进磁盘部分的数据。<blockquote>
<p>这里我想简单介绍一下master thread，这是InnoDB一个在后台运行的主线程，从名字就能看出这个线程相当的重要。它做的主要工作包括但不限于：刷新日志缓冲，合并插入缓冲，刷新脏页等。master thread大致分为每秒运行一次的操作和每10秒运行一次的操作。master thread中刷新数据，属于checkpoint的一种。</p>
</blockquote>
</li>
<li>当设置为1的时候，当然是最安全的，即每次commit都会强迫flush到log file，但是数据库性能会受一定影响。</li>
<li>当设置为2的时候，每次提交都仅写入到操作系统的内核空间os buffer，然后由操作系统异步每秒调用一次fsync()将os buffer中的日志写入到log file。</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-29558eb65234c525c09f9651c104f0f9bb1.png" alt=""></p>
<h3 id="1-6-3-redo日志持久化策略的性能"><a href="#1-6-3-redo日志持久化策略的性能" class="headerlink" title="1.6.3 redo日志持久化策略的性能"></a>1.6.3 redo日志持久化策略的性能</h3><p>选择刷日志的策略会严重影响数据修改时的性能，特别是刷到磁盘的过程。下例就测试了<code>innodb_flush_log_at_trx_commit</code>分别为0、1、2时的差距。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#创建测试表</span><br><span class="line">drop table if exists test_flush_log;</span><br><span class="line">create table test_flush_log(id int,name char(50))engine&#x3D;innodb;</span><br><span class="line"></span><br><span class="line">#创建插入指定行数的记录到测试表中的存储过程</span><br><span class="line">drop procedure if exists proc;</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc(i int)</span><br><span class="line">begin</span><br><span class="line">    declare s int default 1;</span><br><span class="line">    declare c char(50) default repeat(&#39;a&#39;,50);</span><br><span class="line">    while s&lt;&#x3D;i do</span><br><span class="line">        start transaction;</span><br><span class="line">        insert into test_flush_log values(null,c);</span><br><span class="line">        commit;</span><br><span class="line">        set s&#x3D;s+1;</span><br><span class="line">    end while;</span><br><span class="line">end$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<p>当前环境下， <code>innodb_flush_log_at_trx_commit</code> 的值为1，即每次提交都刷日志到磁盘。测试此时插入10W条记录的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; call proc(100000);</span><br><span class="line">Query OK, 0 rows affected (15.48 sec)</span><br></pre></td></tr></table></figure>

<p>结果是15.48秒。</p>
<p>再测试值为2的时候，即每次提交都刷新到os buffer，但每秒才刷入磁盘中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @@global.innodb_flush_log_at_trx_commit&#x3D;2;</span><br><span class="line">mysql&gt; truncate test_flush_log;</span><br><span class="line"></span><br><span class="line">mysql&gt; call proc(100000);</span><br><span class="line">Query OK, 0 rows affected (3.41 sec)</span><br></pre></td></tr></table></figure>

<p>结果插入时间大减，只需3.41秒。</p>
<p>最后测试值为0的时候，即每秒才刷到os buffer和磁盘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @@global.innodb_flush_log_at_trx_commit&#x3D;0;</span><br><span class="line">mysql&gt; truncate test_flush_log;</span><br><span class="line"></span><br><span class="line">mysql&gt; call proc(100000);</span><br><span class="line">Query OK, 0 rows affected (2.10 sec)</span><br></pre></td></tr></table></figure>

<p>结果只有2.10秒。</p>
<p>最后可以发现，其实值为2和0的时候，它们的差距并不太大，但2却比0要安全的多。它们都是每秒从os buffer刷到磁盘，它们之间的时间差体现在log buffer刷到os buffer上。因为将log buffer中的日志刷新到os buffer只是内存数据的转移，并没有太大的开销，所以每次提交和每秒刷入差距并不大。可以测试插入更多的数据来比较，以下是插入100W行数据的情况。从结果可见，值为2和0的时候差距并不大，但值为1的性能却差太多。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5a84cadbc4f69368f44b55bbb5b8c4cb33b.png" alt=""></p>
<p>尽管设置为0和2可以大幅度提升插入性能，但是在故障的时候可能会丢失1秒钟数据，这1秒钟很可能有大量的数据，从上面的测试结果看，100W条记录也只消耗了20多秒，1秒钟大约有4W-5W条数据，尽管上述插入的数据简单，但却说明了数据丢失的大量性。<strong>更好的插入数据的做法是将值设置为1，然后修改存储过程，将每次循环都提交修改为只提交一次，这样既能保证数据的一致性，也能提升性能</strong>，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">drop procedure if exists proc;</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc(i int)</span><br><span class="line">begin</span><br><span class="line">    declare s int default 1;</span><br><span class="line">    declare c char(50) default repeat(&#39;a&#39;,50);</span><br><span class="line">    start transaction;</span><br><span class="line">    while s&lt;&#x3D;i DO</span><br><span class="line">        insert into test_flush_log values(null,c);</span><br><span class="line">        set s&#x3D;s+1;</span><br><span class="line">    end while;</span><br><span class="line">    commit;</span><br><span class="line">end$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<p>测试值为1时的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set @@global.innodb_flush_log_at_trx_commit&#x3D;1;</span><br><span class="line">mysql&gt; truncate test_flush_log;</span><br><span class="line"></span><br><span class="line">mysql&gt; call proc(1000000);</span><br><span class="line">Query OK, 0 rows affected (11.26 sec)</span><br></pre></td></tr></table></figure>


<h2 id="1-7-利用redo日志做系统恢复"><a href="#1-7-利用redo日志做系统恢复" class="headerlink" title="1.7 利用redo日志做系统恢复"></a>1.7 利用redo日志做系统恢复</h2><h3 id="1-7-1-LSN和Checkpoint"><a href="#1-7-1-LSN和Checkpoint" class="headerlink" title="1.7.1 LSN和Checkpoint"></a>1.7.1 LSN和Checkpoint</h3><p>说到恢复，就不得不提LSN，我们在《【InnoDB详解一】体系架构和关键特性》一文中已经有过介绍，为方便计，我们粘贴过来。</p>
<p>对于InnoDB存储引擎而言，是通过LSN（Log Sequence Number）来标记版本的。LSN是一个一直递增的8字节整型数字，<strong>表示事务写入到redo日志的字节总量（注意LSN的含义是日志的字节总量）</strong>。每个页都有LSN字段，重做日志中也有LSN，Checkpoint也有LSN。</p>
<p>在每个数据页头部的LSN字段，记录当前页最后一次数据修改所对应的重做日志的LSN值，用于在recovery时对比重做日志LSN值，以决定是否对该页进行恢复数据。前面说的checkpoint也是有LSN号记录的，checkpoint的LSN表示已刷新到磁盘的最新的数据所对应的重做日志的LSN，LSN号串联起一个事务开始到恢复的过程。</p>
<blockquote>
<p>比如redo日志的文件是600M，LSN的值已经为1G了，也就是LSN=1000000000。因为redo日志是循环使用的，所以我们可以知道LSN=1G=600M+400M，所以redo日志已经重复使用过一整遍后，目前最新的可写入点，在redo日志偏移量400M的位置。</p>
</blockquote>
<blockquote>
<p>我们执行了一个update语句，产生了一个事务t，这次数据的修改，假设产生了512个字节的日志量，那么LSN就会增加到1000000512，而事务t的修改使得A、B、C三个数据页成为了脏页，那么A、B、C三个数据页的LSN值就会更新为1000000512。如果这时，触发了checkpoint，刚刚好将事务t为止的修改刷新到磁盘，那么此时checkpoint LSN也是1000000512。</p>
</blockquote>
<p>除了LSN之外，我们还要知道Checkpoint，同样在《【InnoDB详解一】体系架构和关键特性》一文中已经有过介绍。简单来说就是Checkpoint会定时将buffer里面的redo日志持久化到磁盘。</p>
<h3 id="1-7-2-恢复过程"><a href="#1-7-2-恢复过程" class="headerlink" title="1.7.2 恢复过程"></a>1.7.2 恢复过程</h3><p>InnoDB存储引擎在启动时<strong>不管上次数据库运行时是否正常关闭，都会尝试进行恢复</strong>。因为重做日志记录的是物理日志，因此恢复的速度比逻辑日志，如二进制日毒要快很多。与此同时，InnoDB存储引擎自身也对恢复进行了一定程度的优化，如顺序读取及并行应用重做日志，这样可以进一步地提高数据库恢复的速度。</p>
<p>由于checkpoint会记录已经刷新到磁盘页上的LSN，因此在恢复过程中仅需恢复checkpoint开始的日志部分。假设当数据库在checkpoint的LSN为10000时发生宕机，恢复操作仅恢复LSN10000～13000范围内的日志。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f46c3e46759e30a6596ccab8491f2c7c8af.png" alt=""></p>
<p>恢复的过程中，系统会根据redo日志的类型，调用相关的恢复函数进行恢复，而redo日志中的那些数据就可以被当成是调用这个函数所需的参数。从而使数据库恢复原样。</p>
<p>注意，调用相关的恢复函数的结果是幂等的，即便是insert一条行记录的redo日志，即便多次被恢复函数调用，其结果也是幂等的。</p>
<h1 id="2-undo-log"><a href="#2-undo-log" class="headerlink" title="2 undo log"></a>2 undo log</h1><p>undo log有两个作用：</p>
<ol>
<li>提供回滚<ul>
<li>InnoDB在数据修改的时候，不仅记录了redo，还记录了相对应的undo，如果因为某些原因导致事务失败或回滚了，可以借助该undo进行回滚。</li>
</ul>
</li>
<li>多个行版本控制(MVCC)<ul>
<li>有时候应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而根据事务的版本和行记录的版本匹配，让用户实现非锁定一致性读取。</li>
</ul>
</li>
</ol>
<p>undo log和redo log记录物理日志不一样，<strong>它是逻辑日志</strong>。因此只是将数据库<strong>逻辑地</strong>恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。</p>
<p>这是因为在多用户并发系统中，可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如，一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，<strong>因为这样会影响其他事务正在进行的工作</strong>。</p>
<p>例如，用户执行了一个INSERT 10W条记录的事务，这个事务会导致分配一个新的段，即表空间会增大。在用户执行ROLLBACK时，会将插入的事务进行回滚，但是表空间的大小<strong>并不会因此而收缩</strong>。因此，当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。</p>
<p><strong>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录</strong>。</p>
<p><strong>undo log是采用段(segment)的方式来记录的</strong>，每个undo操作在记录的时候占用一个undo log segment。</p>
<p><strong>另外，undo log也会产生redo log，因为undo log也要实现持久性保护</strong>。</p>
<h2 id="2-1-purge线程"><a href="#2-1-purge线程" class="headerlink" title="2.1 purge线程"></a>2.1 purge线程</h2><p>在详述undo log之前，我们需要了解一个前置知识点：purge线程</p>
<p>delete和update操作可能并不直接删除原有的数据。例如表t（a,b）如下的SQL语句∶</p>
<p><code>DELETE FROM t WHERE a=1;</code></p>
<p>表t上列a有聚集索引，列b上有辅助索引。</p>
<p>对于上述的delete操作，在MVCC的章节介绍已经知道仅是将主键列等于1的记录delete flag设置为1，记录并没有被删除，即记录还是存在于B+树中。其次，对辅助索引上a等于1，b等于1的记录同样没有做任何处理，甚至没有产生undo log。而真正删除这行记录的操作其实被”延时”了，最终在 purge操作中完成。</p>
<p>purge用于最终完成delete和 update操作。这样设计是因为InnoDB存储引擎支持MVCC，所以记录不能在事务提交时立即进行处理。这时其他事物可能正在引用这行，故InnoDB存储引擎需要保存记录之前的版本。而是否可以删除该条记录通过purge来进行判断。若该行记录已不被任何其他事务引用，那么就可以进行真正的delete操作。</p>
<p>可见，purge操作是清理之前的delete和update操作，将上述操作”最终”完成。而实际执行的操作为delete操作，清理之前行记录的版本。</p>
<p>为了节省存储空间，InnoDB存储引擎的undo log设计是这样的：</p>
<ol>
<li>一个页上允许多个事务的undo log存在。虽然这不代表事务在全局过程中提交的顺序，但是后面的事务产生的undo log总在最后。</li>
<li>此外，ImnoDB存储引擎还有一个history列表，它根据事务提交的顺序，将undo log进行链接。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-88c56db52cf6ad7facfd77561eae1e1e56b.png" alt=""></p>
<p>在图7-17的例子中，history list表示<strong>按照事务提交的顺序</strong>将undo log进行组织。在InnoDB存储引擎的设计中，先提交的事务总在尾端。</p>
<p>undo page存放了undo log，由于可以重用，因此一个undo page中可能存放了<strong>多个不同事务</strong>的undo log。tx5的灰色阴影表示该 undo log还被其他事务引用。</p>
<p>执行 purge的过程中，InnoDB存储引擎首先从history list中找到第一个需要被清理的记录，这里为trx1，清理之后InnoDB存储引擎会在trx1的undo log所在的页中继续寻找是否存在可以被清理的记录，这里会找到事务trx3，接着找到trx5，但是发现trx5被其他事务所引用而不能清理，故去再次去history list中查找，发现这时最尾端的记录为trx2，接着找到trx2所在的页，然后依次再把事务trx6、trx4的记录进行清理。</p>
<p>InnoDB存储引擎这种先从history list中找undo log，然后再从undo page中找undo log的设计模式是<strong>为了避免大量的随机读取操作，从而提高 purge的效率</strong>。</p>
<h2 id="2-2-undo-log的存储方式"><a href="#2-2-undo-log的存储方式" class="headerlink" title="2.2 undo log的存储方式"></a>2.2 undo log的存储方式</h2><p>Innodb存储引擎对undo的管理采用段（segment）的方式。rollback segment称为回滚段，每个回滚段中有1024个undo log segment。</p>
<p>在以前老版本，只支持1个rollback segment，这样就只能记录1024个undo log segment。后来MySQL5.5可以支持128个rollback segment，即支持<code>128*1024</code>个undo操作，还可以通过变量 <code>innodb_undo_logs</code> (5.6版本以前该变量是 innodb_rollback_segments )自定义多少个rollback segment，默认值为128。</p>
<p>undo log默认存放在共享表空间中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xuexi data]# ll &#x2F;mydata&#x2F;data&#x2F;ibda*</span><br><span class="line">-rw-rw---- 1 mysql mysql 79691776 Mar 31 01:42 &#x2F;mydata&#x2F;data&#x2F;ibdata1</span><br></pre></td></tr></table></figure>

<p>同样的，如果开启了 innodb_file_per_table ，将放在每个表的.ibd文件中。</p>
<p>在MySQL5.6中，undo的存放位置还可以通过变量 <code>innodb_undo_directory</code> 来自定义存放目录，默认值为”.”表示datadir。</p>
<p>默认rollback segment全部写在一个文件中，但可以通过设置变量 <code>innodb_undo_tablespaces</code> 平均分配到多少个文件中。该变量默认值为0，即全部写入一个表空间文件。该变量为静态变量，只能在数据库示例停止状态下修改，如写入配置文件或启动时带上对应参数。但是innodb存储引擎在启动过程中提示，不建议修改为非0的值，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2017-03-31 13:16:00 7f665bfab720 InnoDB: Expected to open 3 undo tablespaces but was able</span><br><span class="line">2017-03-31 13:16:00 7f665bfab720 InnoDB: to find only 0 undo tablespaces.</span><br><span class="line">2017-03-31 13:16:00 7f665bfab720 InnoDB: Set the innodb_undo_tablespaces parameter to the</span><br><span class="line">2017-03-31 13:16:00 7f665bfab720 InnoDB: correct value and retry. Suggested value is 0</span><br></pre></td></tr></table></figure>
<h2 id="2-3-undo-log的数据结构"><a href="#2-3-undo-log的数据结构" class="headerlink" title="2.3 undo log的数据结构"></a>2.3 undo log的数据结构</h2><p>InnoDB采用回滚段的方式来维护undo log是为了保证事务并发操作时，在写各自的undo log时不产生冲突。回滚段实际上是一种 Undo 文件组织方式，每个回滚段又有多个undo log slot。具体的文件组织方式如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a25c818ad84c7493b4eb9f92c1c8ea108b8.png" alt=""></p>
<p>当事务开启时，会给它指定使用哪个rollback segment，然后在真正执行操作时，分配具体的slot，通常会有两种slot：</p>
<ul>
<li>insert_undo：只用于事务内的insert语句<ul>
<li>insert undo log是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见（这是事务隔离性的要求），故该undo log不会被其他事务引用，不用进行purge操作，可以在事务提交后直接删除（事务提交后就没有回滚需求了）。</li>
</ul>
</li>
<li>update_undo: 只用于事务内的update语句<ul>
<li>update undo log记录的是对delete和 update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除。提交时放入undo log链表，等待 purge线程进行最后的删除。</li>
</ul>
</li>
</ul>
<p>通常如果事务内只包含一种操作类型，则只使用一个slot。但也有例外，例如insert操作，如果insert的记录在page上已经存在了，但是是无效的，那么就可以直接通过更新这条无效记录的方式来实现插入，这时候使用的是update_undo。</p>
<h3 id="2-3-1-insert-undo的数据结构"><a href="#2-3-1-insert-undo的数据结构" class="headerlink" title="2.3.1 insert_undo的数据结构"></a>2.3.1 insert_undo的数据结构</h3><p>insert undo log的数据结构如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1886e6ec7203188f0fa788d3d6d5c1b6c40.png" alt=""></p>
<p>其中<code>*</code>表示对存储的字段进行了压缩。</p>
<ol>
<li>insete undo log开始的前两个字节next 记录的是下一个undo log的位置，通过该next的字节可以知道一个undo log所占的空间字节数。</li>
<li>类似地，尾部的两个字节记录的是undo log的开始位置。</li>
<li>type_cmpl占用一个字节，记录的是undo的类型，对于insert undo log，该值总是为11。</li>
<li>undo_no记录事务的ID，table_id记录undo log所对应的表对象。这两个值都是在压缩后保存的。</li>
<li>接着的部分记录了所有主键的列和值。在进行 rollback操作时，根据这些值可以定位到具体的记录，然后进行删除即可。</li>
</ol>
<h3 id="2-3-2-update-undo的数据结构"><a href="#2-3-2-update-undo的数据结构" class="headerlink" title="2.3.2 update_undo的数据结构"></a>2.3.2 update_undo的数据结构</h3><p>update undo log的结构如图所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1add9223f47f7e189d289b96332cf7f655e.png" alt=""></p>
<p>update undo log相对于之前介绍的insert undo log，记录的内容更多，所需点用的空间也更大。</p>
<ol>
<li>next、start、undo_no、table_id与之前介绍的insert undo log部分相同。</li>
<li>这里的 type_cmpl，由于update undo log本身还有分类，故其可能的值如下∶<ul>
<li>12 TRXUNDO_UPD_EXIST_REC更新 non-delete-mark的记录</li>
<li>13 TRX_UNDO_UPD_DEL_REC将delete的记录标记为not delete </li>
<li>14 TRX_UNDO_DEL_MARK_REC将记录标记为delete</li>
</ul>
</li>
<li>接着的部分记录 update_vector信息，update_vector表示update操作导致发生改变的列。每个修改的列信息都要记录的undo log中。</li>
</ol>
<p>对于不同的undo log类型，可能还需要记录对索引列所做的修改。</p>
<h2 id="2-4-相关参数"><a href="#2-4-相关参数" class="headerlink" title="2.4 相关参数"></a>2.4 相关参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like &#39;%undo%&#39;;</span><br><span class="line">+--------------------------+------------+</span><br><span class="line">| Variable_name            | Value      |</span><br><span class="line">+--------------------------+------------+</span><br><span class="line">| innodb_max_undo_log_size | 1073741824 |</span><br><span class="line">| innodb_undo_directory    | .&#x2F;         |</span><br><span class="line">| innodb_undo_log_truncate | OFF        |</span><br><span class="line">| innodb_undo_logs         | 128        |</span><br><span class="line">| innodb_undo_tablespaces  | 3          |</span><br><span class="line">+--------------------------+------------+</span><br><span class="line"> </span><br><span class="line">mysql&gt; show global variables like &#39;%truncate%&#39;;</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| Variable_name                        | Value |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| innodb_purge_rseg_truncate_frequency | 128   |</span><br><span class="line">| innodb_undo_log_truncate             | OFF   |</span><br><span class="line">+--------------------------------------+-------+</span><br></pre></td></tr></table></figure>
<ul>
<li>innodb_undo_directory<ul>
<li>变量 <code>innodb_undo_directory</code> 来自定义存放目录，默认值为”.”表示datadir。</li>
</ul>
</li>
<li>innodb_max_undo_log_size<ul>
<li>控制最大undo tablespace文件的大小，当启动了innodb_undo_log_truncate 时，undo tablespace 超过innodb_max_undo_log_size 阀值时才会去尝试truncate。该值默认大小为1G，truncate后的大小默认为10M。</li>
</ul>
</li>
<li>innodb_undo_tablespaces<ul>
<li>设置undo独立表空间个数，范围为0-128， 默认为0，0表示表示不开启独立undo表空间，且 undo日志存储在ibdata文件中。该参数只能在最开始初始化MySQL实例的时候指定，如果实例已创建，这个参数是不能变动的，如果在数据库配置文件 .cnf 中指定innodb_undo_tablespaces 的个数大于实例创建时的指定个数，则会启动失败，提示该参数设置有误。</li>
<li>设置该参数后，会在路径inodb_undo_directory看到undo为前缀的文件，该文件就代表rollback segment文件。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-dfb2af1207e6212f287c7518853aae22234.png" alt=""></li>
</ul>
</li>
<li><strong>innodb_undo_log_truncate</strong><ul>
<li>InnoDB的purge线程，根据innodb_undo_log_truncate设置开启或关闭、innodb_max_undo_log_size的参数值，以及truncate的频率来进行空间回收和undo file的重新初始化。</li>
<li>该参数生效的前提是，已设置独立表空间且独立表空间个数大于等于2个。</li>
<li>purge线程在truncate undo log file的过程中，需要检查该文件上是否还有活动事务，如果没有，需要把该undo log file标记为不可分配，这个时候，undo log 都会记录到其他文件上，所以至少需要2个独立表空间文件，才能进行truncate 操作。</li>
<li>标注不可分配后，会创建一个独立的文件undo__trunc.log，记录现在正在truncate 某个undo log文件，然后开始初始化undo log file到10M，操作结束后，删除表示truncate动作的 undo__trunc.log 文件，这个文件保证了即使在truncate过程中发生了故障重启数据库服务，重启后，服务发现这个文件，也会继续完成truncate操作，删除文件结束后，标识该undo log file可分配。</li>
</ul>
</li>
<li>innodb_purge_rseg_truncate_frequency<ul>
<li>用于控制purge回滚段的频度，默认为128。假设设置为n，则说明，当Innodb Purge操作的协调线程 purge事务128次时，就会触发一次History purge，检查当前的undo log 表空间状态是否会触发truncate。</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-hand-o-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-hand-o-right" aria-label="accessibility.next_page"></i></a>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">93</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">457.2k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
