<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/31/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E4%B8%80%E3%80%91%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/31/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E4%B8%80%E3%80%91%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7/" itemprop="url">【InnoDB详解一】体系架构和关键特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-31T21:43:59+08:00">
                2020-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/31/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E4%B8%80%E3%80%91%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/31/【InnoDB详解一】体系架构和关键特性/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  14.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  53
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>InnoDB存储引擎最早由Innobase Oy公司°开发，被包括在MySQL数据库所有的二进制发行版本中，从MySQL5.5版本开始是默认的表存储引擎（之前的版本IlmoDB 存储引擎仅在Windows下为默认的存储引擎）。该存储引擎是第一个完整支持ACID事务的MySQL存储引擎（BDB是第一个支持事务的MySQL存储引擎，现在已经停止开发），其特点是行锁设计、支持MVCC、支持外键、提供一致性非锁定读，同时被设计用来最有效地利用以及使用内存和 CPU。</p>
<p>InnoBD通过有如下机制来优化性能：</p>
<ol>
<li><strong>缓冲池</strong>：使用缓冲池来优化读写性能，写的时候，将页从磁盘刷入缓冲池，再做修改，读的时候，读缓冲池的页，脏数据通过异步适时的刷回磁盘。</li>
<li><strong>后台线程</strong>：使用后台线程来减少对用户线程的阻塞。</li>
<li><strong>插入缓冲</strong>：使用插入缓冲（Insert Buffer）机制来优化非唯一性索引的写性能，使其在缓冲池技术的基础上再少一次磁盘IO。</li>
<li><strong>两次写</strong>：使用两次写（doublewrite）机制来确保数据页从内存刷新到硬盘时如果中途宕机，则仍可以通过数据页副本来恢复该数据页，保证数据页向磁盘flush过程的可靠性。</li>
<li><strong>自适应哈希索引</strong>：通过自适应哈希索引（Adaptive Hash Index，AHI）机制来对缓冲中高频热点的B+树索引页自动建立哈希索引，以替代<strong>等值查询</strong>，优化查询性能。</li>
<li><strong>异步IO</strong>：通过异步IO（Asynchronous IO，AIO）机制，将read ahead方式的读取，磁盘的写入，数据的恢复等诸多操作通过异步来处理，提高处理效率。</li>
<li><strong>刷新邻接页</strong>：通过刷新邻接页（Flush Neighbor Page）机制，可以在flush数据页进入缓存的时候，顺序将该页所在区（extent）的所有脏页一起flush，将本该多次IO的操作合并一次完成，该机制在传统机械硬盘场景中性能提升明显。</li>
</ol>
<p>InnoDB存储引擎已经被许多大型网站使用，如用户熟知的Google、Yahoo!、Facebook、YouTube、Flickr，在网络游戏领域有《魔兽世界》、《Second Life》、《神兵玄奇》等。</p>
<h1 id="1-InnoDB的体系架构"><a href="#1-InnoDB的体系架构" class="headerlink" title="1 InnoDB的体系架构"></a>1 InnoDB的体系架构</h1><p>下图2简单显示了InoDB的存储引擎的体系架构，从图可见，InnoDB存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作∶</p>
<ul>
<li>维护所有进程/线程需要访问的多个内部数据结构。</li>
<li>缓存磁盘上的数据，方便快速地读取，同时在对磁盘文件的数据修改之前在这里缓存。</li>
<li>重做日志（redo log）缓冲。</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-94e3f8ff530d171d53e872caa4a3c2ca5b4.png" alt=""></p>
<p>后台线程的主要作用是负责刷新内存池中的数据，保证缓冲池中的内存缓存的是最近的数据。此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下 InnoDB 能恢复到正常运行状态。</p>
<h2 id="1-1-InnoDB的后台线程"><a href="#1-1-InnoDB的后台线程" class="headerlink" title="1.1 InnoDB的后台线程"></a>1.1 InnoDB的后台线程</h2><p>InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务</p>
<h3 id="1-1-1-Master-Thread"><a href="#1-1-1-Master-Thread" class="headerlink" title="1.1.1 Master Thread"></a>1.1.1 Master Thread</h3><p>Master Thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERTBUFER）、UNDO页的回收等。</p>
<p>Master Thread具有最高的线程优先级别。其内部由多个循环（loop）组成∶<strong>主循环（loop）</strong>、<strong>后台循环（backgroup loop）</strong>、<strong>刷新循环（flush loop）</strong>、<strong>暂停循环（suspend loop）</strong>。Master Thread会根据数据库运行的状态在loop、background loop、flush loop和suspend loop之间切换。</p>
<p><strong>主循环（loop）</strong></p>
<p>Loop被称为主循环，因为大多数的操作是在这个循环中，其中有两大部分的操作———每秒钟的操作和每10秒的操作。伪代码如下∶</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void master thread()&#123;</span><br><span class="line">	loop:</span><br><span class="line">	for(int i&#x3D; 0;i&lt;10;i++)&#123;</span><br><span class="line">		do thing once per second;</span><br><span class="line">		sleep 1 second if necessary;</span><br><span class="line">	&#125;</span><br><span class="line">	do things once per ten seconds</span><br><span class="line">	goto loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，loop循环通过 thread sleep来实现，这意味着所谓的每秒一次或每10秒一次的操作是不精确的。在负载很大的情况下可能会有延迟（delay），只能说大概在这个频率下。当然，InnoDB源代码中还通过了其他的方法来尽量保证这个频率。</p>
<p><strong>每秒一次</strong>的操作包括：（有概念尚不清晰的，后文会做详解）</p>
<ol>
<li>日志缓冲刷新到磁盘，即使这个事务还没有提交（总是）;<ul>
<li>即使某个事务还没有提交，InoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。这一点是必须要知道的，因为这可以很好地解释为什么再大的事务提交（commit）的时间也是很短的。</li>
</ul>
</li>
<li>合并插入缓冲（可能）;<ul>
<li>合并插入缓冲（Insert Buffr）并不是每秒都会发生的。InnoDB存储引擎会判断当前一秒内发生的IO次数是否小于5次，如果小于5次，InoDB认为当前的IO压力很小，可以执行合并插人缓冲的操作。</li>
</ul>
</li>
<li>至多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）;<ul>
<li>同样，刷新100个脏页也不是每秒都会发生的。InoDB存储引擎通过判断当前缓冲池中脏页的比例（buf get_modified_ratio pct）是否超过了配置文件中inodbmax_dirtypages pet这个参数（默认为90，代表90%），如果超过了这个阈值，InoDB存储引擎认为需要做磁盘同步的操作，将100个脏页写人磁盘中。</li>
</ul>
</li>
<li>如果当前没有用户活动，则切换到 background loop（可能）。</li>
</ol>
<p><strong>每10秒一次</strong>的操作包括：（有概念尚不清晰的，后文会做详解）</p>
<ol>
<li>刷新100个脏页到磁盘（可能的情况下）;<ul>
<li>在以上的过程中，InnoDB存储引擎会先判断过去10秒之内磁盘的IO操作是否小于200次，如果是，InnoDB存储引擎认为当前有足够的磁盘IO操作能力，因此将100 个脏页刷新到磁盘。</li>
</ul>
</li>
<li>合并至多5个插人缓冲（总是）;<ul>
<li>接着，InnoDB存储引擎会合并插入缓冲。不同于每秒一次操作时可能发生的合并插入缓冲操作，这次的合并插入缓冲操作总会在这个阶段进行。</li>
</ul>
</li>
<li>将日志缓冲刷新到磁盘（总是）;<ul>
<li>之后，InoDB存储引擎会再进行一次将日志缓冲刷新到磁盘的操作。这和每秒一次时发生的操作是一样的。</li>
</ul>
</li>
<li>删除无用的Undo 页（总是）;<ul>
<li>接着InnoDB存储引擎会进行一步执行full purge操作，即删除无用的Undo 页。对表进行update、delete这类操作时，原先的行被标记为删除，但是因为一致性读（consistent read）的关系，需要保留这些行版本的信息。</li>
<li>但是在full purge过程中，InoDB存储引擎会判断当前事务系统中已被删除的行是否可以删除，比如有时候可能还有查询操作需要读取之前版本的undo信息，如果可以删除，InnoDB会立即将其删除。</li>
</ul>
</li>
<li>刷新100个或者10个脏页到磁盘（总是）。<ul>
<li>然后，InnoDB存储引擎会判断缓冲池中脏页的比例（buf get_modified_ratio pct），如果有超过70%的脏页，则刷新100个脏页到磁盘，如果脏页的比例小于70%，则只需刷新10%的脏页到磁盘。</li>
</ul>
</li>
</ol>
<p><strong>后台循环（backgroup loop）</strong></p>
<p>接着来看background loop，若当前没有用户活动（数据库空闲时）或者数据库关闭（shutdown），就会切换到这个循环。background loop 会执行以下操作∶</p>
<ol>
<li>删除无用的 Undo 页（总是）;</li>
<li>合并20个插人缓冲（总是）;</li>
<li>如果当前数据库还是空闲，则跳回到主循环，否则进入flush loop（总是）;</li>
</ol>
<p><strong>刷新循环（flush loop）</strong><br>刷新循环只做一件事，每次刷新一百个页到磁盘，不断循环直到<code>缓冲池中的脏页比例小于等于innodb_max_dirty_pages_pct的值（默认90）</code></p>
<ol>
<li>不断刷新100个页直到符合条件（可能，跳转到flush loop中完成）。</li>
</ol>
<p><strong>暂停循环（suspend_loop）</strong></p>
<p>若flush loop中也没有什么事情可以做了，InnoDB存储引擎会切换到suspend_loop，将Master Thread挂起，等待事件的发生。若用户启用（enable）了InnoDB存储引擎，却没有使用任何InnoDB存储引擎的表，那么Master Thread总是处于挂起的状态。</p>
<blockquote>
<p>上述核心逻辑是MySQL 1.0.x版本之前的逻辑，在1.0.x版本和1.2.x版本中，Master Thread两次引入了更新</p>
</blockquote>
<p><strong>1.0.x版本的改动：</strong></p>
<ol>
<li>磁盘技术的快速发展中，对于缓冲池向磁盘刷新时都做了一定的hard coding，这些限制很大程度上限制了InnoDB存储引擎对磁盘IO的性能，尤其是写入性能。因此提供参数innodb_io_capacity用来表示IO的吞吐量，默认200，对于刷新到磁盘页的数量，会按照innodb_io_capacity的百分比来控制：<ul>
<li>并插入缓冲时，合并插入缓冲的数量为innodb_io_capacity值的5%;</li>
<li>缓冲池刷新脏页时，刷行脏页的数量为innodb_io_capcity;</li>
</ul>
</li>
<li>脏页比例参数innodb_max_dirty_pages_pct为90太大了。新版本将其改为了75。</li>
<li>innodb_adaptive_flushing参数的引入，该值影响每秒刷新脏页的数量。<ul>
<li>原来的刷新规则是∶脏页在缓冲池所占的比例小于innodb_max_dirty pages pect时，不刷新脏页;大于inodb maxdirtypages_pct时，刷新100个脏页。</li>
<li>随着innodb_adaptive flushing参数的引入，InnoDB存储引擎会通过一个名为buf_flush get_desired_fush_rate的函数来判断需要刷新脏页最合适的数量。</li>
<li>粗略地翻阅源代码后发现 buf flush get desired_fush rate通过判断产生重做日志（redo log）的速度来决定最合适的刷新脏页数量。因此，当脏页的比例小于inodb_max_dirtypages_pct时，也会刷新一定量的脏页。</li>
</ul>
</li>
<li>引入参数innodb_purge_batch_size<ul>
<li>之前每次进行 full purge操作时，最多回收20个Undo页</li>
<li>从InnoDB 1.0.x版本开始引人了参数，该参数可以控制每次 full purge回收的Undo页的数量。该参数的默认值为20，并可以动态地对其进行修改</li>
</ul>
</li>
</ol>
<p><strong>1.2.x版本的改动：</strong></p>
<p>对于刷新脏页的操作，从Master Thread 线程分离到一个单独的<strong>Page Cleaner Thread</strong>，从而减轻了Master Thread的工作，同时进一步提高了系统的并发性。</p>
<p>整体伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void master_thread()&#123;</span><br><span class="line">    goto loop;</span><br><span class="line">loop:</span><br><span class="line">for (int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">    thread_sleep(1) &#x2F;&#x2F;sleep 1 second--&gt;每秒执行操作(负载在情况下会延迟)</span><br><span class="line">    do log buffer flush to disk  &#x2F;&#x2F;重做日志缓冲刷新到磁盘，即使这个事务没有提交(总是)</span><br><span class="line">    if ( last_ten_second_ios &lt; 5% innodb_io_capacity) &#x2F;&#x2F;如果当前的10次数小于(5% * 200&#x3D;10)(innodb_io_capacity默认值是200)</span><br><span class="line">        do merger 5% innodb_io_capacity insert buffer &#x2F;&#x2F;执行10个合并插入缓冲的操作(5% * 200&#x3D;10)</span><br><span class="line">    if ( buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct ) &#x2F;&#x2F;如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct(默认是75时)</span><br><span class="line">        do buffer pool plush 100% innodb_io_capacity dirty page &#x2F;&#x2F;刷新200个脏页到磁盘</span><br><span class="line">    else if enable adaptive flush  &#x2F;&#x2F;如果开户了自适应刷新</span><br><span class="line">        do buffer pool flush desired amount dirty page &#x2F;&#x2F;通过判断产生redo log的速度决定最合适的刷新脏页的数量</span><br><span class="line">    if ( no user activity ) &#x2F;&#x2F;如果当前没有用户活动</span><br><span class="line">        goto backgroud loop  &#x2F;&#x2F;跳到后台循环</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每10秒执行的操作</span><br><span class="line">if ( last_ten_second_ios &lt; innodb_io_capacity)  &#x2F;&#x2F;如果过去10内磁盘IO次数小于设置的innodb_io_capacity的值（默认是200）</span><br><span class="line">    do buffer pool flush 100% innodb_io_capacity dirty page &#x2F;&#x2F;刷新脏页的数量为innodb_io_capacity的值（默认是200）</span><br><span class="line">do merger 5% innodb_io_capacity insert buffer  &#x2F;&#x2F;合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span><br><span class="line">do log buffer flush to disk                    &#x2F;&#x2F;重做日志缓冲刷新到磁盘，即使这个事务没有提交（总是）</span><br><span class="line">do full purge       &#x2F;&#x2F;删除无用的undo页 （总是）</span><br><span class="line">if (buf_get_modified_ratio_pct &gt; 70%)          &#x2F;&#x2F;如果缓冲池中的胜页比例大于70%</span><br><span class="line">    do buffer pool flush 100% innodb_io_capacity dirty page  &#x2F;&#x2F;刷新200个脏页到磁盘</span><br><span class="line">else</span><br><span class="line">    do buffer pool flush 10% innodb_io_capacity dirty page   &#x2F;&#x2F;否则刷新20个脏页到磁盘</span><br><span class="line">goto loop</span><br><span class="line">backgroud loop:   &#x2F;&#x2F;后台循环</span><br><span class="line">do full purge     &#x2F;&#x2F;删除无用的undo页 （总是）</span><br><span class="line">do merger 5% innodb_io_capacity insert buffer  &#x2F;&#x2F;合并插入缓冲是innodb_io_capacity的5%（10）（总是）</span><br><span class="line">if not idle:      &#x2F;&#x2F;如果不空闲，就跳回主循环，如果空闲就跳入flush loop</span><br><span class="line">goto loop:    &#x2F;&#x2F;跳到主循环</span><br><span class="line">else:</span><br><span class="line">    goto flush loop</span><br><span class="line">flush loop:  &#x2F;&#x2F;刷新循环</span><br><span class="line">do buf_get_modified_ratio_pct pool flush 100% innodb_io_capacity dirty page &#x2F;&#x2F;刷新200个脏页到磁盘</span><br><span class="line">if ( buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct ) &#x2F;&#x2F;如果缓冲池中的脏页比例大于innodb_max_dirty_pages_pct的值（默认75%）</span><br><span class="line">    goto flush loop            &#x2F;&#x2F;跳到刷新循环，不断刷新脏页，直到符合条件</span><br><span class="line">    goto suspend loop          &#x2F;&#x2F;完成刷新脏页的任务后，跳入suspend loop</span><br><span class="line">suspend loop:</span><br><span class="line">suspend_thread()               &#x2F;&#x2F;master线程挂起，等待事件发生</span><br><span class="line">waiting event</span><br><span class="line">goto loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-1-2-IO-Thread"><a href="#1-1-2-IO-Thread" class="headerlink" title="1.1.2 IO Thread"></a>1.1.2 IO Thread</h3><p>在InnoDB存储引擎中大量使用了AIO（Async IO，异步IO）来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调（callback）处理。</p>
<p>InnoDB1.0版本之前共有4个IO Thread，分别是write、read、insert buffer和log IO thread。在Linux平台下，IO Thread的数量不能进行调整，但是在Windows平台下可以通过参数innodb file_io_threads来增大IO Thread。</p>
<p>从InnoDB1.0x版本开始，read thread和 write thread分别增大到了4个，并且不再使用innodb_file io threads参数，而是分别使用innodb_read_io threads和inodb_write io threads参数进行设置，如∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b1937bdac20464ad98c59b01feef5112e89.png" alt=""></p>
<p>可以通过命令<code>SHOW ENGINE INNODB STATUS</code>来观察 InnoDB中的IO Thread∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d5e0d14b4fbf29b6bb3bfdcffb517bc851e.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-aef88c1e57e56d4c88299db8c0ecfc9b6e7.png" alt=""></p>
<p>可以看到IO Thread0为insert buffer thread。IO Thread1为log thread。之后就是根据参数innodb_readio threads及innodb_write_io threads来设置的读写线程，并且读线程的 ID总是小于写线程。</p>
<h3 id="1-1-3-purge-Thread"><a href="#1-1-3-purge-Thread" class="headerlink" title="1.1.3 purge Thread"></a>1.1.3 purge Thread</h3><p>事务被提交后，其所使用的undo log可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。</p>
<p>在InnoDB 1.1版本之前，purge操作仅在InnoDB存储引擎的Master Thread中完成。而从InoDB 1.1版本开始，purge操作可以独立到单独的线程中进行，以此来减轻Master Thread的工作，从而提高CPU的使用率以及提升存储引擎的性能。</p>
<p>用户可以在 MySQL数据库的配置文件中添加如下命令来启用独立的Purge Thread:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_purge_threads&#x3D;1</span><br></pre></td></tr></table></figure>

<p>从InnoDB 1.2版本开始，InnoDB 支持多个Purge Thread，这样做的目的是为了进一步加快undo页的回收。同时由于Purge Thread需要离散地读取undo页，这样也能更进一步利用磁盘的随机读取性能。如用户可以设置4个Purge Thread∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0aa50fbe79b5d8c8da349360afdfadba659.png" alt=""></p>
<h3 id="1-1-4-Page-Cleaner-Thread"><a href="#1-1-4-Page-Cleaner-Thread" class="headerlink" title="1.1.4 Page Cleaner Thread"></a>1.1.4 Page Cleaner Thread</h3><p>Page Cleaner Thread是在InnoDB1.2x版本中引人的。其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成。而其目的是为了减轻原Master Thread的工作及对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能。</p>
<h2 id="1-2-InnoDB的内存"><a href="#1-2-InnoDB的内存" class="headerlink" title="1.2 InnoDB的内存"></a>1.2 InnoDB的内存</h2><h3 id="1-2-1-缓冲池"><a href="#1-2-1-缓冲池" class="headerlink" title="1.2.1 缓冲池"></a>1.2.1 缓冲池</h3><p>InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。因此可将其视为基于磁盘的数据库系统（Disk-base Database）。在数据库系统中，由于CPU 速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能。</p>
<p>缓冲池简单来说就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页”FIX”在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</p>
<p>对于数据库中页的修改操作，则首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上。这里需要注意的是，页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新回磁盘。同样，这也是为了提高数据库的整体性能。</p>
<p>对于InnoDB存储引擎而言，其缓冲池的配置通过参数<code>innodb_buffer poolsize</code>来设置。下面显示一台 MySQL数据库服务器，其将InnoDB存储引擎的缓冲池设置为15GB。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ed636b9b36110b3c4837e6bebd140812c1a.png" alt=""></p>
<p>具体来看，缓冲池中缓存的数据页类型有∶索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。不能简单地认为，缓冲池只是缓存索引页和数据页，它们只是占缓冲池很大的一部分而已。下图很好地显示了InnoDB存储引擎中内存的结构情况。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e84b63538abdf9181a48c21e0dadb862049.png" alt=""></p>
<p>从InnoDB1.0.x版本开始，允许有多个缓冲池实例。每个页根据哈希值平均分配到不同缓冲池实例中。这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。实例数量可以通过参数innodb_buffer_pool_instances来进行配置，该值默认为1：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5b6abb0cac04b945e55fff2553713baee85.png" alt=""></p>
<p>从 MySQL5.6版本开始，还可以通过information_schema架构下的表INNODB_BUFFER_POOL_STATS来观察缓冲的状态，如运行下列命令可以看到各个缓冲池的使用状态∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0e383c72335ac6ec4a71641fba4afa6cbfe.png" alt=""></p>
<h3 id="1-2-2-LRU-Free-Flush-List"><a href="#1-2-2-LRU-Free-Flush-List" class="headerlink" title="1.2.2 LRU/Free/Flush List"></a>1.2.2 LRU/Free/Flush List</h3><p>在前一章节中我们知道了缓冲池是一个很大的内存区域，其中存放各种类型的页，一个页的大小默认为16KB，即缓冲池中会存在大量16KB的数据页结构。那么InnoDB存储引擎是怎么对这么大的内存区域进行管理的呢?</p>
<h4 id="1-2-2-1-LRU-List"><a href="#1-2-2-1-LRU-List" class="headerlink" title="1.2.2.1 LRU List"></a>1.2.2.1 LRU List</h4><p>通常来说，数据库中的缓冲池是通过LRU（Latest Recent Used，最近最少使用）算法来进行管理的。即最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放从磁盘新读取到的页时，将首先释放LRU列表中尾端的页。</p>
<p>在InnoDB存储引擎中，缓冲池中页的大小默认为16KB，同样使用LRU算法对缓冲池进行管理。稍有不同的是InoDB存储引擎对传统的LRU算法做了一些优化。在InoDB的存储引擎中，<strong>LRU列表中还加入了midpoint位置</strong>。在默认配置下，该位置在LRU列表长度的5/8处。midpoint位置可由参数<code>inodb old blocks pct</code>控制，如∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3574d90f2897e73ca8fb3cf70bfbb0ebce6.png" alt=""></p>
<p>从上面的例子可以看到，参数 innodb oldblocks pect默认值为37。表示新读取的页插入到LRU列表尾端的37%的位置（差不多3/8的位置）。</p>
<p>在InnoDB存储引擎中，把midpoint 之后的列表称为old列表，之前的列表称为new列表。可以简单地理解为new 列表中的页都是最为活跃的热点数据。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b345d48fb199199fff62cb81c183638e6ee.png" alt=""></p>
<p>当用户需要访问数据时，InnoDB首先会在InnoDB缓冲池查找数据，如果缓冲池中没有数据时，InnoDB会查询硬盘上的数据，并将缓冲池中生成新的页；如果InnoDB缓冲池已满，InnoDB通过LRU算法清除InnoDB缓存池中个别数据块。</p>
<p>每当有新数据块需要加载到InnoDB缓冲池中时，该数据块应变为‘‘数据页’’被插到midpoint的位置，并声明为old数据页。这个算法在InnoDB存储引擎下称为<strong>midpoin insertion strategy</strong>。</p>
<p>那么old链表中的数据页什么时候能移动到new链表中呢？参数<code>InnoDB_old_blocks_time</code>可以控制这个时间：</p>
<ol>
<li>当InnoDB_old_blocks_time的参数值设置为0时。当old部分的数据页被访问到时，该数据页会被提升到链表的头部，并被标记为new数据页。</li>
<li>当InnoDB_old_blocks_time的参数值大于0时（以1000毫秒或者1秒为例）。old部分数据页插入缓冲池后，1秒之后再次被访问，则该数据页会被提升到链表的头部，并被标记为new数据页。在刚插入到一秒内，即便old部分的数据页被访问，该数据页也不会移动到new链表的头部。</li>
</ol>
<p><strong>那为什么不采用朴素的LRU算法，直接将最近被sql访问的页放入到LRU列表的首部呢?</strong></p>
<p>这是因为若直接将最近被访问到的页放入到LRU的首部，那么某些SQL操作可能会使热点的页被顶到靠后的位置去，从而LRU List的效率。</p>
<p>常见的这类操作为索引或数据的扫描操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。如果页被放入LRU列表的首部，那么<strong>非常可能将原本在队首的热点数据页顶到队尾，甚至因为内存空间原因从LRU列表中移除，导致在下一次需要读取该页时，InnoDB存储引擎需要再次访问磁盘</strong>。</p>
<h4 id="1-2-2-2-Free-List"><a href="#1-2-2-2-Free-List" class="headerlink" title="1.2.2.2 Free List"></a>1.2.2.2 Free List</h4><p>LRU列表用来管理已经读取的页，但当数据库刚启动时，LRU列表是空的，即没有任何的页。这时页都存放在Free List中。当需要在缓冲池中划分数据页时，首先从Free列表中查找是否有可用的空闲页。</p>
<ul>
<li><p>若有，则用磁盘中读取的数据填充该页，并将该页从Free列表中移动到LRU列表中。</p>
</li>
<li><p>若没有，则根据LRU算法，淘汰LRU列表末尾的页，将该内存空间分配给新的页。</p>
</li>
</ul>
<h4 id="1-2-2-3-Flush-List"><a href="#1-2-2-3-Flush-List" class="headerlink" title="1.2.2.3 Flush List"></a>1.2.2.3 Flush List</h4><p>在LRU列表中的页被修改后，称该页为脏页（dirty page），即缓冲池中的页和磁盘上的页的数据产生了不一致。这时数据库会通过CHECKPOINT机制将脏页刷新回磁盘，而Flush列表中的页即为脏页列表。</p>
<p>需要注意的是，脏页既存在于LRU列表中，也存在于 Flush列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。</p>
<h4 id="1-2-2-4-List状态查看"><a href="#1-2-2-4-List状态查看" class="headerlink" title="1.2.2.4 List状态查看"></a>1.2.2.4 List状态查看</h4><p>可以通过命令SHOW ENGINE INNODB STATUS来观察LRU列表，Free列表和Flush列表的使用情况和运行状态。</p>
<blockquote>
<p>当页从LRU列表的old部分加入到new部分时，称此时发生的操作为page made young，而因为innodb old_blocks time的设置而导致页没有从old部分移动到new部分的操作称为page not made young。</p>
</blockquote>
<p><img src="https://oscimg.oschina.net/oscnet/up-9eef4f0023da725e57ebf19d77ec6bef001.png" alt=""></p>
<p>通过命令SHOW_ENGINE_INNODB_STATUS可以看到∶当前Buffer_pool_size共有327679个页，即<code>327679*16K</code>，总共5GB的缓冲池。</p>
<p>Free buffers表示当前Free列表中页的数量，Database pages表示LRU列表中页的数量。可能的情况是Free buffers与Database pages的数量之和不等于Buffer pool size。正如之前所说的那样，因为缓冲池中的页还可能会被分配给自适应哈希索引、Lock信息、Insrt Buffer等页，而这部分页不需要LRU算法进行维护，因此不存在于LRU列表中。</p>
<p>pages made young 显示了LRU列表中页从old端移动到new端的次数，因为该服务器在运行阶段没有改变inodb old blocks_time的值，因此not young为0。</p>
<p>youngs/s、non-youngs 表示每秒这两类操作的次数。</p>
<p>Modifed db pages24673就显示了Flush List中脏页的数量。</p>
<p>这里还有一个重要的观察变量——Buffer pool hit rate，表示缓冲池的命中率，这个例子中为100%，说明缓冲池运行状态非常良好。通常该值不应该小于95%。若发生Bufer pool hit rate的值小于95%这种情况，用户需要观察是否是由于全表扫描引起的LRU 列表被污染的问题。</p>
<h3 id="1-2-3-重做日志缓冲"><a href="#1-2-3-重做日志缓冲" class="headerlink" title="1.2.3 重做日志缓冲"></a>1.2.3 重做日志缓冲</h3><p><img src="https://oscimg.oschina.net/oscnet/up-e84b63538abdf9181a48c21e0dadb862049.png" alt=""></p>
<p>在看上图，InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓冲（redo log buffer）。InoDB存储引擎首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置得很大，因为一般情况下每一秒钟会将重做日志缓冲刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。该值可由配置参数 innodb_log buffrsize控制，默认为8MB:</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7b1284e9ce4be6a5be54d776fc9850930b1.png" alt=""></p>
<p>在通常情况下，8MB的重做日志缓冲池足以满足绝大部分的应用，因为重做日志在下列三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。</p>
<ul>
<li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件;</li>
<li>每个事务提交时会将重做日志缓冲刷新到重做日志文件;</li>
<li>当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。</li>
</ul>
<h3 id="1-2-4-额外的内存池"><a href="#1-2-4-额外的内存池" class="headerlink" title="1.2.4 额外的内存池"></a>1.2.4 额外的内存池</h3><p>额外的内存池通常被DBA忽略，他们认为该值并不十分重要，事实恰恰相反，该值同样十分重要。在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆（heap）的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，会从缓冲池中进行申请。</p>
<p>例如，分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓冲（fame buffer）还有对应的缓冲控制对象（buffer control block），这些对象记录了一些诸如LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，在申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。</p>
<h1 id="2-InnoDB的关键特性"><a href="#2-InnoDB的关键特性" class="headerlink" title="2 InnoDB的关键特性"></a>2 InnoDB的关键特性</h1><p>InnoDB存储引擎的关键特性包括∶</p>
<ul>
<li>Checkpoint技术</li>
<li>插入缓冲（Insert Buffer）</li>
<li>两次写（Double Write）</li>
<li>自适应哈希索引（Adaptive Hash Index）</li>
<li>异步IO（Async IO）</li>
<li>刷新邻接页（Flush Neighbor Page）</li>
</ul>
<p>上述这些特性为InnoDB存储引擎带来更好的性能以及更高的可靠性。</p>
<h2 id="2-1-Checkpoint技术"><a href="#2-1-Checkpoint技术" class="headerlink" title="2.1 Checkpoint技术"></a>2.1 Checkpoint技术</h2><p>前面已经讲到了，缓冲池的设计目的为了协调 CPU速度与磁盘速度的鸿沟。因此页的操作首先都是在缓冲池中完成的。如果一条 DML语句，如 Update或Delete改变了页中的记录，那么此时页是脏的，即缓冲池中的页的版本要比磁盘的新。数据库需要将新版本的页从缓冲池刷新到磁盘。</p>
<p>刷新到磁盘的操作，就是Checkpoint。</p>
<p>倘若每次一个页发生变化，就将新页的版本刷新到磁盘，那么这个开销是非常大的。若热点数据集中在某几个页中，那么数据库的性能将变得非常差。同时，如果在从缓冲池将页的新版本刷新到磁盘时发生了宕机，那么数据就不能恢复了。为了避免发生数据丢失的问题，当前事务数据库系统普遍都采用了Write Ahead Log策略，即当事务提交时，先写重做日志，再修改页。当由于发生宕机而导致数据丢失时，通过重做日志来完成<strong>对未刷新到硬盘的数据的恢复</strong>。这也是事务 ACID中D（Durability持久性）的要求。</p>
<p>既然不能每次一个页发生变化，就将新页的版本刷新到磁盘，那么，什么时候将脏页数据刷新到硬盘是合适的呢？先不谈我们应该以什么频率进行一次Checkpoint，我们先来谈什么时候必须要Checkpoint（否则会导致 缓冲池+重做日志 机制出问题）</p>
<ol>
<li>当缓冲池不够用时：<ul>
<li>当缓冲池不够用时，根据LRU算法会清除最近最少使用的页，如果此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。</li>
</ul>
</li>
<li>重做日志出现不可用/不够用时：<ul>
<li>因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，这从成本及管理上都是比较困难的。<strong>重做日志中记录的已经被flush到磁盘中的部分，我们就认为它是可覆盖重用的</strong>。如果重做日志空间中没有可重用的部分，即目前重用日志记录的都是未flush到磁盘的数据，那么必须强制Checkpoint，使得部分重做日志变为可重用。</li>
</ul>
</li>
</ol>
<h3 id="2-1-1-LSN"><a href="#2-1-1-LSN" class="headerlink" title="2.1.1 LSN"></a>2.1.1 LSN</h3><p>对于InnoDB存储引擎而言，是通过LSN（Log Sequence Number）来标记版本的。LSN是一个一直递增的8字节整型数字，<strong>表示事务写入到redo日志的字节总量（注意LSN的含义是日志的字节总量）</strong>。每个页都有LSN字段，重做日志中也有LSN，Checkpoint也有LSN。</p>
<p>在每个数据页头部的LSN字段，记录当前页最后一次数据修改所对应的重做日志的LSN值，用于在recovery时对比重做日志LSN值，以决定是否对该页进行恢复数据。前面说的checkpoint也是有LSN号记录的，checkpoint的LSN表示已刷新到磁盘的最新的数据所对应的重做日志的LSN，LSN号串联起一个事务开始到恢复的过程。</p>
<blockquote>
<p>比如重做日志的文件是600M，LSN的值已经为1G了，也就是LSN=1000000000。因为重做日志是循环使用的，所以我们可以知道LSN=1G=600M+400M，所以重做日志已经重复使用过一整遍后，目前最新的可写入点，在重做日志偏移量400M的位置。</p>
</blockquote>
<blockquote>
<p>我们执行了一个update语句，产生了一个事务t，这次数据的修改，假设产生了512个字节的日志量，那么LSN就会增加到1000000512，而事务t的修改使得A、B、C三个数据页成为了脏页，那么A、B、C三个数据页的LSN值就会更新为1000000512。如果这时，触发了checkpoint，刚刚好将事务t为止的修改刷新到磁盘，那么此时checkpoint LSN也是1000000512。</p>
</blockquote>
<p>可以通过命令SHOW ENGINE INNODB STATUS来观察∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-179216b430c190ac9ad4b5262885db5ef73.png" alt=""></p>
<h3 id="2-1-2-Checkpoint发生的时机"><a href="#2-1-2-Checkpoint发生的时机" class="headerlink" title="2.1.2 Checkpoint发生的时机"></a>2.1.2 Checkpoint发生的时机</h3><p>在InnoDB存储引擎中，Checkpoint发生的时间、条件及脏页的选择等都非常复杂。而Checkpoint所做的事情无外乎是将缓冲池中的脏页刷回到磁盘。不同之处在于<strong>每次刷新多少页到磁盘，每次从哪里取脏页，以及什么时间触发Checkpoint</strong>。</p>
<p>在InnoDB存储引擎内部，有两种Checkpoint，分别为∶</p>
<ol>
<li>Sharp Checkpoint<ul>
<li>Sharp Checkpoint发生在数据库关闭时将所有的脏页都刷新回磁盘，这是默认的工作方式，即参数 innodb_fast_shutdown=1。</li>
</ul>
</li>
<li>Fuzy Checkpoint<ul>
<li>若数据库在运行时也使用Sharp Checkpoint，那么数据库的可用性就会受到很大的影响。故在InnoDB存储引擎内部使用Fuzzy Checkpoint 进行页的刷新，即只刷新一部分脏页，而不是刷新所有的脏页回磁盘。</li>
</ul>
</li>
</ol>
<p>在InnoDB存储引擎中可能发生如下几种情况的Fuzzy Checkpoint:</p>
<ol>
<li>Master Thread Checkpoint</li>
<li>FLUSH_LRU_LIST Checkpoint</li>
<li>Async/Sync Flush Checkpoint</li>
<li>Dirty Page too much Checkpoint</li>
</ol>
<h4 id="2-1-2-1-Master-Thread-Checkpoint"><a href="#2-1-2-1-Master-Thread-Checkpoint" class="headerlink" title="2.1.2.1  Master Thread Checkpoint"></a>2.1.2.1  Master Thread Checkpoint</h4><p>对于Master Thread中发生的Checkpoint，差不多以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。这个过程是异步的，即此时InnoDB存储引擎可以进行其他的操作，用户查询线程不会阻塞。</p>
<h4 id="2-1-2-2-FLUSH-LRU-LIST-Checkpoint"><a href="#2-1-2-2-FLUSH-LRU-LIST-Checkpoint" class="headerlink" title="2.1.2.2  FLUSH_LRU_LIST Checkpoint"></a>2.1.2.2  FLUSH_LRU_LIST Checkpoint</h4><p>FLUSH_LRU_LIST Checkpoint是因为InoDB存储引擎需要保证LRU列表中需要有差不多100个空闲页可供使用。在InoDB1.1.x版本之前，需要检查LRU列表中是否有足够可用空间的操作发生在用户查询线程中，显然这会阻塞用户的查询操作。</p>
<p>倘若没有100个可用空闲页，那么InoDB存储引擎会将LRU列表尾端的页移除。如果要移除的这些页中有脏页，那么需要进行Checkpoint，而这些页是来自LRU和FLUSH列表的，因此称为FLUSH_LRU_LIST Checkpoint。</p>
<p>而从MySQL5.6版本，也就是InnoDB1.2.x版本开始，这个检查被放在了一个单独的Page Cleaner线程中进行，并且用户可以通过参数innodb_Iru_scan_depth控制LRU列表中可用页的数量，该值默认为1024。</p>
<h4 id="2-1-2-3-Async-Sync-Flush-Checkpoint"><a href="#2-1-2-3-Async-Sync-Flush-Checkpoint" class="headerlink" title="2.1.2.3  Async/Sync Flush Checkpoint"></a>2.1.2.3  Async/Sync Flush Checkpoint</h4><p>Async/Sync Flush Checkpoint指的是重做日志文件不可用的情况，这时需要强制将一些页刷新回磁盘，而此时脏页是从脏页列表中选取的。</p>
<p>若将已经写入到重做日志的LSN记为redo_lsn，将已经刷新回磁盘最新页的LSN记为checkpoint_lsn，则可定义：</p>
<p><code>checkpoint_age = redo_lsn - checkpoint_lsn</code>，表示重做日志中还有多少个字节量的数据没有刷新到磁盘。</p>
<p>再定义以下的变量：</p>
<ol>
<li><code>async_water_mark = 75% * total_redo_log_file_size</code></li>
<li><code>sync_water_mark = 90% * total_redo_log_file_size</code></li>
</ol>
<p>若每个重做日志文件的大小为1GB，并且定义了两个重做日志文件，则重做日志文件的总大小为2GB。那么async_water_mark=1.5GB，sync_water_mark=1.8GB。则：</p>
<ol>
<li>当checkpoint_age&lt;async_water_mark时，不需要刷新任何脏页到磁盘；</li>
<li>当async_water_mark&lt;checkpoint_age&lt;sync_water_mark时触发Async Flush，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age&lt;async_water_mark；</li>
<li>当checkpoint_age&gt;sync_water_mark（这种情况一般很少发生，除非设置的重做日志文件太小，并且在进行类似LOAD DATA的BULK INSERT操作），此时触发Sync Flush操作，从Flush列表中刷新足够的脏页回磁盘，使得刷新后满足checkpoint_age&lt;async_water_mark。</li>
</ol>
<p>可见，Async/Sync Flush Checkpoint是为了保证重做日志的循环使用的可用性。在InnoDB 1.2.x版本之前，Async Flush Checkpoint会阻塞发现问题的用户查询线程，而Sync Flush Checkpoint会阻塞所有的用户查询线程，并且等待脏页刷新完成。从InnoDB 1.2.x版本开始——也就是MySQL 5.6版本，这部分的刷新操作同样放入到了单独的Page Cleaner Thread中，故不会阻塞用户查询线程。</p>
<h4 id="2-1-2-4-Dirty-Page-too-much-Checkpoint"><a href="#2-1-2-4-Dirty-Page-too-much-Checkpoint" class="headerlink" title="2.1.2.4  Dirty Page too much Checkpoint"></a>2.1.2.4  Dirty Page too much Checkpoint</h4><p>即脏页的数量太多，导致InnoDB存储引擎强制进行Checkpoint。其目的总的来说还是为了保证缓冲池中有足够可用的页。其可由参数innodb_max_dirty_pages_pct控制：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4e9f8a50c529eeb28cbe8b5eb5bec171543.png" alt=""></p>
<p>innodb_max_dirtypages_pct值为75表示，当缓冲池中脏页的数量占据75%时，强制进行Checkpoint，刷新一部分的脏页到磁盘。在InnoDB 1.0.x版本之前，该参数默认值为90，之后的版本都为75。</p>
<h2 id="2-2-插入缓冲"><a href="#2-2-插入缓冲" class="headerlink" title="2.2 插入缓冲"></a>2.2 插入缓冲</h2><p>插入缓冲本质上是对于为非唯一索引而言的，即对辅助索引的修改操作并非实时更新磁盘中索引的叶子页（索引存于该表的ibd文件中），而是把若干对同一页面的更新缓存起来做，合并为一次性更新操作，减少IO，转随机IO为顺序IO，这样可以避免随机IO带来性能损耗，提高数据库的写性能</p>
<h3 id="2-2-1-Insert-Buffer"><a href="#2-2-1-Insert-Buffer" class="headerlink" title="2.2.1 Insert Buffer"></a>2.2.1 Insert Buffer</h3><p>Insert Buffer可能是InnoDB存储引擎关键特性中最令人激动与兴奋的一个功能。insert buffer是一种特殊的数据结构（B+ tree）并不是缓存的一部分，而是物理页。</p>
<p>在InoDB存储引擎中，主键是行唯一的标识符。通常应用程序中行记录的插人顺序是按照主键递增的顺序进行插入的。因此，插入聚集索引（Primary Key）一般是顺序的，不需要磁盘的随机读取。</p>
<p>但一个表除了聚集索引外，还可能定义辅助索引，我们知道InnoDB中辅助索引是非聚集的。假设我们有一张表t，其中主键是id字段，除此之外还在name字段上面建了一个辅助索引。那么我们在表t每插入一条数据，<strong>都需要在id聚集索引树和name非聚集索引上新增索引节点</strong>。</p>
<ul>
<li><p>前面说过，因为表t的插入顺序就是按照主键自增的，而id聚集索引又是按照id排序的，所以在id聚集索引上新增节点十分方便，只要在顺序插入即可，性能很高。</p>
</li>
<li><p>而在name非聚集索引上新增索引节点，因为表t记录的插入顺序按照id自增的顺序，不是按照name自增的顺序，但name非聚集索引又是按照name字段顺序排列的，所以表t的每次插入，都需要在name非聚集索引上离散的插入新的索引节点，随机IO的消耗太大，性能十分蛋疼。</p>
</li>
</ul>
<p>为了应对这种情况，InnoDB存储引擎开创性地设计了Insert Buffer，对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入;若不在，则先放入到一个Insert Buffer对象中。</p>
<p>好似欺骗数据库这个非聚集的索引已经插到叶子节点了，而实际并没有，只是存放在另一个位置。然后再以Master Thread的调度规则进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为插入的都是在一个索引页中），这就大大提高了对于非聚集索引插人的性能。</p>
<p>然而Insert Buffer的使用需要同时满足以下三个条件∶</p>
<ol>
<li>修改的非聚集索引页不在缓冲池中<ul>
<li>因为如果在缓冲池中，直接改缓冲池就行了，改内存不比改磁盘，没有什么顺序IO/随机IO的性能差异。</li>
</ul>
</li>
<li>索引是辅助索引（secondary index）;<ul>
<li>因为聚集索引的性能很好，不需要用到Insert Buffer。</li>
</ul>
</li>
<li>辅助索引不是唯一（unique）的。<ul>
<li>因为如果辅助索引是唯一的，那么在插入辅助索引树前，要先判断插入的值是否已经在树中重复了，查询操作又是随机IO。</li>
<li>本来Insert Buffer就是为了避免随机IO，既然唯一性辅助索引的插入避免不了随机IO，那Insert Buffer也就没有什么意义了。</li>
</ul>
</li>
</ol>
<h3 id="2-2-2-Change-Buffer"><a href="#2-2-2-Change-Buffer" class="headerlink" title="2.2.2 Change Buffer"></a>2.2.2 Change Buffer</h3><p>InnoDB从1.0.x版本开始引入了Change Buffer，可将其视为Insert Buffer的升级。从这个版本开始，InnoDB存储引擎可以对DML操作——INSERT、DELETE、UPDATE 都进行缓冲，他们分别是∶Insert Buffer、Delete Buffer、Purge buffer。</p>
<p>当然和之前Insert Buffer一样，Change Buffer适用的对象依然是非唯一的辅助索引。</p>
<p>同时，InnoDB存储引擎提供了参数innodb_change_buffering，用来开启各种Buffer的选项。该参数可选的值为∶inserts、deletes、purges、changes、all、none。</p>
<p>inserts、deletes、purges就是前面讨论过的三种情况。changes表示启用inserts和deletes，all表示启用所有，none表示都不启用。该参数默认值为 all。</p>
<p>从InnoDB1.2.x版本开始，可以通过参数innodb_change_buffr_max_size来控制Change Buffer最大使用内存的数量∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-825381052046516637f1d890d48c522270b.png" alt=""></p>
<p>innodb_change_buffer_max_size值默认为25，表示最多使用1/4的缓冲池内存空间。而需要注意的是，该参数的最大有效值为 50。</p>
<h3 id="2-2-3-Insert-Buffer的内部实现"><a href="#2-2-3-Insert-Buffer的内部实现" class="headerlink" title="2.2.3 Insert Buffer的内部实现"></a>2.2.3 Insert Buffer的内部实现</h3><p>Insert Buffer具体是什么呢，内部怎么实现呢？</p>
<p>可能令绝大部分用户感到吃惊的是，Insert Buffer的数据结构是一棵B+树。在MySQL 4.1之前的版本中每张表有一棵Insert Buffer B+树。而在现在的版本中，全局只有一棵Insert Buffer B+树，负责对所有的表的辅助索引进行Insert Buffer。而这棵B+树存放在共享表空间中，默认也就是ibdatal中。</p>
<p>因此，试图通过独立表空间ibd文件恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，也就是共享表空间中，所以通过ibd文件进行恢复后，还需要进行REPAIR TABLE 操作来重建表上所有的辅助索引。</p>
<p>Insert Buffer是一棵B+树，因此其也由叶节点和非叶节点组成。非叶节点存放的是查询的search key（键值），其构造如下图所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2bd374d3dcb4e982cd4da066ba7b9114187.png" alt=""></p>
<p>search key一共占用9个字节，其中</p>
<ul>
<li>space表示待插入记录所在表的表空间id，在InnoDB存储引擎中，每个表有一个唯一的 space id，可以通过 space id查询得知是哪张表。space占用4字节。</li>
<li>marker占用1字节，它是用来兼容老版本的Insert Buffer。</li>
<li>offset 表示页所在的偏移量，你可以理解为页的下标，用来定位页的位置，占用4字节。</li>
</ul>
<p>当一个辅助索引要插入到页（由&lt;space，offset&gt;这个二元组可唯一定位一个页）时，如果这个页不在缓冲池中，那么InnoDB存储引擎首先根据上述规则构造一个search key结构，接下来查询Insert Buffer这棵B+树，然后再将这条记录插入到Insert Buffer B+树的合适的叶子节点中。</p>
<p>和非叶子节点一样，Insert Buffer B+树的叶子节点也有一种特殊的结构：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1ac9a52fd0af013c98409c4c54f0db82ce6.png" alt=""></p>
<ul>
<li>space、marker、offset字段和之前非叶节点中的含义相同，一共占用9字节。</li>
<li>第4个字段metadata 占用4字节，其存储的内容如下表所示。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-8a6dcb73257c42cedfaa860f8cb949d8f3b.png" alt=""></li>
<li>最核心的字段是IBUF_REC_OFFSET_COUNT字段，它保存两个字节的整数，用来排序每个记录进入Insert Buffer的顺序。因为从InnoDB1.0.x开始支持Change Buffer，所以这个值同样记录进入Change Buffer的顺序。merge的时候通过这个顺序回放（replay）才能得到记录的正确值。</li>
</ul>
</li>
<li>从Insert Buffer 叶子节点的第5列开始，就是实际插入记录的各个字段了。因此较之原插入记录，Insert Buffer B+树的叶子节点记录需要额外13字节的开销。</li>
</ul>
<p>因为启用Insert Buffer索引后，辅助索引页（space，offset）中的记录可能被插入到Insert Buffer B+树中，所以为了保证每次Merge Insert Buffer页都能成功，还需要有一个特殊的页用来标记每个辅助索引页（space，offset）的可用空间。这个页的类型为Insert Buffer Bitmap。</p>
<p>每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，也就是256个区（Extent）。<strong>每个辅助索引页</strong>在Insert Buffer Bitmap页中占用4位（bit），这四位的含义见下表</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a9bdfd3ef86c322ef4b88df4ccc1ca4192a.png" alt=""></p>
<h3 id="2-2-4-Merge-Insert-Buffer"><a href="#2-2-4-Merge-Insert-Buffer" class="headerlink" title="2.2.4 Merge Insert Buffer"></a>2.2.4 Merge Insert Buffer</h3><p>我们已经知道了Insert/Change Buffer是一棵B+树。若需要做插入操作的辅助索引页不在缓冲池中，那么需要将辅助索引记录首先插入到这棵B+树中。但是Insert Buffer中的记录何时合并（merge）到真正的辅助索引中呢?这是我们接下来关注的重点。</p>
<p>概括地说，Merge Insert Buffer的操作可能发生在以下几种情况下∶</p>
<ol>
<li>辅助索引页被读取到缓冲池时;<ul>
<li>例如这在执行正常的SELECT查询操作，如果辅助索引页不在缓冲池中，这时我们需要优先将辅助索引读入缓冲池</li>
<li>紧接着检查Insert Buffer Bitmap页，看看该辅助索引页是否有记录存放于Insert Buffer B+树中。若有，则将Insert Buffer B+树中该页的记录插入到缓冲池中的该辅助索引页中。</li>
<li>这样便可以将对该页多次的记录操作通过一次操作合并到了原有的辅助索引页中，因此性能会有大幅提高。</li>
</ul>
</li>
<li>Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时;<ul>
<li>Insert Buffer Bitmap页用来追踪每个辅助索引页的可用空间，若插入辅助索引记录时检测到插入记录后，辅助索引页的可用空间会小于1/32页，则会强制进行一个合并操作，即强制读取辅助索引页至缓冲池，然后将Insert Buffer B+树中该页的记录及待插入的记录插入到缓冲池的辅助索引页中。</li>
</ul>
</li>
<li>Master Thread。<ul>
<li>在Master Thread线程中每秒或每10秒会进行一次Merge Insert Buffer的操作，不同之处在于每次进行merge操作的页的数量不同。</li>
<li>在Master Thread中，执行merge操作的不止是一个页，而是根据 srv_inodb io capactiy的百分比来决定真正要合并多少个辅助索引页。</li>
</ul>
</li>
</ol>
<p>那么InnoDB存储引擎又是根据怎样的算法来确定Insert Buffer B+树中哪些记录是需要合并的呢?</p>
<p>在Insert Buffer B+树中，辅助索引修改记录会根据（space，offset）排序好，故可以根据（space，offset）的排序顺序进行页的选择。然而，对于Insert Buffer页的选择，InnoDB存储引擎并非采用这个方式，<strong>它随机地选择Insert Buffer B+树的一个页，读取该页中的space及之后所需要数量（不同场景需要的数量不同）的页</strong>。</p>
<p>该算法在复杂情况下应有更好的公平性。</p>
<p>同时，若进行merge时，要进行merge的表已经被删除，此时可以直接丢弃已经被Insert/Change Buffer 的数据记录。</p>
<h3 id="2-2-5-缓冲池和Insert-Buffer的区别"><a href="#2-2-5-缓冲池和Insert-Buffer的区别" class="headerlink" title="2.2.5 缓冲池和Insert Buffer的区别"></a>2.2.5 缓冲池和Insert Buffer的区别</h3><p>我们前面学过缓冲池技术，假如我们要修改页号为40的索引页，而这个页正好不在缓冲池内。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-120ef3437c3b0858f837b70172467832f83.png" alt=""></p>
<p>此时我们依照缓冲池的机制，整个写过程如上图需要3步：</p>
<ol>
<li>先把需要为40的索引页，从磁盘加载到缓冲池，<strong>一次磁盘随机读操作</strong>；</li>
<li>修改缓冲池中的页，一次内存操作；</li>
<li>写入redo log，一次磁盘顺序写操作；</li>
</ol>
<blockquote>
<p>注意：没有命中缓冲池的时候，至少产生一次磁盘IO？</p>
</blockquote>
<p>而InnoDB加入Insert Buffer优化后，则写入流程优化为：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-16b0c1d81b9eda5ab4ee808299dc7421a04.png" alt=""></p>
<ol>
<li>在Insert Buffer B+树中记录这个操作，一次内存操作；</li>
<li>写入redo log，一次磁盘顺序写操作；</li>
</ol>
<p>可以看到，Insert Buffer机制能在缓冲池技术的基础上减少一次磁盘IO，其性能与这个索引页在缓冲池中的情况相近。可以看到，40这一页，并没有加载到缓冲池中。此时数据库异常奔溃，则能够从redo log中恢复数据；</p>
<p>假设稍后的一个时间，有请求查询索引页40的数据。</p>
<p>此时的流程如序号1-3：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b0af759bbe0a2de82eda2ea19bfcadb0fe1.png" alt=""></p>
<ol>
<li>缓冲池未命中，则从磁盘载入索引页，这次磁盘IO不可避免；</li>
<li>从Insert Buffer B+树中读取辅助索引页的修改记录；</li>
<li>根据Insert Buffer修改从缓存载入的索引页，使其达到最终态，并放到缓冲池LRU List里；</li>
</ol>
<p>可以看到，40这一页，在真正被读取时，才会被加载到缓冲池中。</p>
<blockquote>
<p>注意，insert buffer的merge操作是将索引文件从磁盘载入到缓冲池的索引页中，并且将insert buffer里的更改再执行到缓冲池索引页上。</p>
</blockquote>
<blockquote>
<p>系统大部分空闲时或在慢速关闭期间运行的清除（purge）操作会定期将缓冲池中的辅助索引页（此时一般为脏页）写入磁盘。与每个值立即写入磁盘相比，purge操作可以更有效地为一系列索引值写入磁盘块。</p>
</blockquote>
<h3 id="2-2-6-查看insert-change-Buffer"><a href="#2-2-6-查看insert-change-Buffer" class="headerlink" title="2.2.6 查看insert/change Buffer"></a>2.2.6 查看insert/change Buffer</h3><p>用户可以通过命令SHOW ENGINE INNODB STATUS来查看Insert Buffer的信息∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-82548d7a2a410db63648a82d24d08e4ac03.png" alt=""><br><img src="https://oscimg.oschina.net/oscnet/up-bed6c7af819e278cdd9e697ccbf046517d1.png" alt=""></p>
<ul>
<li>seg size显示了当前Insert Buffer的大小为11336×16KB，大约为177MB;</li>
<li>free list len代表了空闲列表的长度;</li>
<li>size代表了已经合并记录页的数量。</li>
</ul>
<p>而黑体部分的第2行可能是用户真正关心的，因为它显示了插入性能的提高。</p>
<ul>
<li>Inserts代表了插入的记录数;</li>
<li>mergedrecs代表了合并的插入记录数量;</li>
<li>merges代表合并的次数，也就是实际读取页的次数。</li>
<li>merges∶merged recs大约为1∶3，代表了插入缓冲将对于非聚集索引页的离散1O 逻辑请求大约降低了23。</li>
</ul>
<p>在MySQL5.5版本中通过命令SHOW ENGINE INNODB STATUS，可以观察到change Buffer的信息∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9c1fb50810e2009f3fb819b428f073d3292.png" alt=""><br><img src="https://oscimg.oschina.net/oscnet/up-ac6e49a8c5cdb7ce94a0622768d87f4d314.png" alt=""></p>
<p>可以看到这里显示了merged operations和discarded operation，并且下面具体显示Change Buffr中每个操作的次数。</p>
<ul>
<li>insert表示Insert Buffer;</li>
<li>delete mark表示 Delete Buffer;</li>
<li>delete表示Purge Buffer;</li>
<li>discarded operations表示当Change Buffer发生merge 时，表已经被删除，此时就无需再将记录合并（merge）到辅助索引中了。</li>
</ul>
<h2 id="2-3-两次写"><a href="#2-3-两次写" class="headerlink" title="2.3 两次写"></a>2.3 两次写</h2><p>如果说Insert Buffer带给InnoDB存储引擎的是性能上的提升，那么doublewrite（两次写）带给InnoDB存储引擎的是数据页的可靠性。</p>
<p><strong>当发生数据库宕机时，可能InnoDB存储引擎正在将某个页写入到表中，而这个页只写了一部分</strong>，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效（partial page write）。在InnoDB存储引擎未使用doublewrite技术前，曾经出现过因为部分写失效而导致数据丢失的情况。</p>
<p>有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复。这是一个办法。<strong>但是必须清楚地认识到，重做日志中记录的是对页的物理操作，如偏移量800，写’aaa’记录。如果这个页本身已经发生了损坏，再对其进行重做是没有意义的</strong>。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。在InnoDB存储引擎中doublewrite的体系架构如下图所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4f4227efdd3deb6b3833306e6ad4459082b.png" alt=""></p>
<p>doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中连续的128个页，即2个区（extent），大小同样为2MB。</p>
<p>在对缓冲池的脏页进行flush时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次IMB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。</p>
<p>在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时的写入则是离散的。可以通过以下命令观察到doublewrite 运行的情况∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-06e023bef3b3f3788a047f8175cd2c0b6f1.png" alt=""></p>
<p>可以看到，doublewrite一共写了6325194个页，但实际的写人次数为100399，基本上符合64∶1。</p>
<p>如果发现系统在高峰时的Innodb_dblwr_pages_written∶Innodb_dblwr_writes远小于64∶1，那么可以说明系统写人压力并不是很高。</p>
<p>如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件，再应用重做日志。</p>
<p><strong>参数skip_innodb_doublewrite可以禁止使用doublewrite功能</strong>，这时可能会发生前面提及的写失效问题。不过如果用户有多个从服务器（slave server），需要提供较快的性能（如在slaves server上做的是RAID0），也许启用这个参数是一个办法。不过对于需要提供数据高可靠性的主服务器（master server），任何时候用户都应确保开启doublewrite 功能。</p>
<h2 id="2-4-自适应哈希索引"><a href="#2-4-自适应哈希索引" class="headerlink" title="2.4 自适应哈希索引"></a>2.4 自适应哈希索引</h2><p>哈希（hash）是一种非常快的查找方法，在一般情况下这种查找的时间复杂度为O（1），即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般为3～4层，故需要3～4次的查询。</p>
<p><strong>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）</strong>。</p>
<p>AHI是通过<strong>缓冲池</strong>中的的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p>
<p>AHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引页，其访问模式可以是以下情况∶</p>
<ol>
<li>WHERE a=xxx</li>
<li>WHERE a=xxx and b=xxx</li>
</ol>
<p>访问模式一样指的是查询的条件一样，若交替进行上述两种查询，那么InnoDB存储引擎不会对该页构造 AHI。</p>
<p>此外 AHI 还有如下的要求∶</p>
<ol>
<li>以该模式访问了100次</li>
<li>页通过该模式访问了N次，其中<code>N=页中记录/16</code></li>
</ol>
<p>根据InnoDB存储引擎官方的文档显示，启用AHI后，读取和写入速度可以提高2 倍，辅助索引的连接操作性能可以提高5倍。毫无疑问，AHI是非常好的优化模式，其设计思想是数据库自优化的（self-tuning），即无需 DBA对数据库进行人为调整。</p>
<p>通过命令SHOW ENGINE INNODB STATUS可以看到当前AHI的使用状况∶</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-69ad2998f5404052484ea0489a357b90bb4.png" alt=""></p>
<p>现在可以看到AHI的使用信息了，包括AHI的大小、使用情况、每秒使用AHI搜索的情况。</p>
<p>值得注意的是，哈希索引只能用来搜索等值的查询，如<code>SELECT* FROM table WHERE index_col=&#39;xxx&#39;</code>。而对于其他查找类型，如范围查找，是不能使用哈希索引的，因此这里出现了non-hash searches/s的情况。通过 hash searches∶non-hash searches的比值，可以大概了解使用哈希索引后的效率。</p>
<p>参数 innodb_adaptive_hash_index可以控制是否启动AHI。</p>
<h2 id="2-5-异步IO"><a href="#2-5-异步IO" class="headerlink" title="2.5 异步IO"></a>2.5 异步IO</h2><p>为了提高磁盘操作性能，当前的数据库系统都采用异步IO（Asynchronous IO，AIO）的方式来处理磁盘操作。InnoDB存储引擎亦是如此。</p>
<p>与AIO对应的是Sync IO，即每进行一次IO操作，需要等待此次操作结束才能继续接下来的操作。但是如果用户发出的是一条索引扫描的查询，那么这条SQL查询语句可能需要扫描多个索引页，也就是需要进行多次的IO操作。在每扫描一个页并等待其完成后再进行下一次的扫描，这是没有必要的。用户可以在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。</p>
<p>AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能。例如用户需要访问页的（space，page_no）为∶<code>(8,6)，(8,7)，(8,8)</code></p>
<p>每个页的大小为16KB，那么同步IO需要进行3次IO操作。而AIO会判断到这三个页是连续的（显然可以通过（space，page_no）得知）。因此AIO底层会发送一个IO 请求，从（8，6）开始，读取48KB的页。</p>
<p>在InnoDB1.1.x之前，AIO的实现通过InnoDB存储引擎中的代码来模拟实现。而从InnoDB1.1.x开始（InnoDB Plugin不支持），提供了内核级别AIO的支持，称为Native AIO。因此在编译或者运行该版本MySQL时，需要libaio库的支持。</p>
<p>需要注意的是，Native AIO需要操作系统提供支持。Windows系统和Linux系统都提供Native AIO支持，参数<code>innodb_use_native_aio</code>用来控制是否启用Native AIO，在Linux操作系统下，默认值为 ON。</p>
<p>用户可以通过开启和关闭Native AIO功能来比较InnoDB性能的提升。官方的测试显示，启用Native AIO，恢复速度可以提高 75%。</p>
<p>在InnoDB存储引擎中，read ahead方式的读取都是通过AIO完成，脏页的刷新，即磁盘的写人操作则全部由 AIO完成。</p>
<h2 id="2-6-刷新邻接页"><a href="#2-6-刷新邻接页" class="headerlink" title="2.6 刷新邻接页"></a>2.6 刷新邻接页</h2><p>InnoDB存储引擎还提供了Flush Neighbor Page（刷新邻接页）的特性。其工作原理为∶当flush一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行flush。</p>
<p>这样做的好处显而易见，通过AIO可以将多个IO写人操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势。但是需要考虑到下面两个问题∶</p>
<ol>
<li>是不是可能将不怎么脏的页进行了写入，而该页之后又会很快变成脏页?</li>
<li>固态硬盘有着较高的IOPS，是否还需要这个特性?</li>
</ol>
<p>为此，InnoDB存储引擎从1.2x版本开始提供了参数 innodb_flush_neighbors，用来控制是否启用该特性。对于传统机械硬盘建议启用该特性，而对于固态硬盘有着超高IOPS性能的磁盘，则建议将该参数设置为0，即关闭此特性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/13/%E8%AF%A6%E8%A7%A3IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%85%B6%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94select-poll-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/13/%E8%AF%A6%E8%A7%A3IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%85%B6%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94select-poll-epoll/" itemprop="url">详解IO多路复用和其三种模式——select/poll/epoll</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-13T22:52:48+08:00">
                2020-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/Linux%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">Linux相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/13/%E8%AF%A6%E8%A7%A3IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%85%B6%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94select-poll-epoll/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/13/详解IO多路复用和其三种模式——select-poll-epoll/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们平常采用的多进程方式实现的服务器端，即一次创建多个工作子进程来给客户端提供服务。其实这种方式是存在问题的。</p>
<p>可以打个比方：如果我们先前创建的几个进程承载不了目前快速发展的业务的话，是不是还得增加进程数？我们都知道系统创建进程是需要消耗大量资源的，多进程方式实现的服务器端会导致系统出现资源不足的情况。</p>
<p>那么有没有一种方式可以让一个进程同时为多个客户端端提供服务？</p>
<p>接下来要讲的<strong>IO多路复用技术</strong>就是对于上述问题的最好解答。即一个进程同时为多个客户端端提供服务。</p>
<p>对于IO复用，我们可以通过一个例子来很好的理解它。（例子来自于《TCP/IP网络编程》）</p>
<p>某教室有10名学生和1名老师，这些学生上课会不停的提问，所以一个老师处理不了这么多的问题。那么学校为每个学生都配一名老师，</p>
<p>也就是这个教室目前有10名老师。此后，只要有新的转校生，那么就会为这个学生专门分配一个老师，因为转校生也喜欢提问题。如果把以上例子中的学生比作客户端，那么老师就是负责进行数据交换的服务端。则该例子可以比作是多进程的方式。</p>
<p>后来有一天，来了一位具有超能力的老师，这位老师回答问题非常迅速，并且可以应对所有的问题。而这位老师采用的方式是学生提问前必须先举手，老师确认举手学生后再回答问题，这就是IO复用。</p>
<p>目前的常用的IO复用模型有三种：select，poll，epoll。</p>
<p>在了解IO复用模型前，我们需要连接一些<strong>Linux操作系统</strong>中的前置知识。</p>
<h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1 前置知识"></a>1 前置知识</h1><h2 id="1-1-socket编程"><a href="#1-1-socket编程" class="headerlink" title="1.1 socket编程"></a>1.1 socket编程</h2><p>socket编程内容繁多，具体详见该文章</p>
<p><a href="https://blog.csdn.net/hguisu/article/details/7445768" target="_blank" rel="noopener" title="Linux的SOCKET编程详解">Linux的SOCKET编程详解</a></p>
<h2 id="1-2-用户空间-内核空间"><a href="#1-2-用户空间-内核空间" class="headerlink" title="1.2 用户空间 / 内核空间"></a>1.2 用户空间 / 内核空间</h2><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。</p>
<p>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
<h2 id="1-3-文件描述符"><a href="#1-3-文件描述符" class="headerlink" title="1.3 文件描述符"></a>1.3 文件描述符</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述<strong>指向文件的引用</strong>的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。</p>
<p>我们都知道在Linux下一切皆文件。当然设备也不例外，如果要对某个设备进行操作，就不得不打开此设备文件，打开文件就会获得该文件的文件描述符fd( file discriptor)，它就是一个很小的整数。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-27980055d2ce450a71129b9f92c697d9df0.png" alt=""></p>
<p>每个进程在PCB（Process Control Block，进程控制块）中保存着一份文件描述符表，文件描述符就是这个表的索引，文件描述符表中每个表项都有一个指向已打开文件的指针。<strong>现在我们明确一下：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体</strong>。file结构体才是内核中用来描述文件属性的结构体。</p>
<p>file结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct FILE</span><br><span class="line">&#123;</span><br><span class="line">    char *_ptr;&#x2F;&#x2F;文件输入的下一个位置</span><br><span class="line">    int _cnt;&#x2F;&#x2F;当前缓冲区的相对位置</span><br><span class="line">    char *_base;&#x2F;&#x2F;指基础位置（文件的起始位置）</span><br><span class="line">    int _flag;&#x2F;&#x2F;文件标志</span><br><span class="line">    int _file;&#x2F;&#x2F;文件的有效性验证</span><br><span class="line">    int _charbuf;&#x2F;&#x2F;检查缓冲区状况，如果缓冲区则不读取</span><br><span class="line">    int _bufsiz;&#x2F;&#x2F;文件的大小</span><br><span class="line">    char *_tmpfname;&#x2F;&#x2F;临时文件名</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体详见文章<a href="https://blog.csdn.net/mm_hh/article/details/71374474" target="_blank" rel="noopener" title="Linux下 文件描述符（fd）与 文件指针（FILE*）">Linux下 文件描述符（fd）与 文件指针（FILE*）</a></p>
<h1 id="2-select模式"><a href="#2-select模式" class="headerlink" title="2 select模式"></a>2 select模式</h1><p>select模型的原理，套用前言中的老师回答学生问题的例子，则是：<strong>老师仅仅知道有学生举手了，但是到底是哪些学生举手了，他需要用眼睛扫描一遍全班同学，找出举手的同学，然后倾听他的问题，并回答他的问题</strong>。</p>
<p>所以select具有O(n)的无差别轮询时间复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
<h2 id="2-1-select函数"><a href="#2-1-select函数" class="headerlink" title="2.1 select函数"></a>2.1 select函数</h2><p>Linux系统提供了一个函数来供开发者使用select多路复用机制：</p>
<p><code>int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout);</code></p>
<p>该函数的作用是：<strong>通过轮询，可以同时监视多个文件描述符是否发生了读/写/异常这三类IO变化，最后返回发生变化的文件描述符数量，以及读/写/异常这三种变化分别发生在哪些文件描述符中</strong>。</p>
<p>我们来看看它的参数的含义：</p>
<blockquote>
<p>在看参数前，我们要了解：struct fd_set可以理解为一个集合，这个集合中存放的是文件描述符(file descriptor)，即文件句柄。fd_set集合可以通过下列宏由人为来操作。<br>FD_ZERO(fd_set *fdset)：清空fdset与所有文件句柄的联系。<br>FD_SET(int fd, fd_set *fdset)：建立文件句柄fd与fdset的联系。<br>FD_CLR(int fd, fd_set *fdset)：清除文件句柄fd与fdset的联系。<br>FD_ISSET(int fd, fdset *fdset)：检查fdset联系的文件句柄fd是否可读写，&gt;0表示可读写。</p>
</blockquote>
<ol>
<li><p>int maxfdp：是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。</p>
</li>
<li><p>readfds：传入select函数的需要被监控读IO的fd_set文件描述符集合，select函数会负责监视readfds的读变化，如果readfds中的某个文件描述符指向的文件能读出数据，那么在返回的时候，select不仅会统计它的数量，而且还会改写readfds，以标出是它的位置。</p>
</li>
<li><p>writefds：传入select函数的需要被监控写IO的fd_set文件描述符集合，select函数会负责监视writefds的写变化，如果writefds中的某个文件描述符指向的文件能写入数据，那么在返回的时候，select不仅会统计它的数量，而且还会改写writefds，以标出是它的位置。</p>
</li>
<li><p>errorfds：传入select函数的需要被监控异常IO的fd_set文件描述符集合，select函数会负责监视errorfds的异常变化，如果readfds中的某个文件描述符指向的文件能读出异常数据，那么在返回的时候，select不仅会统计它的数量，而且还会改写errorfds，以标出是它的位置。</p>
</li>
<li><p>struct timeval：用来代表时间值，有两个成员，一个是秒数，另一个是毫秒数。 </p>
<ol>
<li>若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；</li>
<li>若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；</li>
<li>timeout的值如果大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct timeval&#123;</span><br><span class="line"></span><br><span class="line">	long tv_sec;   &#x2F;*秒 *&#x2F;</span><br><span class="line"></span><br><span class="line">	long tv_usec;  &#x2F;*微秒 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="2-2-select函数的使用"><a href="#2-2-select函数的使用" class="headerlink" title="2.2 select函数的使用"></a>2.2 select函数的使用</h2><p>select函数用来验证3种读、写、异常三种监视项的变化情况。使用前，我们先声明3个fd_set变量，然后分别向其注册文件描述符信息，并把变量的地址传入到函数的readfds/writefds/errorfds参数上。</p>
<p>同时我们要明确要监控的文件描述符数量，原本这个数量不好计算，但好在每次新建文件描述符时，其值（文件描述符是非负整数）都会增1，故只需将最大的文件描述符值加1（因为文件描述符从0开始，所以要+1）再传递到select函数的maxfdp参数即可。</p>
<p>最后再设置一下超时时间（如果需要的话）到timeval参数即可。</p>
<h2 id="2-3-select函数的返回"><a href="#2-3-select函数的返回" class="headerlink" title="2.3 select函数的返回"></a>2.3 select函数的返回</h2><p>在超时时间之内，如果三个fd_set对应的文件描述符有变化，那么select会返回一个大于0的值，表示<strong>发生变化的文件描述符数量</strong>。如果没有变化，则在timeout的时间后select返回0，若发生错误返回负值。</p>
<p>那么问题来了，select函数只返回了变化的文件描述符数量，那么怎样获知哪些文件描述符发生了变化呢？</p>
<p>原来select函数还会改写传进去的readfds/writefds/errorfds集合，即将他们都用<code>FD_ZERO(fd_set *fdset)</code>清空，即fd_set中的所有位数都置为0，然后如果某个文件描述符有读IO，那么在其对应项上用<code>FD_SET(int fd, fd_set *fdset)</code>来设置1；</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1f994da65488ceafb471a4eb3d2edc6c75f.png" alt=""></p>
<p>select函数调用完成后，向其传递的fd_set变量中将发生变化。发生变化的文件描述符对应位除外，其他原来为1的所有位均变为0。因此，可以认为readfds中值为1的位置上的文件描述符发生了读变化，writefds中值为1的位置上的文件描述符发生了写变化，errorfds中值为1的位置上的文件描述符发生了异常变化。</p>
<blockquote>
<p>因为传入的三个fd_set会被改写，所以使用前记得备份原set。</p>
</blockquote>
<h2 id="2-4-select的实现机制"><a href="#2-4-select的实现机制" class="headerlink" title="2.4 select的实现机制"></a>2.4 select的实现机制</h2><p>我们来简单了解一下select机制的源码：</p>
<ol>
<li>使用copy_from_user从用户空间拷贝fd_set到内核空间</li>
<li>注册回调函数__pollwait，__pollwait的主要工作就是把current进程（当前进程）挂到设备的等待队列中，不同的设备有不同的等待队列，对于tcp_poll来说，其等待队列是sk-&gt;sk_sleep（注意把进程挂到等待队列中并不代表进程已经睡眠了）。驱动程序在得知设备有IO事件时（通常是该设备上IO事件中断），会调用wakeup，wakeup –&gt; _wake_up_common -&gt; curr-&gt;func(即pollwake)，pollwake函数里面调用_pollwake函数, 通过pwq-&gt;triggered = 1将进程标志为唤醒。再调用default_wake_function(&amp;dummy_wait, mode, sync, key)这个默认的通用唤醒函数唤醒调用select的进程，这时current进程便被唤醒了。</li>
<li>遍历所有fd，依次调用其fd的poll方法（对于socket，这个poll方法是sock_poll，sock_poll根据情况会调用到tcp_poll,udp_poll或者datagram_poll），poll函数调用poll_wait函数，poll_wait函数调用__pollwait()。</li>
<li>以tcp_poll为例，tcp_poll的核心实现就是<strong>pollwait，也就是上面注册的回调函数。它调用</strong>pollwait检查是否有读写操作，并返回一个描述读写操作是否就绪的mask掩码（可以理解为我们上面说的fd_set对应项置为1的那个1），根据这个mask掩码给fd_set中当前fd的对应项赋值。</li>
<li>如果遍历完所有的fd，fd_set中还没有一个表示可读/写/异常的mask掩码（也就是三个fd_set还没有位置置1），则会调用schedule_timeout使调用select的进程（也就是current进程）进入睡眠。当设备驱动发生自身资源可读写后，会唤醒其等待队列上睡眠的进程。如果超过一定的超时时间（schedule_timeout指定），还是没人唤醒，则调用select的进程会重新被唤醒获得CPU，进而重新遍历fd，判断有没有就绪的fd。</li>
<li>重复直到要么超时，要么有就绪的fd，然后返回，并把fd_set从内核空间拷贝回用户空间。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-9d4e33a737df6b520954a3db71599b59979.png" alt=""></p>
<h2 id="2-5-select机制的缺点"><a href="#2-5-select机制的缺点" class="headerlink" title="2.5 select机制的缺点"></a>2.5 select机制的缺点</h2><ol>
<li>每次调用select，都需要把fd_set集合从用户态拷贝到内核态，如果fd_set集合很大时，那这个开销也很大</li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd_set，如果fd_set集合很大时，那这个开销也很大</li>
<li>为了减少数据拷贝带来的性能损坏，内核对被监控的fd_set集合大小做了限制，并且这个是通过宏控制的，一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048。</li>
</ol>
<h1 id="3-poll模式"><a href="#3-poll模式" class="headerlink" title="3 poll模式"></a>3 poll模式</h1><p>poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构而不是select的fd_set结构，pollfd结构使用链表而非数组，<strong>这导致pollfd的长度没有限制</strong>。除此之外，二者的原理基本一致，即对多个描述符也是进行轮询，根据描述符的状态进行处理。</p>
<h2 id="3-1-poll函数"><a href="#3-1-poll函数" class="headerlink" title="3.1 poll函数"></a>3.1 poll函数</h2><p><code>int poll (struct pollfd *fds, unsigned int nfds, int timeout);</code></p>
<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>
<p>同时也不需要三个fd_set来表示分别要监控哪些事件，poll定义的pollfd结构，就封装了该fd需要监控的事件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd; &#x2F;* file descriptor *&#x2F;</span><br><span class="line">    short events; &#x2F;* requested events to watch *&#x2F;</span><br><span class="line">    short revents; &#x2F;* returned events witnessed *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和select函数一样，poll会改写pollfd，返回后，<strong>需要轮询pollfd来获取就绪的描述符</strong>。</p>
<h2 id="3-2-poll函数的实现"><a href="#3-2-poll函数的实现" class="headerlink" title="3.2 poll函数的实现"></a>3.2 poll函数的实现</h2><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<p>因为poll和select的区别不大，所以除了fd集合没有限制外(但是数量过大后性能也是会下降)，select其他的缺点poll都有。</p>
<h1 id="4-epoll模式"><a href="#4-epoll模式" class="headerlink" title="4 epoll模式"></a>4 epoll模式</h1><p>由于epoll的实现机制与select/poll机制完全不同，上面所说的 select的缺点在epoll上不复存在。</p>
<p>设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？</p>
<p>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p>
<h2 id="4-1-epoll的设计"><a href="#4-1-epoll的设计" class="headerlink" title="4.1 epoll的设计"></a>4.1 epoll的设计</h2><p>epoll的设计和实现与select完全不同。epoll通过在Linux内核中申请一个简易的文件系统，这个文件系统早期使用哈希表实现，后来改用红黑树来实现。</p>
<p>epoll把原先的select/poll调用分成了3个部分：</p>
<ol>
<li><p>调用epoll_create()建立一个epoll句柄对象(在epoll文件系统中为这个句柄对象分配资源)</p>
</li>
<li><p>调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p>
</li>
<li><p>调用epoll_wait收集发生的事件的连接</p>
</li>
</ol>
<p>如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接（epoll通过内核和用户空间共享一块内存来实现共享句柄数据）。</p>
<h2 id="4-2-epoll函数"><a href="#4-2-epoll函数" class="headerlink" title="4.2 epoll函数"></a>4.2 epoll函数</h2><p>epoll操作过程需要三个函数，分别如下：</p>
<ol>
<li><p><code>int epoll_create(int size)；</code></p>
<ul>
<li>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</li>
<li>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</li>
</ul>
</li>
<li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</code></p>
<ul>
<li>该函数是对指定描述符fd执行op操作，你可以理解为将套接字以及它要监控的事件，注册到epoll句柄中。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。其各参数含义如下</li>
<li>epfd：是epoll_create()的返回值，可以理解为指向epoll句柄的指针。</li>
<li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct epoll_event &#123;</span><br><span class="line">  __uint32_t events;  &#x2F;* Epoll events *&#x2F;</span><br><span class="line">  epoll_data_t data;  &#x2F;* User data variable *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;events可以是以下几个宏的集合：</span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>
<blockquote>
<p>epoll的全程是eventpoll，顾名思义，它的实现机制是基于event事件的，所以不同于select使用三个fd_set来对应读/写/异常的IO变化，也不同于poll只是在pollfd的结构体中使用short events来对应事件，epoll专门定义了一个epoll_event结构体，将其作为读/写/异常的IO变化的逻辑封装，称为事件（event）。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</code></p>
<ul>
<li>等待epfd上的io事件，最多返回maxevents个事件。</li>
<li>epfd参数是epoll_create()的返回值，可以理解为指向epoll句柄的指针。</li>
<li>events参数用来从内核得到事件的集合</li>
<li>maxevents参数告知内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size。</li>
<li>timeout参数是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</li>
</ul>
</li>
</ol>
<h2 id="4-3-epoll的两种工作模式"><a href="#4-3-epoll的两种工作模式" class="headerlink" title="4.3 epoll的两种工作模式"></a>4.3 epoll的两种工作模式</h2><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<ul>
<li><strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<ul>
<li>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</li>
</ul>
</li>
<li><strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。<ul>
<li>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核也不会发送更多的通知(only once)</li>
<li>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作，把处理多个文件描述符的任务饿死。</li>
</ul>
</li>
</ul>
<p>二者的区别举个一个例子：</p>
<ol>
<li>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符</li>
<li>这个时候从管道的另一端被写入了2KB的数据</li>
<li>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作</li>
<li>然后我们读取了1KB的数据</li>
<li>调用epoll_wait(2)……</li>
</ol>
<p>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能收到通知RFD有事件。因为第四步我们没有把RFD的数据读完，只读了1KB。</p>
<p>如果是ET模式，那么在第5步调用epoll_wait(2)之后，不会收到通知RFD有事件了，ET模式只会在第三步提醒一次。</p>
<h2 id="4-4-epoll的实现机制"><a href="#4-4-epoll的实现机制" class="headerlink" title="4.4 epoll的实现机制"></a>4.4 epoll的实现机制</h2><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct eventpoll&#123;</span><br><span class="line">    ....</span><br><span class="line">    &#x2F;*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*&#x2F;</span><br><span class="line">    struct rb_root  rbr;</span><br><span class="line">    &#x2F;*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*&#x2F;</span><br><span class="line">    struct list_head rdlist;</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>每一个epoll对象都有一个独立的eventpoll结构体</strong>，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。<strong>这些事件都会挂载在红黑树中</strong>，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p>
<p>而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，<strong>当相应的事件发生时会调用这个回调方法</strong>。这个回调方法在内核中叫ep_poll_callback,它会将发生的event事件添加到rdlist双链表中。</p>
<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct epitem&#123;</span><br><span class="line">    struct rb_node  rbn;&#x2F;&#x2F;红黑树节点</span><br><span class="line">    struct list_head    rdllink;&#x2F;&#x2F;双向链表节点</span><br><span class="line">    struct epoll_filefd  ffd;  &#x2F;&#x2F;事件句柄信息</span><br><span class="line">    struct eventpoll *ep;    &#x2F;&#x2F;指向其所属的eventpoll对象</span><br><span class="line">    struct epoll_event event; &#x2F;&#x2F;期待发生的事件类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epitem可以理解为：事件逻辑结构体epoll_event与双向链表/红黑树之间的映射关系，其关系如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ed4db33152307f23c38cd588d76916d6f16.png" alt=""></p>
<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-82bebc2938db6e54af7df375b24c9ddfa52.png" alt=""></p>
<h1 id="5-三种模型的区别和取舍"><a href="#5-三种模型的区别和取舍" class="headerlink" title="5 三种模型的区别和取舍"></a>5 三种模型的区别和取舍</h1><ol>
<li><p>支持一个进程所能打开的最大连接数</p>
<ul>
<li>select：单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小，当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</li>
<li>poll：poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。</li>
<li>epoll：虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接。</li>
</ul>
</li>
<li><p>FD剧增后带来的IO效率问题</p>
<ul>
<li>select：因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</li>
<li>poll：同上</li>
<li>epoll：因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</li>
</ul>
</li>
<li><p>消息传递方式</p>
<ul>
<li>select：内核需要将消息传递到用户空间，都需要内核拷贝动作</li>
<li>poll：同上</li>
<li>epoll：epoll通过内核和用户空间共享一块内存来实现的。</li>
</ul>
</li>
</ol>
<p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p>
<p>表面上看epoll的性能最好，但是<strong>在连接数少并且连接都十分活跃</strong>的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>
<p>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>
<p>select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善 </p>
<p>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/07/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/07/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/" itemprop="url">volatile关键字详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-07T22:38:04+08:00">
                2020-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA线程与并发控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/07/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/07/volatile关键字详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>提到JAVA的并发编程，就不得不提volatile关键字，不管是在面试还是实际开发中，volatile关键字的使用都是一个应该掌握的技能。它之所以重要，是因为它和JAVA并发编程中会遇到三种重要问题中的两种密切相关。</p>
<p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。而volatile关键字之所以神奇，在于它可以解决<strong>可见性问题</strong>和<strong>有序性问题</strong>。</p>
<h1 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1 可见性"></a>1 可见性</h1><h2 id="1-1-可见性问题"><a href="#1-1-可见性问题" class="headerlink" title="1.1 可见性问题"></a>1.1 可见性问题</h2><p>如果我们学过java内存模型的话，对下面这张图想必不陌生：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-abfdf25cd3ba1dc266bdfed64c2e8d577b5.png" alt=""></p>
<p>每一个线程都有一份自己的本地内存，所有线程共用一份主内存。如果一个线程A对主内存中的某个数据V进行了修改，而此时另外一个线程B不知道该数据V已经发生了修改，它会从本地内存中去读取这个数据V，显然数据V已经过时了。<strong>这就是说，本次线程A修改后的数据V，对线程B来说，此时是不可见的</strong>。</p>
<h2 id="1-2-volatile保证内存可见性"><a href="#1-2-volatile保证内存可见性" class="headerlink" title="1.2 volatile保证内存可见性"></a>1.2 volatile保证内存可见性</h2><p>可见性问题在并发场景中是十分常见，那么volatile关键字如何保证内存可见性呢？</p>
<p>volatile关键字的作用很简单，就是一个线程在对主内存的某一份数据进行更改时，改完之后会立刻刷新到主内存。并且会强制让缓存了该变量的线程中的数据清空，必须从主内存重新读取最新数据。这样一来就保证了可见性。</p>
<p>其底层原理如下：</p>
<p>JMM把主内存和线程的本地内存之间的交互分为8个原子操作，他们分别是：</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>JMM要求，如果要把一个变量从主内存复制到工作内存，那么应该顺序的执行read和load操作。反之，应该顺序的执行store和write操作。JMM只要求上述两个指令是顺序执行，不要求必须要连续执行，也就说是，可以在read和load操作之间插入其他指令。这基本构成了JMM的主内存和工作内存之间的交互逻辑。</p>
<p>而volatile如何实现内存可见性呢？其实很简单，下面我截取一段被volatile关键字修饰的变量的赋值逻辑的汇编指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">0x0000000002931351: lock add dword ptr [rsp],0h  ;*putstatic instance</span><br><span class="line">                                                ; - org.xrq.test.design.singleton.LazySingleton::getInstance@13 (line 14)</span><br><span class="line">···</span><br></pre></td></tr></table></figure>

<p>你不用去关心这段字节码什么意思，你知道知道它的语意是对一个volatile修饰的变量进行赋值操作。<strong>和没有volatile修饰的变量的赋值操作字节码相比，volatile修饰的变量的赋值操作仅仅是多了一个lock指令前缀</strong>。</p>
<p>lock指令前缀有什么作用呢？<strong>lock后的写操作会强制回写已修改的数据到主内存，相当于连续执行了store和write操作</strong>。</p>
<p>看到这里有同学不禁要问了，lock操作只是强制回写数据到主内存，但没有强制其他线程去刷新他们工作内存中的值啊。</p>
<p>这要结合JMM的缓存一致性协议——MESI协议来看了，不懂的同学可回顾本博客另外一篇文章《JAVA内存模型》的MESI协议一章。</p>
<p>假如线程A操作赋值逻辑，使用lock操作强制回写数据V到主内存，根据MESI协议，线程A会将主内存中该数据V的状态改为M，其他线程一直在监听主内存，发现该数据V的状态为M后，会将他们的工作内存中的数据V的状态改为I——即失效状态，最终迫使其他线程在使用V之前，必须去主内存读取新值。</p>
<p>这就是volatile保证内存可见性的原理，其实只是一个lock指令前缀而已。</p>
<h1 id="2-有序性"><a href="#2-有序性" class="headerlink" title="2 有序性"></a>2 有序性</h1><h2 id="2-1-有序性问题"><a href="#2-1-有序性问题" class="headerlink" title="2.1 有序性问题"></a>2.1 有序性问题</h2><p>并发场景中，有序性问题，许多是由JVM的指令重排优化引起的。</p>
<p>指令重排序是JVM为了优化指令、提高程序运行效率，在不影响单线程程序执行结果的前提下，尽可能地提高并行度。指令重排序包括编译器重排序和运行时重排序。</p>
<blockquote>
<p>实质上指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理</p>
</blockquote>
<p>我们来看一个因为指令重排而引起的并发问题，懒加载的双重检查模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">	private static Singleton instance;</span><br><span class="line">	private Singleton()&#123;&#125;</span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">		if ( instance &#x3D;&#x3D; null ) &#123; &#x2F;&#x2F;当instance不为null时，仍可能指向一个“被部分初始化的对象”</span><br><span class="line">			synchronized (Singleton.class) &#123;</span><br><span class="line">				if ( instance &#x3D;&#x3D; null ) &#123;</span><br><span class="line">					instance &#x3D; new Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个模型我们并不陌生，在 《Effecitve Java》一书中作者层提到了双重检查模式，并指出这种模式在Java中通常并不适用。并不适用的原因，就是因为指令重排。</p>
<p>上面这段代码，初看没问题，但是在并发模型下，可能会出错。那是因为<code>instance = new Singleton();</code>并非一个原子操作，编译器会将其编译为三行字节码，也就是三个步骤：</p>
<ol>
<li><p>memory=allocate();// 分配内存</p>
</li>
<li><p>ctorInstanc(memory) //初始化对象</p>
</li>
<li><p>instance=memory //设置instance指向刚分配的地址</p>
</li>
</ol>
<p>在编译器运行时，因为步骤三和步骤二无依赖关系，故而JVM会对其进行指令重排优化，从1-2-3顺序优化为1-3-2顺序。</p>
<p>可以看到指令重排之后，操作3排在了操作2之前，即引用instance指向内存memory时，这段崭新的内存还没有初始化——也就是说引用instance指向了一个”被部分初始化的对象”。</p>
<p>此时，如果另一个线程调用getInstance方法，由于instance已经指向了一块内存空间，从而if (instance == null) 条件判为false，方法返回instance引用，那么用户则得到了没有完成初始化的“半个”单例。从而发生问题。</p>
<h2 id="2-2-volatile防止指令重排"><a href="#2-2-volatile防止指令重排" class="headerlink" title="2.2 volatile防止指令重排"></a>2.2 volatile防止指令重排</h2><p>解决这个该问题，只需要将instance声明为volatile变量：<code>private static volatile Singleton instance;</code></p>
<p>volatile关键字能够禁止JVM对修饰的变量的读写做指令重排，从而保证了<code>instance = new Singleton();</code>在底层能够按照顺序执行。</p>
<p><strong>其底层原理其实和volatile保证可见性的原理是一样的，也就是在汇编指令层面加入一个lock前缀</strong>：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-97a29eb4b5f1305232f4981ff4d69b16a3f.png" alt=""></p>
<p>这里的lock前缀指令相当于一个内存屏障（但实际上不是内存屏障），它保证了：<strong>当程序执行到volatile变量的读或写时，在lock指令前面的操作必须全部执行完毕，且结果必须已经对后面的操作可见（也就是上面说的lock会强制刷新新值到主存）；</strong></p>
<p>指令重排的原则是无依赖关系间的优化排序，而volatile字段带来的lock前缀，则会使<code>instance = new Singleton();</code>的三个字节码<strong>相当于</strong>变成这样（lock是汇编指令，所以说只是相当于）：</p>
<ol>
<li><p>memory=allocate();// 分配内存</p>
</li>
<li><p>ctorInstanc(memory) //初始化对象</p>
</li>
<li><p><strong>lock</strong> instance=memory //设置instance指向刚分配的地址</p>
</li>
</ol>
<p>这使得原本没有依赖关系的2和3操作，<strong>因为lock前缀的语意强制，被强加上了一个2必须在3之前完成的“依赖”</strong>，形成了虽然不是内存屏障，但却达到了内存屏障功能的效果，给人一种指令重排无法越过volatile读写操作两边的观感。</p>
<h1 id="3-lock指令前缀作用总结"><a href="#3-lock指令前缀作用总结" class="headerlink" title="3 lock指令前缀作用总结"></a>3 lock指令前缀作用总结</h1><p>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令。</p>
<ul>
<li><p>确保指令重排序时不会把lock指令后面的指令排到lock之前的位置，也不会把前面的指令排到lock的后面；即在执行到lock这句指令时，在它前面的操作已经全部完成；</p>
</li>
<li><p>强制将对缓存的修改操作立即写入主存，同时利用缓存一致性机制，让其他工作线程从主存重新读值；</p>
</li>
</ul>
<h1 id="4-volatile不能保证原子性"><a href="#4-volatile不能保证原子性" class="headerlink" title="4 volatile不能保证原子性"></a>4 volatile不能保证原子性</h1><p>从上文我们知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc &#x3D; 0;</span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;有10个线程分别进行了1000次操作inc的自增操作</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test &#x3D; new Test();</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        while(Thread.activeCount()&gt;1)  &#x2F;&#x2F;保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，volatile关键字能保证可见性没有错，但可见性只能保证每次读取的是最新的值，volatile没办法保证对变量的操作的原子性。</p>
<p>自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<ol>
<li>假如某个时刻变量inc的值为10，</li>
<li>线程1对变量进行自增操作，线程1先读取了变量inc的原始值10。</li>
<li>线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，还没有没有对变量进行修改操作，线程2读到的10也是10；</li>
<li>这时候线程1对inc进行自增，并且通过可见性，将结果11写回主存，并将线程2的工作内存中inc的状态改为无效。</li>
<li>但是此时线程2对inc的读操作已经结束了，已经在进行+1操作了，inc就算在线程2中被置为无效，线程2也过了能感知到的时间点了，导致线程2也是对10+1，得到11再写回主存。</li>
</ol>
<p>以此类推，导致最后的结果必定小于10000；这说明了volatile无法保证原子性，它本身也不适用类似场景。</p>
<p><strong>volatile比较适合用来修饰一个会被单线程更改，但又需要立刻让其他线程感知到值变化的值，比如代码逻辑里面的业务开关等</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/JAVA%E7%9A%84CAS%E5%8F%8A%E5%85%B6ABA%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/JAVA%E7%9A%84CAS%E5%8F%8A%E5%85%B6ABA%E9%97%AE%E9%A2%98/" itemprop="url">JAVA的CAS及其ABA问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T23:35:26+08:00">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA线程与并发控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/05/JAVA%E7%9A%84CAS%E5%8F%8A%E5%85%B6ABA%E9%97%AE%E9%A2%98/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/05/JAVA的CAS及其ABA问题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-CAS是什么"><a href="#1-CAS是什么" class="headerlink" title="1 CAS是什么"></a>1 CAS是什么</h1><p>CAS是Compare-And-Swap的缩写，即<strong>对比和替换</strong>，它在保证数据原子性的前提下尽可能的减少了锁的使用，很多编程语言或者系统实现上都大量的使用了CAS。</p>
<p>因为没有没有线程阻塞唤醒带来的性能消耗问题。这也是为什么CAS比synchronized性能高的原因！</p>
<h2 id="1-1-JAVA中CAS的实现"><a href="#1-1-JAVA中CAS的实现" class="headerlink" title="1.1 JAVA中CAS的实现"></a>1.1 JAVA中CAS的实现</h2><p>JAVA中的CAS主要使用的是Unsafe类。Unsafe的CAS操作主要是基于硬件平台的汇编指令，目前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。</p>
<p>sun.misc.Unsafe虽然类提供了一系列直接操作内存对象的方法，但只是在 jdk 内部使用，JAVA官方不建议开发者直接调用Unsafe类；所以我们一般直接使用到的，都是java.util.concurrent.atomic 包下的Atomic*类，比如 AtomicBoolean、AtomicInteger 等，其compareAndSet方法，也都是调用的Unsafe的CAS方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class Unsafe &#123;</span><br><span class="line">	...</span><br><span class="line">	public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line">	public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line">	public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>value 表示 需要操作的对象</li>
<li>valueOffset 表示 对象(value)的地址的偏移量（通过Unsafe.objectFieldOffset(Field valueField)获取）</li>
<li>expect 表示更新时value的期待值</li>
<li>update 表示将要更新的值</li>
</ul>
<p>具体过程为每次在执行CAS操作时，线程会根据valueOffset去内存中获取当前值去跟expect的值做对比如果一致则修改并返回true，如果不一致说明有别的线程也在修改此对象的值，则返回false。</p>
<p>Unsafe类中compareAndSwapInt的具体实现所对应的cpp代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h2 id="1-2-CAS和自旋的配合"><a href="#1-2-CAS和自旋的配合" class="headerlink" title="1.2 CAS和自旋的配合"></a>1.2 CAS和自旋的配合</h2><blockquote>
<p>很多文章都信誓旦旦的说CAS底层使用自旋，从而达到高效的无锁并发。这时将Atomic的CAS实现和Unsafe的CAS实现混淆的结果，JAVA的CAS追本溯源都在Unsafe的CAS方法中，它顾名思义，只有比较和替换，没有自旋。</p>
</blockquote>
<p>但不可否认，当CAS和自旋搭配使用的时候，确实效果更佳，尤其是在并发做加减的时候，所以Unsafe类提供了一个将CAS和自旋搭配使用的自增方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndSetInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;getIntVolatile方法获取对象var1中offset&#x3D;var2偏移地址对应的整型field的值,支持volatile load语义。</span><br><span class="line">        &#x2F;&#x2F;说人话就是取出var1内存中偏移量为var2位置对应的整型field的值</span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">        &#x2F;&#x2F;自旋操作，不停比较该值，如果CAS成功，则退出，否则一直循环。</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同原理的还有getAndSetLong/getAndSetObject/getAndAddLong/getAndAddInt等方法。</p>
<h2 id="1-3-Java-8对CAS机制的优化——LongAdder"><a href="#1-3-Java-8对CAS机制的优化——LongAdder" class="headerlink" title="1.3 Java 8对CAS机制的优化——LongAdder"></a>1.3 Java 8对CAS机制的优化——LongAdder</h2><p>当并发操作一个AtomicInteger而不是使用synchronize时，我们确实可以享受到CAS无锁并发带来的高性能，但CAS就完美无缺么？肯定不是的，比如说大量的线程同时并发修改一个AtomicInteger，可能有很多线程会不停的自旋，进入一个无限重复的循环中。</p>
<p>这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。</p>
<p>在大量线程高并发更新AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。</p>
<p>于是，Java 8推出了一个新的类，LongAdder，他尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-610bcb236b50f94729fea4711c012e101fa.png" alt=""></p>
<p>在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。</p>
<p>接着如果发现并发更新的线程数量过多，就会开始施行分段CAS的机制，也就是内部会搞一个Cell数组，每个数组是一个数值分段。这时，<strong>让大量的线程分别去对不同Cell内部的value值进行CAS累加操作</strong>，这样就把CAS计算压力分散到了不同的Cell分段数值中。</p>
<p>如此操作可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！</p>
<p>更重要的是他内部实现了<strong>自动分段迁移的机制</strong>，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。</p>
<p>最后，如果你要从LongAdder中获取当前累加的总值，<strong>就会把base值和所有Cell分段数值加起来返回给你</strong>。</p>
<h1 id="2-CAS的ABA问题"><a href="#2-CAS的ABA问题" class="headerlink" title="2 CAS的ABA问题"></a>2 CAS的ABA问题</h1><p>CAS还存在一个更加严重的问题——ABA问题：</p>
<p>线程1准备用CAS修改变量值A，在此之前，其它线程将变量的值由A替换为B，又由B替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-36b9583db6094422fbc837b64cceb1cf483.png" alt=""></p>
<p>有没有解决方案呢？有的，JAVA中ABA中解决方案有两种，我们依次介绍</p>
<h2 id="2-1-AtomicStampedReference类"><a href="#2-1-AtomicStampedReference类" class="headerlink" title="2.1 AtomicStampedReference类"></a>2.1 AtomicStampedReference类</h2><p>解决ABA最简单的方案就是给值加一个修改版本号，每次值变化，都会修改它版本号，CAS操作时都对比此版本号。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2594f459d269ecbecaca0fbea9d4b37d1ce.png" alt=""></p>
<p>AtomicStampedReference就是这种思路在JAVA中的产物，它主要维护包含一个对象引用以及一个可以自动更新的整数”stamp”的pair对象来解决ABA问题。</p>
<p>其关键代码如下（省略无用代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;关键代码</span><br><span class="line">public class AtomicStampedReference&lt;V&gt; &#123;</span><br><span class="line">    private static class Pair&lt;T&gt; &#123;</span><br><span class="line">        final T reference;  &#x2F;&#x2F;维护对象引用</span><br><span class="line">        final int stamp;  &#x2F;&#x2F;用于标志版本</span><br><span class="line">        private Pair(T reference, int stamp) &#123;</span><br><span class="line">            this.reference &#x3D; reference;</span><br><span class="line">            this.stamp &#x3D; stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</span><br><span class="line">            return new Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private volatile Pair&lt;V&gt; pair;</span><br><span class="line">    ....</span><br><span class="line">    &#x2F;**</span><br><span class="line">      * expectedReference ：更新之前的原始值</span><br><span class="line">      * newReference : 将要更新的新值</span><br><span class="line">      * expectedStamp : 期待更新的标志版本</span><br><span class="line">      * newStamp : 将要更新的标志版本</span><br><span class="line">      *&#x2F;</span><br><span class="line">    public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 int expectedStamp,</span><br><span class="line">                                 int newStamp) &#123;</span><br><span class="line">        Pair&lt;V&gt; current &#x3D; pair; &#x2F;&#x2F;获取当前pair</span><br><span class="line">        return</span><br><span class="line">            expectedReference &#x3D;&#x3D; current.reference &amp;&amp; &#x2F;&#x2F;原始值等于当前pair的值引用，说明值未变化</span><br><span class="line">            expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp; &#x2F;&#x2F; 原始标记版本等于当前pair的标记版本，说明标记未变化</span><br><span class="line">            ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">              newStamp &#x3D;&#x3D; current.stamp) || &#x2F;&#x2F; 将要更新的值和标记都没有变化</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp))); &#x2F;&#x2F; cas 更新pair</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要过分在意源码，我们只要知道怎么用就好，demo如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        AtomicStampedReference&lt;String&gt; reference &#x3D; new AtomicStampedReference&lt;String&gt;(&quot;aaa&quot;,1);</span><br><span class="line">        reference.compareAndSet(&quot;aaa&quot;,&quot;bbb&quot;,reference.getStamp(),reference.getStamp()+1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-AtomicMarkableReference类"><a href="#2-2-AtomicMarkableReference类" class="headerlink" title="2.2 AtomicMarkableReference类"></a>2.2 AtomicMarkableReference类</h2><p>AtomicMarkableReference可以理解为AtomicStampedReference的简化版，就是不关心修改过几次，仅仅关心是否修改过。因此变量mark是boolean类型，仅记录值是否有过修改。</p>
<p>关键代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Pair对象维护对象的引用和对象标记</span><br><span class="line">private static class Pair&lt;T&gt; &#123;</span><br><span class="line">    final T reference;</span><br><span class="line">    final boolean mark;&#x2F;&#x2F; 通过标记的状态区分对象是否有更改</span><br><span class="line"></span><br><span class="line">    private Pair(T reference, boolean mark) &#123;</span><br><span class="line">        this.reference &#x3D; reference;</span><br><span class="line">        this.mark &#x3D; mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;T&gt; Pair&lt;T&gt; of(T reference, boolean mark) &#123;</span><br><span class="line">        return new Pair&lt;T&gt;(reference, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param expectedReference 期待的原始对象</span><br><span class="line"> * @param newReference      将要更新的对象</span><br><span class="line"> * @param expectedMark      期待原始对象的标记</span><br><span class="line"> * @param newMark           将要更新对象的标记</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean compareAndSet(V expectedReference,</span><br><span class="line">                             V newReference,</span><br><span class="line">                             boolean expectedMark,</span><br><span class="line">                             boolean newMark) &#123;</span><br><span class="line">    Pair&lt;V&gt; current &#x3D; pair;</span><br><span class="line">    return</span><br><span class="line">            expectedReference &#x3D;&#x3D; current.reference &amp;&amp; &#x2F;&#x2F; 如果期待的原始对象与Pair的reference一样则返回true</span><br><span class="line">                    expectedMark &#x3D;&#x3D; current.mark &amp;&amp; &#x2F;&#x2F; 如果期待的原始对象的标记与Pair的mark一样则返回true</span><br><span class="line">                    ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">                            newMark &#x3D;&#x3D; current.mark) || &#x2F;&#x2F; 如果要更新的对象和对象标记与Pair的refernce和mark一样的话直接返回true，否则执行CAS操作</span><br><span class="line">                            casPair(current, Pair.of(newReference, newMark)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要过分在意源码，我们只要知道怎么用就好，demo如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicMarkableReferenceDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static final Integer INIT_NUM &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    private static final Integer TEM_NUM &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    private static final Integer UPDATE_NUM &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    private static final Boolean INITIAL_MARK &#x3D; Boolean.FALSE;</span><br><span class="line"></span><br><span class="line">    private static AtomicMarkableReference atomicMarkableReference &#x3D; new AtomicMarkableReference(INIT_NUM, INITIAL_MARK);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; ： 初始值为：&quot; + INIT_NUM + &quot; , 标记为： &quot; + INITIAL_MARK);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if (atomicMarkableReference.compareAndSet(INIT_NUM, UPDATE_NUM, atomicMarkableReference.isMarked(), Boolean.TRUE)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; ： 修改后的值为：&quot; + atomicMarkableReference.getReference() + &quot; , 标记为： &quot; + atomicMarkableReference.isMarked());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  &quot; CAS返回false&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; ： 初始值为：&quot; + atomicMarkableReference.getReference() + &quot; , 标记为： &quot; + INITIAL_MARK);</span><br><span class="line">            atomicMarkableReference.compareAndSet(atomicMarkableReference.getReference(), TEM_NUM, atomicMarkableReference.isMarked(), Boolean.TRUE);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; ： 修改后的值为：&quot; + atomicMarkableReference.getReference() + &quot; , 标记为： &quot; + atomicMarkableReference.isMarked());</span><br><span class="line">        &#125;, &quot;线程B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A ： 初始值为：10 , 标记为： false</span><br><span class="line">线程B ： 初始值为：10 , 标记为： false</span><br><span class="line">线程B ： 修改后的值为：20 , 标记为： true</span><br><span class="line">线程A CAS返回false</span><br></pre></td></tr></table></figure>

<p>由于线程B修改了对象，标记由false改为true，所以当上下文切换为线程A的时候，如果标记不一致，线程A执行CAS方法就会返回false。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/" itemprop="url">LRU和LFU算法以及其在Redis中的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-04T23:34:29+08:00">
                2020-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/04/LRU和LFU算法以及其在Redis中的实现/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文讲述的两个缓存淘汰算法，LRU算法（Least recently used）和LFU算法（Least Frequently used），两者看起来很相似，但我们要明确其区别在于：</p>
<ul>
<li><p>LRU是按访问时间排序，发生淘汰的时候，把访问时间最旧的淘汰掉。</p>
</li>
<li><p>LFU是按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。</p>
</li>
</ul>
<p>本文旨在描述LRU/LFU算法定义，并给出性能最佳的实现方式，最后再延伸至当前最热门的缓存中间件Redis中二者的实现。</p>
<p>其中，LRU/LFU算法性能最优的实现，也是各大厂技术面的常问题。leetcode上有两个这样的题目，要求是缓存的加入put()，缓存读取get()，都要在O(1)内实现：</p>
<ul>
<li>LRU：<a href="https://leetcode.com/problems/lru-cache/description/" target="_blank" rel="noopener">https://leetcode.com/problems/lru-cache/description/</a> 或者 <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache/</a></li>
<li>LFU：<a href="https://leetcode.com/problems/lfu-cache/description/" target="_blank" rel="noopener">https://leetcode.com/problems/lfu-cache/description/</a> 或者 <a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lfu-cache/</a></li>
</ul>
<h1 id="1-LRU算法"><a href="#1-LRU算法" class="headerlink" title="1 LRU算法"></a>1 LRU算法</h1><p>LRU（Least recently used）算法，也叫作<strong>最近最久未使用算法</strong>，顾名思义，就是哪个是最近不用的，就把他淘汰掉。它根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。它经常使用在内存/缓存空间不足的场景，以便在受限时舍弃掉不常用的数据。</p>
<h2 id="1-1-链表实现简单LRU"><a href="#1-1-链表实现简单LRU" class="headerlink" title="1.1 链表实现简单LRU"></a>1.1 链表实现简单LRU</h2><p>使用链表，可以实现最简单的LRU算法：</p>
<ol>
<li>维护一个定长的链表</li>
<li>当一个新的key被访问时<ul>
<li>如果这个key不存在链表中，那么新key插入到链表头部；</li>
<li>如果这个key存在链表中，那么将这个key移到链表头部；</li>
</ul>
</li>
<li>当链表满的时候，如果还有新的key要插入，则将链表尾部的key丢弃。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-c609868da6b2cfefb197343aeee43d3d711.png" alt=""></p>
<p>这种简单的实现固然能达到我们的目的，但也有致命的要求：这种实现的性能不是很好，查询一个key是否存在链表中，以及在链表中的具体位置的时间复杂度是O(n)，这在数据数量巨大的场景下是灾难的。</p>
<h2 id="1-2-HashMap和双向链表实现高性能LRU"><a href="#1-2-HashMap和双向链表实现高性能LRU" class="headerlink" title="1.2 HashMap和双向链表实现高性能LRU"></a>1.2 HashMap和双向链表实现高性能LRU</h2><p>链表实现的LRU算法瓶颈主要在<strong>定位一个key在链表中位置的消耗</strong>。</p>
<p>为了规避这个代价，我们可以引入在查询和定位方面具有极高优势的HashMap来作为互补，整体的设计思路是，可以使用 HashMap 存储 key，而HashMap的Value指向双向链表实现的LRU的 Node 节点。这样可以做到save和get的时间都是 O(1)。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-04a2a22decea9ebd74bd5aab3ad4de3fbb6.png" alt=""></p>
<p>假如我们预设链表的大小是3，下图展示了LRU链表在存储和访问过程中的变化。为了简化图复杂度，图中没有展示HashMap部分的变化，仅仅演示了上图LRU双向链表的变化。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9bbae79816c5ac35c34cd21e3bb7f20a342.png" alt=""></p>
<h2 id="1-3-继承LinkedHashMap实现LRU"><a href="#1-3-继承LinkedHashMap实现LRU" class="headerlink" title="1.3 继承LinkedHashMap实现LRU"></a>1.3 继承LinkedHashMap实现LRU</h2><p>LinkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储（也就是其put方法会将最近访问的数据放到表头）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e15263be2c99e9a89332fc6c464029aa4df.png" alt=""></p>
<p>此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry，用于在每次数据发生变更时（put和get）判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素（也正因此，LinkedHashMap是无限长的）。所以为了将其改造为一个定长且会自动移除队尾数据的链表，需要重写removeEldestEntry方法，即当缓存满后就移除最不常用的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里就是传递进来最多能缓存多少数据</span><br><span class="line">    public LRUCache(int cacheSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置一个hashmap的初始大小，最后一个true指的是让linkedhashmap按照访问顺序来进行排序，最近访问的放在头，最老访问的就在尾</span><br><span class="line">        super((int) Math.ceil(cacheSize &#x2F; 0.75) + 1, 0.75f, true);</span><br><span class="line">        CACHE_SIZE &#x3D; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据</span><br><span class="line">        return size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2-Redis中的LRU"><a href="#2-Redis中的LRU" class="headerlink" title="2 Redis中的LRU"></a>2 Redis中的LRU</h1><blockquote>
<p>在讨论Redis的LRU之前，需要明确，Redis的缓存淘汰策略（LRU）与Redis键的过期删除策略不是一回事，LRU是在Redis内存使用超过一定值的时候（一般这个值可以配置）使用的淘汰降级策略；而后者是通过定期删除+惰性删除两者结合的方式进行过期删除的。</p>
</blockquote>
<h2 id="2-1-Redis缓存淘汰策略"><a href="#2-1-Redis缓存淘汰策略" class="headerlink" title="2.1 Redis缓存淘汰策略"></a>2.1 Redis缓存淘汰策略</h2><p>当内存达到极限时，Redis就要开始利用回收策略对内存进行回收释放。回收的配置在 redis.conf 中填写，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 1073741824</span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure>

<ul>
<li>maxmemory： 指定了内存使用的极限，以字节为单位。当内存达到极限时，他会尝试去删除一些键值。</li>
<li>maxmemory-policy：指定删除的策略。Redis提供了如下几种缓存淘汰策略的取值<ul>
<li>noeviction：当内存使用超过配置的时候（如SET、LPUSH 等等命令）会返回错误，不会驱逐任何键。</li>
<li>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</li>
<li>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</li>
<li>allkeys-random：加入键的时候如果过限，从所有key随机删除</li>
<li>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐</li>
<li>volatile-ttl：从配置了过期时间的键中驱逐过期时间最近 (TTL 最小)的键</li>
<li>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</li>
<li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li>
</ul>
</li>
<li>maxmemory-samples ：指定了在进行删除时的键的采样数量。LRU 和 TTL 都是近似算法，所以可以根据参数来进行取舍，到底是要速度还是精确度。默认值一般填 5。10 的话已经非常近似正式的 LRU 算法了，但是会多一些 CPU 消耗；3 的话执行更快，然而不够精确。</li>
</ul>
<p>上述说到的缓存淘汰策略中，带lru后缀的，就是采用Redis LRU算法的策略，带有lfu后缀的策略，就是采用Redis LFU算法的策略（后文详述）。</p>
<h2 id="2-2-Redis中的LRU时钟"><a href="#2-2-Redis中的LRU时钟" class="headerlink" title="2.2 Redis中的LRU时钟"></a>2.2 Redis中的LRU时钟</h2><p>在LRU实现中，最核心的要点就是标记哪些数据是“最久”的，前文提到的LRU实现，我们利用链表的顺序来确定哪个数据“最久”，但如果按照性能较好的HashMap和双向链表来实现，在Redis key数量巨大的情况下，HashMap和双向链表的长度也会非常巨大，会牺牲比较大的存储空间，显然是不划算的。</p>
<p> 我们知道Redis中的所有对象都被定义为redisObject结构体。Redis LRU算法回收的数据，也正是这些对象。</p>
<p>Redis不采用链表来确定哪些redisObject是最久的，而是在redisObject结构体中定义了一个lru成员来用来记录该对象的最近一次被访问的时间。由于时钟的最大值只需要 24 个比特位就能表示，所以结构体定义时采用了位域。定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:LRU_BITS;</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>


<p>而在Redis在全局中也维护了一个24位全局时钟，可以简单理解为当前系统的时间戳。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">       pid_t pid;</span><br><span class="line">       char *configfile;</span><br><span class="line">       &#x2F;&#x2F;全局时钟</span><br><span class="line">       unsigned lruclock:LRU_BITS;</span><br><span class="line">       ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Redis每隔一定时间会通过全局的定时器函数serverCron来更新这个时钟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int serverCron(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    server.lruclock &#x3D; getLRUClock();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时钟的刷新频率由 server.hz 决定，即每秒钟会调用 server.hz （默认值为 10）次 serverCron 函数。那么，服务器每 1 / server.hz 秒就会调用一次定时器函数 serverCron。</p>
</blockquote>
<p>当一个对象redisObject新建或者被访问时，redis使用全局lru时钟来赋值对象内的lru时钟。</p>
<p>基于上面的基础，redis就可以很轻易的得到一个对象的空闲时间了：<strong>用全局的lru时钟减去对象本身的lru时钟，得到的就是这个对象没有被访问的时间间隔（也称空闲时间，idle time），空闲时间最大的就是需要淘汰的对象</strong>。</p>
<h2 id="2-3-Redis-LRU回收流程"><a href="#2-3-Redis-LRU回收流程" class="headerlink" title="2.3 Redis LRU回收流程"></a>2.3 Redis LRU回收流程</h2><p>Redis并不需要一个完全准确的LRU算法，就算移除了一个最近访问过的Key，影响也不大。为了性能计，Redis采用了一个近似LRU的实现：</p>
<p>Redis的数据库是一个巨大的字典，redisDb结构体中，维护着一个全局的，保存了数据库中的所有键值对的字典——dict字典，我们也称它做键空间。还维护着一个保存了所有带过期配置的键值对的字典——expire字典。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d6e14f11d52889dd33329a8330c815e5b10.png" alt=""></p>
<p>当内存使用超过最大使用数（即超过maxmemory的上限）时，就需要采用回收策略进行内存回收。如果回收策略采用带有LRU算法的策略，那么就会使用到Redis的近似LRU算法实现，流程如下</p>
<ol>
<li><p><strong>触发淘汰</strong>：在每一次处理客户端命令时。当 server.maxmemory的值非 0，则检测是否有需要回收淘汰的内存，如果有则触发redis.c/freeMemoryIfNeeded(void)函数以清理超出的内存，即步骤2的逻辑</p>
</li>
<li><p><strong>更新回收池</strong>：随机按策略从dict或者expire中取出maxmemory_samples个键（实际取到的数量取决于大字典原本的大小）</p>
<ul>
<li>然后用一个长度为16（由宏 MAXMEMORY_EVICTION_POOL_SIZE 指定）的evictionPool（回收池）对这几个键进行筛选</li>
<li>依次将取出的键的idle time和evictionPool中最小的idle time比较。将随机取出的键中，idle time比当前evictionPool中最小的idle time还要大的键，按idle time从小到大的顺序插入到evictionPool内的相应位置中（因为evictionPool是定长，所以如果在evictionPool已满的情况下插入新key，则要释放idle time较小的key）。</li>
</ul>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-fe014848ed18d0f5f5cc817267d06dc2268.png" alt=""></p>
<ol start="3">
<li><strong>删除淘汰的键</strong>：最后再从evictionPool池中取出idle time最大且在字典中存在的键作为bestkey执行删除，并且将该key从evictionPool池中移除；</li>
</ol>
<blockquote>
<p>注意这个清理过程是阻塞的，直到清理出足够的内存空间。所以如果在达到maxmemory并且调用方还在不断写入的情况下，可能会反复触发主动清理策略，导致请求会有一定的延迟。</p>
</blockquote>
<p>Redis采用回收池，把一个<strong>全局排序问题</strong>转化成为了<strong>局部的比较问题</strong>。要想知道idle time最大的key，精确的LRU需要对全局的key的idle time排序，这样的成本对于Redis来说太高了。Redis的LRU算法采用一种近似的思想，即随机采样(samping)若干个key，这若干个key就代表着全局的key，把samping得到的key放到pool里面，每次采样之后更新pool，使得pool里面总是保存着随机选择过的key的idle time最大的那些key。</p>
<p>需要evict key时，直接从pool里面取出idle time最大的key，将之evict掉。这种思想是很值得借鉴的。</p>
<p>而且，Redis团队经过试验，发现当samples=10时，Redis随机的LRU算法，已经能够很准确的淘汰掉最久没有使用的键，其效果和精确的LRU基本持平。如下图（浅灰色表示已经删除的键，深灰色表示没有被删除的键，绿色表示新加入的键，越往上表示键加入的时间越久）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-da6975d89b1e5c0929529b709d71d0d0840.png" alt=""></p>
<h1 id="3-LFU算法"><a href="#3-LFU算法" class="headerlink" title="3 LFU算法"></a>3 LFU算法</h1><p>LFU（Least Frequently used）算法，也叫作<strong>最近最少使用算法</strong>，顾名思义，就是淘汰缓存里面用的最少的数据。它根据数据的访问频次来进行淘汰数据，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。</p>
<h2 id="3-1-使用双哈希表实现高性能LFU"><a href="#3-1-使用双哈希表实现高性能LFU" class="headerlink" title="3.1 使用双哈希表实现高性能LFU"></a>3.1 使用双哈希表实现高性能LFU</h2><p>有了LRU的打底，我们知道，在排序问题中（LFU和LRU本质都是排序问题）要想实现O(1)时间复杂度的get性能，必须要借助哈希表来实现。但LFU相比LRU有个难点：<strong>频次相比于访问时间，更容易重复，即容易同时出现多于一个的key，他们的频次是一样的，且都是最低的。这时候出现平局，则需要在频次最低的基础上，再在重复的key中间，找到最久未使用的key，并淘汰</strong>。</p>
<p>也就是说，LFU的实现，除了要按照访问频率来排序，还要按照访问时间来排序。排序顺序是：访问频率降序&gt;访问时间降序。</p>
<p>为了达到上述目的，并且达到put和get都为O(1)复杂度，那么我们引入了双哈希表。</p>
<ul>
<li>第一个哈希表的含义是<strong>HashMap&lt;缓存的key，缓存数据节点的地址&gt;</strong><ul>
<li>第一个哈希表，和lru的实现一样，是用来实现O(1)时间查找key对应的节点。</li>
</ul>
</li>
<li>第一个哈希表的含义是<strong>HashMap&lt;访问频率，链表的头结点的地址&gt;</strong><ul>
<li>这个哈希表的每一个value，都是采用拉链法，挂上了一个缓存数据节点组成的双向链表（链表节点按照访问时间从近到远排序，表头访问时间最近，表尾访问时间最远）。</li>
<li>该哈希表的value值指向链表头部，而这个双向链表内存的，都是目前访问频率为其value对应的key值的缓存数据。</li>
<li>比如key=3的value是一个三个节点的链表，则表示这个链表内的三个缓存节点，访问频次都是3次。</li>
</ul>
</li>
</ul>
<p>一图胜万言：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-07e66e8579884f9a6e2e02cc87c79c8889b.png" alt=""></p>
<p>这样的实现下，我们对于get和put操作就可以：</p>
<ul>
<li><strong>get</strong>：如果第一个哈希表中能查到key，那么取得相应链表节点数据。接下来在第二个哈希表中，把该节点<strong>移到</strong>其访问频率+1位置的链表头部。</li>
<li><strong>put</strong>：如果第一个哈希表中能查找key，那么操作和get(key)一样，只是最后要把新节点的value更新为新value。</li>
<li><strong>当发生淘汰时</strong>：也就是要执行put操作，但是容量已经达到限制时，这时直接找到第二个哈希表中最小引用计数的链表，删除其末尾节点（最晚使用）。之后再添加新节点即可。</li>
</ul>
<blockquote>
<p>容量超限需要删除节点时，删除了第二个哈希表中的项的同时，第一个哈希表中对应的映射也应该删掉。</p>
</blockquote>
<blockquote>
<p>需要在双哈希表之外维护一个额外的min_cnt变量用来保存当前的最小访问频率。因为容量超限需要删除节点时，我们需要O(1)时间找到需要删除的节点。及调用get(min_cnt)来定位到要被删除的那个链表。</p>
</blockquote>
<h1 id="4-Redis中的LFU"><a href="#4-Redis中的LFU" class="headerlink" title="4 Redis中的LFU"></a>4 Redis中的LFU</h1><p>Redis4.0开始，maxmemory_policy淘汰策略添加了两个LFU模式：</p>
<ul>
<li>volatile-lfu：对有过期时间的key采用LFU淘汰算法</li>
<li>allkeys-lfu：对全部key采用LFU淘汰算法</li>
</ul>
<p>使用这两种淘汰策略，便会使用到Redis的LFU算法，一种<strong>近似计数算法</strong>。</p>
<h2 id="4-1-常规LFU算法面临的问题"><a href="#4-1-常规LFU算法面临的问题" class="headerlink" title="4.1 常规LFU算法面临的问题"></a>4.1 常规LFU算法面临的问题</h2><p>在数据请求模式比较稳定（没有对于某个数据突发的高频访问这样的不稳定模式）的情况下，LFU的表现还是很不错的。</p>
<p>但在数据的请求模式大多不稳定的情况下，LFU一般会有这样一些问题：</p>
<ol>
<li><strong>热点数据问题</strong>：热点数据一般只是几天内有较高的访问频次，过了这段时间就没那么大意义去缓存了。但是因为在热点期间他的频次被刷上去了，导致之后很长一段时间内很难被淘汰；</li>
<li><strong>新增数据问题</strong>：如果采用只记录缓存中的数据的访问信息，新加入的高频访问数据在刚加入的时候由于没有累积优势，很容易被淘汰掉；</li>
<li><strong>空间问题</strong>：如果记录全部出现过的数据的访问信息，会占用更多的内存空间。</li>
</ol>
<p>对于上面这些问题，其实也都有一些对应的解决方式，相应的出现了很多LFU的变种。如：Window-LFU、LFU*、LFU-Aging。在Redis的LFU算法实现中，也有其解决方案。</p>
<h2 id="4-2-Redis中的频次计算"><a href="#4-2-Redis中的频次计算" class="headerlink" title="4.2 Redis中的频次计算"></a>4.2 Redis中的频次计算</h2><p>在常规操作中，我们一般会引入一个字段作为计数器，对每个key的访问频次做简单的加法，但这样的实现显然无法规避上述的三个问题：一味做加法，过期的热点数据很难淘汰；新增的数据频次太低，容易被淘汰；Redis的访问频次量级非常大，每个key都维护一个长的字段，空间代价太大。</p>
<p>为了解决这三个问题，Redis的频次计算实现，引入了三个策略：</p>
<ol>
<li><strong>概率量级计数</strong>：该策略可以解决空间问题。<ul>
<li>可配参数server.lfu_log_factor就服务于该策略，它能够影响计数的量级范围，整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。</li>
</ul>
</li>
<li><strong>计数衰减</strong>：该策略可以解决热点数据问题。<ul>
<li>可配参数server.lfu-decay-time就服务于该策略，它能够控制LFU计数衰减，是一个以分钟为单位的数值，可以调整counter的减少速度。</li>
</ul>
</li>
<li><strong>新增数据赋值</strong>：该策略可以解决新增数据问题。<ul>
<li>固定常量LFU_INIT_VAL就服务于该策略，其值默认为5，即为新生key的counter设置一个初始频次，默认为5。</li>
</ul>
</li>
</ol>
<h3 id="4-2-1-概率量级计数"><a href="#4-2-1-概率量级计数" class="headerlink" title="4.2.1 概率量级计数"></a>4.2.1 概率量级计数</h3><p>Redis的LFU实现也是需要为每个key维护一个字段来承载该key的访问频次的，而且<strong>这个字段不能太大</strong>，不然Redis这么多key，那么消耗的空间将是一个可怕的数字，同时，本着Redis一贯对空间锱铢必较的心态，能重复利用的字段，我们绝不维护新的字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:LRU_BITS; &#x2F;* LRU time (relative to global lru_clock) or</span><br><span class="line">                            * LFU data (least significant 8 bits frequency</span><br><span class="line">                            * and most significant 16 bits access time). *&#x2F;</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>看来看去，redisObject结构中，也只有lru字段可以重复利用了，因为淘汰策略是互斥的，Redis同时只能选择一种淘汰策略，要么LRU，要么LFU，要么其他，所以lru字段重复利用不会冲突。</p>
<p>在LRU算法中，24 bits的lru是用来记录LRU time的，<strong>在LFU中使用这个字段，却是分成16 bits与8 bits使用</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*          16 bits      8 bits</span><br><span class="line">*     +----------------+--------+</span><br><span class="line">*     + Last decr time | LOG_C  |</span><br><span class="line">*     +----------------+--------+</span><br></pre></td></tr></table></figure>

<p>高16 bits用来记录最近一次计数器衰减的时间ldt，单位是分钟，这个我们下文再说。</p>
<p><strong>低8 bits记录计数器数值counter</strong>。8个bit位最大为255，显然如果只是简单的对counter做加法，那8 bit的counter根本无法容纳Redis那动辄百万或千万级别的命中频次。</p>
<p>那么，Redis如何使用8 bit的counter来承载百万或者千万级别的命中频次呢？相关源码在<code>evict.c</code>文件中的<code>LFULogIncr</code>方法中实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Logarithmically increment a counter. The greater is the current counter value</span><br><span class="line"> * the less likely is that it gets really implemented. Saturate it at 255. *&#x2F;</span><br><span class="line">uint8_t LFULogIncr(uint8_t counter) &#123;</span><br><span class="line">    if (counter &#x3D;&#x3D; 255) return 255;</span><br><span class="line">    &#x2F;&#x2F;这里的rand()方法会生成一个 0 ~ RAND_MAX 之间的随机数，所以r的范围也就是0~1之间。</span><br><span class="line">    double r &#x3D; (double)rand()&#x2F;RAND_MAX;</span><br><span class="line">    double baseval &#x3D; counter - LFU_INIT_VAL;</span><br><span class="line">    if (baseval &lt; 0) baseval &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;根据目前counter和server.lfu_log_factor值得出一个p</span><br><span class="line">    double p &#x3D; 1.0&#x2F;(baseval*server.lfu_log_factor+1);</span><br><span class="line">    &#x2F;&#x2F;如果r &lt; p，counter才+1</span><br><span class="line">    if (r &lt; p) counter++;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看p字段：</p>
<p>对于<code>p=1.0/(baseval*server.lfu_log_factor+1);</code></p>
<p>等价于<code>p=1/((counter−LFU_INIT_VAL)*factor+1);</code></p>
<p>因为LFU_INIT_VAL是常数，所以当counter够大时，近似等于：<code>p=1/(counter*factor+1)</code></p>
<p>factor是个常数，server.lfu_log_factor默认值是10，下图展示了factor不同时，p=f(counter)的函数曲线</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bc7b790c06e282c599c94a25afdb0d0736c.png" alt=""></p>
<p>紧接着再来看r，r是由random函数随机出来的范围在0~1之间的值，我们可以认为r的值是随机的，那么我们可以认为：</p>
<p>r的值在0 ~ 1范围内，也就是r&lt;=1的概率为100%（1）；</p>
<p>r的值在0 ~ 0.9范围内，也就是r&lt;=0.9的概率为90%（0.9）；</p>
<p>以此类推。</p>
<p>r的值在0 ~ p的范围内，也就是r&lt;=p的概率为p；</p>
<p><strong>所以综上所诉</strong>，Redis的概率量级计数的核心逻辑就是：</p>
<ol>
<li><p><strong>每一次key被访问，counter都有近似<code>p=1/(counter*factor+1)</code>的概率会+1。在factor是常数的情况下，counter+1的概率随着counter值的增大而减小</strong>。</p>
</li>
<li><p><strong>factor值我们设置的越大，则counter+1的概率在同等情况下则会越低，counter字段8 bit一共255的上限也就越不容易被触达，换句话说，factor越大，Redis的counter字段能够记录的访问频次量级也就越高</strong>。</p>
</li>
</ol>
<blockquote>
<p>概率量级计数，就体现在p和factor上，p控制的是counter的概率上升，factor控制的是counter承载的访问量级。</p>
</blockquote>
<p>下表是不同的factor的值能够控制计数代表的量级的范围，当factor为100时，能够最大代表10M，也就是千万级别的命中数。</p>
<table>
<thead>
<tr>
<th align="center">factor</th>
<th align="center">100 hits</th>
<th align="center">1000 hits</th>
<th align="center">100K hits</th>
<th align="center">1M hits</th>
<th align="center">10M hits</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">104</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">18</td>
<td align="center">49</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">18</td>
<td align="center">142</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">100</td>
<td align="center">8</td>
<td align="center">11</td>
<td align="center">49</td>
<td align="center">143</td>
<td align="center">255</td>
</tr>
</tbody></table>
<p>下图是不同factor场景下，不同key的counter字段的值（颜色不同的线）在固定访问频率下随着时间的上升走势。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ddad582bc4e83b730a0c8fff3336ddd3158.png" alt=""></p>
<h3 id="4-2-2-计数衰减"><a href="#4-2-2-计数衰减" class="headerlink" title="4.2.2 计数衰减"></a>4.2.2 计数衰减</h3><p>上一章节我们讲了counter是概率增加，但为了解决热点问题，使热点数据能够随着时间推移慢慢的降低频次，以至于最后淘汰，那么Redis引入了计数衰减的策略。</p>
<p><strong>某个key的counter被衰减的时机是在它被访问的时候</strong>。在缓存被访问时，会更新数据的访问计数，更新的步骤是：</p>
<ol>
<li>先在现有数据的计数上进行计数衰减。</li>
<li>再对完成衰减后的计数进行概率增加。</li>
</ol>
<blockquote>
<p>所以要注意，计数衰减的触发也是被动的，而非Redis主动或者定时触发的。</p>
</blockquote>
<p>计数衰减的实现在LFUDecrAndReturn方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Return the current time in minutes, just taking the least significant</span><br><span class="line"> * 16 bits. The returned time is suitable to be stored as LDT (last decrement</span><br><span class="line"> * time) for the LFU implementation. *&#x2F;</span><br><span class="line">unsigned long LFUGetTimeInMinutes(void) &#123;</span><br><span class="line">    return (server.unixtime&#x2F;60) &amp; 65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Given an object last access time, compute the minimum number of minutes</span><br><span class="line"> * that elapsed since the last access. Handle overflow (ldt greater than</span><br><span class="line"> * the current 16 bits minutes time) considering the time as wrapping</span><br><span class="line"> * exactly once. *&#x2F;</span><br><span class="line">unsigned long LFUTimeElapsed(unsigned long ldt) &#123;</span><br><span class="line">    &#x2F;&#x2F;计算当前时间和ldt的时间差值，如果now &lt; ldt，默认为过了一个周期了，那么差值应该是65535-ldt+now。</span><br><span class="line">    unsigned long now &#x3D; LFUGetTimeInMinutes();</span><br><span class="line">    if (now &gt;&#x3D; ldt) return now-ldt;</span><br><span class="line">    return 65535-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* If the object decrement time is reached decrement the LFU counter but</span><br><span class="line"> * do not update LFU fields of the object, we update the access time</span><br><span class="line"> * and counter in an explicit way when the object is really accessed.</span><br><span class="line"> * And we will times halve the counter according to the times of</span><br><span class="line"> * elapsed time than server.lfu_decay_time.</span><br><span class="line"> * Return the object frequency counter.</span><br><span class="line"> *</span><br><span class="line"> * This function is used in order to scan the dataset for the best object</span><br><span class="line"> * to fit: as we check for the candidate, we incrementally decrement the</span><br><span class="line"> * counter of the scanned objects if needed. *&#x2F;</span><br><span class="line">unsigned long LFUDecrAndReturn(robj *o) &#123;</span><br><span class="line">    unsigned long ldt &#x3D; o-&gt;lru &gt;&gt; 8;</span><br><span class="line">    unsigned long counter &#x3D; o-&gt;lru &amp; 255;</span><br><span class="line">    &#x2F;&#x2F;算出该key已经经历过num_periods个周期了</span><br><span class="line">    unsigned long num_periods &#x3D; server.lfu_decay_time ? LFUTimeElapsed(ldt) &#x2F; server.lfu_decay_time : 0;</span><br><span class="line">    if (num_periods)</span><br><span class="line">        counter &#x3D; (num_periods &gt; counter) ? 0 : counter - num_periods;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很晦涩，没关系，逻辑其实并不复杂：</p>
<ol>
<li><p>可配参数server.lfu-decay-time所代表的含义是计数衰减的周期长度，单位是分钟。当时间过去一个周期（也就是lfu-decay-time分钟），计数值就会减1。</p>
</li>
<li><p>redisObject结构中的lru字段的高16bit，记录的是该key上次进行衰减的时间。</p>
</li>
<li><p>有上述两个数据可以算出从上次衰减到现在，该key已经经历过n个周期了，这也表示着，key需要先将counter衰减n。</p>
<ul>
<li>n的计算过程如代码所示，即从上次衰减到现在经过的时间除以衰减周期长度 server.lfu_decay_time：</li>
<li><code>unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;</code></li>
</ul>
</li>
<li><p>通过<code>LFUDecrAndReturn</code>方法得到该key的counter需要衰减的值n，将counter=counter-n，然后再执行概率增加计数的操作。</p>
</li>
</ol>
<h3 id="4-2-3-新增数据赋值"><a href="#4-2-3-新增数据赋值" class="headerlink" title="4.2.3 新增数据赋值"></a>4.2.3 新增数据赋值</h3><p>为了解决新增数据问题，即如果采用只记录缓存中的数据的访问信息，新加入的高频访问数据在刚加入的时候由于没有累积优势，很容易被淘汰掉；</p>
<p>那么对于新增加的key，则不能将他们的counter设为0，Redis为新增的key的counter设置了一个初始值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">robj *createObject(int type, void *ptr) &#123;</span><br><span class="line">    robj *o &#x3D; zmalloc(sizeof(*o));</span><br><span class="line">    o-&gt;type &#x3D; type;</span><br><span class="line">    o-&gt;encoding &#x3D; OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr &#x3D; ptr;</span><br><span class="line">    o-&gt;refcount &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set the LRU to the current lruclock (minutes resolution), or</span><br><span class="line">     * alternatively the LFU counter. *&#x2F;</span><br><span class="line">    if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru &#x3D; (LFUGetTimeInMinutes()&lt;&lt;8) | LFU_INIT_VAL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        o-&gt;lru &#x3D; LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即counter会被初始化为LFU_INIT_VAL，默认5。</p>
<blockquote>
<p>回顾我们上文说道的p=1/((counter−LFU_INIT_VAL)*factor+1)，可以看到，当计数值等于LFU_INIT_VAL时， p=1，也就是说，对于新增的key，下一次访问时，counter增加的概率为100%</p>
</blockquote>
<h2 id="4-3-Redis-LFU回收流程"><a href="#4-3-Redis-LFU回收流程" class="headerlink" title="4.3 Redis LFU回收流程"></a>4.3 Redis LFU回收流程</h2><p>Redis LFU回收流程和Redis LRU的回收流程<strong>一模一样</strong>（有所遗忘可以回顾本文2.3章），<strong>都是采用抽样+回收池的实现方式，不同的是LRU比较的是idle time空闲时间，而LFU比较的是counter访问频次</strong>。故不再赘述。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" itemprop="url">JAVA静态/动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T17:02:42+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E5%AE%9E%E7%8E%B0%E6%88%96%E7%89%B9%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA实现或特性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/26/JAVA静态-动态代理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-静态代理（简单描述）"><a href="#1-静态代理（简单描述）" class="headerlink" title="1 静态代理（简单描述）"></a>1 静态代理（简单描述）</h1><p>先定义一个接口，里面定义目标方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;目标类要实现的接口</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;目标方法</span><br><span class="line">	void doFunc(String words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class StaticProxy implements ITarget&#123;</span><br><span class="line">	</span><br><span class="line">	private ITarget target &#x3D; null;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;关联要增强的目标类</span><br><span class="line">    public StaticProxy(ITarget target)&#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F;在这里增强目标类的目标方法</span><br><span class="line">	@Override</span><br><span class="line">	public void doFunc() &#123;</span><br><span class="line">	    ...</span><br><span class="line">	    ...</span><br><span class="line">	    ...</span><br><span class="line">        &#x2F;&#x2F;增强目标方法</span><br><span class="line">        target.doFunc();</span><br><span class="line">        ...</span><br><span class="line">	    ...</span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后，任意的一个ITarget接口的子类，都可以注入给StaticProxy类，然后实现一套增强，不再赘述。</p>
<h1 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2 动态代理"></a>2 动态代理</h1><p>代理类在程序运行时创建的代理方式被成为 动态代理。也就是说，这种情况下，代理类并不是像静态代理一样，是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。</p>
<p>动态代理是spring AOP的实现原理，spring有两种动态代理模式，cglib和jdk，我们先来将java jdk的动态代理。</p>
<h2 id="2-1-jdk的动态代理"><a href="#2-1-jdk的动态代理" class="headerlink" title="2.1 jdk的动态代理"></a>2.1 jdk的动态代理</h2><p>首先，我们需要知道，jdk的动态代理只能代理实现了接口的类 没有实现接口的类不能实现JDK动态代理。其次，我们还要了解一个重要的中介接口InvocationHandler，这是jdk的动态代理的基石，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">        throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来写一个jdk的动态代理实例，再来讨论其中的原理吧</p>
<h3 id="2-1-1-jdk动态代理实例"><a href="#2-1-1-jdk动态代理实例" class="headerlink" title="2.1.1 jdk动态代理实例"></a>2.1.1 jdk动态代理实例</h3><p>我们先来定义一个目标类，或者说委托类，或者又叫被代理类，它实现了我们上面定义的那个接口ITarget：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Entrust implements ITarget &#123;</span><br><span class="line">    public void doFunc(String words)&#123;</span><br><span class="line">        System.out.println(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个中介类，实现InvocationHandler接口，这个中介类，持有被代理的对象，在invoke中利用反射，调用目标类的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class JdkDynamicProxyHandler&lt;T&gt;  implements InvocationHandler &#123;</span><br><span class="line">    &#x2F;&#x2F;invocationHandler持有的被代理对象</span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    public JdkDynamicProxyHandler(T target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * proxy:代表动态代理对象</span><br><span class="line">     * method：代表正在执行的方法</span><br><span class="line">     * args：代表调用目标方法时传入的实参</span><br><span class="line">     * </span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;do before&quot;);</span><br><span class="line">        Object result &#x3D; method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;do after&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我们现在来写一个代理demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        ITarget attorney = <span class="keyword">new</span> Attorney();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler jdkDynamicProxyHandler = <span class="keyword">new</span> JdkDynamicProxyHandler&lt;ITarget&gt;(attorney);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个代理对象proxy来代理attorney，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        ITarget proxy = (ITarget) Proxy.newProxyInstance(ITarget.class.getClassLoader(), new Class&lt;?&gt;[]&#123;ITarget.class&#125;, jdkDynamicProxyHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        proxy.doFunc(<span class="string">"hello word"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将生成的代理类写到桌面</span></span><br><span class="line">        writeProxyClassToHardDisk(<span class="string">"/home/ls/Desktop/$Proxy22.class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeProxyClassToHardDisk</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy22"</span>, Attorney<span class="class">.<span class="keyword">class</span>.<span class="title">getInterfaces</span>())</span>;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f546dfbc4dc94c8202ee7ec822f109c869c.png" alt=""></p>
<h3 id="2-1-2-原理剖析"><a href="#2-1-2-原理剖析" class="headerlink" title="2.1.2 原理剖析"></a>2.1.2 原理剖析</h3><p>我们来看看Proxy.newProxyInstance方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        final Class&lt;?&gt;[] intfs &#x3D; interfaces.clone();</span><br><span class="line">        final SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">        if (sm !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;验证一些参数</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Look up or generate the designated proxy class.</span><br><span class="line">         * 从缓存里面获取某个类的代理类，如果该类的代理类不存在，就根据该类的类型创建一个</span><br><span class="line">         * 如果要深挖逻辑，可以看看ProxyClassFactory的apply方法。</span><br><span class="line">         * 其实生成代理类字节码文件的工作是通过 ProxyGenerate类中的generateProxyClass方法来完成的。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Invoke its constructor with the designated invocation handler.</span><br><span class="line">         *</span><br><span class="line">         * &#x2F;** parameter types of a proxy class constructor *&#x2F;</span><br><span class="line">         * private static final Class&lt;?&gt;[] constructorParams &#x3D; &#123; InvocationHandler.class &#125;;</span><br><span class="line">         * </span><br><span class="line">         *&#x2F;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (sm !&#x3D; null) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;看上面的注释，constructorParams&#x3D;&#123; InvocationHandler.class &#125;，</span><br><span class="line">            &#x2F;&#x2F;这是在生成代理类的构造函数,获得一个参数为InvocationHandler的构造方法</span><br><span class="line">            final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih &#x3D; h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        cons.setAccessible(true);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;这行代码的意思是将h,也就是实现InvocationHandler的实现类，</span><br><span class="line">            &#x2F;&#x2F;我们传入的是jdkDynamicProxyHandler，注入到cons中。</span><br><span class="line">            &#x2F;&#x2F;然后newInstance生成一个已经组装过参数的代理类。</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t &#x3D; e.getCause();</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的。</p>
<p>我们对这个代理类进行反编译：（本次使用<a href="http://www.javadecompilers.com/在线反编译工具）" target="_blank" rel="noopener">http://www.javadecompilers.com/在线反编译工具）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import aopLearn.ITarget;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; Decompiled by Procyon v0.5.30</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line"></span><br><span class="line">public final class $Proxy22 extends Proxy implements ITarget</span><br><span class="line">&#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m0;</span><br><span class="line">    &#x2F;**</span><br><span class="line">      *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白了</span><br><span class="line">      *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span><br><span class="line">      *被代理对象的实例</span><br><span class="line">      *</span><br><span class="line">      *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span><br><span class="line">      *父类持有：protected InvocationHandler h;</span><br><span class="line">      *Proxy构造方法：</span><br><span class="line">      *    protected Proxy(InvocationHandler h) &#123;</span><br><span class="line">      *         Objects.requireNonNull(h);</span><br><span class="line">      *         this.h &#x3D; h;</span><br><span class="line">      *     &#125;</span><br><span class="line">      *</span><br><span class="line">      *&#x2F;</span><br><span class="line">    public $Proxy22(final InvocationHandler invocationHandler) &#123;</span><br><span class="line">        super(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;这个静态块本来是在最后的，我把它拿到前面来，方便描述</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;doFunc通过反射得到的名字m3</span><br><span class="line">            $Proxy22.m1 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            $Proxy22.m3 &#x3D; Class.forName(&quot;aopLearn.ITarget&quot;).getMethod(&quot;doFunc&quot;, Class.forName(&quot;java.lang.String&quot;));</span><br><span class="line">            $Proxy22.m2 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, (Class&lt;?&gt;[])new Class[0]);</span><br><span class="line">            $Proxy22.m0 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, (Class&lt;?&gt;[])new Class[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (NoSuchMethodException ex) &#123;</span><br><span class="line">            throw new NoSuchMethodError(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ClassNotFoundException ex2) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(ex2.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final boolean equals(final Object o) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (boolean)super.h.invoke(this, $Proxy22.m1, new Object[] &#123; o &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">      * </span><br><span class="line">      *这里调用代理对象的doFunc方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span><br><span class="line">      *this.h.invoke(this, m3, null);这里简单，明了。</span><br><span class="line">      *代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span><br><span class="line">      *再联系到InvacationHandler中的invoke方法。其实就是代理对象调用InvocationHandler，</span><br><span class="line">      * InvocationHandler对象反射调用委托类对象。</span><br><span class="line">      *&#x2F;</span><br><span class="line">    public final void doFunc(final String s) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, $Proxy22.m3, new Object[] &#123; s &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final String toString() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, $Proxy22.m2, null);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (int)super.h.invoke(this, $Proxy22.m0, null);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了这些，我们来想一下，为什么jdk的动态代理，一定要委托类实现一个接口？这是因为我们可以看到，<strong>我们生成的代理类Proxy22 extends Proxy implements ITarget，已经继承了Proxy类，而java中不能多继承，为了让$Proxy22和委托类建立联系，只能实现一个接口</strong>。这里的建立联系，是指通过接口，得到委托类方法的反射等，<strong>并且，委托类实现自接口的方法，才能被增强</strong>。</p>
<p>故而，本质上来说，jdk的动态代理，<strong>是为接口产生代理</strong>。</p>
<p>在spring AOP中，我们使用jdk动态代理时当然也要定义InvocationHandler的实现类对象，spring中的是org.springframework.aop.framework.JdkDynamicAopProxy类。</p>
<h2 id="2-2-cglib的动态代理"><a href="#2-2-cglib的动态代理" class="headerlink" title="2.2 cglib的动态代理"></a>2.2 cglib的动态代理</h2><p>cglib的动态代理针对类来实现代理,对指定目标产生一个子类 通过方法拦截技术拦截所有父类方法的调用。我们要使用cglib代理必须引入cglib的jar包。</p>
<h3 id="2-2-1-cglib动态代理实例"><a href="#2-2-1-cglib动态代理实例" class="headerlink" title="2.2.1 cglib动态代理实例"></a>2.2.1 cglib动态代理实例</h3><p>同样，定义一个跟上面例子一样的委托类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Entrust &#123;</span><br><span class="line">    public void doFunc(String words)&#123;</span><br><span class="line">        System.out.println(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现MethodInterceptor接口生成方法拦截器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class EntrustInterceptor implements MethodInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        Object o &#x3D; proxy.invokeSuper(obj,args);</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] a)&#123;</span><br><span class="line">    &#x2F;&#x2F;cglib自带的debug工具，可以将代理类输出到指定路径</span><br><span class="line">    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;&#x2F;home&#x2F;ls&#x2F;Desktop&#x2F;cglib&quot;);</span><br><span class="line">    Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">    &#x2F;&#x2F;继承被代理类</span><br><span class="line">    enhancer.setSuperclass(Entrust.class);</span><br><span class="line">    enhancer.setCallback(new EntrustInterceptor());</span><br><span class="line">    &#x2F;&#x2F;生成的代理类对象</span><br><span class="line">    Entrust entrust &#x3D; (Entrust) enhancer.create();</span><br><span class="line">    &#x2F;&#x2F;在调用我们代理类中的方法时会被我们实现的方法拦截器拦截</span><br><span class="line">    entrust.doFunc(&quot;hello word&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：<br><img src="https://oscimg.oschina.net/oscnet/up-b3377d0e8764157f3d7b386c8cf3223b381.png" alt=""></p>
<h3 id="2-2-2-原理剖析"><a href="#2-2-2-原理剖析" class="headerlink" title="2.2.2 原理剖析"></a>2.2.2 原理剖析</h3><p>CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。</p>
<p>我们看到，代理类对象是由Enhancer类创建的。Enhancer是CGLIB的字节码增强器，可以很方便的对类进行拓展，创建代理对象的几个步骤:</p>
<ol>
<li>生成代理类的二进制字节码文件；</li>
<li>加载二进制字节码，生成Class对象( 例如使用Class.forName()方法 )；</li>
<li>通过反射机制获得实例构造，并创建代理类对象</li>
</ol>
<p>我们来看看将代理类Class文件反编译之后的Java代码，一个动态代理，产生了三个类：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6c31ef9c2dc4797d243753037ae6e48b39b.png" alt=""></p>
<p>主要的代理类是 </p>
<pre><code>Entrust$$EnhancerByCGLIB$$832e20ab</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Decompiled by Procyon v0.5.30</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.lufax.util.aopCache.cglibProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.Signature;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Factory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成的代理类Entrust$$EnhancerByCGLIB$$832e20ab继承被代理类Entrust。</span></span><br><span class="line"><span class="comment"> * 在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；</span></span><br><span class="line"><span class="comment"> * 同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entrust</span>$$<span class="title">EnhancerByCGLIB</span>$$832<span class="title">e20ab</span> <span class="keyword">extends</span> <span class="title">Entrust</span> <span class="keyword">implements</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$doFunc$<span class="number">0</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$doFunc$<span class="number">0</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$finalize$<span class="number">1</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$finalize$<span class="number">1</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$equals$<span class="number">2</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$equals$<span class="number">2</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$toString$<span class="number">3</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$toString$<span class="number">3</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$hashCode$<span class="number">4</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$hashCode$<span class="number">4</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$clone$<span class="number">5</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$clone$<span class="number">5</span>$Proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName = Class.forName(<span class="string">"com.lufax.util.aopCache.cglibProxy.Entrust$$EnhancerByCGLIB$$832e20ab"</span>);</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName2;</span><br><span class="line">        <span class="keyword">final</span> Method[] methods = ReflectUtils.findMethods(<span class="keyword">new</span> String[] &#123; <span class="string">"finalize"</span>, <span class="string">"()V"</span>, <span class="string">"equals"</span>, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"hashCode"</span>, <span class="string">"()I"</span>, <span class="string">"clone"</span>, <span class="string">"()Ljava/lang/Object;"</span> &#125;, (forName2 = Class.forName(<span class="string">"java.lang.Object"</span>)).getDeclaredMethods());</span><br><span class="line">        CGLIB$finalize$<span class="number">1</span>$Method = methods[<span class="number">0</span>];</span><br><span class="line">        CGLIB$finalize$<span class="number">1</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()V"</span>, <span class="string">"finalize"</span>, <span class="string">"CGLIB$finalize$1"</span>);</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Method = methods[<span class="number">1</span>];</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"equals"</span>, <span class="string">"CGLIB$equals$2"</span>);</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Method = methods[<span class="number">2</span>];</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"toString"</span>, <span class="string">"CGLIB$toString$3"</span>);</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Method = methods[<span class="number">3</span>];</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()I"</span>, <span class="string">"hashCode"</span>, <span class="string">"CGLIB$hashCode$4"</span>);</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Method = methods[<span class="number">4</span>];</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()Ljava/lang/Object;"</span>, <span class="string">"clone"</span>, <span class="string">"CGLIB$clone$5"</span>);</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName3;</span><br><span class="line">        CGLIB$doFunc$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[] &#123; <span class="string">"doFunc"</span>, <span class="string">"(Ljava/lang/String;)V"</span> &#125;, (forName3 = Class.forName(<span class="string">"com.lufax.util.aopCache.cglibProxy.Entrust"</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">        CGLIB$doFunc$<span class="number">0</span>$Proxy = MethodProxy.create((Class)forName3, (Class)forName, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="string">"doFunc"</span>, <span class="string">"CGLIB$doFunc$0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理类会为委托方法生成两个方法，一个是重写的doFunc方法，</span></span><br><span class="line">    <span class="comment">//另一个是CGLIB$doFunc$0方法，我们可以看到它是直接调用父类的doFunc方法；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$doFunc$<span class="number">0</span>(<span class="keyword">final</span> String s) &#123;</span><br><span class="line">        <span class="keyword">super</span>.doFunc(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当执行代理对象的doFunc方法时，会首先判断一下是否存在实现了MethodInterceptor接口的CGLIB$CALLBACK_0;</span></span><br><span class="line">    <span class="comment">//如果存在，则将调用MethodInterceptor中的intercept方法，如图2.1。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doFunc</span><span class="params">(<span class="keyword">final</span> String s)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里开始调用我们定义的EntrustInterceptor中的intercept方法。</span></span><br><span class="line">            <span class="comment">//参数1、代理对象；2、委托类方法；3、方法参数；4、代理方法的MethodProxy对象（注意这个对象）。</span></span><br><span class="line">            cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$doFunc$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[] &#123; s &#125;, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$doFunc$<span class="number">0</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.doFunc(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$finalize$<span class="number">1</span>() <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$finalize$<span class="number">1</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$finalize$<span class="number">1</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> CGLIB$equals$<span class="number">2</span>(<span class="keyword">final</span> Object o) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object intercept = cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$equals$<span class="number">2</span>$Method, <span class="keyword">new</span> Object[] &#123; o &#125;, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$equals$<span class="number">2</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> intercept != <span class="keyword">null</span> &amp;&amp; (<span class="keyword">boolean</span>)intercept;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> String CGLIB$toString$<span class="number">3</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$toString$<span class="number">3</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$toString$<span class="number">3</span>$Proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CGLIB$hashCode$<span class="number">4</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object intercept = cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$hashCode$<span class="number">4</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$hashCode$<span class="number">4</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> (intercept == <span class="keyword">null</span>) ? <span class="number">0</span> : ((Number)intercept).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Object CGLIB$clone$<span class="number">5</span>() <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$clone$<span class="number">5</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$clone$<span class="number">5</span>$Proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodProxy CGLIB$findMethodProxy(<span class="keyword">final</span> Signature signature) &#123;</span><br><span class="line">        <span class="keyword">final</span> String string = signature.toString();</span><br><span class="line">        <span class="keyword">switch</span> (string.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">1574182249</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"finalize()V"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$finalize$<span class="number">1</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">508378822</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"clone()Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$clone$<span class="number">5</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">346793840</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"doFunc(Ljava/lang/String;)V"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$doFunc$<span class="number">0</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1826985398</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"equals(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$equals$<span class="number">2</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1913648695</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"toString()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$toString$<span class="number">3</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1984935277</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"hashCode()I"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$hashCode$<span class="number">4</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">final</span> Callback[] array) &#123;</span><br><span class="line">        Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$THREAD_CALLBACKS.set(array);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(<span class="keyword">final</span> Callback[] cglib$STATIC_CALLBACKS) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = cglib$STATIC_CALLBACKS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(<span class="keyword">final</span> Object o) &#123;</span><br><span class="line">        <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = (Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab)o;</span><br><span class="line">        <span class="keyword">if</span> (!entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$BOUND) &#123;</span><br><span class="line">            entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object o2;</span><br><span class="line">            <span class="keyword">if</span> ((o2 = Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$THREAD_CALLBACKS.get()) != <span class="keyword">null</span> || (o2 = Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$STATIC_CALLBACKS) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])o2)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Callback[] array)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(array);</span><br><span class="line">        <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = <span class="keyword">new</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">new</span> Callback[] &#123; callback &#125;);</span><br><span class="line">        <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = <span class="keyword">new</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Class[] array, <span class="keyword">final</span> Object[] array2, <span class="keyword">final</span> Callback[] array3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(array3);</span><br><span class="line">        <span class="keyword">switch</span> (array.length) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = <span class="keyword">new</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab();</span><br><span class="line">                CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Constructor not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        Object cglib$CALLBACK_0 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                cglib$CALLBACK_0 = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Callback)cglib$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> n, <span class="keyword">final</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)callback;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[] &#123; <span class="keyword">this</span>.CGLIB$CALLBACK_0 &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(<span class="keyword">final</span> Callback[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑进入到我们在EntrustInterceptor 中定义的intercept方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;before&quot;);</span><br><span class="line">    Object o &#x3D; proxy.invokeSuper(obj,args);</span><br><span class="line">    System.out.println(&quot;after&quot;);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看MethodProxy的invokeSuper方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Invoke the original (super) method on the specified object.</span><br><span class="line">     * @param obj the enhanced object, must be the object passed as the first</span><br><span class="line">     * argument to the MethodInterceptor</span><br><span class="line">     * @param args the arguments passed to the intercepted method; you may substitute a different</span><br><span class="line">     * argument array as long as the types are compatible</span><br><span class="line">     * @see MethodInterceptor#intercept</span><br><span class="line">     * @throws Throwable the bare exceptions thrown by the called method are passed through</span><br><span class="line">     * without wrapping in an &lt;code&gt;InvocationTargetException&lt;&#x2F;code&gt;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            init();</span><br><span class="line">            FastClassInfo fci &#x3D; fastClassInfo;</span><br><span class="line">            &#x2F;&#x2F;f2是由CGlib生成的,在输出的class中有这个类。</span><br><span class="line">            &#x2F;&#x2F;它就是Entrust$$EnhancerByCGLIB$$832e20ab$$FastClassByCGLIB$$817a77c.class</span><br><span class="line">            return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            throw e.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们把</p>
<pre><code>Entrust$$EnhancerByCGLIB$$832e20ab$$FastClassByCGLIB$$817a77c.class</code></pre><p>也反编译出来，然后贴出invoke方法,注意case14调用了</p>
<pre><code>entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$doFunc$0((String)array[0]);：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(final int n, final Object o, final Object[] array) throws InvocationTargetException &#123;</span><br><span class="line">        final Entrust$$EnhancerByCGLIB$$832e20ab entrust$$EnhancerByCGLIB$$832e20ab &#x3D; (Entrust$$EnhancerByCGLIB$$832e20ab)o;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (n) &#123;</span><br><span class="line">                case 0: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.setCallbacks((Callback[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 1: &#123;</span><br><span class="line">                    Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$SET_STATIC_CALLBACKS((Callback[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 2: &#123;</span><br><span class="line">                    Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$SET_THREAD_CALLBACKS((Callback[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 3: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.getCallback(((Number)array[0]).intValue());</span><br><span class="line">                &#125;</span><br><span class="line">                case 4: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.getCallbacks();</span><br><span class="line">                &#125;</span><br><span class="line">                case 5: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.doFunc((String)array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 6: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.setCallback(((Number)array[0]).intValue(), (Callback)array[1]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 7: &#123;</span><br><span class="line">                    return Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$findMethodProxy((Signature)array[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 8: &#123;</span><br><span class="line">                    Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$STATICHOOK1();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 9: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$finalize$1();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 10: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$toString$3();</span><br><span class="line">                &#125;</span><br><span class="line">                case 11: &#123;</span><br><span class="line">                    return new Integer(entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$hashCode$4());</span><br><span class="line">                &#125;</span><br><span class="line">                case 12: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$clone$5();</span><br><span class="line">                &#125;</span><br><span class="line">                case 13: &#123;</span><br><span class="line">                    return new Boolean(entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$equals$2(array[0]));</span><br><span class="line">                &#125;</span><br><span class="line">                case 14: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$doFunc$0((String)array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 15: &#123;</span><br><span class="line">                    return new Boolean(entrust$$EnhancerByCGLIB$$832e20ab.equals(array[0]));</span><br><span class="line">                &#125;</span><br><span class="line">                case 16: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                case 17: &#123;</span><br><span class="line">                    return new Integer(entrust$$EnhancerByCGLIB$$832e20ab.hashCode());</span><br><span class="line">                &#125;</span><br><span class="line">                case 18: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.newInstance((Callback)array[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 19: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.newInstance((Class[])array[0], (Object[])array[1], (Callback[])array[2]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 20: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.newInstance((Callback[])array[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 21: &#123;</span><br><span class="line">                    Entrust.main((String[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 22: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.wait(((Number)array[0]).longValue(), ((Number)array[1]).intValue());</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 23: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.wait(((Number)array[0]).longValue());</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 24: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.wait();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 25: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.getClass();</span><br><span class="line">                &#125;</span><br><span class="line">                case 26: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.notify();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 27: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.notifyAll();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new InvocationTargetException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot find matching method&#x2F;constructor&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>事实证明，最后确实是进入了case14，调用了代理类的代理doFunc方法，最后再回到EntrustInterceptor.invoke中。完成逻辑</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" itemprop="url">ZAB协议分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T16:18:54+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分布式算法&理论</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务和数据一致性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/26/ZAB协议分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ZAB并不是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p>
<h1 id="1-ZAB协议内容"><a href="#1-ZAB协议内容" class="headerlink" title="1 ZAB协议内容"></a>1 ZAB协议内容</h1><ul>
<li>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为leader服务器，而余下的其他服务器则成为follower服务器。</li>
<li>leader服务器负责将一个客户端事务请求转换成一个事务proposal，并将该proposal分发给集群中所有的follower服务器。之后leader服务器需要等待所有follower服务器的反馈，一旦超过半数的follower服务器进行了正确的反馈后，那么leader就会自己先commit这个事务，并再次向所有的follower服务器分发commit消息，要求其将前一个proposal进行提交。</li>
</ul>
<p>ZAB有两种基本的模式：<strong>崩溃恢复</strong>和<strong>消息广播</strong>。</p>
<ul>
<li><p>当整个服务框架启动过程中或Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。</p>
</li>
<li><p>当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式，那么整个服务框架就可以进入消息广播模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够与leader服务器的数据状态保持一致。</p>
</li>
<li><p>Leader选举算法不仅仅需要让Leader自身知道已经被选举为Leader，同时还需要让集群中的所有其他机器也能够快速地感知到选举产生的新的Leader服务器。</p>
</li>
<li><p>当一台同样遵守ZAB协议的服务器启动并加入集群后，如果已经存在leader，那么它会自觉的找到leader，与其进行数据同步，然后一起参与消息广播。</p>
</li>
<li><p>如果follower服务器接收到客户端的事务请求，那么他们会将这个事务请求转发给leader服务器。</p>
</li>
<li><p>当Leader服务器出现崩溃或者机器重启、集群中已经不存在过半的服务器与Leader服务器保持正常通信时，那么在重新开始新的一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此到达一致状态，于是整个ZAB流程就会从消息广播模式进入到崩溃恢复模式。</p>
</li>
<li><p>一个机器要成为leader，要获得过半机器的支持，而由于每台机器都可能崩溃，因此整个过程可能出现多个leader，一个机器也可能多次成为leader。</p>
</li>
</ul>
<h1 id="2-消息广播"><a href="#2-消息广播" class="headerlink" title="2 消息广播"></a>2 消息广播</h1><ul>
<li><p>ZAB协议的消息广播过程使用原子广播协议，类似于一个二阶段提交过程，针对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal，并将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交。</p>
<p>  <img src="https://oscimg.oschina.net/oscnet/ffe6905ecbbad6dd3f977e0ef78de5e1c8e.jpg" alt=""></p>
</li>
<li><p>此处ZAB的二阶段提交和一般的二阶段提交略有不同，ZAB移除了二阶段提交中的事务中断的逻辑，follower服务器要么正常反馈，要么抛弃leader。好处是我们不需要等待所有follower都反馈响应才能提交事务，坏处是集群无法处理leader崩溃而带来的数据不一致的问题。后者需要崩溃恢复模式来解决这个问题。</p>
</li>
<li><p>整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能够很容易保证消息广播过程中消息接受与发送的顺序性。</p>
</li>
<li><p>整个消息广播过程中，Leader服务器会为每个事务生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会先为这个Proposal分配一个全局单调递增的唯一ID，称之为事务ID（ZXID），由于ZAB协议需要保证每个消息严格的因果关系，因此必须将每个事务Proposal按照其ZXID的先后顺序来进行排序和处理。</p>
</li>
<li><p>在广播过程中，leader会为每一个follower分配一个单独的队列，然后将需要广播的事务proposal依次放入，并且根据FIFO策略进行消息发送。每个follower接收到proposal之后，都会首先将其以事务日志的形式写入本地磁盘，写入成功后反馈leader一个ack响应。当leader收到超过半数的follower的ack响应之后，就会广播一个commit消息给所有follower以通知其进行事务提交，同时leader自身也完成事务的提交。每个follower在接收到commit之后，也会完成对事务的提交。</p>
</li>
<li><p>在广播过程中，follower接收到proposal之后记录事务日志失败，或者proposal丢失，而是直接接到了这个proposal的commit，那么follower就会向leader发送请求重新申请这个任务，leader会再次发送proposal和commit。</p>
</li>
</ul>
<h1 id="3-崩溃恢复"><a href="#3-崩溃恢复" class="headerlink" title="3 崩溃恢复"></a>3 崩溃恢复</h1><ul>
<li>当整个服务框架启动过程中或Leader服务器出现网络中断、崩溃退出与重启等异常情况无法与半数以上的follower联系时，ZAB协议就会进入恢复模式。</li>
</ul>
<h2 id="3-1-崩溃恢复下的两种情况和所要保证的特性"><a href="#3-1-崩溃恢复下的两种情况和所要保证的特性" class="headerlink" title="3.1 崩溃恢复下的两种情况和所要保证的特性"></a>3.1 崩溃恢复下的两种情况和所要保证的特性</h2><ol>
<li><p>ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交。</p>
<ul>
<li>如果leader在崩溃前发出了proposal1，proposal2，commit1（proposal1的commit），proposal3，commit2（说明leader自己已经commit了proposal2），那么ZAB需要确保恢复后proposal2在所有服务器上都被提交成功，否则会出现不一致。</li>
</ul>
</li>
<li><p>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务</p>
<ul>
<li>如果leader服务器A在崩溃前发出了proposal1，proposal2，commit1（proposal1的commit），proposal3，commit2，并且执行了commit3（说明leader自己已经commit了proposal3），但是commit3还未发出，leader便宕机了，那么ZAB需要确保恢复后，A重新加入集群（大概率不是leader了）后，要舍弃proposal3这个事务。<h2 id="3-2-进入崩溃恢复模式的流程"><a href="#3-2-进入崩溃恢复模式的流程" class="headerlink" title="3.2 进入崩溃恢复模式的流程"></a>3.2 进入崩溃恢复模式的流程</h2></li>
</ul>
</li>
<li><p>当leader出现问题，zab协议进入崩溃恢复模式，并且选举出新的leader。当新的leader选举出来以后，如果集群中已经有过半机器完成了leader服务器的状态同（数据同步），退出崩溃恢复，进入消息广播模式。</p>
</li>
</ol>
<ol start="2">
<li>当新的机器加入到集群中的时候，如果已经存在leader服务器，那么新加入的服务器就会自觉进入崩溃恢复模式，找到leader进行数据同步。</li>
</ol>
<h3 id="3-2-1-leader选举算法"><a href="#3-2-1-leader选举算法" class="headerlink" title="3.2.1 leader选举算法"></a>3.2.1 leader选举算法</h3><p>在崩溃恢复过程中需要处理的特殊情况，就决定了ZAB协议必须设计这样的</p>
<ul>
<li>能够确保提交已经被Leader提交的事务的Proposal，同时丢弃已经被跳过的事务Proposal。</li>
<li>如果让Leader选举算法能够保证新选举出来的Leader服务器拥有集群所有机器中最高编号（ZXID最大）的事务Proposal，那么就可以保证这个新选举出来的Leader一定具有所有已经提交的更改。</li>
<li>更为重要的是如果让具有最高编号事务的Proposal机器成为Leader，就可以省去Leader服务器查询Proposal的提交和丢弃工作这一步骤了。</li>
</ul>
<h3 id="3-2-2-数据同步"><a href="#3-2-2-数据同步" class="headerlink" title="3.2.2 数据同步"></a>3.2.2 数据同步</h3><ul>
<li>完成Leader选举后，在正式开始工作前，Leader服务器首先会确认日志中的所有Proposal是否都已经被集群中的过半机器提交了，即是否完成了数据同步。</li>
<li>基于上文讲到的两种情况，数据同步会有不同的处理：</li>
</ul>
<hr>
<ul>
<li>同步事务的提交：<ul>
<li>leader为每一个follower都准备一个队列，并将那些没有被各follower同步的事务以proposal消息的形式逐个发送给follower，并在每个proposal消息后面紧跟一个commit消息表示该事务已经被leader提交。等到某个follower同步了所有之前尚未同步的事务并将其成功应用到本地数据库，leader会将该follower加入到可用follower列表中。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>处理丢弃的事务<ul>
<li>下面分析ZAB协议如何处理需要丢弃的事务Proposal的，ZXID是一个64位的数字，其中低32位可以看做是一个简单的单调递增的计数器，针对客户端的每一个事务请求，Leader服务器在产生一个新的事务Proposal时，都会对该计数器进行加1操作；而高32位则代表了Leader周期epoch的编号，每当选举产生一个新的Leader时，就会从这个Leader上取出其本地日志中最大事务Proposal的ZXID，并解析出epoch值，然后加1，之后以该编号作为新的epoch，低32位从0来开始生成新的ZXID。</li>
</ul>
</li>
</ul>
<blockquote>
<p>epoch：可以理解为当前集群所处的年代或者周期，每个 leader 就像皇帝，都有自己的年号，所以每次改朝换代，leader 变更之后，都会在前一个年代的基础上加 1。这样就算旧的 leader 崩溃恢复之后，也没有人听他的了，因为 follower 只听从当前年代的 leader 的命令。</p>
</blockquote>
<pre><code>- ZAB协议通过epoch号来区分Leader周期变化的策略，能够有效地避免不同的Leader服务器错误地使用不同的ZXID编号提出不一样的事务Proposal的异常情况。当一个包含了上一个Leader周期中尚未提交过的事务Proposal的服务器启动时，其肯定无法成为Leader，因为当前集群中一定包含了一个Quorum（过半）集合，该集合中的机器一定包含了更高epoch的事务的Proposal，因此这台机器的事务Proposal并非最高，也就无法成为Leader。

- 当这台机器以follower身份连上leader之后，leader会根据自己最后被提交的proposal来和这台机器的proposal作比较，发现需要舍弃的事务后，leader会要求该台机器进行回滚操作，回滚到某个被半数机器执行的最新的事务版本。</code></pre><h1 id="4-ZAB和paxos的联系和区别"><a href="#4-ZAB和paxos的联系和区别" class="headerlink" title="4 ZAB和paxos的联系和区别"></a>4 ZAB和paxos的联系和区别</h1><h2 id="4-1-联系"><a href="#4-1-联系" class="headerlink" title="4.1 联系"></a>4.1 联系</h2><ol>
<li>都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行。</li>
<li>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提议进行提交。</li>
<li>在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前的Leader周期，在Paxos算法中，同样存在这样的一个标识，名字为Ballot。</li>
</ol>
<h2 id="4-2-区别"><a href="#4-2-区别" class="headerlink" title="4.2 区别"></a>4.2 区别</h2><ol>
<li>Paxos算法中，新选举产生的主进程会进行两个阶段的工作，第一阶段称为读阶段，新的主进程和其他进程通信来收集主进程提出的提议，并将它们提交。第二阶段称为写阶段，当前主进程开始提出自己的提议。</li>
<li>ZAB协议在Paxos基础上添加了同步阶段，此时，新的Leader会确保存在过半的Follower已经提交了之前的Leader周期中的所有事务Proposal。</li>
<li>ZAB协议主要用于构建一个高可用的分布式数据主备系统，而Paxos算法则用于构建一个分布式的一致性状态机系统。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" itemprop="url">一致性hash算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T15:52:16+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">分布式相关</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">负载均衡算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/26/一致性hash算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在解决分布式系统中负载均衡问题的时候，我们可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），进而起到负载均衡的作用。</p>
<p>但是普通的hash取模算法伸缩性很差，当新增或者下线服务器机器时候，用户id与服务器的映射关系会大量失效。这在分布式缓存系统中，是非常严重的问题。</p>
<p>例如我们原先有10台服务器，故而hash取模我们一般会这么算：<code>hash(key)%10</code>，从而得到一个在0-9之间的余数，确定请求由哪个服务器处理。</p>
<p>此时如果我们上线新服务器，或下线旧服务器，都会使服务器数量发生改变，这时候不论是<code>hash(key)%11</code>还是<code>hash(key)%9</code>，都会使近乎所有的key的hash取模结果和原先不一样，进而引发问题。比如缓存场景中的负载均衡，如果遇到这种情况，会使短时间内近乎所有的key失效，进而引发缓存雪崩。</p>
<p>为了解决这个问题，使得分布式系统可以自由且无顾虑的增减服务器，我们引入了一致性hash算法，利用hash环对其原本的hash取模算法进行了改进。</p>
<h1 id="1-一致性hash算法"><a href="#1-一致性hash算法" class="headerlink" title="1 一致性hash算法"></a>1 一致性hash算法</h1><p>一致性哈希算法在1997年由麻省理工学院提出，是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。</p>
<blockquote>
<p>一致性hash算法主要用于解决cache miss问题</p>
</blockquote>
<p>一致性哈希算法是在哈希算法基础上提出的，在动态变化的分布式环境中，哈希算法应该满足的几个条件：</p>
<ol>
<li>平衡性<ul>
<li>是指hash的结果应该平均分配到各个节点，这样从算法上解决了负载均衡问题。</li>
</ul>
</li>
<li>单调性<ul>
<li>是指在新增或者删减节点时，不影响系统正常运行。</li>
</ul>
</li>
<li>分散性<ul>
<li>是指数据应该分散地存放在分布式集群中的各个节点(节点自己可以有备份)，不必每个节点都存储所有的数据。</li>
</ul>
</li>
</ol>
<h2 id="1-1-算法概述"><a href="#1-1-算法概述" class="headerlink" title="1.1 算法概述"></a>1.1 算法概述</h2><p>为了能直观的理解一致性hash原理，这里结合一个简单的例子来讲解，假设有4台服务器，地址为ip1,ip2,ip3,ip4。</p>
<p>一致性hash是首先计算四个ip地址对应的hash值<br><code>hash(ip1),hash(ip2),hash(ip3),hash(ip3)</code>，计算出来的hash值是0~最大正整数（2^32）之间的一个值，这四个值在一致性hash环上呈现如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4391ab6c977b13c200508d135cb099b9d4c.png" alt=""></p>
<p>hash环上顺时针从整数0开始，一直到最大正整数，我们根据四个ip计算的hash值肯定会落到这个hash环上的某一个点，至此我们把服务器的四个ip映射到了一致性hash环。</p>
<p>当用户在客户端进行请求时候，首先根据hash(userId)计算路由规则，然后看hash值落到了hash环的那个地方，根据hash值在hash环上的位置顺时针找距离最近的ip作为路由ip。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b6c08822defde6081f28f35f8b4ce4e036c.png" alt=""></p>
<p>如上图可知，user1和user2由ip2的服务器处理，user3由ip3服务器处理，以此类推</p>
<blockquote>
<p>0~2^32的区间导致了hash值数量远超过服务器数量，使得hash碰撞的概率降到了极低。</p>
</blockquote>
<h2 id="1-2-上线服务器"><a href="#1-2-上线服务器" class="headerlink" title="1.2 上线服务器"></a>1.2 上线服务器</h2><p>当新增一个ip5的服务器后，一致性hash环大致如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-54cd082a9f13300b86d1ca9e36bdf5e299c.png" alt=""></p>
<p>根据顺时针规则可知之前user5的请求应该被ip5服务器处理，现在被新增的ip5服务器处理，其他用户的请求处理服务器不变，也就是说，新增服务器顺时针方向最近的服务器的一部分请求会被新增的服务器所替代。</p>
<h2 id="1-3-下线服务器"><a href="#1-3-下线服务器" class="headerlink" title="1.3 下线服务器"></a>1.3 下线服务器</h2><p>当ip2的服务器挂了的时候，一致性hash环大致如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e65b067374c1bf1d75ff571fe9febd9c152.png" alt=""></p>
<p>根据顺时针规则可知user1,user2的请求会被服务器ip3进行处理，而其它用户的请求对应的处理服务器不变，也就是只有之前被ip2处理的一部分用户的映射关系被破坏了，并且其负责处理的请求被顺时针下一个节点委托处理。</p>
<h1 id="2-一致性hash倾斜问题"><a href="#2-一致性hash倾斜问题" class="headerlink" title="2 一致性hash倾斜问题"></a>2 一致性hash倾斜问题</h1><p>一致性hash可以做到每个服务器都进行处理请求，但是不能保证每个服务器处理的请求的数量大致相同，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-551a6029640f2d81b118bef2dfc03f7ffcf.png" alt=""></p>
<p>服务器ip1,ip2,ip3经过hash后落到了一致性hash环上，从图中hash值分布可知ip1会负责处理大概80%的请求，而ip2和ip3则只会负责处理大概20%的请求，虽然三个机器都在处理请求，但是明显每个机器的负载不均衡，这样称为一致性hash的倾斜，我们可以使用设置虚拟节点的方式解决这个问题。</p>
<h2 id="2-1-设置虚拟节点"><a href="#2-1-设置虚拟节点" class="headerlink" title="2.1 设置虚拟节点"></a>2.1 设置虚拟节点</h2><p>当服务器节点比较少的时候会出现上节所说的一致性hash倾斜的问题，一个解决方法是多加机器，但是加机器是有成本的，那么就加虚拟节点，比如上面三个机器，<strong>每个机器引入1个虚拟节点</strong>后的一致性hash环的图如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-67344339d941bc965c8d5381a4458d36dad.png" alt=""></p>
<p>其中ip1-1是ip1的虚拟节点，ip2-1是ip2的虚拟节点，ip3-1是ip3的虚拟节点。命中ip3-1的请求，则会被导向到ip3服务器。</p>
<p>可知当物理机器数目为M，虚拟节点为N的时候，实际hash环上节点个数为<code>M*N</code>。比如当客户端计算的hash值处于ip2和ip3或者处于ip2-1和ip3-1之间时候使用ip3服务器进行处理。</p>
<blockquote>
<p>当然，我们很难得到一个完美均衡的一致性hash环，但理论上虚拟节点数量的增加，和一致性hash环的均衡性呈正相关。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
</blockquote>
<h1 id="3-一致性hash的优点"><a href="#3-一致性hash的优点" class="headerlink" title="3 一致性hash的优点"></a>3 一致性hash的优点</h1><ol>
<li><p>可扩展性。</p>
<ul>
<li>一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销</li>
</ul>
</li>
<li><p>更好地适应数据的快速增长。</p>
<ul>
<li>采用一致性哈希算法分布数据，当数据不断增长时，部分虚拟节点中可能包含很多数据、造成数据在虚拟节点上分布不均衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二、不需要对全部的数据进行重新哈希和划分。</li>
<li>虚拟节点分裂后，如果物理服务器的负载仍然不均衡，只需在服务器之间调整部分虚拟节点的存储分布。这样可以随数据的增长而动态的扩展物理服务器的数量，且代价远比传统哈希算法重新分布所有数据要小很多</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/Spring-IoC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/15/Spring-IoC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/" itemprop="url">Spring IoC源码详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T23:00:10+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/15/Spring-IoC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/15/Spring-IoC源码详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  15.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  77
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文中，所有spring framework源码，均采用5.0.x版本</p>
</blockquote>
<p>在《Spring IoC概念分析》一文中，我们对Spring IoC的前置概念和整体流程有了一个初步的了解，在本文中，我们会解读源码，力图将spring IoC的逻辑扁平化，可视化。</p>
<h1 id="1-Spring-IoC容器的启动"><a href="#1-Spring-IoC容器的启动" class="headerlink" title="1. Spring IoC容器的启动"></a>1. Spring IoC容器的启动</h1><p>applicationContext是Spring的核心，Context我们通常解释为上下文环境，我想用“容器”来表述它更容易理解一些，ApplicationContext则是“应用的容器”了；在Web应用中，我们会用到WebApplicationContext，WebApplicationContext继承自ApplicationContext；</p>
<p><strong>以企业级java项目最常用的web项目为例</strong>；我们知道，在web项目中，Spring启动是在web.xml配置监听器，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring上下文监听器 --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，ContextLoaderListener类是spring IoC容器启动的核心，也是整个Spring框架的启动入口：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5dc2965cc62b4769c88079950beb40dacf0.png" alt=""></p>
<p>ContextLoaderListener类实现了Tomcat容器的ServletContextListener接口，所以它与普通的Servlet监听是一样的。同样是重写到两个方法：</p>
<ul>
<li>contextInitialized()方法在web容器初始化时执行</li>
<li>contextDestroyed()方法在容器销毁时执行。</li>
</ul>
<p>WEB容器启动时会触发初始化事件，ContextLoaderListener监听到这个事件，其contextInitialized()方法会被调用，在这个方法中Spring会初始化一个root上下文，即WebApplicationContext。</p>
<p>WebApplicationContext是一个接口，其实际默认实现类是XmlWebApplicationContext。（重点关注红色箭头指示的两条继承/实现关系）</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-17ccc43554b5fda2180fb653d0646b31914.png" alt=""></p>
<p>这个就是Spring IOC的容器，其对应bean定义的配置信息由web.xml中的context-param来指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring配置文件路径 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>在ContextLoaderListener类中，只是实现了ServletContextListener提供的到两个方法，Spring启动主要的逻辑在父类ContextLoader的方法initWebApplicationContext实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">	public ContextLoaderListener() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public ContextLoaderListener(WebApplicationContext context) &#123;</span><br><span class="line">		super(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Initialize the root web application context.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void contextInitialized(ServletContextEvent event) &#123;</span><br><span class="line">		initWebApplicationContext(event.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Close the root web application context.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void contextDestroyed(ServletContextEvent event) &#123;</span><br><span class="line">		closeWebApplicationContext(event.getServletContext());</span><br><span class="line">		ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ContextLoaderListener的作用就是启动web容器时自动装配ApplicationContext的配置信息。更细化一点讲，Spring的启动过程其实就是Spring IOC容器的启动过程。</p>
</blockquote>
<h2 id="1-1-ContextLoader剖析"><a href="#1-1-ContextLoader剖析" class="headerlink" title="1.1 ContextLoader剖析"></a>1.1 ContextLoader剖析</h2><p>上文说过，Spring启动主要的逻辑在父类ContextLoader的方法initWebApplicationContext实现。所以我们有必要重点看下ContextLoader类：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2d9116f17f39e0f66409d490c3c00b4aac2.png" alt=""></p>
<p>这里面，最核心的方法是initWebApplicationContext()，它被ContextLoaderListene的contextInitialized()调用，负责spring容器的初始化。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-aa26938c4529a044c005dd5be15ec5f2138.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bf5c4a1709ad4caa111342055031fe6275c.png" alt=""></p>
<blockquote>
<p>注意，该图代码非5.0.x版本，但核心逻辑变化不大，可以参考。</p>
</blockquote>
<h2 id="1-2-Context的生成门面"><a href="#1-2-Context的生成门面" class="headerlink" title="1.2 Context的生成门面"></a>1.2 Context的生成门面</h2><p> 在这个方法中，入参ServletContext是由web容器监听器（ContextLoaderListener）提供。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize Spring's web application context for the given servlet context,</span></span><br><span class="line"><span class="comment"> * using the application context provided at construction time, or creating a new one</span></span><br><span class="line"><span class="comment"> * according to the "&#123;<span class="doctag">@link</span> #CONTEXT_CLASS_PARAM contextClass&#125;" and</span></span><br><span class="line"><span class="comment"> * "&#123;<span class="doctag">@link</span> #CONFIG_LOCATION_PARAM contextConfigLocation&#125;" context-params.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用构造时提供的应用程序上下文，或者根据“ &#123;<span class="doctag">@link</span> #CONTEXT_CLASS_PARAM contextClass&#125;”</span></span><br><span class="line"><span class="comment"> * 和“ &#123;<span class="doctag">@link</span> #CONFIG_LOCATION_PARAM contextConfigLocation&#125;”上下文参数，</span></span><br><span class="line"><span class="comment"> * 为给定的servlet上下文初始化Spring的Web应用程序上下文。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> servletContext current servlet context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new WebApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #ContextLoader(WebApplicationContext)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CONTEXT_CLASS_PARAM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CONFIG_LOCATION_PARAM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	 </span><br><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断给定的ServletContext是否已经存在WebApplicationContext，如果存在则抛出异常。</span></span><br><span class="line">	<span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">"Cannot initialize context because there is already a root application context present - "</span> +</span><br><span class="line">				<span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Log logger = LogFactory.getLog(ContextLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line">		<span class="comment">// it is available on ServletContext shutdown.</span></span><br><span class="line">		<span class="comment">//判断ContextLoader的context属性是否为空，为空表示WebApplicationContext还不存在。</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//不存在则创建WebApplicationContext，该方法也是核心方法，我们后面详解。</span></span><br><span class="line">			<span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//WebApplicationContext默认实现是XmlWebApplicationContext，</span></span><br><span class="line">		<span class="comment">//XmlWebApplicationContext是ConfigurableWebApplicationContext子类</span></span><br><span class="line">		<span class="comment">//所以该判断基本上都是正确的。</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">			ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line">			<span class="keyword">if</span> (!cwac.isActive()) &#123;<span class="comment">//这个context还未执行refresh方法。</span></span><br><span class="line">				<span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">				<span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">				<span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">					<span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">					<span class="comment">//通过loadParentContext()方法为其设置父上下文。</span></span><br><span class="line">					ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">					cwac.setParent(parent);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//通过configureAndRefreshWebApplicationContext为根上下文构建bean工厂和bean对象。</span></span><br><span class="line">				configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将ApplicationContext放入ServletContext中，其key为</span></span><br><span class="line">		<span class="comment">//WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span></span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line">		</span><br><span class="line">		ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (ccl == ContextLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()) </span>&#123;<span class="comment">//如果当前线程的类加载器和ContextLoader类加载器一致</span></span><br><span class="line">			<span class="comment">//那么创建的ApplicationContext赋值给ContextLoader.currentContext</span></span><br><span class="line">			<span class="comment">//即在ContextLoader类被加载的进程中，如果创建了context的话，context赋值currentContext，方便取用</span></span><br><span class="line">			<span class="comment">//而不是放在全局静态常量Map存起来。</span></span><br><span class="line">			currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;<span class="comment">//否则</span></span><br><span class="line">			<span class="comment">//将ApplicationContext放入ContextLoader的全局静态常量Map中</span></span><br><span class="line">			<span class="comment">//其中key为：Thread.currentThread().getContextClassLoader()即当前线程类加载器</span></span><br><span class="line">			<span class="comment">//正常的context创建流程，走这里。</span></span><br><span class="line">			currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +</span><br><span class="line">					WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">			<span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">			logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">		logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">		logger.error(<span class="string">"Context initialization failed"</span>, err);</span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">		<span class="keyword">throw</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归纳一下：</p>
<ul>
<li>首先判断servlectContext中是否已经存在根上下文，如果存在，则抛出异常；</li>
<li>否则通过createWebApplicationContext方法创建新的根上下文。</li>
<li>然后通过loadParentContext()方法为其设置父上下文。</li>
<li>再通过configureAndRefreshWebApplicationContext为根上下文构建bean工厂和bean对象。</li>
<li>最后把上下文存入servletContext，并且存入currentContextPerThread。</li>
<li>至此初始化过程完毕，接下来可以获取WebApplicationContext，进而用getBean(“bean name”)得到bean。</li>
</ul>
<h2 id="1-3-创建Context"><a href="#1-3-创建Context" class="headerlink" title="1.3 创建Context"></a>1.3 创建Context</h2><p>我们刚刚看到，initWebApplicationContext方法主要调用createWebApplicationContext方法来创建上下文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Instantiate the root WebApplicationContext for this loader, either the</span><br><span class="line"> * default context class or a custom context class if specified.</span><br><span class="line"> * &lt;p&gt;This implementation expects custom contexts to implement the</span><br><span class="line"> * &#123;@link ConfigurableWebApplicationContext&#125; interface.</span><br><span class="line"> * Can be overridden in subclasses.</span><br><span class="line"> *</span><br><span class="line"> * 实例化此加载程序的根WebApplicationContext（默认上下文类或自定义上下文类（如果已指定））。</span><br><span class="line"> * &lt;p&gt;此实现期望自定义上下文实现&#123;@link ConfigurableWebApplicationContext&#125;接口。 可以在子类中覆盖。</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;In addition, &#123;@link #customizeContext&#125; gets called prior to refreshing the</span><br><span class="line"> * context, allowing subclasses to perform custom modifications to the context.</span><br><span class="line"> * @param sc current servlet context</span><br><span class="line"> * @return the root WebApplicationContext</span><br><span class="line"> * @see ConfigurableWebApplicationContext</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123;</span><br><span class="line">	&#x2F;&#x2F;从web.xml配置的contextClass参数中获取上下文的实现类，如果contextClass为空，则使用默认的。</span><br><span class="line">	&#x2F;&#x2F;下文有说明  </span><br><span class="line">	Class&lt;?&gt; contextClass &#x3D; determineContextClass(sc);</span><br><span class="line">	&#x2F;&#x2F;根上下文的实现类必须是ConfigurableWebApplicationContext的子类，否则抛出异常</span><br><span class="line">	if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;Custom context class [&quot; + contextClass.getName() +</span><br><span class="line">				&quot;] is not of type [&quot; + ConfigurableWebApplicationContext.class.getName() + &quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;BeanUtils.instantiateClass工具方法，通过反射得到contextClass的构造方法，根据类名创建类</span><br><span class="line">	return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归纳一下：</p>
<ul>
<li>createWebApplicationContext方法使用determineContextClass方法，从web.xml配置的contextClass参数中，获取要创建的context的具体实现类，如果没有指定，则默认使用XmlWebApplicationContext为其实现类。</li>
<li>限制根上下文的实现类必须是ConfigurableWebApplicationContext的子类。</li>
<li>使用BeanUtils.instantiateClass工具方法，根据类名创建类实例。</li>
</ul>
<h2 id="1-4-确定Context实现类"><a href="#1-4-确定Context实现类" class="headerlink" title="1.4 确定Context实现类"></a>1.4 确定Context实现类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Return the WebApplicationContext implementation class to use, either the</span><br><span class="line"> * default XmlWebApplicationContext or a custom context class if specified.</span><br><span class="line"> *</span><br><span class="line"> * 返回要使用的WebApplicationContext实现类，</span><br><span class="line"> * 如果指定，则为自定义上下文类。否则默认为XmlWebApplicationContext</span><br><span class="line"> *</span><br><span class="line"> * @param servletContext current servlet context</span><br><span class="line"> * @return the WebApplicationContext implementation class to use</span><br><span class="line"> * @see #CONTEXT_CLASS_PARAM</span><br><span class="line"> * @see org.springframework.web.context.support.XmlWebApplicationContext</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">	&#x2F;&#x2F;从web.xml获得参数contextClass，在一般的web项目中，此参数为null，即没有指定。</span><br><span class="line">	&#x2F;&#x2F;（spring源生的XmlWebApplicationContext就挺好，没必要重复造轮子）</span><br><span class="line">	String contextClassName &#x3D; servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">	if (contextClassName !&#x3D; null) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;如果指定了，返回类名</span><br><span class="line">			return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Failed to load custom context class [&quot; + contextClassName + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;获得根上下文WebApplicationContext的默认实现类的类名，defaultStrategies是Properties类型，</span><br><span class="line">		&#x2F;&#x2F;在CotnextLoader类开头static语句块中初始化</span><br><span class="line">		&#x2F;&#x2F;获取当前包下面的ContextLoader.properties文件，文件内容是：</span><br><span class="line">		&#x2F;&#x2F;org.springframework.web.context.WebApplicationContext&#x3D;org.springframework.web.context.support.XmlWebApplicationContext</span><br><span class="line">		contextClassName &#x3D; defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class="line">		try &#123;</span><br><span class="line">			return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Failed to load default context class [&quot; + contextClassName + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);方法获取的，就是web.xml中配置指定的IoC容器类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextClass&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>截止到这里为止，WebApplicationContext的实例就已经创建出来了。然后逻辑往下走，到了configureAndRefreshWebApplicationContext(cwac, servletContext)方法，该方法为根上下文构建bean工厂和bean对象。</p>
<h2 id="1-5-配置和刷新Context"><a href="#1-5-配置和刷新Context" class="headerlink" title="1.5 配置和刷新Context"></a>1.5 配置和刷新Context</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123;</span><br><span class="line">	if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">		&#x2F;&#x2F; The application context id is still set to its original default value</span><br><span class="line">		&#x2F;&#x2F; -&gt; assign a more useful id based on available information</span><br><span class="line">		&#x2F;&#x2F;如果web.xml中配置了context的id，那么读取配置的id并使用。</span><br><span class="line">		String idParam &#x3D; sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">		if (idParam !&#x3D; null) &#123;</span><br><span class="line">			wac.setId(idParam);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;如果没有配置context的id，则使用默认的id。</span><br><span class="line">			&#x2F;&#x2F; Generate default id...</span><br><span class="line">			wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">					ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;把ServletContext塞入WebApplicationContext</span><br><span class="line">	wac.setServletContext(sc);</span><br><span class="line">	&#x2F;&#x2F;读取web.xml中的&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;的value值</span><br><span class="line">	&#x2F;&#x2F;获取上下文的配置xml地址和文件名。</span><br><span class="line">	String configLocationParam &#x3D; sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line">	if (configLocationParam !&#x3D; null) &#123;</span><br><span class="line">		wac.setConfigLocation(configLocationParam);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; The wac environment&#39;s #initPropertySources will be called in any case when the context</span><br><span class="line">	&#x2F;&#x2F; is refreshed; do it eagerly here to ensure servlet property sources are in place for</span><br><span class="line">	&#x2F;&#x2F; use in any post-processing or initialization that occurs below prior to #refresh</span><br><span class="line">	ConfigurableEnvironment env &#x3D; wac.getEnvironment();</span><br><span class="line">	if (env instanceof ConfigurableWebEnvironment) &#123;</span><br><span class="line">		((ConfigurableWebEnvironment) env).initPropertySources(sc, null);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;customizeContext方法的功能是：</span><br><span class="line">	&#x2F;&#x2F;对从web.xml的&lt;context-param&gt;中读取globalInitializerClasses和contextInitializerClasses参数</span><br><span class="line">	&#x2F;&#x2F;获取配置的ApplicationContextInitializer实现类，然后对他们的实现类依次回调他们的initialize方法。</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;ApplicationContextInitializer是Spring框架原有的接口，这个接口的主要作用就是</span><br><span class="line">	&#x2F;&#x2F;在ConfigurableApplicationContext类型(或者子类型)的ApplicationContext做refresh之前</span><br><span class="line">	&#x2F;&#x2F;允许我们对ConfiurableApplicationContext的实例做进一步的设置和处理。例如，根据上下文环境注册属性源或激活概要文件。</span><br><span class="line">	&#x2F;&#x2F;ApplicationContextInitializer支持Order注解，表示执行顺序，越小越早执行；</span><br><span class="line">	customizeContext(sc, wac);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;核心代码，开始容器的初始化</span><br><span class="line">	wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);方法获取的，就是web.xml中配置指定的IoC容器配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring配置文件路径 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，容器的初始化逻辑，都在wac.refresh();中。</p>
<h2 id="1-6-阶段性流程图"><a href="#1-6-阶段性流程图" class="headerlink" title="1.6 阶段性流程图"></a>1.6 阶段性流程图</h2><p><img src="https://oscimg.oschina.net/oscnet/up-8553a091ba36acb65cfef255e27192f896f.png" alt=""></p>
<h1 id="2-refresh-核心方法"><a href="#2-refresh-核心方法" class="headerlink" title="2 refresh()核心方法"></a>2 refresh()核心方法</h1><p>我们之前说过，WebApplicationContext方法的默认实现是XmlWebApplicationContext，而XmlWebApplicationContext的refresh()方法，继承自它的父类AbstractApplicationContext。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">	synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">		&#x2F;&#x2F; Prepare this context for refreshing.</span><br><span class="line">		&#x2F;&#x2F;刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等，同时给容器设置同步标识</span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Tell the subclass to refresh the internal bean factory.</span><br><span class="line">		&#x2F;&#x2F;该方法调用链路，会启动Bean定义资源文件的载入方法loadBeanDefinitions方法</span><br><span class="line">		&#x2F;&#x2F;值得下文讨论。</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Prepare the bean factory for use in this context.</span><br><span class="line">		&#x2F;&#x2F;为BeanFactory配置容器特性，例如类加载器、事件处理器等</span><br><span class="line">		&#x2F;&#x2F;还是一些准备工作，添加了两个后置处理器：ApplicationContextAwareProcessor，ApplicationListenerDetector</span><br><span class="line">		&#x2F;&#x2F;还设置了 忽略自动装配 和 允许自动装配 的接口，如果不存在某个bean的时候，spring就自动注册singleton bean</span><br><span class="line">		&#x2F;&#x2F;还设置了bean表达式解析器 等</span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">			&#x2F;&#x2F;这是一个空方法，给子类继承用，执行自定义的BeanPost事件</span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Invoke factory processors registered as beans in the context.</span><br><span class="line">			&#x2F;&#x2F;调用所有注册的BeanFactoryPostProcessor的Bean</span><br><span class="line">			&#x2F;&#x2F;执行自定义的BeanFactoryProcessor和内置的BeanFactoryProcessor</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Register bean processors that intercept bean creation.</span><br><span class="line">			&#x2F;&#x2F; 注册BeanPostProcessor</span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Initialize message source for this context.</span><br><span class="line">			&#x2F;&#x2F;初始化信息源，和国际化相关.</span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Initialize event multicaster for this context.</span><br><span class="line">			&#x2F;&#x2F;初始化容器事件传播器.</span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Initialize other special beans in specific context subclasses.</span><br><span class="line">			&#x2F;&#x2F; 空方法，给子类做定制</span><br><span class="line">			&#x2F;&#x2F;调用子类的某些特殊Bean初始化方法</span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Check for listener beans and register them.</span><br><span class="line">			&#x2F;&#x2F;为事件传播器注册事件监听器.</span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">			&#x2F;&#x2F;初始化所有剩余的，非懒加载的单例Bean</span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Last step: publish corresponding event.</span><br><span class="line">			&#x2F;&#x2F;初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">						&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">			&#x2F;&#x2F;销毁已创建的Bean</span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">			&#x2F;&#x2F;取消refresh操作，重置容器的同步标识。</span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Propagate exception to caller.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		finally &#123;</span><br><span class="line">			&#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">			&#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">			&#x2F;&#x2F;重设公共缓存</span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-加载xml文件的beanDefinition"><a href="#3-加载xml文件的beanDefinition" class="headerlink" title="3 加载xml文件的beanDefinition"></a>3 加载xml文件的beanDefinition</h1><p>refresh()方法调用了obtainFreshBeanFactory()方法，在这个方法中，会发起IoC容器对配置文件的读取，并将其加载为beanDefinition，不过在了解beanDefinition加载过程之前，我们有需要了解一些前置知识点。</p>
<h2 id="3-1-Resource资源文件框架"><a href="#3-1-Resource资源文件框架" class="headerlink" title="3.1 Resource资源文件框架"></a>3.1 Resource资源文件框架</h2><p>详见文章本博客《Spring Resource资源文件体系》；</p>
<h2 id="3-2-加载前的准备工作"><a href="#3-2-加载前的准备工作" class="headerlink" title="3.2 加载前的准备工作"></a>3.2 加载前的准备工作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * 让子类refresh内部bean工厂。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//核心方法在这，拆开看看</span></span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refreshBeanFactory()方法的实现在AbstractRefreshableApplicationContext类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * This implementation performs an actual refresh of this context&#39;s underlying</span><br><span class="line"> * bean factory, shutting down the previous bean factory (if any) and</span><br><span class="line"> * initializing a fresh bean factory for the next phase of the context&#39;s lifecycle.</span><br><span class="line"> * 此实现对该上下文的基础bean工厂执行实际的刷新，</span><br><span class="line"> * 关闭前一个bean工厂（如果有），并为上下文生命周期的下一阶段初始化一个新的bean工厂。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">	if (hasBeanFactory()) &#123;&#x2F;&#x2F;关闭前一个bean工厂（如果有）</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;初始化一个新的bean工厂</span><br><span class="line">		DefaultListableBeanFactory beanFactory &#x3D; createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		&#x2F;&#x2F;加载BeanDefinitions，核心方法，加载配置信息</span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">			this.beanFactory &#x3D; beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;I&#x2F;O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-设置和获取Reader工具类"><a href="#3-3-设置和获取Reader工具类" class="headerlink" title="3.3 设置和获取Reader工具类"></a>3.3 设置和获取Reader工具类</h2><p>前文说过，XmlWebApplicationContext类是默认的Context类，所以默认情况下，loadBeanDefinitions(DefaultListableBeanFactory)调用的是XmlWebApplicationContext类中实现的loadBeanDefinitions(DefaultListableBeanFactory);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">	&#x2F;&#x2F; Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">	&#x2F;&#x2F;初始化XmlBeanDefinitionReader，Reader是将配置文件转为beanDefinition文件的主要工具类。</span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader &#x3D; new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Configure the bean definition reader with this context&#39;s</span><br><span class="line">	&#x2F;&#x2F; resource loading environment.</span><br><span class="line">	beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">	&#x2F;&#x2F;注意这里，将this，也就是XmlWebApplicationContext本身，作为XmlBeanDefinitionReader的ResourceLoader。</span><br><span class="line">	&#x2F;&#x2F;XmlWebApplicationContext是实现了ResourceLoader接口的，并且它是ResourcePatternResolver接口的子类。</span><br><span class="line">	beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">	&#x2F;&#x2F; then proceed with actually loading the bean definitions.</span><br><span class="line">	&#x2F;&#x2F;空方法，给自定义的context类一个变更Reader类的回调机会</span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	&#x2F;&#x2F;核心方法，继续往下看</span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadBeanDefinitions(beanDefinitionReader)方法调用的是loadBeanDefinitions(XmlBeanDefinitionReader)方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load the bean definitions with the given XmlBeanDefinitionReader.</span><br><span class="line"> * &lt;p&gt;The lifecycle of the bean factory is handled by the refreshBeanFactory method;</span><br><span class="line"> * therefore this method is just supposed to load and&#x2F;or register bean definitions.</span><br><span class="line"> * &lt;p&gt;Delegates to a ResourcePatternResolver for resolving location patterns</span><br><span class="line"> * into Resource instances.</span><br><span class="line"> </span><br><span class="line"> * 使用给定的XmlBeanDefinitionReader加载Bean定义。beanFactory的生命周期由refreshBeanFactory方法处理；</span><br><span class="line"> * 因此该方法仅应加载 或 注册Bean定义。委托ResourcePatternResolver将位置模式解析为Resource实例。</span><br><span class="line"> </span><br><span class="line"> * @throws IOException if the required XML document isn&#39;t found</span><br><span class="line"> * @see #refreshBeanFactory</span><br><span class="line"> * @see #getConfigLocations</span><br><span class="line"> * @see #getResources</span><br><span class="line"> * @see #getResourcePatternResolver</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws IOException &#123;</span><br><span class="line">	&#x2F;&#x2F;获取web.xml配置的configLocations，即配置文件的路径</span><br><span class="line">	String[] configLocations &#x3D; getConfigLocations();</span><br><span class="line">	if (configLocations !&#x3D; null) &#123;</span><br><span class="line">		for (String configLocation : configLocations) &#123;</span><br><span class="line">			&#x2F;&#x2F;遍历得到的configLocation路径，依次调用reader的loadBeanDefinitions方法解析每个路径</span><br><span class="line">			reader.loadBeanDefinitions(configLocation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-通配-完整路径解析策略"><a href="#3-4-通配-完整路径解析策略" class="headerlink" title="3.4 通配/完整路径解析策略"></a>3.4 通配/完整路径解析策略</h2><p>核心逻辑又进入了reader.loadBeanDefinitions(configLocation)方法，这个方法，XmlBeanDefinitionReader自己没有实现，是继承自AbstractBeanDefinitionReader的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load bean definitions from the specified resource location.</span><br><span class="line"> * &lt;p&gt;The location can also be a location pattern, provided that the</span><br><span class="line"> * ResourceLoader of this bean definition reader is a ResourcePatternResolver.</span><br><span class="line"> * @param location the resource location, to be loaded with the ResourceLoader</span><br><span class="line"> * (or ResourcePatternResolver) of this bean definition reader</span><br><span class="line"> * @param actualResources a Set to be filled with the actual Resource objects</span><br><span class="line"> * that have been resolved during the loading process. May be &#123;@code null&#125;</span><br><span class="line"> * to indicate that the caller is not interested in those Resource objects.</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> * @see #getResourceLoader()</span><br><span class="line"> * @see #loadBeanDefinitions(org.springframework.core.io.Resource)</span><br><span class="line"> * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) </span><br><span class="line">	throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F;获取ResourceLoader，ResourceLoader是用来确定location用哪种resource策略的逻辑封装。</span><br><span class="line">	&#x2F;&#x2F;当前类XmlBeanDefinitionReader，在XmlWebApplicationContext类的loadBeanDefinitions(DefaultListableBeanFactory)方法中</span><br><span class="line">	&#x2F;&#x2F;就已经指定了XmlBeanDefinitionReader的ResourceLoader。</span><br><span class="line">	&#x2F;&#x2F;XmlBeanDefinitionReader的ResourceLoader就是XmlWebApplicationContext</span><br><span class="line">	ResourceLoader resourceLoader &#x3D; getResourceLoader();</span><br><span class="line">	if (resourceLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;Cannot import bean definitions from location [&quot; + location + &quot;]: </span><br><span class="line">					no ResourceLoader available&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果该reader注入的ResourceLoader是ResourcePatternResolver的子类。</span><br><span class="line">	&#x2F;&#x2F;也就是支持解析配置路径是通配符形式的location。</span><br><span class="line">	&#x2F;&#x2F;在web应用场景中，ResourceLoader已经指定了是XmlWebApplicationContext</span><br><span class="line">	&#x2F;&#x2F;而XmlWebApplicationContext是ResourcePatternResolver的子类，所以判断必然为真</span><br><span class="line">	if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">		&#x2F;&#x2F; Resource pattern matching available.</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;那么，一个带通配符的路径，是可能返回多个Resource的</span><br><span class="line">			Resource[] resources &#x3D; ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">			int loadCount &#x3D; loadBeanDefinitions(resources);</span><br><span class="line">			if (actualResources !&#x3D; null) &#123;</span><br><span class="line">				for (Resource resource : resources) &#123;</span><br><span class="line">					actualResources.add(resource);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions </span><br><span class="line">					from location pattern [&quot; + location + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return loadCount;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(</span><br><span class="line">					&quot;Could not resolve bean definition resource </span><br><span class="line">						pattern [&quot; + location + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Can only load single resources by absolute URL.</span><br><span class="line">		&#x2F;&#x2F;否则，则l该reader注入的ResourceLoader只支持解析配置路径是完整路径形式</span><br><span class="line">		&#x2F;&#x2F;那么一个绝对路径，只会取回来一个resource</span><br><span class="line">		Resource resource &#x3D; resourceLoader.getResource(location);</span><br><span class="line">		int loadCount &#x3D; loadBeanDefinitions(resource);</span><br><span class="line">		if (actualResources !&#x3D; null) &#123;</span><br><span class="line">			actualResources.add(resource);</span><br><span class="line">		&#125;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions </span><br><span class="line">				from location [&quot; + location + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return loadCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的两个分支，即<strong>resourceLoader支持解析location为通配符形式的</strong>和<strong>resourceLoader支持解析location为完整路径形式的</strong>，二者分别调用了：</p>
<ol>
<li>resourceLoader支持解析location为通配符形式的<ul>
<li>PathMatchingResourcePatternResolver#getResources(String locationPattern)</li>
<li>AbstractBeanDefinitionReader#loadBeanDefinitions(Resource… resources)方法</li>
</ul>
</li>
<li>resourceLoader支持解析location为完整路径形式的<ul>
<li>DefaultResourceLoader#getResources(String locationPattern)</li>
<li>XmlBeanDefinitionReader#loadBeanDefinitions(Resource resource)</li>
</ul>
</li>
</ol>
<p>而AbstractBeanDefinitionReader#loadBeanDefinitions(Resource… resources)方法的逻辑很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(resources, &quot;Resource array must not be null&quot;);</span><br><span class="line">	int counter &#x3D; 0;</span><br><span class="line">	for (Resource resource : resources) &#123;</span><br><span class="line">		&#x2F;&#x2F;遍历Resource，依次调用loadBeanDefinitions(Resource resource)</span><br><span class="line">		counter +&#x3D; loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后殊途同归，最后都是落在了XmlBeanDefinitionReader#loadBeanDefinitions(Resource resource)方法上。</p>
<h2 id="3-5-编码设置和循环依赖检测"><a href="#3-5-编码设置和循环依赖检测" class="headerlink" title="3.5 编码设置和循环依赖检测"></a>3.5 编码设置和循环依赖检测</h2><p>XmlBeanDefinitionReader的loadBeanDefinitions(Resource resource)重写方法，主要就是加载xml文件配置的beanDefinition：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load bean definitions from the specified XML file.</span><br><span class="line"> * @param resource the resource descriptor for the XML file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F;对传进来的Resource又进行了一次封装，变成了编码后的Resource</span><br><span class="line">	return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，resource在这里被封装为了EncodedResource，我们继续往下看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load bean definitions from the specified XML file.</span><br><span class="line"> * @param encodedResource the resource descriptor for the XML file,</span><br><span class="line"> * allowing to specify an encoding to use for parsing the file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">	if (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;resourcesCurrentlyBeingLoaded是一个ThreadLocal，里面存放Resource包装类EncodedResource的set集合</span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources &#x3D; this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	if (currentResources &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果set不存在，new一个</span><br><span class="line">		currentResources &#x3D; new HashSet&lt;&gt;(4);</span><br><span class="line">		this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果set中已有这个元素则返回false，进入该条件抛出异常</span><br><span class="line">	if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		&#x2F;&#x2F;只有当前线程重复加载了某个资源，这里才会抛出异常</span><br><span class="line">		&#x2F;&#x2F;用来检测是否循环加载某个Resource，如果是，提醒需要检查导入的definitions</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;获取封装的InputStream</span><br><span class="line">		InputStream inputStream &#x3D; encodedResource.getResource().getInputStream();</span><br><span class="line">		try &#123;</span><br><span class="line">			InputSource inputSource &#x3D; new InputSource(inputStream);</span><br><span class="line">			&#x2F;&#x2F;没有设置编码集，跳过</span><br><span class="line">			if (encodedResource.getEncoding() !&#x3D; null) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		if (currentResources.isEmpty()) &#123;</span><br><span class="line">			this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，核心逻辑，又进入了doLoadBeanDefinitions方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Actually load bean definitions from the specified XML file.</span><br><span class="line"> * @param inputSource the SAX InputSource to read from</span><br><span class="line"> * @param resource the resource descriptor for the XML file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> * @see #doLoadDocument</span><br><span class="line"> * @see #registerBeanDefinitions</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;根据不同的xml约束（dtd，xsd等），将xml文件生成对应的文档对象</span><br><span class="line">		&#x2F;&#x2F;这个方法里面涉及xml的解析，不赘述，简单来说：</span><br><span class="line">		&#x2F;&#x2F;检测解析传入的xml文件（也就是resource）时该用哪种验证方式</span><br><span class="line">		&#x2F;&#x2F;如果这个文件有DOCTYPE声明，那么就用DTD验证，否则就使用XSD验证模式。</span><br><span class="line">		&#x2F;&#x2F;使用标准JAXP配置XML解析器，加载InputSource的Document对象，然后返回一个新的DOM对象</span><br><span class="line">		&#x2F;&#x2F;注意，这个Document对象，是W3C定义的标准XML对象，跟spring无关。</span><br><span class="line">		Document doc &#x3D; doLoadDocument(inputSource, resource);</span><br><span class="line">		&#x2F;&#x2F;核心方法，beanDefinitions的注册</span><br><span class="line">		return registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXParseException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ParserConfigurationException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Parser configuration exception parsing XML from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Unexpected exception parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，两个核心方法，doLoadDocument和registerBeanDefinitions方法，前者负责解析xml文件，后者负责注册BeanDefinitions，我们分别来分析。先看doLoadDocument()方法</p>
<h2 id="3-6-解析XML文件"><a href="#3-6-解析XML文件" class="headerlink" title="3.6 解析XML文件"></a>3.6 解析XML文件</h2><p>此方法在XmlBeanDefinitionReader类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Actually load the specified document using the configured DocumentLoader.</span><br><span class="line">* @param inputSource the SAX InputSource to read from --从中读取的SAX输入源</span><br><span class="line">* @param resource the resource descriptor for the XML file --xml文件的资源描述符</span><br><span class="line">* @return the DOM Document DOM文档对象</span><br><span class="line">* </span><br><span class="line">* 使用配置好的DocumentLoader文档加载器加载指定的文档</span><br><span class="line">*&#x2F;</span><br><span class="line">protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123;</span><br><span class="line">	return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,</span><br><span class="line">											getValidationModeForResource(resource), isNamespaceAware());</span><br></pre></td></tr></table></figure>
<h3 id="3-6-1-参数1"><a href="#3-6-1-参数1" class="headerlink" title="3.6.1 参数1"></a>3.6.1 参数1</h3><p>上文中的getEntityResolver() 方法返回 XmlBeanDefinitionReader 类的 entityResolver 属性。</p>
<p>entityResolver 属性在 loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 方法中被赋值。</p>
<p><code>beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</code></p>
<p>和resourceLoader一样，this拿的是XmlWebApplicationContext实例，我们再来看下ResourceEntityResolver的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Create a ResourceEntityResolver for the specified ResourceLoader</span><br><span class="line">* (usually, an ApplicationContext).</span><br><span class="line">* @param resourceLoader the ResourceLoader (or ApplicationContext)</span><br><span class="line">* to load XML entity includes with</span><br><span class="line">*</span><br><span class="line">* 为指定的ResourceLoade（通常是应用上下文）r创建一个ResourceEntityResolver</span><br><span class="line">*&#x2F;</span><br><span class="line">public ResourceEntityResolver(ResourceLoader resourceLoader) &#123;</span><br><span class="line">    super(resourceLoader.getClassLoader());</span><br><span class="line">    &#x2F;&#x2F;此处解析器拿到了上下文的引用</span><br><span class="line">    this.resourceLoader &#x3D; resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了父类构造，再跟进一层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Create a new DelegatingEntityResolver that delegates to</span><br><span class="line">* a default &#123;@link BeansDtdResolver&#125; and a default &#123;@link PluggableSchemaResolver&#125;.</span><br><span class="line">* &lt;p&gt;Configures the &#123;@link PluggableSchemaResolver&#125; with the supplied</span><br><span class="line">* &#123;@link ClassLoader&#125;.</span><br><span class="line">* @param classLoader the ClassLoader to use for loading</span><br><span class="line">* (can be &#123;@code null&#125;) to use the default ClassLoader)</span><br><span class="line">*&#x2F;</span><br><span class="line">public DelegatingEntityResolver(ClassLoader classLoader) &#123;</span><br><span class="line">    &#x2F;&#x2F;这两个解析器和约束的类型有关，DTD</span><br><span class="line">    this.dtdResolver &#x3D; new BeansDtdResolver();</span><br><span class="line">    &#x2F;&#x2F;可插拔的Schema解析器，拿的上下文的类加载器</span><br><span class="line">    this.schemaResolver &#x3D; new PluggableSchemaResolver(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间的this.errorHandler参数可忽略。</p>
<h3 id="3-6-2-参数2"><a href="#3-6-2-参数2" class="headerlink" title="3.6.2 参数2"></a>3.6.2 参数2</h3><p>ok，然后是getValidationModeForResource(resource)入参。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Gets the validation mode for the specified &#123;@link Resource&#125;. If no explicit</span><br><span class="line">* validation mode has been configured then the validation mode is</span><br><span class="line">* &#123;@link #detectValidationMode detected&#125;.</span><br><span class="line">* &lt;p&gt;Override this method if you would like full control over the validation</span><br><span class="line">* mode, even when something other than &#123;@link #VALIDATION_AUTO&#125; was set.</span><br><span class="line">* </span><br><span class="line">* 通过给定Resource给出验证模式。如果没有明确配置验证模式，那么调用detectValidationMode方法去检测。</span><br><span class="line">*&#x2F;</span><br><span class="line">protected int getValidationModeForResource(Resource resource) &#123;</span><br><span class="line">    &#x2F;&#x2F;默认自动验证，为1</span><br><span class="line">    int validationModeToUse &#x3D; getValidationMode();</span><br><span class="line">    &#x2F;&#x2F;如果有给出具体验证方式，则返回结果</span><br><span class="line">    if (validationModeToUse !&#x3D; VALIDATION_AUTO) &#123;</span><br><span class="line">        return validationModeToUse;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;检测验证模式，进入这个方法</span><br><span class="line">    int detectedMode &#x3D; detectValidationMode(resource);</span><br><span class="line">    if (detectedMode !&#x3D; VALIDATION_AUTO) &#123;</span><br><span class="line">        return detectedMode;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Hmm, we didn&#39;t get a clear indication... Let&#39;s assume XSD,</span><br><span class="line">    &#x2F;&#x2F; since apparently no DTD declaration has been found up until</span><br><span class="line">    &#x2F;&#x2F; detection stopped (before finding the document&#39;s root tag).</span><br><span class="line">    &#x2F;&#x2F; 如果实在不能判断验证模式是那种就使用XSD方式，</span><br><span class="line">    &#x2F;&#x2F; 因为检测完后还是没有发现DTD模式的声明（在查找document的根标签之前)。</span><br><span class="line">    &#x2F;&#x2F; 值为3</span><br><span class="line">    return VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getValidationModeForResource的核心方法是detectValidationMode()，我们继续：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Detects which kind of validation to perform on the XML file identified</span><br><span class="line">* by the supplied &#123;@link Resource&#125;. If the file has a &#123;@code DOCTYPE&#125;</span><br><span class="line">* definition then DTD validation is used otherwise XSD validation is assumed.</span><br><span class="line">* &lt;p&gt;Override this method if you would like to customize resolution</span><br><span class="line">* of the &#123;@link #VALIDATION_AUTO&#125; mode.</span><br><span class="line">* </span><br><span class="line">* 检测执行xml文件时该用哪种验证方式，这个xml由Resource对象提供</span><br><span class="line">* 如果这个文件有DOCTYPE声明，那么就用DTD验证，否则就默认使用XSD。</span><br><span class="line">* 如果你想要自定义自动验证模式的解决方式，你可以覆盖这个方法</span><br><span class="line">*&#x2F;</span><br><span class="line">protected int detectValidationMode(Resource resource) &#123;</span><br><span class="line">    &#x2F;&#x2F;默认false</span><br><span class="line">    if (resource.isOpen()) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;Passed-in Resource [&quot; + resource + &quot;] contains an open stream: &quot; +</span><br><span class="line">            &quot;cannot determine validation mode automatically. Either pass in a Resource &quot; +</span><br><span class="line">            &quot;that is able to create fresh streams, or explicitly specify the validationMode &quot; +</span><br><span class="line">            &quot;on your XmlBeanDefinitionReader instance.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    InputStream inputStream;</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream &#x3D; resource.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;Unable to determine validation mode for [&quot; + resource + &quot;]: cannot open InputStream. &quot; +</span><br><span class="line">            &quot;Did you attempt to load directly from a SAX InputSource without specifying the &quot; +</span><br><span class="line">            &quot;validationMode on your XmlBeanDefinitionReader instance?&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;XmlBeanDefinitionReader的validationModeDetector属性有默认实现XmlValidationModeDetector</span><br><span class="line">        &#x2F;&#x2F;核心方法，接下来进入这个方法看下</span><br><span class="line">        return this.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(&quot;Unable to determine validation mode for [&quot; +</span><br><span class="line">                                               resource + &quot;]: an error occurred whilst reading from the InputStream.&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以来看validationModeDetector调用的detectValidationMode方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Detect the validation mode for the XML document in the supplied &#123;@link InputStream&#125;.</span><br><span class="line">* Note that the supplied &#123;@link InputStream&#125; is closed by this method before returning.</span><br><span class="line">* </span><br><span class="line">* 在提供的InputStream中检测XML文档的验证模式</span><br><span class="line">* 注意，提供的InputStream在这个方法return之前会被关闭</span><br><span class="line">*&#x2F;</span><br><span class="line">public int detectValidationMode(InputStream inputStream) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Peek into the file to look for DOCTYPE.</span><br><span class="line">    &#x2F;&#x2F; 查找文件的DOCTYPE</span><br><span class="line">    BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean isDtdValidated &#x3D; false;</span><br><span class="line">        String content;</span><br><span class="line">        while ((content &#x3D; reader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;读一行字符串就干掉字符串里面的注释，如果全是注释全干掉</span><br><span class="line">            &#x2F;&#x2F;主要为了剥离注释，因为非注释内容要么是DOCTYPE声明要么是文档的根元素对象</span><br><span class="line">            content &#x3D; consumeCommentTokens(content);</span><br><span class="line">            &#x2F;&#x2F;剥离注释后完全没内容就继续循环</span><br><span class="line">            if (this.inComment || !StringUtils.hasText(content)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;有DOCTYPE声明，就跳出去</span><br><span class="line">            if (hasDoctype(content)) &#123;</span><br><span class="line">                isDtdValidated &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;注释不能进去。开头是&quot;&lt;&quot;,后面第一个字符是字母，就进入。</span><br><span class="line">            &#x2F;&#x2F;比如&#39;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;&#39;</span><br><span class="line">            &#x2F;&#x2F;进去后跳出循环</span><br><span class="line">            if (hasOpeningTag(content)) &#123;</span><br><span class="line">                &#x2F;&#x2F; End of meaningful data...</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当遍历到名称空间了也就是&quot;&lt;beans xmlns&#x3D;...&gt;&quot;还没有DOCTYPE声明，</span><br><span class="line">        &#x2F;&#x2F;那么就判定他为XSD验证</span><br><span class="line">        return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CharConversionException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; Choked on some character encoding...</span><br><span class="line">        &#x2F;&#x2F; Leave the decision up to the caller.</span><br><span class="line">        return VALIDATION_AUTO;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        &#x2F;&#x2F;关流</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-3-解析的核心逻辑"><a href="#3-6-3-解析的核心逻辑" class="headerlink" title="3.6.3 解析的核心逻辑"></a>3.6.3 解析的核心逻辑</h3><p>讲完核心的两个入参后进入正主，loadDocument方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,</span><br><span class="line">				getValidationModeForResource(resource), isNamespaceAware());</span><br></pre></td></tr></table></figure>
<p>documentLoader属性的默认实现是DefaultDocumentLoader；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Load the &#123;@link Document&#125; at the supplied &#123;@link InputSource&#125; using the standard JAXP-configured</span><br><span class="line">* XML parser.</span><br><span class="line">*</span><br><span class="line">* 使用标准JAXP配置XML解析器加载InputSource的Document对象</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,</span><br><span class="line">                             ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建文档构建器工厂对象，并初始化一些属性</span><br><span class="line">    &#x2F;&#x2F;如果验证模式为XSD，那么强制支持XML名称空间，并加上schema属性</span><br><span class="line">    DocumentBuilderFactory factory &#x3D; createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个JAXP文档构建器</span><br><span class="line">    DocumentBuilder builder &#x3D; createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;按照XML文档解析给定inputSource的内容，然后返回一个新的DOM对象</span><br><span class="line">    return builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步，DocumentBuilder的默认实现是DocumentBuilderImpl，这个是jdk里面的xml解析器了，不再赘述。</p>
<p>至此，我们拿到了Document对象</p>
<h2 id="3-7-准备注册BeanDefinitions"><a href="#3-7-准备注册BeanDefinitions" class="headerlink" title="3.7 准备注册BeanDefinitions"></a>3.7 准备注册BeanDefinitions</h2><p>两个核心方法，看完了doLoadDocument方法，我们再来看registerBeanDefinitions方法，后者负责注册BeanDefinitions，我们分别来分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Register the bean definitions contained in the given DOM document.</span><br><span class="line"> * Called by &#123;@code loadBeanDefinitions&#125;.</span><br><span class="line"> * &lt;p&gt;Creates a new instance of the parser class and invokes</span><br><span class="line"> * &#123;@code registerBeanDefinitions&#125; on it.</span><br><span class="line"> * 注册包含在给定DOM文档中的bean定义。由&#123;@code loadBeanDefinitions&#125;调用。&lt;p&gt;创建解析器类的新实例，并在其上调用&#123;@code registerBeanDefinitions&#125;。</span><br><span class="line"> *</span><br><span class="line"> * 注册包含在给定DOM文档对象中的 bean definition</span><br><span class="line"> * 被loadBeanDefinitions方法所调用</span><br><span class="line"> * 解析class后创建一个新的实例，并调用registerBeanDefinitions方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F;其实就是new了一个DefaultBeanDefinitionDocumentReader工具类。</span><br><span class="line">	BeanDefinitionDocumentReader documentReader &#x3D; createBeanDefinitionDocumentReader();</span><br><span class="line">	&#x2F;&#x2F;getRegistry()方法拿的是bean工厂对象，beanDefinition注册在工厂中</span><br><span class="line">	&#x2F;&#x2F;这个方法就是返回已经被注册在工厂中的beanDefinitions数量</span><br><span class="line">	int countBefore &#x3D; getRegistry().getBeanDefinitionCount();</span><br><span class="line">	&#x2F;&#x2F;核心方法</span><br><span class="line">	&#x2F;&#x2F;createReaderContext创建了XmlReaderContext对象</span><br><span class="line">	&#x2F;&#x2F;XmlReaderContext对象是BeanDefinition读取过程中传递的上下文，封装相关的的配置和状态</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	&#x2F;&#x2F;返回上文这个核心方法真正注册在工厂中的beanDefinition数量</span><br><span class="line">	return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心方法documentReader.registerBeanDefinitions实现在DefaultBeanDefinitionDocumentReader类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 这个方法在刚创建的DefaultBeanDefinitionDocumentReader中</span><br><span class="line">*</span><br><span class="line">* This implementation parses bean definitions according to the &quot;spring-beans&quot; XSD</span><br><span class="line">* (or DTD, historically).</span><br><span class="line">* &lt;p&gt;Opens a DOM Document; then initializes the default settings</span><br><span class="line">* specified at the &#123;@code &lt;beans&#x2F;&gt;&#125; level; then parses the contained bean definitions.</span><br><span class="line">*</span><br><span class="line">* 根据“spring-beans&quot;的XSD（或者DTD）去解析bean definition</span><br><span class="line">* 打开一个DOM文档，然后初始化在&lt;beans&#x2F;&gt;层级上指定的默认设置，然后解析包含在其中的bean definitions</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">	&#x2F;&#x2F;入参时创建的XmlReaderContext对象</span><br><span class="line">	this.readerContext &#x3D; readerContext;</span><br><span class="line">	logger.debug(&quot;Loading bean definitions&quot;);</span><br><span class="line">	&#x2F;&#x2F;拿到了xml文档对象的根元素</span><br><span class="line">	Element root &#x3D; doc.getDocumentElement();</span><br><span class="line">	&#x2F;&#x2F;进入这个方法进行查看</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看DefaultBeanDefinitionDocumentReader类的doRegisterBeanDefinitions方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Register each bean definition within the given root &#123;@code &lt;beans&#x2F;&gt;&#125; element.</span><br><span class="line">*</span><br><span class="line">* 从&lt;beans &#x2F;&gt;配置中注册每一个bean，如果有嵌套的beans，那么递归执行这个方法。</span><br><span class="line">*&#x2F;</span><br><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">    &#x2F;&#x2F; Any nested &lt;beans&gt; elements will cause recursion in this method. In</span><br><span class="line">    &#x2F;&#x2F; order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span><br><span class="line">    &#x2F;&#x2F; keep track of the current (parent) delegate, which may be null. Create</span><br><span class="line">    &#x2F;&#x2F; the new (child) delegate with a reference to the parent for fallback purposes,</span><br><span class="line">    &#x2F;&#x2F; then ultimately reset this.delegate back to its original (parent) reference.</span><br><span class="line">    &#x2F;&#x2F; this behavior emulates a stack of delegates without actually necessitating one.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; delegate可以理解为配置参数&#x2F;属性，传递的上下文，封装相关的的配置和状态等信息的集合对象</span><br><span class="line">    &#x2F;&#x2F; 任何被嵌套的&lt;beans&gt;元素都会导致此方法的递归。为了正确的传播和保存delegate内的信息，所以这里需要做delegate交接</span><br><span class="line">    &#x2F;&#x2F; 它可能为null</span><br><span class="line">    &#x2F;&#x2F; 为了能够回退，新的（子）delegate具有父的引用，最终会重置this.delegate回到它的初始（父）引用。</span><br><span class="line">    BeanDefinitionParserDelegate parent &#x3D; this.delegate;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重要方法，创建一个新的代理，继承父delegate，并初始化一些默认值</span><br><span class="line">    this.delegate &#x3D; createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;默认明明空间是&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        String profileSpec &#x3D; root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果当前层级的&lt;beans &#x2F;&gt;配置有profile属性，那么处理这个属性。不是很重要不赘述</span><br><span class="line">        if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            String[] specifiedProfiles &#x3D; StringUtils.tokenizeToStringArray(</span><br><span class="line">                profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +</span><br><span class="line">                                &quot;] not matching: &quot; + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;xml预处理，子类没有重写里面就是空实现</span><br><span class="line">    preProcessXml(root);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重要方法，生成BeanDefinition，并注册在工厂中</span><br><span class="line">    parseBeanDefinitions(root, this.delegate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;xml后处理，子类没有重写里面就是空实现</span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    this.delegate &#x3D; parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好，这里两个核心方法，我们一个一个来</p>
<h2 id="3-8-生成代理和传递基础配置"><a href="#3-8-生成代理和传递基础配置" class="headerlink" title="3.8 生成代理和传递基础配置"></a>3.8 生成代理和传递基础配置</h2><p>先看DefaultBeanDefinitionDocumentReader类的createDelegate方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">protected BeanDefinitionParserDelegate createDelegate(</span><br><span class="line">		XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;生成用来解析XML bean definition的有状态Delegate类，用来被主解析器和其他扩展使用。</span><br><span class="line">	&#x2F;&#x2F;上下文readerContext继承在其内部</span><br><span class="line">	BeanDefinitionParserDelegate delegate &#x3D; new BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">	&#x2F;&#x2F;给新生成的delegate做继承和赋初值</span><br><span class="line">	delegate.initDefaults(root, parentDelegate);</span><br><span class="line">	return delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Initialize the default lazy-init, autowire, dependency check settings,</span><br><span class="line"> * init-method, destroy-method and merge settings. Support nested &#39;beans&#39;</span><br><span class="line"> * element use cases by falling back to the given parent in case the</span><br><span class="line"> * defaults are not explicitly set locally.</span><br><span class="line"> *</span><br><span class="line"> * 用默认的值填充DocumentDefaultsDefinition实例</span><br><span class="line"> * 通过使用parentDefaults（父代理的default属性），来解决嵌套的&#39;beans&#39;元素情况，以防默认值在局部设定不明确</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void initDefaults(Element root, BeanDefinitionParserDelegate parent) &#123;</span><br><span class="line"></span><br><span class="line">	 &#x2F;&#x2F;重要方法，构造当前delegate的默认配置信息封装类，为其赋初值。</span><br><span class="line">	 &#x2F;&#x2F;this.defaults，也就是当前delegate的默认配置信息封装类，它的类型是DocumentDefaultsDefinition</span><br><span class="line">	 &#x2F;&#x2F;如果有父delegate，也要让新生成的defaults继承父delegate的defaults</span><br><span class="line">	populateDefaults(this.defaults, (parent !&#x3D; null ? parent.defaults : null), root);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;默认没做任何实现</span><br><span class="line">	this.readerContext.fireDefaultsRegistered(this.defaults);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Populate the given DocumentDefaultsDefinition instance with the default lazy-init,</span><br><span class="line"> * autowire, dependency check settings, init-method, destroy-method and merge settings.</span><br><span class="line"> * Support nested &#39;beans&#39; element use cases by falling back to &#123;@code parentDefaults&#125;</span><br><span class="line"> * in case the defaults are not explicitly set locally.</span><br><span class="line"> * 用默认的值填充DocumentDefaultsDefinition实例</span><br><span class="line"> * 通过使用parentDefaults（父代理的default属性），来解决嵌套的&#39;beans&#39;元素情况，以防默认值在局部设定不明确</span><br><span class="line"> * @param defaults the defaults to populate</span><br><span class="line"> * @param parentDefaults the parent BeanDefinitionParserDelegate (if any) defaults to fall back to</span><br><span class="line"> * @param root the root element of the current bean definition document (or nested beans element)</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root) &#123;</span><br><span class="line">	&#x2F;&#x2F;根元素上如果没有设定值，则返回&quot;default&quot;字符串</span><br><span class="line">	String lazyInit &#x3D; root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);</span><br><span class="line">	&#x2F;&#x2F;如果为&quot;default&quot;，先看parentDefaults有没有，有用它的，没有用&quot;false&quot;</span><br><span class="line">	if (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to false.</span><br><span class="line">		&#x2F;&#x2F; 可能从外部&lt;beans&gt;继承，否则返回false</span><br><span class="line">		lazyInit &#x3D; (parentDefaults !&#x3D; null ? parentDefaults.getLazyInit() : FALSE_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	defaults.setLazyInit(lazyInit);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;下面的逻辑和lazyInit差不多，即看本级是否有显性配置，没有的话，看父类有没有继承，也没有就设默认值。</span><br><span class="line"></span><br><span class="line">	String merge &#x3D; root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(merge)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to false.</span><br><span class="line">		merge &#x3D; (parentDefaults !&#x3D; null ? parentDefaults.getMerge() : FALSE_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	defaults.setMerge(merge);</span><br><span class="line"></span><br><span class="line">	String autowire &#x3D; root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(autowire)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to &#39;no&#39;.</span><br><span class="line">		autowire &#x3D; (parentDefaults !&#x3D; null ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	defaults.setAutowire(autowire);</span><br><span class="line"></span><br><span class="line">	if (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) &#123;</span><br><span class="line">		defaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (parentDefaults !&#x3D; null) &#123;</span><br><span class="line">		defaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		defaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (parentDefaults !&#x3D; null) &#123;</span><br><span class="line">		defaults.setInitMethod(parentDefaults.getInitMethod());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		defaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (parentDefaults !&#x3D; null) &#123;</span><br><span class="line">		defaults.setDestroyMethod(parentDefaults.getDestroyMethod());</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;extractSource方法这里没有做任何实现，默认返回null</span><br><span class="line">	defaults.setSource(this.readerContext.extractSource(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-拆解根层级，并根据子标签命名空间做不同处理"><a href="#3-9-拆解根层级，并根据子标签命名空间做不同处理" class="headerlink" title="3.9 拆解根层级，并根据子标签命名空间做不同处理"></a>3.9 拆解根层级，并根据子标签命名空间做不同处理</h2><p>我们再来看另一个核心方法：DefaultBeanDefinitionDocumentReader类的parseBeanDefinitions方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse the elements at the root level in the document:</span><br><span class="line"> * 将文档中&lt;beans&#x2F;&gt;层级下的元素一层层剥开，为子标签的不同命名空间选择不同策略。</span><br><span class="line"> * 主要两种命名空间：beans命名空间 +其他命名空间（context&#x2F;aop等命名空间）</span><br><span class="line"> </span><br><span class="line"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;等标签都属于beans命名空间</span><br><span class="line"> *</span><br><span class="line"> * 这里判断是否是不同的命名空间，不同命名空间，后续会使用不同解析器来解析。</span><br><span class="line"> *</span><br><span class="line"> * @param root the DOM root element of the document</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;判断默认命名空间是&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		&#x2F;&#x2F;获取根元素(&lt;beans &#x2F;&gt;)下的子Node，注意，Node不一定是子标签，可能是回车，可能是注释</span><br><span class="line">		NodeList nl &#x3D; root.getChildNodes();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node &#x3D; nl.item(i);</span><br><span class="line">			if (node instanceof Element) &#123;</span><br><span class="line">				&#x2F;&#x2F;拿到了&lt;beans&gt;下的子标签</span><br><span class="line">				Element ele &#x3D; (Element) node;</span><br><span class="line">				&#x2F;&#x2F;如果该标签属于beans的名称空间，则进入这个方法</span><br><span class="line">				&#x2F;&#x2F;xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">				if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					&#x2F;&#x2F;如果该标签属于其他的名称空间比如：context,aop等</span><br><span class="line">					&#x2F;&#x2F;xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">					&#x2F;&#x2F;xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">					&#x2F;&#x2F;比如我们使用注解注入的话，会在spring的配置文件加&lt;context:annotation-config&#x2F;&gt;</span><br><span class="line">					&#x2F;&#x2F;这个启用注解的标签，就属于context命名空间</span><br><span class="line">					&#x2F;&#x2F;在接下来的逻辑中，不同命名空间，使用不同处理器来解析</span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-解析beans命名空间的配置"><a href="#3-10-解析beans命名空间的配置" class="headerlink" title="3.10 解析beans命名空间的配置"></a>3.10 解析beans命名空间的配置</h2><p>前文我们说到，如果该标签属于beans的名称空间，则进入parseDefaultElement(ele, delegate)方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;&lt;import&gt;标签进入这个方法</span><br><span class="line">	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;&lt;alias&gt;标签进入这个方法</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;&lt;bean&gt;标签进入这个方法</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F;核心方法</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;&#x2F;&#x2F;又嵌套一层&lt;beans&gt;标签进入这个方法</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F; recurse</span><br><span class="line">		&#x2F;&#x2F; 如果是嵌套的beans，那么就会重新调用doRegisterBeanDefinitions进行递归</span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述几个标签中，我们主要来看<code>&lt;bean&gt;</code>标签的解析方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Process the given bean element, parsing the bean definition</span><br><span class="line"> * and registering it with the registry.</span><br><span class="line"> * 处理bean元素，解析成bean definition并注册到工厂中</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;使用delegate的内容（默认配置）来解析bean元素，核心方法</span><br><span class="line">	BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	if (bdHolder !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有要求的话渲染beanDefinition</span><br><span class="line">		bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Register the final decorated instance.</span><br><span class="line">			&#x2F;&#x2F;注册最终被渲染的实例到工厂中</span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +</span><br><span class="line">					bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; Send registration event.</span><br><span class="line">		&#x2F;&#x2F; 发送注册事件</span><br><span class="line">		&#x2F;&#x2F; 这里是空实现</span><br><span class="line">		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-11-解析并生成BeanDefinition实例"><a href="#3-11-解析并生成BeanDefinition实例" class="headerlink" title="3.11 解析并生成BeanDefinition实例"></a>3.11 解析并生成BeanDefinition实例</h2><p>进入BeanDefinitionParserDelegate类的parseBeanDefinitionElement方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Parses the supplied &#123;@code &lt;bean&gt;&#125; element. May return &#123;@code null&#125;</span><br><span class="line">* if there were errors during parse. Errors are reported to the</span><br><span class="line">* &#123;@link org.springframework.beans.factory.parsing.ProblemReporter&#125;.</span><br><span class="line">*</span><br><span class="line">* 解析bean元素。如果解析过程中发生错误则返回空</span><br><span class="line">*&#x2F;</span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">    &#x2F;&#x2F;拿bean标签上的id</span><br><span class="line">    String id &#x3D; ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    &#x2F;&#x2F;拿bean标签上的name属性</span><br><span class="line">    String nameAttr &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    List&lt;String&gt; aliases &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">    &#x2F;&#x2F;有name属性进入</span><br><span class="line">    if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        &#x2F;&#x2F;name属性对应的name值如果有分隔符&quot;,; &quot;，那么切分成数组</span><br><span class="line">        String[] nameArr &#x3D; StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        &#x2F;&#x2F;这些name值就是别名</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;指定了id就用id值作为bean名称</span><br><span class="line">    String beanName &#x3D; id;</span><br><span class="line">    &#x2F;&#x2F;如果没有id，但是指定了name，就用name值作为bean名称</span><br><span class="line">    if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        &#x2F;&#x2F;拿第一个name值作为bean名称，其余的还是别名</span><br><span class="line">        beanName &#x3D; aliases.remove(0);</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +</span><br><span class="line">                         &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (containingBean &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;检查bean名称和别名是否已经被使用了，如果用了就报错</span><br><span class="line">        &#x2F;&#x2F;同时把这个bean的名称和别名加入代理的usedNames属性中</span><br><span class="line">        &#x2F;&#x2F;private final Set&lt;String&gt; usedNames &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;直接进入这个方法</span><br><span class="line">    AbstractBeanDefinition beanDefinition &#x3D; parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    if (beanDefinition !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;既没有指定id，也没有指定name就走这里面</span><br><span class="line">        if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;前面containingBean传递时为null，这里不走这个方法</span><br><span class="line">                if (containingBean !&#x3D; null) &#123;</span><br><span class="line">                    beanName &#x3D; BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                        beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F;生成一个bean名称，beanName</span><br><span class="line">                    &#x2F;&#x2F;如果这个bean是内部bean，全限定名后加#号再加哈希值</span><br><span class="line">                    &#x2F;&#x2F;如果是顶层bean，那么后面加#号再从0开始加数字，id已被注册数字就增1，直到唯一</span><br><span class="line">                    &#x2F;&#x2F;比如：tk.mybatis.spring.mapper.MapperScannerConfigurer#0</span><br><span class="line">                    beanName &#x3D; this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    &#x2F;&#x2F; Register an alias for the plain bean class name, if still possible,</span><br><span class="line">                    &#x2F;&#x2F; if the generator returned the class name plus a suffix.</span><br><span class="line">                    &#x2F;&#x2F; This is expected for Spring 1.2&#x2F;2.0 backwards compatibility.</span><br><span class="line">                    &#x2F;&#x2F;如果可能的话，如果生成器返回类名加后缀，则注册一个别名，这个别名就是该类的类名。</span><br><span class="line">                    &#x2F;&#x2F;这是为了向后兼容</span><br><span class="line">                    String beanClassName &#x3D; beanDefinition.getBeanClassName();</span><br><span class="line">                    if (beanClassName !&#x3D; null &amp;&amp;</span><br><span class="line">                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                        !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果该类名没有被使用，那么注册该类名作为别名，比如：</span><br><span class="line">                        &#x2F;&#x2F;tk.mybatis.spring.mapper.MapperScannerConfigurer作为</span><br><span class="line">                        &#x2F;&#x2F;tk.mybatis.spring.mapper.MapperScannerConfigurer#0的别名</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +</span><br><span class="line">                                 &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray &#x3D; StringUtils.toStringArray(aliases);</span><br><span class="line">        &#x2F;&#x2F;返回beanDefinition的持有者</span><br><span class="line">        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上文中，核心方法是这句话：</p>
<p><code>AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse the bean definition itself, without regard to name or aliases. May return</span><br><span class="line"> * 不关注名称和别名，只解析bean definition自身</span><br><span class="line"> * &#123;@code null&#125; if problems occurred during the parsing of the bean definition.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">		Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123;</span><br><span class="line">	&#x2F;&#x2F;栈结构，解析的时候放入bean标签，解析完成弹出</span><br><span class="line">	&#x2F;&#x2F;如果还嵌套有子标签，则后续放入子标签</span><br><span class="line">	&#x2F;&#x2F;栈结构当然后进先出，所以子标签先弹出</span><br><span class="line">	this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">	String className &#x3D; null;</span><br><span class="line">	if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有指定class属性，则拿到class属性值</span><br><span class="line">		className &#x3D; ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">	&#125;</span><br><span class="line">	String parent &#x3D; null;</span><br><span class="line">	if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有指定parent属性，则拿到parent属性值</span><br><span class="line">		parent &#x3D; ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;创建BeanDefinition并设置两属性，核心方法</span><br><span class="line">		AbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);</span><br><span class="line">		&#x2F;&#x2F;将bean标签上的属性设置到bean definition中，核心方法2</span><br><span class="line">		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为description，拿到标签中的文本，设置到bean definition中</span><br><span class="line">		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为meta，拿到他的key和value属性，设置到bean definition中</span><br><span class="line">		parseMetaElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为lookup-method，拿到他的name和bean属性，设置到bean definition中</span><br><span class="line">		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为replaced-method，设置bean definition </span><br><span class="line">		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为constructor-arg，设置bean definition的构造方式</span><br><span class="line">		parseConstructorArgElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;这个标签比较常用，为Property标签</span><br><span class="line">		&#x2F;&#x2F;解析Property的属性设置到bean definition中</span><br><span class="line">		parsePropertyElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;有qualifier子标签才走这个方法</span><br><span class="line">		parseQualifierElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;设置资源</span><br><span class="line">		bd.setResource(this.readerContext.getResource());</span><br><span class="line">		&#x2F;&#x2F;这里为null</span><br><span class="line">		bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">		return bd;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (NoClassDefFoundError err) &#123;</span><br><span class="line">		error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		&#x2F;&#x2F;解析的时候放入，解析完成弹出</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个重要的核心方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建BeanDefinition并设置两属性，核心方法</span><br><span class="line">AbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);</span><br><span class="line">&#x2F;&#x2F;将bean标签上的属性设置到bean definition中，核心方法2</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;这个标签比较常用，为Property标签</span><br><span class="line">&#x2F;&#x2F;解析Property的属性设置到bean definition中</span><br><span class="line">parsePropertyElements(ele, bd);</span><br></pre></td></tr></table></figure>

<p>我们依次来看：</p>
<h3 id="3-11-1-创建实例"><a href="#3-11-1-创建实例" class="headerlink" title="3.11.1 创建实例"></a>3.11.1 创建实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Create a bean definition for the given class name and parent name.</span><br><span class="line"> * 通过给定的className和parentName创建beanDefinition</span><br><span class="line"> * </span><br><span class="line"> * @param className the name of the bean class</span><br><span class="line"> * @param parentName the name of the bean&#39;s parent bean</span><br><span class="line"> * @return the newly created bean definition</span><br><span class="line"> * @throws ClassNotFoundException if bean class resolution was attempted but failed</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)</span><br><span class="line">		throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">	return BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">			parentName, className, this.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用BeanDefinitionReaderUtils的静态方法createBeanDefinition():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Create a new GenericBeanDefinition for the given parent name and class name,</span><br><span class="line"> * eagerly loading the bean class if a ClassLoader has been specified.</span><br><span class="line"> </span><br><span class="line"> * 通过给定的parentName和className穿件一个新的GenericBeanDefinition</span><br><span class="line"> * 如果指定了ClassLoader，就提前加载bean class</span><br><span class="line"> </span><br><span class="line"> * @param parentName the name of the parent bean, if any</span><br><span class="line"> * @param className the name of the bean class, if any</span><br><span class="line"> * @param classLoader the ClassLoader to use for loading bean classes</span><br><span class="line"> * (can be &#123;@code null&#125; to just register bean classes by name)</span><br><span class="line"> * @return the bean definition</span><br><span class="line"> * @throws ClassNotFoundException if the bean class could not be loaded</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static AbstractBeanDefinition createBeanDefinition(</span><br><span class="line">		@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader)</span><br><span class="line">		throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">	GenericBeanDefinition bd &#x3D; new GenericBeanDefinition();</span><br><span class="line">	bd.setParentName(parentName);</span><br><span class="line">	if (className !&#x3D; null) &#123;</span><br><span class="line">		if (classLoader !&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F;有classloader，则通过反射，动态加载一个实例返回</span><br><span class="line">			bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F;没有classloader，先存个className</span><br><span class="line">			bd.setBeanClassName(className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-11-2-标签的属性注入"><a href="#3-11-2-标签的属性注入" class="headerlink" title="3.11.2 标签的属性注入"></a>3.11.2 标签的属性注入</h3><p>看完了create，我们再来看parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);方法，该方法会将bean标签的属性值注入到BeanDefinition实例中，也就是给BeanDefinition赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Apply the attributes of the given bean element to the given bean * definition.</span><br><span class="line"> * 将bean标签上的属性设置到bean definition中</span><br><span class="line"> * @param ele bean declaration element</span><br><span class="line"> * @param beanName bean name</span><br><span class="line"> * @param containingBean containing bean definition</span><br><span class="line"> * @return a bean definition initialized according to the bean element attributes</span><br><span class="line"> *&#x2F;</span><br><span class="line">public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,</span><br><span class="line">		@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) &#123;</span><br><span class="line">	&#x2F;&#x2F;bean标签上已经没有singleton属性了，新版用scope代替，所以出现singleton就报错提醒</span><br><span class="line">	if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">		error(&quot;Old 1.x &#39;singleton&#39; attribute in use - upgrade to &#39;scope&#39; declaration&quot;, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果设置了scope就拿其值</span><br><span class="line">	else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;此处containingBean为空</span><br><span class="line">	else if (containingBean !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F; Take default from containing bean in case of an inner bean definition.</span><br><span class="line">		&#x2F;&#x2F; 如果bd是一个内部的beanDefinition，用包含它的bean的配置</span><br><span class="line">		bd.setScope(containingBean.getScope());</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果设置了abstract就拿其值</span><br><span class="line">	if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;lazyInit如果没有设置则为默认值，默认值用的代理类中defaults属性，</span><br><span class="line">	&#x2F;&#x2F;也就是this.defaults</span><br><span class="line">	String lazyInit &#x3D; ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">		lazyInit &#x3D; this.defaults.getLazyInit();</span><br><span class="line">	&#125;</span><br><span class="line">	bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line">	&#x2F;&#x2F;拿autowire配置，无则用默认值，默认值用的代理类中defaults属性，即不进行autowire</span><br><span class="line">	String autowire &#x3D; ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">	bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line">	&#x2F;&#x2F;拿depends-on配置</span><br><span class="line">	if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line">		String dependsOn &#x3D; ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">		bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有autowire-candidate属性，没有或者为默认则不设置</span><br><span class="line">	String autowireCandidate &#x3D; ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(autowireCandidate)) &#123;</span><br><span class="line">		String candidatePattern &#x3D; this.defaults.getAutowireCandidates();</span><br><span class="line">		if (candidatePattern !&#x3D; null) &#123;</span><br><span class="line">			String[] patterns &#x3D; StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">			bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有primary属性</span><br><span class="line">	if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有init-method属性</span><br><span class="line">	if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		String initMethodName &#x3D; ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">		bd.setInitMethodName(initMethodName);</span><br><span class="line">	&#125;&#x2F;&#x2F;没有init-method属性，就拿代理类defaults属性的</span><br><span class="line">	else if (this.defaults.getInitMethod() !&#x3D; null) &#123;</span><br><span class="line">		bd.setInitMethodName(this.defaults.getInitMethod());</span><br><span class="line">		bd.setEnforceInitMethod(false);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有destroy-method属性</span><br><span class="line">	if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		String destroyMethodName &#x3D; ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">		bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">	&#125;&#x2F;&#x2F;没有destroy-method属性，就拿代理类defaults属性的</span><br><span class="line">	else if (this.defaults.getDestroyMethod() !&#x3D; null) &#123;</span><br><span class="line">		bd.setDestroyMethodName(this.defaults.getDestroyMethod());</span><br><span class="line">		bd.setEnforceDestroyMethod(false);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有factory-method属性</span><br><span class="line">	if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有factory-bean属性</span><br><span class="line">	if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，bean标签上的属性也就解析完成了，对其属性的描述不管设置了还是没有设置的，都有相应的值对应到bean definition中。</p>
<h3 id="3-11-3-bean标签下的property注入"><a href="#3-11-3-bean标签下的property注入" class="headerlink" title="3.11.3 bean标签下的property注入"></a>3.11.3 bean标签下的property注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.sgcc.bean.Student&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;无敌&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;20&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>如上述配置，我们知道property的存在，parsePropertyElements()负责解析Property的属性设置到beanDefinition中，此方法在BeanDefinitionParserDelegate类中实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse property sub-elements of the given bean element.</span><br><span class="line"> * 解析bean标签下property子标签</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void parsePropertyElements(Element beanEle, BeanDefinition bd) &#123;</span><br><span class="line">	NodeList nl &#x3D; beanEle.getChildNodes();</span><br><span class="line">	&#x2F;&#x2F;循环查找元素的子元素，也就是bean标签的子元素</span><br><span class="line">	for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		Node node &#x3D; nl.item(i);</span><br><span class="line">		&#x2F;&#x2F;标签名为property才能进入，进入这个方法</span><br><span class="line">		if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">			parsePropertyElement((Element) node, bd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse a property element.</span><br><span class="line"> * 解析property元素，核心的属性只有name和value</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void parsePropertyElement(Element ele, BeanDefinition bd) &#123;</span><br><span class="line">	&#x2F;&#x2F;拿到property标签的name属性</span><br><span class="line">	String propertyName &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	if (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">		error(&quot;Tag &#39;property&#39; must have a &#39;name&#39; attribute&quot;, ele);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;解析的时候放入，解析完成弹出，这里放入property标签，</span><br><span class="line">	&#x2F;&#x2F;注意，此时这里还存有bean父标签，子标签解析完成后先弹出</span><br><span class="line">	this.parseState.push(new PropertyEntry(propertyName));</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;bean标签下可以有多个property，但是不能重复name属性，有重复报错</span><br><span class="line">		if (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">			error(&quot;Multiple &#39;property&#39; definitions for property &#39;&quot; + propertyName + &quot;&#39;&quot;, ele);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;核心方法，解析property标签属性</span><br><span class="line">		Object val &#x3D; parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">		&#x2F;&#x2F;将name属性和对应的value封装为PropertyValue对象</span><br><span class="line">		PropertyValue pv &#x3D; new PropertyValue(propertyName, val);</span><br><span class="line">		&#x2F;&#x2F;解析property标签的子标签meta，</span><br><span class="line">		&#x2F;&#x2F;拿到meta的key和value属性，设置到PropertyValue中</span><br><span class="line">		parseMetaElements(ele, pv);</span><br><span class="line">		&#x2F;&#x2F;这里没有实现，为null</span><br><span class="line">		pv.setSource(extractSource(ele));</span><br><span class="line">		&#x2F;&#x2F;将PropertyValue添加到bean definition中</span><br><span class="line">		bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		&#x2F;&#x2F;解析的时候放入，解析完成弹出，这里弹出的是property标签</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Get the value of a property element. May be a list etc.</span><br><span class="line"> * Also used for constructor arguments, &quot;propertyName&quot; being null in this case.</span><br><span class="line"> * 拿到property标签的value值，可能是list</span><br><span class="line"> * 也可能被constructor标签使用，这种情况propertyName为null</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) &#123;</span><br><span class="line">	&#x2F;&#x2F;如果propertyName为null，则ele是constructor-arg标签</span><br><span class="line">	&#x2F;&#x2F;否则为property标签</span><br><span class="line">	String elementName &#x3D; (propertyName !&#x3D; null ?</span><br><span class="line">			&quot;&lt;property&gt; element for property &#39;&quot; + propertyName + &quot;&#39;&quot; :</span><br><span class="line">			&quot;&lt;constructor-arg&gt; element&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Should only have one child element: ref, value, list, etc.</span><br><span class="line">	&#x2F;&#x2F;不管是哪种标签，下面都应该只有一个子标签: ref, value, list等.</span><br><span class="line">	NodeList nl &#x3D; ele.getChildNodes();</span><br><span class="line">	Element subElement &#x3D; null;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		Node node &#x3D; nl.item(i);</span><br><span class="line">		if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">				!nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">			&#x2F;&#x2F; Child element is what we&#39;re looking for.</span><br><span class="line">			&#x2F;&#x2F;除开description和meta标签，子标签最多只能有一个</span><br><span class="line">			&#x2F;&#x2F;如果该判断为真，说明不止一个除开description和meta的标签</span><br><span class="line">			if (subElement !&#x3D; null) &#123;</span><br><span class="line">				error(elementName + &quot; must not contain more than one sub-element&quot;, ele);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				&#x2F;&#x2F;得到除开description和meta之外的子标签</span><br><span class="line">				&#x2F;&#x2F;比如下面这种配置，那么&lt;value&gt;helloworld&lt;&#x2F;value&gt;就是子元素subElement。</span><br><span class="line">				&#x2F;&#x2F;&lt;property name&#x3D;&quot;Nnnn&quot;&gt;</span><br><span class="line">				&#x2F;&#x2F;	&lt;value&gt;helloworld&lt;&#x2F;value&gt;</span><br><span class="line">				&#x2F;&#x2F;&lt;&#x2F;property&gt;</span><br><span class="line">				subElement &#x3D; (Element) node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;看标签属性用的是value还是ref</span><br><span class="line">	boolean hasRefAttribute &#x3D; ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">	boolean hasValueAttribute &#x3D; ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">	&#x2F;&#x2F;value和ref属性不能同时存在，如果有子标签，则value和ref都不能存在，否则报错</span><br><span class="line">	if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">			((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement !&#x3D; null)) &#123;</span><br><span class="line">		error(elementName +</span><br><span class="line">				&quot; is only allowed to contain either &#39;ref&#39; attribute OR &#39;value&#39; attribute OR sub-element&quot;, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;用的ref的情况，如&lt;property name&#x3D;&quot;name&quot; ref&#x3D;&quot;......&quot;&#x2F;&gt;</span><br><span class="line">	if (hasRefAttribute) &#123;</span><br><span class="line">		&#x2F;&#x2F;拿到ref属性</span><br><span class="line">		String refName &#x3D; ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">		if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(elementName + &quot; contains empty &#39;ref&#39; attribute&quot;, ele);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;通过ref属性来构建一个RuntimeBeanReference实例对象</span><br><span class="line">		RuntimeBeanReference ref &#x3D; new RuntimeBeanReference(refName);</span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		return ref;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;用的value的情况，如&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line">	else if (hasValueAttribute) &#123;</span><br><span class="line">		TypedStringValue valueHolder &#x3D; new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">		valueHolder.setSource(extractSource(ele));</span><br><span class="line">		return valueHolder;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;子标签不为null的情况，比如</span><br><span class="line">	&#x2F;&#x2F;&lt;property name&#x3D;&quot;Nnnn&quot;&gt;</span><br><span class="line">	&#x2F;&#x2F;	&lt;value&gt;helloworld&lt;&#x2F;value&gt;</span><br><span class="line">	&#x2F;&#x2F;&lt;&#x2F;property&gt;</span><br><span class="line">	else if (subElement !&#x3D; null) &#123;</span><br><span class="line">		return parsePropertySubElement(subElement, bd);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.</span><br><span class="line">		&#x2F;&#x2F;没指定ref或者value或者子标签，返回null</span><br><span class="line">		error(elementName + &quot; must specify a ref or value&quot;, ele);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse a value, ref or collection sub-element of a property or</span><br><span class="line"> * constructor-arg element.</span><br><span class="line"> * 解析property或者constructor-arg标签的子标签，可能为value, ref或者集合</span><br><span class="line"> * @param ele subelement of property element; we don&#39;t know which yet</span><br><span class="line"> * @param bd the current bean definition (if any)</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) &#123;</span><br><span class="line">	return parsePropertySubElement(ele, bd, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse a value, ref or collection sub-element of a property or</span><br><span class="line"> * constructor-arg element.</span><br><span class="line"> * 解析property或者constructor-arg标签的子标签，可能为value, ref或者集合</span><br><span class="line"> * @param ele subelement of property element; we don&#39;t know which yet</span><br><span class="line"> * @param bd the current bean definition (if any)</span><br><span class="line"> * @param defaultValueType the default type (class name) for any</span><br><span class="line"> * &#123;@code &lt;value&gt;&#125; tag that might be created</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) &#123;</span><br><span class="line">	if (!isDefaultNamespace(ele)) &#123;&#x2F;&#x2F;如果这个子标签不属于beans的名称空间，则走这个方法</span><br><span class="line">		return parseNestedCustomElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是bean子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		BeanDefinitionHolder nestedBd &#x3D; parseBeanDefinitionElement(ele, bd);</span><br><span class="line">		if (nestedBd !&#x3D; null) &#123;</span><br><span class="line">			nestedBd &#x3D; decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">		&#125;</span><br><span class="line">		return nestedBd;</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是ref子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F; A generic reference to any name of any bean.</span><br><span class="line">		String refName &#x3D; ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">		boolean toParent &#x3D; false;</span><br><span class="line">		if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">			&#x2F;&#x2F; A reference to the id of another bean in a parent context.</span><br><span class="line">			refName &#x3D; ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">			toParent &#x3D; true;</span><br><span class="line">			if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">				error(&quot;&#39;bean&#39; or &#39;parent&#39; is required for &lt;ref&gt; element&quot;, ele);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		RuntimeBeanReference ref &#x3D; new RuntimeBeanReference(refName, toParent);</span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		return ref;</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是idref子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">		return parseIdRefElement(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是value子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F;以这个方法作为演示，其他的方法都是大同小异，进入。</span><br><span class="line">		return parseValueElement(ele, defaultValueType);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是null子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F; It&#39;s a distinguished null value. Let&#39;s wrap it in a TypedStringValue</span><br><span class="line">		&#x2F;&#x2F; object in order to preserve the source location.</span><br><span class="line">		TypedStringValue nullHolder &#x3D; new TypedStringValue(null);</span><br><span class="line">		nullHolder.setSource(extractSource(ele));</span><br><span class="line">		return nullHolder;</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是array子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">		return parseArrayElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是list子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">		return parseListElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是set子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">		return parseSetElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是map子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">		return parseMapElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是props子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">		return parsePropsElement(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;否则返回null，报错</span><br><span class="line">	else &#123;</span><br><span class="line">		error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Return a typed String value Object for the given value element.</span><br><span class="line"> * 通过指定的value标签，返回指定的字符串value对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Object parseValueElement(Element ele, @Nullable String defaultTypeName) &#123;</span><br><span class="line">	&#x2F;&#x2F; It&#39;s a literal value.</span><br><span class="line">	&#x2F;&#x2F;拿到value中的文本，包括回车、tab制表符、空格</span><br><span class="line">	String value &#x3D; DomUtils.getTextValue(ele);</span><br><span class="line">	&#x2F;&#x2F;有无type属性</span><br><span class="line">	String specifiedTypeName &#x3D; ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">	String typeName &#x3D; specifiedTypeName;</span><br><span class="line">	if (!StringUtils.hasText(typeName)) &#123;</span><br><span class="line">		&#x2F;&#x2F;没有就用入参defaultTypeName，其实这里defaultTypeName也是null</span><br><span class="line">		typeName &#x3D; defaultTypeName;</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;构建一个value的封装类。</span><br><span class="line">		TypedStringValue typedValue &#x3D; buildTypedStringValue(value, typeName);</span><br><span class="line">		&#x2F;&#x2F;这里设置为空</span><br><span class="line">		typedValue.setSource(extractSource(ele));</span><br><span class="line">		&#x2F;&#x2F;这里为空字符串</span><br><span class="line">		typedValue.setSpecifiedTypeName(specifiedTypeName);</span><br><span class="line">		&#x2F;&#x2F;返回typedValue</span><br><span class="line">		return typedValue;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(&quot;Type class [&quot; + typeName + &quot;] not found for &lt;value&gt; element&quot;, ele, ex);</span><br><span class="line">		return value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-12-注册BeanDefinition到工厂中"><a href="#3-12-注册BeanDefinition到工厂中" class="headerlink" title="3.12 注册BeanDefinition到工厂中"></a>3.12 注册BeanDefinition到工厂中</h2><p>好，回到processBeanDefinition方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Process the given bean element, parsing the bean definition</span><br><span class="line"> * and registering it with the registry.</span><br><span class="line"> * 处理bean元素，解析成bean definition并注册到工厂中</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;使用delegate的内容（默认配置）来解析bean元素，核心方法</span><br><span class="line">	BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	if (bdHolder !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有要求的话渲染beanDefinition，不是很重要</span><br><span class="line">		bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Register the final decorated instance.</span><br><span class="line">			&#x2F;&#x2F;注册最终被渲染的实例到工厂中</span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +</span><br><span class="line">					bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; Send registration event.</span><br><span class="line">		&#x2F;&#x2F; 发送注册事件</span><br><span class="line">		&#x2F;&#x2F; 这里是空实现</span><br><span class="line">		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);这一句我们已经在3.11章节中详细介绍了，接下来我们视角继续往下，看下BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Register the given bean definition with the given bean factory.</span><br><span class="line"> * @param definitionHolder the bean definition including name and aliases</span><br><span class="line"> * @param registry the bean factory to register with</span><br><span class="line"> * @throws BeanDefinitionStoreException if registration failed</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void registerBeanDefinition(</span><br><span class="line">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Register bean definition under primary name.</span><br><span class="line">	&#x2F;&#x2F; 注册beanDefinition的beanName</span><br><span class="line">	&#x2F;&#x2F; 比如tk.mybatis.spring.mapper.MapperScannerConfigurer#0</span><br><span class="line">	String beanName &#x3D; definitionHolder.getBeanName();</span><br><span class="line">	&#x2F;&#x2F; 核心方法，比较重要，待会儿详解</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Register aliases for bean name, if any.</span><br><span class="line">	&#x2F;&#x2F; 如果有别名的话，为bean name注册别名</span><br><span class="line">	String[] aliases &#x3D; definitionHolder.getAliases();</span><br><span class="line">	if (aliases !&#x3D; null) &#123;</span><br><span class="line">		for (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主流程由此进入了registry.registerBeanDefinition中，其中registry实例是DefaultListableBeanFactory的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">	Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">	if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;做一个验证，静态工厂方法和覆盖方法不能组合使用</span><br><span class="line">			&#x2F;&#x2F;如果bean definition中的beanClass属性不是String类型而是Class类型</span><br><span class="line">			&#x2F;&#x2F;那么就要验证和准备这个bean定义的覆盖方法，检查指定名称的方法是否存在</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Validation of bean definition failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;查看beanName是否已经被注册在工厂的beanDefinitionMap属性中</span><br><span class="line">	BeanDefinition existingDefinition &#x3D; this.beanDefinitionMap.get(beanName);</span><br><span class="line">	&#x2F;&#x2F;已经被注册的情况走这个方法，覆盖或者抛异常</span><br><span class="line">	if (existingDefinition !&#x3D; null) &#123;</span><br><span class="line">		if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &#39;&quot; + beanName +</span><br><span class="line">					&quot;&#39;: There is already [&quot; + existingDefinition + &quot;] bound.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			&#x2F;&#x2F; e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Overriding user-defined bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">						&quot;&#39; with a framework-generated bean definition: replacing [&quot; +</span><br><span class="line">						existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Overriding bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">						&quot;&#39; with a different definition: replacing [&quot; + existingDefinition +</span><br><span class="line">						&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">						&quot;&#39; with an equivalent definition: replacing [&quot; + existingDefinition +</span><br><span class="line">						&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;这场景表示beanName还没有被注册</span><br><span class="line">		&#x2F;&#x2F;然后根据阶段不同又有一层判断</span><br><span class="line">		if (hasBeanCreationStarted()) &#123;</span><br><span class="line">			&#x2F;&#x2F; Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">			&#x2F;&#x2F;这个阶段是bean已经开始创建，启动阶段不会进入这里</span><br><span class="line">			&#x2F;&#x2F;如果在非启动阶段注册beanDefinition，那么要加锁后才能操作beanDefinitionMap、beanDefinitionNames</span><br><span class="line">			&#x2F;&#x2F;和manualSingletonNames</span><br><span class="line">			synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">				this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions &#x3D; new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">				updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				this.beanDefinitionNames &#x3D; updatedDefinitions;</span><br><span class="line">				if (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">					Set&lt;String&gt; updatedSingletons &#x3D; new LinkedHashSet&lt;&gt;(this.manualSingletonNames);</span><br><span class="line">					updatedSingletons.remove(beanName);</span><br><span class="line">					this.manualSingletonNames &#x3D; updatedSingletons;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F; 仍然处于启动时的注册阶段</span><br><span class="line">			&#x2F;&#x2F; 所以这里走这个方法</span><br><span class="line">			&#x2F;&#x2F; beanDefinitionMap是工厂的一个属性，ConcurrentHashMap类型</span><br><span class="line">			&#x2F;&#x2F;他保存所有解析好的bean Definition的名称和实例的映射</span><br><span class="line">			&#x2F;&#x2F; Still in startup registration phase</span><br><span class="line">			this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			&#x2F;&#x2F;beanName也单独使用了一个ArrayList来保存，方便遍历</span><br><span class="line">			this.beanDefinitionNames.add(beanName);</span><br><span class="line">			&#x2F;&#x2F;如果该beanDefinition是手动注册的，还要从manualSingletonNames中移除beanDefinition的beanName</span><br><span class="line">			&#x2F;&#x2F;manualSingletonNames是LinkedHashSet</span><br><span class="line">			this.manualSingletonNames.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		this.frozenBeanDefinitionNames &#x3D; null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (existingDefinition !&#x3D; null || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看别名的注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerAlias(String name, String alias) &#123;</span><br><span class="line">	Assert.hasText(name, &quot;&#39;name&#39; must not be empty&quot;);</span><br><span class="line">	Assert.hasText(alias, &quot;&#39;alias&#39; must not be empty&quot;);</span><br><span class="line">	synchronized (this.aliasMap) &#123;</span><br><span class="line">		if (alias.equals(name)) &#123;</span><br><span class="line">			&#x2F;&#x2F;移除别名中的beanName</span><br><span class="line">			&#x2F;&#x2F;aliasMap是ConcurrentHashMap类型，保存别名和beanName的映射</span><br><span class="line">			this.aliasMap.remove(alias);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Alias definition &#39;&quot; + alias + &quot;&#39; ignored since it points to same name&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			String registeredName &#x3D; this.aliasMap.get(alias);</span><br><span class="line">			&#x2F;&#x2F;如果别名对应beanName已经被注册，则不需要再注册一次</span><br><span class="line">			&#x2F;&#x2F;别名不允许被覆盖</span><br><span class="line">			if (registeredName !&#x3D; null) &#123;</span><br><span class="line">				if (registeredName.equals(name)) &#123;</span><br><span class="line">					&#x2F;&#x2F; An existing alias - no need to re-register</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				if (!allowAliasOverriding()) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;Cannot define alias &#39;&quot; + alias + &quot;&#39; for name &#39;&quot; +</span><br><span class="line">							name + &quot;&#39;: It is already registered for name &#39;&quot; + registeredName + &quot;&#39;.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Overriding alias &#39;&quot; + alias + &quot;&#39; definition for registered name &#39;&quot; +</span><br><span class="line">							registeredName + &quot;&#39; with new target name &#39;&quot; + name + &quot;&#39;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;再检查一遍，aliasMap中不能已经存在name和alias</span><br><span class="line">			checkForAliasCircle(name, alias);</span><br><span class="line">			&#x2F;&#x2F;工厂的aliasMap属性保存别名，那么alias已被注册</span><br><span class="line">			this.aliasMap.put(alias, name);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Alias definition &#39;&quot; + alias + &quot;&#39; registered for name &#39;&quot; + name + &quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-13-加载xml文件beanDefinition流程图"><a href="#3-13-加载xml文件beanDefinition流程图" class="headerlink" title="3.13 加载xml文件beanDefinition流程图"></a>3.13 加载xml文件beanDefinition流程图</h2><p><img src="https://oscimg.oschina.net/oscnet/up-0a652bfc13671b2b64650cd88b8b2aec238.png" alt=""></p>
<h1 id="4-加载注解配置的beanDefinition"><a href="#4-加载注解配置的beanDefinition" class="headerlink" title="4 加载注解配置的beanDefinition"></a>4 加载注解配置的beanDefinition</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/" itemprop="url">Spring Resource资源文件体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-29T22:58:12+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/06/29/Spring-Resource资源文件体系/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Resource接口"><a href="#1-Resource接口" class="headerlink" title="1. Resource接口"></a>1. Resource接口</h1><p>Spring对于资源加载有着一套自己的框架——Resource，Resource继承自InputStream。<br>下面的是Resource的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public interface Resource extends InputStreamSource &#123;</span><br><span class="line">    boolean exists();&#x2F;&#x2F;判断资源是否存在</span><br><span class="line">    default boolean isReadable() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断资源是否打开</span><br><span class="line">    default boolean isOpen() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断资源是否是一个文件</span><br><span class="line">    default boolean isFile() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取资源文件的URL</span><br><span class="line">    URL getURL() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;获取资源文件的URI</span><br><span class="line">    URI getURI() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;获取资源文件的File对象</span><br><span class="line">    File getFile() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;这个方法接口中有默认实现，返回的是ReadableByteChannel，这个类属于Java的NIO中的管道。</span><br><span class="line">    default ReadableByteChannel readableChannel() throws IOException &#123;</span><br><span class="line">        return Channels.newChannel(getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取内容的长度，这个方法返回一个long，因为文件内容可能很长。</span><br><span class="line">    long contentLength() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;这个方法返回的是最后修改时间，虽然也返回的是long，但是这个数字是一个时间戳。</span><br><span class="line">    long lastModified() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;这个方法根据relativePath相对路径返回一个相对与该Resource的Resource。</span><br><span class="line">    Resource createRelative(String relativePath) throws IOException;</span><br><span class="line">    @Nullable</span><br><span class="line">    &#x2F;&#x2F;获取文件的名字。</span><br><span class="line">    String getFilename();</span><br><span class="line">    &#x2F;&#x2F;获取一个对该资源的一个描述。</span><br><span class="line">    String getDescription();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-Resource实现类"><a href="#2-Resource实现类" class="headerlink" title="2. Resource实现类"></a>2. Resource实现类</h1><p>你可以理解为，Resource就是一个增强版的InputStreamSource，Resource 接口是Spring资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略（策略模式）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-14643860b1762106730a60406986062587a.png" alt=""></p>
<ul>
<li>UrlResource:<ul>
<li>UrlResource封装了java.net.URL，可用于访问通常可通过url访问的任何对象，如文件、HTTP目标、FTP目标和其他对象。所有URL可以使用一个标准化前缀来表示一个URL类型。例如： file：用于访问文件系统路径。 http：用于通过HTTP协议访问资源。 ftp：用于通过FTP访问资源。</li>
</ul>
</li>
<li>ClassPathResource:<ul>
<li>表示从类路径加载资源。如果资源路径带上前缀ClassPath:，那么会隐式的解析为ClassPathResource。注意，如果类资源文件是在文件系统中，则该资源实现会被解析为java.io.File， 如果是在Jar包中，则会使用java.net.URL来解析。</li>
</ul>
</li>
<li>FileSystemResource:<ul>
<li>他是java.io.File和java.nio.file.Path的Resource实现，支持解析为File或者URL。如D:/aaa/vvv.java</li>
</ul>
</li>
<li>ServletContextResource:<ul>
<li>这是ServletContext的Resource实现，用于解释相关Web应用程序根目录中的相对路径。访问Web容器上下文中的资源而设计的类，负责对于Web应用根目录的路径加载资源。它支持以流和URL的方式访问，在WAR解包的情况下，也可以通过File方式访问。该类还可以直接从JAR包中访问资源。</li>
</ul>
</li>
<li>InputStreamResource:<ul>
<li>InputStreamResource 是InputStream 的Resource实现。只有在其他Resource实现不可用的时候才考虑使用它。和其他的Resource实现相反，它是一个already-opened resource的描述器，所以isOpen()会返回true。 如果你想保存资源描述器或者多次读取一个stream， 那么不要使用它。</li>
</ul>
</li>
<li>ByteArrayResource:<ul>
<li>是byte array的Resource实现， 它创建了ByteArrayInputStream。它对于从任何给定的字节数组加载内容都很有用，而不必求助于单次使用的InputStreamResource。</li>
</ul>
</li>
<li>PathResource:<ul>
<li>Spring4.0提供的读取资源文件的新类。Path封装了java.net.URL、java.nio.Path、文件系统资源，它使用户能够访问任何可以通过URL、Path、系统文件路径表示的资源，如文件系统的资源，HTTP资源、FTP资源等。</li>
</ul>
</li>
</ul>
<h1 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3. 使用示例"></a>3. 使用示例</h1><p>使用示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testResource() throws IOException &#123;</span><br><span class="line">    String filePath &#x3D; &quot;E:\\源码\\Spring源码阅读\\testSpring\\src\\test\\resources\\spring.txt&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 使用系统的文件路径方式加载文件</span><br><span class="line">    WritableResource resource1 &#x3D; new PathResource(filePath);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 使用类路径方式加载文件</span><br><span class="line">    Resource resource2 &#x3D; new ClassPathResource(&quot;spring.txt&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3. 使用WritableResource接口写资源文件</span><br><span class="line">    OutputStream os &#x3D; resource1.getOutputStream();</span><br><span class="line">    os.write(&quot;Spring是一套非常优秀的框架&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4. 使用Resource接口读文件</span><br><span class="line">    InputStream in1 &#x3D; resource1.getInputStream();</span><br><span class="line">    InputStream in2 &#x3D; resource1.getInputStream();</span><br><span class="line">    BufferedInputStream bis &#x3D; new BufferedInputStream(in1);</span><br><span class="line">    byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">    bis.read(bytes);</span><br><span class="line">    System.out.println(new String(bytes));</span><br><span class="line">    System.out.println(&quot;resource1: &quot; + resource1.getFilename());</span><br><span class="line">    System.out.println(&quot;resource2: &quot; + resource2.getFilename());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-资源路径通配符。"><a href="#4-资源路径通配符。" class="headerlink" title="4. 资源路径通配符。"></a>4. 资源路径通配符。</h1><p>Resource解析各种资源路径，依靠资源路径通配符可以带来很多方便。</p>
<h2 id="4-1-Ant-style-Patterns"><a href="#4-1-Ant-style-Patterns" class="headerlink" title="4.1 Ant-style Patterns"></a>4.1 Ant-style Patterns</h2><p>定义资源路径可以是用Ant风格的通配符，下面是 Ant-style patterns 的路径例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;WEB-INF&#x2F;*-context.xml</span><br><span class="line">com&#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml</span><br><span class="line">file:C:&#x2F;some&#x2F;path&#x2F;*-cont?xt.xml</span><br><span class="line">classpath:com&#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml</span><br></pre></td></tr></table></figure>

<p>Ant风格的资源地址支持三种通配符：</p>
<ul>
<li>?:匹配文件名中的一个字符</li>
<li>*：匹配文件名中的多个字符</li>
<li>**:匹配多层路径。</li>
</ul>
<h2 id="4-2-classpath-前缀"><a href="#4-2-classpath-前缀" class="headerlink" title="4.2 classpath*:前缀"></a>4.2 classpath*:前缀</h2><p>构造基于XML的ApplicationContext，路径地址可以使用classpath*: 前缀，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx &#x3D;</span><br><span class="line">    new ClassPathXmlApplicationContext(&quot;classpath*:conf&#x2F;appContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>classpath* 和 classpath 的区别是：classpath* 会去查找所有匹配的classpath， 而classpath 只会找到第一个匹配的资源。</p>
</blockquote>
<h1 id="5-ResourceLoader"><a href="#5-ResourceLoader" class="headerlink" title="5. ResourceLoader"></a>5. ResourceLoader</h1><p>不过有个问题随之而来，那就是Resource的选择，这么多的Resource如何知道选择使用哪一个？Spring提供了一个强大的资源加载机制，他可以通过前缀标识加载资源，如：classpath:, file:,ftp:等，同时还支持使用Ant风格的通配符。</p>
<p>ResourceLoader用来返回Resource实例，下面是其定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ResourceLoader &#123;</span><br><span class="line">    Resource getResource(String location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>前缀</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:</td>
<td>classpath:com/myapp/config.xml</td>
<td>使用ClassPathResource从classpath中加载。</td>
</tr>
<tr>
<td>file:</td>
<td>file:/data/config.xml</td>
<td>作为 URL 加载。使用UrlResource从文件系统目录中装载资源</td>
</tr>
<tr>
<td>http:</td>
<td><a href="http://myserver/logo.png" target="_blank" rel="noopener">http://myserver/logo.png</a></td>
<td>作为 URL 加载。使用UrlResource从Web服务器中装载资源</td>
</tr>
<tr>
<td>ftp:</td>
<td><a href="ftp://www.mcwebsite.top/bean.xml">ftp://www.mcwebsite.top/bean.xml</a></td>
<td>作为 URL 加载。使用UrlResource从ftp服务器中装载资源</td>
</tr>
<tr>
<td>(none)</td>
<td>/data/config.xml</td>
<td>根据ApplicationContext的具体实现选择对应类型的Resource</td>
</tr>
</tbody></table>
<p>上表中最后一种情况，需要说明下：</p>
<p>所有的<strong>ApplicationContext</strong>都实现了ResourceLoader类。因此所有的ApplicationContext都可以用来获取Resource。</p>
<p>当在特定的应用程序上下文上调用getResource（），并且指定的位置路径没有特定的前缀时，将返回适合该特定应用程序上下文的资源类型。</p>
<p>例如，假设对ClassPathXmlApplicationContext实例执行了以下代码片段：</p>
<p><code>Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);</code></p>
<p>在ClassPathXmlApplicationContext中，这个方法返回ClassPathResource。</p>
<p>以此类推，在FileSystemXmlApplicationContext中，方法返回FileSystemResource。在WebApplicationContext， 方法返回ServletContextResource。</p>
<p>当然，就像我们表中说的，我们可以强制使用ClassPathResource，而不管ApplicationContext到底是什么。这样做的话，我们需要添加classpath:前缀。如下：</p>
<p><code>Resource template = ctx.getResource(&quot;classpath:some/resource/path/myTemplate.txt&quot;);</code></p>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>同样的，你可以强制使用UrlResource通过添加标准的java.net.URL前缀(context-param配置的话同理):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource template &#x3D; ctx.getResource(&quot;file:&#x2F;&#x2F;&#x2F;some&#x2F;resource&#x2F;path&#x2F;myTemplate.txt&quot;);</span><br><span class="line"></span><br><span class="line">Resource template &#x3D; ctx.getResource(&quot;https:&#x2F;&#x2F;myhost.com&#x2F;resource&#x2F;path&#x2F;myTemplate.txt&quot;);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-hand-o-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-hand-o-right" aria-label="accessibility.next_page"></i></a>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">94</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">376.6k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
