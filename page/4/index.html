<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/" itemprop="url">Spring IoC概念分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T22:55:51+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/25/Spring-IoC概念分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  13k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  50
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-IoC概念简介"><a href="#1-IoC概念简介" class="headerlink" title="1. IoC概念简介"></a>1. IoC概念简介</h1><p>IoC是随着近年来轻量级容器（Lightweight Container)的兴起而逐渐被很多人提起的一个名词，它的全称为Inversion of Control，中文通常翻译为“控制反转”。好莱坞原则“Don’t call us, we will call you.”恰如其分地表达了“反转”的意味，是用来形容IoC最多的一句话。</p>
<p>它不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</p>
<ul>
<li>正控：若要使用某个对象，需要自己去负责对象的创建</li>
<li>反控：若要使用某个对象，只需要从Spring容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-38d5b7469789631b0fa0fbc1e04e2dfb312.png" alt=""></p>
<h1 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h1><p>依赖注入（Dependency Injection，简称DI），2004年，Martin Fowler探讨了一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“<strong>获得依赖对象的过程被反转了</strong>”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IoC容器主动注入。</p>
<p>于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IoC的方法：<strong>注入</strong>——所谓依赖注入，就是由IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p>所以，依赖注入(DI)和控制反转(IoC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p>
<p><strong>或者说，IoC是一种思想，是一种目标，而DI这时一种手段，一种过程</strong>。</p>
<h2 id="2-1-理论上的依赖注入方式"><a href="#2-1-理论上的依赖注入方式" class="headerlink" title="2.1 理论上的依赖注入方式"></a>2.1 理论上的依赖注入方式</h2><p>在学术理论上，依赖注入有三种实现方式：</p>
<h3 id="2-1-1-三种注入的方式"><a href="#2-1-1-三种注入的方式" class="headerlink" title="2.1.1 三种注入的方式"></a>2.1.1 三种注入的方式</h3><p>当你来到酒吧，想要喝杯啤酒的时候，通常会直接招呼服务生，让他为你送来一杯清凉的啤酒。同样地，作为被注入对象，要想让IoC容器为其提供服务，并将所需要的被依赖对象送过来，也需要通过某种方式通知对方。</p>
<p>这里就牵涉到了三种依赖注入的方式：</p>
<ol>
<li><strong>构造方法注入</strong><ul>
<li>顾名思义，构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表，让外部（通常是IoC容器）知道它需要哪些依赖对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FXNewsProvider(IFXNewsListener newsListner,IFXNewsPersister newsPersister) &#123;</span><br><span class="line">	this.newsListener &#x3D; newsListner;</span><br><span class="line">	this.newPersistener &#x3D; newsPersister;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>IoC Service Provider会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。同一个对象是不可能被构造两次的，因此，被注入对象的构造乃至其整个生命周期，应该是由IoC Service Provider来管理的。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</li>
<li><blockquote>
<p>这就好比你刚进酒吧的门，服务生已经将你喜欢的啤酒摆上了桌面一样。坐下就可马上享受一份清凉与惬意。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>setter 方法注入</strong><ul>
<li>对于JavaBean对象来说，通常会通过setXXX()和getXXX()方法来访问对应属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FXNewsProvider&#123;</span><br><span class="line">	private IFXNewsListener newsListener;</span><br><span class="line"></span><br><span class="line">	public IFXNewsListener getNewsListener() &#123;</span><br><span class="line">	return newsListener;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNewsListener(IFXNewsListener newsListener) &#123;</span><br><span class="line">	this.newsListener &#x3D; newsListener;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样，外界就可以通过调用setNewsListener方法为FXNewsProvider对象注入所依赖的对象了。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再注入。</li>
<li><blockquote>
<p>这就好比你可以到酒吧坐下后再决定要点什么啤酒，可以要百威，也可以要青岛，随意性比较强。如果你不急着喝，这种方式当然是最适合你的。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>接口注入</strong><ul>
<li><strong>首先注意，因为代码侵入性高，所以这种方式Spring框架不支持，只要了解即可。</strong></li>
<li>相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service  Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。</li>
<li>FXNewsProvider为了让IoC Service Provider为其注入所依赖的IFXNewsListener，首先需要实现IFXNewsListenerCallable接口，这个接口会声明一个injectNewsListner方法（方法名随意），该方法的参数，就是所依赖对象的类型。这样，InjectionServiceContainer对象，即对应的IoC Service Provider就可以通过这个接口方法将依赖对象注入到被注入对象FXNewsProvider当中。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-cbadc8320845789e72095140547d4c456b4.png" alt=""></li>
<li>接口注入方式最早并且使用最多的是在一个叫做Avalon的项目中，相对于前两种依赖注入方式，接口注入比较死板和烦琐。如果需要注入依赖对象，被注入对象就必须声明和实现另外的接口。</li>
<li><blockquote>
<p>这就好像你同样在酒吧点啤酒，为了让服务生理解你的意思，你就必须戴上一顶啤酒杯式的帽子<img src="https://oscimg.oschina.net/oscnet/up-020c50b28bcf338955887894a8dccdd5b1e.png" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-三种注入方式的比较"><a href="#2-1-2-三种注入方式的比较" class="headerlink" title="2.1.2 三种注入方式的比较"></a>2.1.2 三种注入方式的比较</h3><ol>
<li>接口注入：<ul>
<li>从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter方法注入则不需要如此。</li>
</ul>
</li>
<li>构造方法注入：<ul>
<li>这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以马上使用。</li>
<li>缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。</li>
</ul>
</li>
<li>setter方法注入：<ul>
<li>因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。另外，setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。</li>
<li>缺点当然就是对象无法在构造完成后马上进入就绪状态。</li>
</ul>
</li>
</ol>
<p>综上所述，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式；而接口注入因为侵入性较强，近年来已经不流行了。</p>
<h2 id="2-2-Spring的依赖注入方式"><a href="#2-2-Spring的依赖注入方式" class="headerlink" title="2.2 Spring的依赖注入方式"></a>2.2 Spring的依赖注入方式</h2><p>因为代码侵入性高的问题，接口注入的方式，spring框架并不支持。Spring的依赖注入方式只有构造方法注入和setter方法注入：</p>
<ol>
<li>构造方法<ul>
<li>开箱即用，适合用于注入实例必须的初始值时使用，但是当参数列表较长时难以维护和使用。构造方法无法被继承，也无法设置默认值。适合较固定的对象使用。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.spring.test.di.LoginImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.spring.test.di.LoginAction"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructorarg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"login"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor­arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>setter方法<ul>
<li>适合依赖对象多，且组成对象灵活多变的场景，是目前最为常见的注入方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;login&quot; class&#x3D;&quot;com.spring.test.di.LoginImpl&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;loginAction&quot; class&#x3D;&quot;com.spring.test.di.LoginAction&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;login&quot; ref&#x3D;&quot;login&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="3-IoC-Service-Provider"><a href="#3-IoC-Service-Provider" class="headerlink" title="3. IoC Service Provider"></a>3. IoC Service Provider</h1><p>了解了IoC和DI的概念中，我们可以知道，在DI的过程中，IoC Service Provider是一个非常重要的概念——业务对象可以通过IoC方式声明相应的依赖，但是最终仍然需要通过某种角色或者服务将这些相互依赖的对象绑定到一起，IoC Service Provider就是这样一个角色。</p>
<p>IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或者IoC容器实现。Spring的IoC容器就是一个提供依赖注入服务的IoC Service Provider。</p>
<h2 id="3-1-IoC-Service-Provider的职责"><a href="#3-1-IoC-Service-Provider的职责" class="headerlink" title="3.1 IoC Service Provider的职责"></a>3.1 IoC Service Provider的职责</h2><p>IoC Service Provider的职责相对来说比较简单，主要有两个：</p>
<ol>
<li>业务对象的注册管理。<ul>
<li>在IoC场景中，业务对象无需关心所依赖的对象如何构建如何取得，但这部分工作始终需要有人来做。所以，IoC Service Provider需要识别这部分需要管理的对象，并且将这些对象的构建逻辑从客户端对象那里剥离出来，以免这部分逻辑污染业务对象的实现。</li>
</ul>
</li>
<li>业务对象间的依赖绑定。<ul>
<li>IoC Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状态。</li>
</ul>
</li>
</ol>
<h2 id="3-2-常见IoC-Service-Provider依赖注册方式"><a href="#3-2-常见IoC-Service-Provider依赖注册方式" class="headerlink" title="3.2 常见IoC Service Provider依赖注册方式"></a>3.2 常见IoC Service Provider依赖注册方式</h2><p>那么，对于IoC Service Provider来说，如何知道哪些对象是被其他对象依赖（即需要它管理起来的）的呢？又是如何知道某个管理的对象，具体要注入到哪一个具体的其他对象中呢？就像一个资深的酒吧服务员，客人点了哪些酒，且每一杯酒分别是被哪个客人点的，他都要了然于心，这时如何做到的呢？</p>
<p>很显然，我们需要记录下来这些的“服务信息”(在Spring的术语中，把BeanFactory需要使用的对象注册和依赖绑定信息称为<strong>Configuration Metadata</strong>)，当前流行的IoC Service Provider产品使用的Configuration Metadata的方式主要有以下几种：</p>
<ol>
<li><strong>直接编码方式</strong><ul>
<li>当前大部分的IoC容器都应该支持直接编码方式，比如PicoContainer、Spring、Avalon等。在容器启动之前，我们就可以通过程序编码的方式将被注入对象和依赖对象注册到容器中，并明确它们相互之间的依赖注入关系。</li>
</ul>
</li>
<li><strong>配置文件方式</strong><ul>
<li>这是一种较为普遍的依赖注入关系管理方式。像普通文本文件、properties文件、XML文件等，都可以成为管理依赖注入关系的载体。不过，最为常见的，还是通过XML文件来管理对象注册和对象间依赖关系，比如Spring IoC容器和在PicoContainer基础上扩展的NanoContainer，都是采用XML文件来管理和保存依赖注入信息的。</li>
</ul>
</li>
<li><strong>元数据方式（注解）</strong><ul>
<li>这种方式的代表实现是Google Guice，这是Bob Lee在Java 5的注解和Generic的基础上开发的一套IoC框架。我们可以直接在类中使用元数据信息来标注各个对象之间的依赖关系，然后由Guice框架根据这些注解所提供的信息将这些对象组装后，交给客户端对象使用。</li>
</ul>
</li>
</ol>
<h2 id="3-3-Spring-IoC-Service-Provider依赖注册方式"><a href="#3-3-Spring-IoC-Service-Provider依赖注册方式" class="headerlink" title="3.3 Spring IoC Service Provider依赖注册方式"></a>3.3 Spring IoC Service Provider依赖注册方式</h2><p>Spring IoC Service Provider的注册依赖方式同样是三种，也就是说，其他IoC Service Provider支持的主流的三种依赖注册方式，Spring都支持。</p>
<ol>
<li><strong>直接编码方式</strong><ul>
<li>使用<code>@Configuration</code>注解可以将java的类文件声明成spring的配置类，使用<code>@Bean</code>来声明方法的返回对象要注册为spring的bean对象。</li>
<li>而当bean中需要注入其他参数或者引用时，将其作为方法的参数即可，Spring会帮你注入这些引用。</li>
<li>默认情况下，方法名即为id名，当然也可以为bean指定名称，通过其<code>@Bean</code>注解的name属性。</li>
<li>同时<code>@Bean</code>注解的initMethod属性和destroyMethod属性，可以指定初始化和销毁时的生命周期回调函数。</li>
<li>而<code>@Scope</code>和<code>@Description</code>注解，则可以给bean设置Scope和Description<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用@Configuration注解可以将java的类文件声明成spring的配置类</span><br><span class="line">@Configuration</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line"></span><br><span class="line">	@Bean &#x2F;&#x2F;你可以理解为定义一个String类型的bean，值是&quot;test&quot;，做依赖注入用。</span><br><span class="line">	public String username()&#123;</span><br><span class="line">		return &quot;test&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public List&lt;String&gt; tags()&#123;</span><br><span class="line">		List&lt;String&gt; tags &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">		tags.add(&quot;cool&quot;);</span><br><span class="line">		tags.add(&quot;nice&quot;);</span><br><span class="line">		return tags;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;使用@Bean 注解表明myBean需要交给Spring进行管理</span><br><span class="line">	&#x2F;&#x2F;如果未指定bean的id，默认采用的是 &quot;方法名&quot; + &quot;首字母小写&quot;的配置方式</span><br><span class="line">	&#x2F;&#x2F;name属性可以定义bean的id ; initMethod和destroyMethod属性指定初始化和销毁时的生命周期回调函数。</span><br><span class="line">	@Bean(name &#x3D; &quot;userInterfaceIml&quot; , initMethod &#x3D; &quot;init&quot; , destroyMethod &#x3D; &quot;cleanup&quot;)</span><br><span class="line">	@Scope(&quot;prototype&quot;) &#x2F;&#x2F;指定该bean的scope</span><br><span class="line">	@Description(&quot;Provides a basic example of a bean&quot;) &#x2F;&#x2F;指定该bean的description</span><br><span class="line">	public UserInterface userInterface()&#123;</span><br><span class="line">		return new UserInterfaceImpl();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	&#x2F;&#x2F;通过参数列表，将bean的依赖注入</span><br><span class="line">	public UserCall userCall(UserInterface userInterface, String username, List&lt;String&gt; tags)&#123;</span><br><span class="line">		UserCall uc &#x3D; new UserCall();</span><br><span class="line">		uc.setUi(userInterface);</span><br><span class="line">		uc.setUsername(username);</span><br><span class="line">		uc.setTags(tags);</span><br><span class="line">		return uc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>配置文件方式</strong><ul>
<li>Spring使用XML文件来管理和保存依赖注入信息，配置组件bean的话只需要使用<code>&lt;bean&gt;</code>标签即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userInterface&quot; class&#x3D;&quot;com.springbean.impl.UserInterfaceImpl&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用构造器注入。使用构造器注入的时候必须在类中存在对应的构造方法才能有效</span><br><span class="line">&lt;util:list id&#x3D;&quot;tagsList&quot;&gt;</span><br><span class="line">	&lt;value&gt;cool&lt;&#x2F;value&gt;</span><br><span class="line">	&lt;value&gt;nice&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;util:list&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;userCall&quot; class&#x3D;&quot;com.springbean.UserCall&quot;&gt;</span><br><span class="line">	&lt;constructor-arg name&#x3D;&quot;ui&quot; ref&#x3D;&quot;userInterface&quot;&#x2F;&gt;</span><br><span class="line">	&lt;constructor-arg name&#x3D;&quot;username&quot; value&#x3D;&quot;test&quot;&#x2F;&gt;</span><br><span class="line">	&lt;constructor-arg name&#x3D;&quot;tags&quot; ref&#x3D;&quot;tagsList&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用属性注入</span><br><span class="line">&lt;bean id&#x3D;&quot;userCall&quot; class&#x3D;&quot;com.springbean.UserCall&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;ui&quot; ref&#x3D;&quot;userInterface&quot; &#x2F;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;test&quot; &#x2F;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;tags&quot; value&#x3D;&quot;tagsList&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>元数据方式（注解）</strong><ul>
<li>spring支持通过注解方式管理依赖，但是需要指定spring扫描注解的包，指定扫描的包有两种方式<ol>
<li>可以在Spring的xml文件中配置（前提是引入了Spring context的命名空间），使用<code>&lt;context:component-scan base-package=&quot;com.springbean.*&quot;/&gt;</code></li>
<li>注解@ComponentScan指定了spring将扫描这个配置类所在的包及其子包下面的所有类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan</span><br><span class="line">public class SpringConfig &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>有了组件扫描后，所有被注解@Component或者它衍生的注解标记类都将被识别为组件类，他们完善了spring通过注解来注册依赖的功能：<ul>
<li>@Component: 自动被comonent扫描。 表示被注解的类会自动被component扫描</li>
<li>@Repository: 用于持久层，主要是数据库存储库。</li>
<li>@Service: 表示被注解的类是位于业务层的业务component。</li>
<li>@Controller:表明被注解的类是控制component，主要用于展现层 。</li>
</ul>
</li>
<li>除此之外，spring使用注解<code>@Autowired</code>等完成依赖装配：<ul>
<li>@Autowired：支持按类型自动转配</li>
<li>@Qualifier：根据byName的方式自动装配，其中@Qualifier不能单独使用。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	@Autowired</span><br><span class="line">	@Qualifier(value&#x3D;&quot;carXXX&quot;)</span><br><span class="line">	private Cat cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>@Resource（这个注解属于J2EE的）：<strong>如果同时指定了name和type</strong>，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常;<strong>如果指定了name</strong>，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常;如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常;<strong>如果既没有指定name，又没有指定type</strong>，则自动按照byName方式(字段名)进行装配；<strong>如果没有匹配</strong>，则回退为一个原始类型进行匹配，如果匹配则自动装配；  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	@Resource</span><br><span class="line">	private Cat cat;</span><br><span class="line">	@Resource(name&#x3D;&quot;dogXXX&quot;)</span><br><span class="line">	private Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="4-Spring的IoC容器"><a href="#4-Spring的IoC容器" class="headerlink" title="4. Spring的IoC容器"></a>4. Spring的IoC容器</h1><p>上文中，我们从浅到深，从思想到概念，了解了DI过程中的一个重要的角色——IoC Service Provider。</p>
<p><strong>IoC Service Provider只是一个概念，不同的框架，对IoC Service Provider的具体的实现也是五花八门，接下来我们了解一个完成度高，重要性高且知名度极高的IoC Service Provider实现产品——Spring IoC容器</strong>。</p>
<p>Spring的IoC容器是一个IoC Service Provider，但不止是一个IoC Service Provider，作为轻量级容器，Spring的IoC容器还提供了IoC之外的支持。如在Spring的IoC容器之上，Spring还提供了相应的AOP框架支持、企业级服务集成等服务。Spring的IoC容器和IoC Service Provider所提供的服务之间存在一定的交集，二者的关系如图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-632d868bd3dc83060bd4dea30a7839f43c3.png" alt=""></p>
<h2 id="4-1-Spring-IoC容器类型"><a href="#4-1-Spring-IoC容器类型" class="headerlink" title="4.1 Spring IoC容器类型"></a>4.1 Spring IoC容器类型</h2><p>Spring提供了两种容器类型：BeanFactory和ApplicationContext。</p>
<ol>
<li><strong>BeanFactory</strong>。<ul>
<li>基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，<strong>默认采用延迟初始化策略（lazy-load）</strong>。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</li>
</ul>
</li>
<li><strong>ApplicationContext</strong>。<ul>
<li>ApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如<strong>事件发布</strong>、<strong>国际化信息支持</strong>等，这些会在后面详述。ApplicationContext所管理的对象，在该类型容器启动之后，<strong>默认全部初始化并绑定完成</strong>。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</li>
</ul>
</li>
</ol>
<blockquote>
<p>ApplicationContext包含BeanFactory的所有功能，<strong>几乎所有的应用系统都选择ApplicationContext而不是BeanFactory</strong>。只有在资源很少的情况下，才会考虑采用BeanFactory，如在移动设备上等。</p>
</blockquote>
<p>通过下图，我们可以对BeanFactory和ApplicationContext之间的关系有一个更清晰的认识：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dfda2270ce6b3b965c4c3f1ffd5420d98c6.png" alt=""></p>
<h3 id="4-1-1-BeanFactory"><a href="#4-1-1-BeanFactory" class="headerlink" title="4.1.1 BeanFactory"></a>4.1.1 BeanFactory</h3><blockquote>
<p>在没有特殊指明的情况下，以BeanFactory为中心所讲述的内容同样适用于ApplicationContext，这一点需要明确一下，二者有差别的地方会在合适的位置给出解释。</p>
</blockquote>
<p>BeanFactory，顾名思义，就是生产Bean的工厂。BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零件送入这个汽车生产厂，最后，只需要从生产线的终点取得成品汽车就可以了。至于业务对象如何组装，你不需要关心。</p>
<p>BeanFactory只是个interface，它核心实现，在DefaultListableBeanFactory实现类中。BeanFactory声明了如下的方法：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7bfb551900305838e32ce2559d6ad2b3c9d.png" alt=""></p>
<p>通过方法名我们也能大概了解每个方法的作用，基本上都是查询相关的方法，例如，取得某个对象的方法（getBean）、查询<br>某个对象是否存在于容器中的方法（containsBean），或者取得某个bean的状态或者类型的方法等。</p>
<p>这些api使得我们可以非常方便的从容器中获取特定类型的bean。那么，BeanFactory如何知道它需要管理和生成哪些bean呢？被托管的bean又是如何注册的呢？后文我们会就bean的注册/绑定/注入做深入介绍。</p>
<h3 id="4-1-2-ApplicationContext"><a href="#4-1-2-ApplicationContext" class="headerlink" title="4.1.2 ApplicationContext"></a>4.1.2 ApplicationContext</h3><p>作为Spring提供的较之BeanFactory更为先进的IoC容器实现，<strong>ApplicationContext是BeanFactory的子类，故而ApplicationContext拥有BeanFactory支持的所有功能</strong>，但除此之外，还进一步扩展了基本容器的功能，如：更易与Spring AOP集成，容器启动后bean实例的自动初始化、国际化的信息支持、容器内事件发布等；</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-def463323553c42f7902c8107e524f8cea7.png" alt=""></p>
<h2 id="4-2-spring-bean和bean定义"><a href="#4-2-spring-bean和bean定义" class="headerlink" title="4.2 spring bean和bean定义"></a>4.2 spring bean和bean定义</h2><p>java bean对我们来说十分熟悉，我们把符合下面四点的java对象叫做java bean。</p>
<ol>
<li>所有属性为private</li>
<li>提供默认构造方法</li>
<li>提供getter和setter</li>
<li>实现serializable接口</li>
</ol>
<h3 id="4-2-1-spring中的bean"><a href="#4-2-1-spring中的bean" class="headerlink" title="4.2.1 spring中的bean"></a>4.2.1 spring中的bean</h3><p>spring中的bean是基于java bean概念的延伸，但为了更好的实现bean的注册/绑定/注入，spring bean的定义显然不能止步于此，为了更好的管理bean，spring在bean上做了许多拓展，不仅对bean本身的属性做纵向拓展，在横向的种类上，也按照不同的职责划分，定义了许多“专业”的，有特点功能的bean。</p>
<blockquote>
<p>注意，特殊的bean也是基于普通bean的拓展，普通bean拥有的特点，特殊bean都有。</p>
</blockquote>
<h4 id="4-2-1-1-普通的spring-bean"><a href="#4-2-1-1-普通的spring-bean" class="headerlink" title="4.2.1.1 普通的spring bean"></a>4.2.1.1 普通的spring bean</h4><p>为了应对许多不同的场景，我们在配置spring bean的Configuration Metadata的时候，需要定义bean的许多属性来达到不同的目的，故而我们有必要了解spring为bean定义了哪些属性可用。</p>
<ol>
<li><p>id属性</p>
<ul>
<li>通常，每个注册到容器的对象都需要一个唯一标志来将其与“同处一室”的“兄弟们”区分开来，就好像我们每一个人都有一个身份证号一样（重号的话就比较麻烦）。通过id属性来指定当前注册对象的beanName是什么。</li>
<li><code>&lt;bean id=&quot;djNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt;</code></li>
</ul>
</li>
<li><p>name属性</p>
<ul>
<li>除了可以使用id来指定<code>&lt;bean&gt;</code>在容器中的标志，还可以使用name属性来指定<code>&lt;bean&gt;</code>的别名（alias）</li>
<li>与id属性相比，name属性的灵活之处在于，name可以使用id不能使用的一些字符，比如/。而且还可以通过逗号、空格或者冒号分割指定多个name。</li>
<li><code>&lt;bean id=&quot;djNewsListener&quot; name=&quot;/news/djNewsListener,dowJonesNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt;</code></li>
</ul>
</li>
<li><p>class属性</p>
<ul>
<li>每个注册到容器的对象都需要通过<code>&lt;bean&gt;</code>元素的class属性指定其类型，否则，容器可不知道这个对象到底是何方神圣。</li>
<li>在大部分情况下，该属性是必须的。仅在少数情况下不需要指定，如后面将提到的在使用抽象配置模板的情况下。</li>
<li><code>&lt;bean id=&quot;djNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt;</code></li>
</ul>
</li>
<li><p>scope属性</p>
<ul>
<li>scope用来声明容器中的对象所应该处的限定场景或者说该对象的存活时间，即容器在对象进入其相应的scope之前，生成并装配这些对象，在该对象不再处于这些scope的限定之后，容器通常会销毁这些对象。</li>
<li>Spring容器最初提供了两种bean的scope类型：singleton和prototype，但发布2.0之后，又引入了另外三种scope类型，即request、session和global session类型。不过这三种类型有所限制，只能在Web应用中使用。</li>
<li><code>&lt;bean id=&quot;mockObject2&quot; class=&quot;...MockBusinessObject&quot; scope=&quot;prototype&quot;/&gt;</code><ol>
<li><strong>singleton</strong>：单例的意思。即标记为拥有singleton scope的对象定义，在Spring的IoC容器中只存在一个实例，所有对该对象的引用将共享这个实例。该实例从容器启动，并因为第一次被请求而初始化之后，将一直存活到容器退出。</li>
<li><strong>prototype</strong>：容器在接到该类型对象的请求的时候，会每次都重新生成一个新的对象实例给请求方。虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不再拥有当前返回对象的引用，请求方需要自己负责当前返回对象的后继生命周期的管理工作，包括该对象的销毁。</li>
<li><strong>request、session和global session</strong>：这三个scope类型是Spirng 2.0之后新增加的，它们不像之前的singleton和prototype那么“通用”，因为它们只适用于Web应用程序，通常是与XmlWebApplicationContext共同使用。三者的作用域顾名思义，分别对应web应用的request、session和global session。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="4-2-1-2-FactoryBean"><a href="#4-2-1-2-FactoryBean" class="headerlink" title="4.2.1.2 FactoryBean"></a>4.2.1.2 FactoryBean</h4><p>FactoryBean是我们接触到的第一个特殊bean，首先它是一个Bean（这表示spring bean的定义它都有），但又不仅仅是一个Bean（它有特殊功能）。<strong>它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式</strong>。它能在需要的时候“改装”一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>
<blockquote>
<p>简而言之，factoryBean是一个bean，一个拥有简单bean工厂职能的bean。</p>
</blockquote>
<p>FactoryBean是一个接口，它只定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个方法最核心的 getObject()方法，其他两个方法都服务于它。</p>
<p>那么FactoryBean有什么作用呢？？</p>
<p>我们知道，在spring Ioc容器中getBean的时候，底层是通过java的反射机制调用bean的构造器来new一个对象返回，如果我希望从容器中返回的对象不是新new出来的对象，而是某个我指定的对象呢？？</p>
<p>比如我们需要从容器中获取一辆车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Car&#123;</span><br><span class="line">	private String color;</span><br><span class="line">	public Car() &#123;</span><br><span class="line">		this.color &#x3D; &quot;黑色&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	...   &#x2F;&#x2F;set&#x2F;get方法省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为反射都是调用无参构造器来new对象，所以我们只能得到一辆黑色的车，那我如果想要一辆白色的车呢？</p>
<p>我们现有的beanFactory只支持生产默认的黑色的车，那为了得到白色的车，我们得拥有指定想要哪台车的能力，如何指定呢？</p>
<p>我们知道，在对象的概念中，A extends B表示的是A是B； A implements B表示的是A有B提供的能力。我们希望我们在提车时可以自己选择自己想要的车，而FactoryBean就提供了这种能力。</p>
<p>Car类实现了FactoryBean，就表示告诉spring IoC：当beanFactory按照Car类的图纸（beanDefinition，下文将详细描述）来生产Car的实例的时候，如果发现我的图纸上有注明要指定我想要的汽车（即实现FactoryBean接口），那么beanFactory就得按照我的要求来生产我制定的汽车。</p>
<p>这时候，我们的“图纸”可以这么定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Car implements FactoryBean&lt;Car&gt;&#123;</span><br><span class="line">	private String color;</span><br><span class="line">	public Car() &#123;</span><br><span class="line">		this.color &#x3D; &quot;黑色&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	...   &#x2F;&#x2F;set&#x2F;get方法省略</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;这座新工厂，要生产白色的车</span><br><span class="line">	@Override</span><br><span class="line">	public Car getObject() throws Exception &#123;</span><br><span class="line">		Car car&#x3D;new Car();</span><br><span class="line">		car.setColor(&quot;白色&quot;);</span><br><span class="line">		return car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		return Car.class;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;表示我要的白车，在全局中单例</span><br><span class="line">	@Override</span><br><span class="line">	public boolean isSingleton() &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候你从容器中取出来的Car类型的实例，都会是白车了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes &#x3D; TestApplication.class)</span><br><span class="line">public class FactoryBeanTest &#123;</span><br><span class="line">	@Autowired</span><br><span class="line">	private ApplicationContext context;</span><br><span class="line">	@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		Car car1 &#x3D; (Car) context.getBean(&quot;car&quot;);</span><br><span class="line">		System.out.println(&quot;car1 &#x3D; &quot; + car1.getColor());</span><br><span class="line">		如果要获取Car非定制的实例，那么需要在名称前面加上&#39;&amp;&#39;符号。</span><br><span class="line">		 Car car2 &#x3D; (Car) context.getBean(&quot;&amp;car&quot;);</span><br><span class="line">		System.out.println(&quot;car2 &#x3D; &quot; + car2.getColor());</span><br><span class="line">		System.out.println(&quot;car1.equals(car2) &#x3D; &quot; + car1.equals(car2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<blockquote>
<p>car1 = 白色<br>car2 = 黑色<br>car1.equals(car2) = false</p>
</blockquote>
<p>说了这么多，为什么要有FactoryBean这个东西呢，有什么具体的作用吗？</p>
<p>其实FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。</p>
<p>我们知道AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的反射机制，在运行时指定了一个定制的代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。</p>
<p>所以，FactoryBean为我们实例化Bean提供了一个更为灵活的方式，我们可以通过FactoryBean创建出更为复杂的Bean实例。</p>
<h3 id="4-2-2-BeanDefinition"><a href="#4-2-2-BeanDefinition" class="headerlink" title="4.2.2 BeanDefinition"></a>4.2.2 BeanDefinition</h3><p>在Java中，一切皆对象。在JDK中使用java.lang.Class来描述类这个对象。</p>
<p>在Spring中，存在bean这样一个概念，那Spring又是怎么抽象bean这个概念，用什么类来描述bean这个对象呢？<strong>Spring使用BeanDefinition来描述bean</strong>。</p>
<p>顾名思义，BeanDefinition就是Spring对bean的定义对象，spring从Configuration Metadata中读取bean的配置，包括它的beanName，是否是单例，具体指向哪个类，是否是懒加载，有哪些依赖等等信息，都存在BeanDefinition对象中，<strong>BeanDefinition就是beanFactory生产bean的图纸</strong>。</p>
<p>将bean定义成BeanDefinition后，spring对bean的操作就可以改为对BeanDefinition进行，比如拿到某个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-607d2dbaeff31870bdaf8d3404790f1302a.png" alt=""></p>
<p>BeanDefinition实现了AttributeAccessor和BeanMetadataElement接口。在Spring中充斥着大量的各种接口，每种接口都拥有不同的能力，某个类实现了某个接口，也就相应的拥有了某种能力:</p>
<ol>
<li>AttributeAccessor：顾名思义，这是一个属性访问者，它提供了对外访问属性的能力。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-1e6fbda257ebbc736e6475307b00b438cd9.png" alt=""></li>
</ul>
</li>
<li>BeanMetadataElement：提供了获取元数据元素的配置源对象的能力。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-81004107878dac4a14374dfc66dd2ac4b44.png" alt=""></li>
</ul>
</li>
</ol>
<p>BeanDefinition的属性和方法如下图所示，大部分方法/属性的作用都能简单从名字区分出来，部分方法的作用，我们下面来简单介绍。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-06c3268fc33840829f3be778fd91baf5fef.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于描述一个具体bean实例</span><br><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line">    &#x2F;&#x2F;scope值，单例</span><br><span class="line">    String SCOPE_SINGLETON &#x3D; ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;scope值，非单例</span><br><span class="line">    String SCOPE_PROTOTYPE &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Bean角色：</span><br><span class="line">    &#x2F;&#x2F;用户</span><br><span class="line">    int ROLE_APPLICATION &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;某些复杂的配置</span><br><span class="line">    int ROLE_SUPPORT &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F;完全内部使用</span><br><span class="line">    int ROLE_INFRASTRUCTURE &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回此bean定义的父bean定义的名称，如果有的话 &lt;bean parent&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String getParentName();</span><br><span class="line">    void setParentName(String parentName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取bean对象className &lt;bean class&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String getBeanClassName();</span><br><span class="line">    void setBeanClassName(String beanClassName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义创建该Bean对象的工厂类  &lt;bean factory-bean&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F;如果该 Bean 采用工厂方法生成，指定工厂名称。</span><br><span class="line">    String getFactoryBeanName();</span><br><span class="line">    void setFactoryBeanName(String factoryBeanName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义创建该Bean对象的工厂方法 &lt;bean factory-method&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String getFactoryMethodName();</span><br><span class="line">    void setFactoryMethodName(String factoryMethodName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&lt;bean scope&#x3D;&quot;singleton&#x2F;prototype&quot;&gt;</span><br><span class="line">    String getScope();</span><br><span class="line">    void setScope(String scope);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;懒加载 &lt;bean lazy-init&#x3D;&quot;true&#x2F;false&quot;&gt;</span><br><span class="line">    boolean isLazyInit();</span><br><span class="line">    void setLazyInit(boolean lazyInit);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;依赖对象  &lt;bean depends-on&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String[] getDependsOn();</span><br><span class="line">    void setDependsOn(String[] dependsOn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否为被自动装配 &lt;bean autowire-candidate&#x3D;&quot;true&#x2F;false&quot;&gt;</span><br><span class="line">    boolean isAutowireCandidate();</span><br><span class="line">    void setAutowireCandidate(boolean autowireCandidate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否为主候选bean    使用注解：@Primary。</span><br><span class="line">    &#x2F;&#x2F;同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span><br><span class="line">    boolean isPrimary();</span><br><span class="line">    void setPrimary(boolean primary);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回此bean的构造函数参数值。</span><br><span class="line">    ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取普通属性集合</span><br><span class="line">    MutablePropertyValues getPropertyValues();</span><br><span class="line">    &#x2F;&#x2F;是否为单例</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">    &#x2F;&#x2F;是否为原型</span><br><span class="line">    boolean isPrototype();</span><br><span class="line">    &#x2F;&#x2F;是否为抽象类</span><br><span class="line">    &#x2F;&#x2F; 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br><span class="line">   &#x2F;&#x2F; 常用于作为 父bean 用于继承，其实也很少用......</span><br><span class="line">    boolean isAbstract();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取这个bean的应用</span><br><span class="line">    int getRole();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回对bean定义的可读描述。</span><br><span class="line">    String getDescription();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回该bean定义来自的资源的描述（用于在出现错误时显示上下文）</span><br><span class="line">    String getResourceDescription();</span><br><span class="line"></span><br><span class="line">    BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinition接口有诸多的实现类，不同的实现类，使用的场景也不尽相同：<br><img src="https://oscimg.oschina.net/oscnet/up-721e187dbcf42aebbc3aca0d339e18062e8.png" alt=""></p>
<ol>
<li>AbstractBeanDefinition，是BeanDefinition的主要实现类，也是所有bean定义的父类。</li>
<li>RootBeanDefinition，是在XML配置时代，注册bean定义时用的类。</li>
<li>ChildBeanDefinition，是在XML配置时代，注册bean定义时用的类，必须在配置时指定一个父bean定义。</li>
<li>GenericBeanDefinition，在注解配置时代，推荐使用的bean定义类，可以在运行时动态指定一个父bean定义，也可以不指定。</li>
<li>AnnotatedGenericBeanDefinition，在注解配置时代，通过编程方式注册bean定义时用的类，继承了GenericBeanDefinition。</li>
<li>ScannedGenericBeanDefinition，在注解配置时代，通过扫描jar包中.class文件的方式注册bean定义时用的类，继承了GenericBeanDefinition。</li>
</ol>
<h2 id="4-3-Spring-IoC容器流程"><a href="#4-3-Spring-IoC容器流程" class="headerlink" title="4.3 Spring IoC容器流程"></a>4.3 Spring IoC容器流程</h2><p>Spring的IoC容器所起的作用，就像下图所展示的那样，它会以某种方式加载Configuration Metadata（通常也就是XML格式的配置信息），然后根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-53938a98292785a01ef1731f32901f4f490.png" alt=""></p>
<p>Spring的IoC容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即容器启动阶段和Bean实例化阶段</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f7c9a513d97f0f4e5abcb2e1f809d42d016.png" alt=""></p>
<h3 id="4-3-1-容器启动阶段"><a href="#4-3-1-容器启动阶段" class="headerlink" title="4.3.1 容器启动阶段"></a>4.3.1 容器启动阶段</h3><ol>
<li><p>容器启动伊始，首先会通过某种途径加载Configuration MetaData。除了代码方式比较直接，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的Configuration MetaData。</p>
</li>
<li><p>对Configuration MetaData进行解析和分析，并将分析后的信息编组为相应的BeanDefinition，最后把这些保存了bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-2c47772c36c20bcf748015c48f8c12fbccb.png" alt=""></p>
<blockquote>
<p>总地来说，该阶段所做的工作可以认为是准备性的，重点更加侧重于对象管理信息的收集。</p>
</blockquote>
<h3 id="4-3-2-Bean实例化阶段"><a href="#4-3-2-Bean实例化阶段" class="headerlink" title="4.3.2 Bean实例化阶段"></a>4.3.2 Bean实例化阶段</h3><p>经过第一阶段，现在所有的bean定义信息都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中。当某个请求方通过容器的getBean方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用getBean方法时，就会触发第二阶段的活动。</p>
<ol>
<li><p>容器会首先检查所请求的对象之前是否已经实例化和初始化。如果没有，则会根据注册的BeanDefinition所提供的信息<strong>实例化</strong>被请求对象，并为其<strong>注入依赖</strong>，然后<strong>初始化</strong>。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。</p>
</li>
<li><p>当该对象装配完毕之后，容器会立即将其返回请求方使用。</p>
</li>
</ol>
<blockquote>
<p>如果说第一阶段只是根据图纸装配生产线的话，那么第二阶段就是使用装配好的生产线来生产具体的产品了</p>
</blockquote>
<blockquote>
<p>注意，我们上面提高的bean的实例化，注入依赖（或者叫依赖装配），初始化，是三个递进的不同阶段，注意区分。</p>
</blockquote>
<h2 id="4-4-spring-bean的生命周期"><a href="#4-4-spring-bean的生命周期" class="headerlink" title="4.4 spring bean的生命周期"></a>4.4 spring bean的生命周期</h2><p>确的了解Spring Bean的生命周期是非常必要的。我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p>
<p>开门见山，我们先直接给出一张总图，然后再分别描述：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-336e2eddd6c632b56f4784f9efa0937cd05.png" alt=""></p>
<p>可以看到，Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p>
<ol>
<li><p>Bean自身的方法：这个包括了Bean本身调用的方法（如构造器，依赖注入的set方法等）和通过配置文件中<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>指定的方法。</p>
</li>
<li><p>Bean级生命周期接口方法：这个包括了Aware接口的相关实现类（如BeanNameAware、BeanFactoryAware）以及InitializingBean、DiposableBean这些接口的方法。</p>
</li>
<li><p>容器级生命周期接口方法：</p>
<ol>
<li><strong>Bean后处理器</strong>接口方法：所有实现了BeanPostProcessor这个接口的实现类，一般称它们为“后处理器”，或者“bean后处理器”。主要作用是对容器中的bean进行后处理，也就是额外的加强。（注意，它的作用对象是它所注册的容器中的所有收管bean）</li>
<li><strong>工厂后处理器</strong>接口方法：所有实现了BeanFactoryPostProcessor这个接口的实现类，一般称它们为“工厂后处理器”，或者“容器后处理器”。主要作用是对IoC容器进行后处理，增强容器功能。（注意，它的作用对象是它所注册的容器的对象）</li>
</ol>
</li>
</ol>
<p>这些类或接口叫做Hook类/接口，这些接口/类的存在，使得Spring Framework具有非常高的扩展性，<strong>使得我们可以在bean的生命周期的关键节点介入，得到一些我们需要的信息，或者做一些对bean的“改装”</strong>。</p>
<p>第一类，Bean自身的方法，这个不再赘述，我们从bean的生命周期中各类的调用顺序，来依次介绍二三类的这些接口方法：</p>
<h3 id="4-4-1-Bean级生命周期接口方法"><a href="#4-4-1-Bean级生命周期接口方法" class="headerlink" title="4.4.1  Bean级生命周期接口方法"></a>4.4.1  Bean级生命周期接口方法</h3><h4 id="4-4-1-1-InitializingBean-DisposableBean接口方法"><a href="#4-4-1-1-InitializingBean-DisposableBean接口方法" class="headerlink" title="4.4.1.1 InitializingBean/DisposableBean接口方法"></a>4.4.1.1 InitializingBean/DisposableBean接口方法</h4><p>InitializingBean和DisposableBean接口十分的简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InitializingBean &#123;</span><br><span class="line">	void afterPropertiesSet() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface DisposableBean &#123;</span><br><span class="line">	void destroy() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能也十分简单：如果想在bean的 创建/销毁 过程中做一些骚操作的话，就实现这两个接口中对应的接口方法，将骚操作逻辑定义在里面。</p>
<p>Spring在创建/销毁bean的过程中，会判断bean是否实现了这二者的接口方法，如果实现了，就在适当的时机调用它。</p>
<p>具体逻辑见AbstractAutowireCapableBeanFactory#initializeBean()和AbstractAutowireCapableBeanFactory#invokeInitMethods()</p>
<h4 id="4-4-1-2-Aware接口方法"><a href="#4-4-1-2-Aware接口方法" class="headerlink" title="4.4.1.2 Aware接口方法"></a>4.4.1.2 Aware接口方法</h4><p>Spring中有很多继承于aware接口的类，如下图，那么这些类到底是做什么用到的呢？？</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ea8fe95bed3c58c5c737e7d70d67fe22138.png" alt=""></p>
<p>有些时候，我们需要在bean的实例化过程中，获取bean的某些信息来做一些工作，这些信息包括bean的beanName，构造这个bean的ApplicationContext，加载这个bean类的beanClassLoader等等。</p>
<p>假设我们有一个Car类，我们希望在bean的初始化过程中能够有机会获取到bean的beanName，以便我们把beanName赋值给carName，让每辆car的carName和beanName一致，那么我们可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements BeanNameAware&#123;  &#x2F;&#x2F;让Car实现BeanNameAware</span><br><span class="line">	private String carName;</span><br><span class="line">	public void setBeanName(String beanName) &#123;</span><br><span class="line">		&#x2F;&#x2F;ID保存BeanName的值</span><br><span class="line">		carName&#x3D;beanName;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们在Configuration MetaData中定义两个Car类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;benchi&quot;  class&#x3D;&quot;balabala.Car&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;baoma&quot;  class&#x3D;&quot;balabala.Car&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;benchi&quot;)</span><br><span class="line">private Car benchi;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;baoma&quot;)</span><br><span class="line">private Car baoma;</span><br></pre></td></tr></table></figure>
<p>那么可以得到结果：<code>benchi.carName=“benchi”，baoma.carName=“baoma”；</code></p>
<p>aware，翻译过来是知道的，已感知的，意识到的，所以，这些接口从字面意思是能感知到所有Aware前缀值的含义。</p>
<p>实际上，这些接口也确实提供了可实现的方法，在bean的实例化过程中，将各个Aware想要获取的信息通过参数的方式传到实现的方法中来，给开发者一个获取到相关信息值的机会。</p>
<p>如上例的<code>Car implements BeanNameAware</code>，BeanNameAware定义的setBeanName(String beanName)方法，就会在实例化过程中把beanName信息传进方法中来让开发者使用，得意于此，我们才能得到beanName，并将其赋值给carName。</p>
<p>至于其他的Aware实现类，他们获取的信息不同，但逻辑也都是一样的。</p>
<ul>
<li><p>BeanNameAware接口是为了让自身Bean能够感知到，获取到自身在Spring容器中的id（也就是beanName）属性。</p>
</li>
<li><p>实现了ApplicationContextAware接口的类，能够获取到ApplicationContext</p>
</li>
<li><p>实现了BeanFactoryAware接口的类，能够获取到BeanFactory对象。</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>在实例化过程中，将相关信息传进接口方法中以供使用，spring怎么做到这一点的呢？？</p>
<p>其实非常简单，bean在初始化前会调用一次ApplicationContextAwareProcessor类的postProcessBeforeInitialization方法，如果bean实现了Aware接口，那么会继续判断bean实现了具体的什么接口，执行对应接口的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">		if (bean instanceof Aware) &#123;</span><br><span class="line">			if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">				((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">				((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">				((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">				((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">				((MessageSourceAware) bean).setMessageSource(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">				((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-容器级生命周期接口方法"><a href="#4-4-2-容器级生命周期接口方法" class="headerlink" title="4.4.2  容器级生命周期接口方法"></a>4.4.2  容器级生命周期接口方法</h3><p>容器级生命周期接口方法主要分为<strong>Bean后处理器</strong>接口方法和<strong>工厂后处理器</strong>接口方法。前者可以对容器中的bean进行增强，后者对容器进行增强，二者我们依次介绍</p>
<h4 id="4-4-2-1-Bean后处理器"><a href="#4-4-2-1-Bean后处理器" class="headerlink" title="4.4.2.1 Bean后处理器"></a>4.4.2.1 Bean后处理器</h4><p><strong>BeanPostProcessor接口是所有Bean后处理器的顶层接口</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;参数：arg1：被增强的bean对象；arg2：被增强的bean对象的id</span><br><span class="line">	@Nullable</span><br><span class="line">	default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;参数：arg1：被增强的bean对象；arg2：被增强的bean对象的id</span><br><span class="line">	@Nullable</span><br><span class="line">	default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，postProcessBeforeInitialization和postProcessAfterInitialization，在接口上就已经有默认实现了，所以其他的Bean后处理器实现类，不一定要重写这两个方法。</p>
</blockquote>
<p>可以看到postProcessBeforeInitialization和postProcessAfterInitialization是一组对称的方法，一个后缀是BeforeInitialization，一个后缀是AfterInitialization。注意，Initialization，初始化的意思，故而一个在初始化前，一个在初始化后。</p>
<p>spring bean的初始化（注意，初始化不是实例化）包含：</p>
<ol>
<li>调用InitializingBean接口的afterPropertiesSet方法（如果有实现的话）。</li>
<li>Configuration Metadata中的init方法，如xml配置的init-method属性指定方法，或@Bean注解注册bean定义时，设置注解initMethod属性指定的方法等。</li>
<li>使用java的注解@PostConstruct，把它标在bean的一个方法上。</li>
</ol>
<p>而postProcessBeforeInitialization和postProcessAfterInitialization方法的调用位置就是：</p>
<p><strong>bean的实例化-&gt; bean的依赖装配 -&gt; BeforeInitialization接口方法（初始化前） -&gt; bean的初始化方法 -&gt; AfterInitialization接口方法（初始化后）</strong></p>
<p>那么bean后处理器如何使用呢？来，我们来自定义一个bean后处理器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyBeanProcessor implements BeanPostProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object arg0, String arg1)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;bean:&quot; + arg1 + &quot; after&quot;);</span><br><span class="line">        return arg0;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object arg0, String arg1)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;bean:&quot; + arg1 + &quot; before&quot;);</span><br><span class="line">        return arg0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring在初始化bean的过程中，会优先初始化那些实现了像BeanPostProcessor这类特殊接口的bean，<strong>如果容器发现初始化的bean实现了BeanPostProcessor 接口，将会将其注册为bean后处理器</strong>。</p>
<p><strong>一经注册，它对它注册的spring容器下的所有bean起作用，任何bean在初始化过程都会通过bean后处理器做额外增强操作</strong>。</p>
<p>作为开发者，我们可以通过实现BeanPostProcessor接口方法，来自定义后处理器类，也可以使用现成，spring为我们准备好的一些后处理器，下面我们简单介绍一些重要的bean后处理器。</p>
<h5 id="4-4-2-1-1-InstantiationAwareBeanPostProcessor"><a href="#4-4-2-1-1-InstantiationAwareBeanPostProcessor" class="headerlink" title="4.4.2.1.1 InstantiationAwareBeanPostProcessor"></a>4.4.2.1.1 InstantiationAwareBeanPostProcessor</h5><p>InstantiationAwareBeanPostProcessor也是一个接口，注意，InstantiationAwareBeanPostProcessor的一对before和after接口方法，不是重写的BeanPostProcessor的postProcessBeforeInitialization和postProcessAfterInitialization。</p>
<p>Instantiation和Initialization，还是不一样的，前者是实例化，后者是初始化，要注意区分。</p>
<p>InstantiationAwareBeanPostProcessor实现BeanPostProcessor接口，更多意义上是为了将自己归类进bean后处理器中，好让容器识别自己的“身份”。它的逻辑载体（即三个方法），都是自实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;注意！！！这个方法是InstantiationAwareBeanPostProcessor自己定义的</span><br><span class="line">	&#x2F;&#x2F;不是重写BeanPostProcessor的postProcessBeforeInitialization，两个方法名很像，但不一样</span><br><span class="line">	&#x2F;&#x2F;在bean实例化前调用，如果返回一个非null对象，则Spring就使用这个对象了，不再进行实例化了。</span><br><span class="line">	&#x2F;&#x2F;所以这里可以返回一个目标bean的代理，来压制（延迟）目标bean的实例化。</span><br><span class="line">	&#x2F;&#x2F;这个方法的参数是bean的类型，因为此时还没有bean实例呢。</span><br><span class="line">	@Nullable</span><br><span class="line">	default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;注意！！！这个方法是InstantiationAwareBeanPostProcessor自己定义的</span><br><span class="line">	&#x2F;&#x2F;不是重写BeanPostProcessor的postProcessAfterInitialization，两个方法名很像，但不一样</span><br><span class="line">	&#x2F;&#x2F;这是一个理想的地方用来执行自定义字段注入，因为此时Spring的自动装配尚未到来。</span><br><span class="line">	&#x2F;&#x2F;通常方法返回true，如果返回false，后续的属性设置将被跳过。</span><br><span class="line">	default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;在bean属性设置前调用，可以用来定制即将为bean实例设置的属性。</span><br><span class="line">	&#x2F;&#x2F;方法pvs是传进来的已有属性。方法默认返回null。表示不对属性进行操作。</span><br><span class="line">	@Nullable</span><br><span class="line">	default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	@Deprecated</span><br><span class="line">	@Nullable</span><br><span class="line">	default PropertyValues postProcessPropertyValues(</span><br><span class="line">			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return pvs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InstantiationAwareBeanPostProcessor的名字中有Instantiation（实例化），说明和BeanPostProcessor只能介入初始化的前后不一样，InstantiationAwareBeanPostProcessor可以介入到bean的实例化的前后，所以它的执行时机是：</p>
<p><strong>bean的实例化准备阶段 -&gt; BeforeInstantiation接口方法（实例化前）-&gt; bean的实例化 -&gt; AfterInstantiation接口方法（实例化后） -&gt; PropertyValues接口方法（定制bean所需的属性值） -&gt; bean的属性设置</strong></p>
<h5 id="4-4-2-1-2-DestructionAwareBeanPostProcessor"><a href="#4-4-2-1-2-DestructionAwareBeanPostProcessor" class="headerlink" title="4.4.2.1.2 DestructionAwareBeanPostProcessor"></a>4.4.2.1.2 DestructionAwareBeanPostProcessor</h5><p>DestructionAwareBeanPostProcessor接口和InstantiationAwareBeanPostProcessor对应，后者负责实例化前后的增强，后者负责销毁前后的增强。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface DestructionAwareBeanPostProcessor extends BeanPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;在bean实例销毁前会被调用，来执行一些定制的销毁代码。</span><br><span class="line">	void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException;</span><br><span class="line">	&#x2F;&#x2F;决定是否要为bean实例调用第一个方法来执行一些销毁代码。返回true表示需要，false表示不需要调用。</span><br><span class="line">	default boolean requiresDestruction(Object bean) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spring bean的销毁包含：</p>
<ol>
<li>调用DisposableBean接口的destroy方法（如果有实现的话）。</li>
<li>Configuration Metadata中的init方法，如xml配置的destroy-method属性指定方法，或@Bean注解注册bean定义时，设置注解destroyMethod属性指定的方法等。</li>
<li>使用java的注解@PreDestroy，把它标在bean的一个方法上。</li>
</ol>
<p>执行时机就在销毁前后，不再细述。</p>
<h5 id="4-4-2-1-3-SmartInstantiationAwareBeanPostProcessor"><a href="#4-4-2-1-3-SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="4.4.2.1.3 SmartInstantiationAwareBeanPostProcessor"></a>4.4.2.1.3 SmartInstantiationAwareBeanPostProcessor</h5><p>占位，知道有这么一个后处理器，可以用来修改bean类型，定制构造方法，还有获取一个早期（初始化还没执行）bean实例的引用，典型的用法是可以用来解决循环引用。</p>
<h5 id="4-4-2-1-4-MergedBeanDefinitionPostProcessor"><a href="#4-4-2-1-4-MergedBeanDefinitionPostProcessor" class="headerlink" title="4.4.2.1.4 MergedBeanDefinitionPostProcessor"></a>4.4.2.1.4 MergedBeanDefinitionPostProcessor</h5><p>占位，知道有这么一个后处理器，这个接口的主要目的不是用来修改合并后的bean定义的，虽然也可以进行一些修改。<br>它主要用来进行一些自省操作，如一些检测，或在处理bean实例之前缓存一些相关的元数据。<br>这些作用都在第一个方法里实现。</p>
<h4 id="4-4-2-2-Bean工厂后处理器"><a href="#4-4-2-2-Bean工厂后处理器" class="headerlink" title="4.4.2.2 Bean工厂后处理器"></a>4.4.2.2 Bean工厂后处理器</h4><p>和Bean后处理器一样，Bean工厂后处理器是一种特殊的Bean，这种Bean并不对外提供服务，它甚至可以无需id属性，它主要负责对容器本身进行某些特殊的处理和增强。</p>
<p>BeanFactoryPostProcessor是所有工厂后处理器的顶层接口，在spring容器实例化bean的逻辑中，spring正是通过<code>instanceof BeanFactoryPostProcessor</code>这一判断语句来确定一个bean是不是工厂后处理器。</p>
<p>如下图所示，spring提供的BeanFactoryPostProcessor实现类有很多，一些常见的功能，我们可以直接选择合适的工厂后处理器来继承或者实现，以免重复造轮子，其中BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor最重要的一个实现类。<br><img src="https://oscimg.oschina.net/oscnet/up-026c8508b80dc53ed001a173d88f0b207f4.png" alt=""></p>
<p>Spring中有两类工厂后处理器，<strong>BeanDefinitionRegistryPostProcessor和其他</strong>。其中其他里面又分为spring源生的，和我们自定义的。</p>
<blockquote>
<p>BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，设计它的目的是为了使用它向容器注册额外的bean的配置信息——BeanDefinition对象。</p>
</blockquote>
<h5 id="4-4-2-2-1-自定义BeanFactoryPostProcessor"><a href="#4-4-2-2-1-自定义BeanFactoryPostProcessor" class="headerlink" title="4.4.2.2.1 自定义BeanFactoryPostProcessor"></a>4.4.2.2.1 自定义BeanFactoryPostProcessor</h5><p>我们把spring提供的源生的Bean工厂后处理器之外的，我们自己通过实现BeanFactoryPostProcessor顶层接口的工厂后处理器称为<strong>普通工厂后处理器，或者自定义BeanFactoryPostProcessor</strong>；</p>
<p>我们先来看下BeanFactoryPostProcessor接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;postProcessBeanFactory方法，它的执行的时机是，所有的bean定义都已经注册完毕，不可能再增多了</span><br><span class="line">	&#x2F;&#x2F;该方法允许去修改bean定义的一些属性。</span><br><span class="line">	&#x2F;&#x2F;它允许覆盖或者设置bean的属性值，甚至是立即实例化bean，比如实例化bean后处理器对象。</span><br><span class="line">	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor能改变bean在实例化之前的一些原配置值，比如Scope，lazy，Primary，DependsOn，Role，Description等等。</p>
<p>比如我们有个单例的bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class Teacher&#123;</span><br><span class="line">	public Teacher()&#123;</span><br><span class="line">		System.out.println(&quot;Construct&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义实现BeanFactoryPostProcessor的处理器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">		BeanDefinition beanDefinition &#x3D; beanFactory.getBeanDefinition(&quot;teacher&quot;);</span><br><span class="line">		beanDefinition.setScope(&quot;prototype&quot;);</span><br><span class="line">		System.out.println(&quot;Scope:&quot;+beanDefinition.getScope());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了对于bean的作用域的变化。</p>
<h5 id="4-4-2-2-2-BeanDefinitionRegistryPostProcessor"><a href="#4-4-2-2-2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="4.4.2.2.2 BeanDefinitionRegistryPostProcessor"></a>4.4.2.2.2 BeanDefinitionRegistryPostProcessor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;bean定义注册后处理器，就是用来向容器中注册bean定义的，造成的结果就是beanDefinition的数目变多。</span><br><span class="line">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;它的接口方法执行的时机是，所有的“常规bean定义”都已注册完毕，该方法允许添加进一步的bean定义注册到容器中。</span><br><span class="line">	void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多说无益，我们来看demo：</p>
<p>首先我们创建一个类并实现BeanDefinitionRegistryPostProcessor接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;</span><br><span class="line">		System.out.println(&quot;TestBeanDefinitionRegistryPostProcessor...postProcessBeanDefinitionRegistry&quot;);</span><br><span class="line">		System.out.println(registry.getBeanDefinitionCount());</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;这里添加一个Dog.class的BeanDefinition进入容器</span><br><span class="line">		&#x2F;&#x2F;RootBeanDefinition beanDefinition &#x3D; new RootBeanDefinition(Dog.class);  作用同下行</span><br><span class="line">		AbstractBeanDefinition beanDefinition &#x3D; BeanDefinitionBuilder.rootBeanDefinition(Dog.class).getBeanDefinition();</span><br><span class="line">		registry.registerBeanDefinition(&quot;dog&quot;,beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">		System.out.println(&quot;TestBeanDefinitionRegistryPostProcessor...postProcessBeanFactory&quot;);</span><br><span class="line">		System.out.println(beanFactory.getBeanDefinitionCount());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就完成了往容器中添加BeanDefinition的操作。</p>
<h5 id="4-4-2-2-3-源生工厂后处理器之ConfigurationClassPostProcessor"><a href="#4-4-2-2-3-源生工厂后处理器之ConfigurationClassPostProcessor" class="headerlink" title="4.4.2.2.3 源生工厂后处理器之ConfigurationClassPostProcessor"></a>4.4.2.2.3 源生工厂后处理器之ConfigurationClassPostProcessor</h5><p>ConfigurationClassPostProcessor是Spring中非常重要的工厂后处理器，它的主要功能是参与BeanFactory的建造，在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。</p>
<p>ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而ConfigurationClassPostProcessor类的作用就是通过这两个方法去实现的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4230db35c74bd0b4acc1f353f7129eab984.png" alt=""></p>
<p>具体代码逻辑，可以见该文：<a href="https://blog.csdn.net/qq_34436819/article/details/100944204" target="_blank" rel="noopener" title="ConfigurationClassPostProcessor源码解析">ConfigurationClassPostProcessor源码解析</a>，介绍的非常的详细。</p>
<pre><code>- </code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/" itemprop="url">JVM学习总结之『一个类的前世今生』</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-07T22:11:44+08:00">
                2020-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA-JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/07/JVM学习总结之『一个类的前世今生』/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  26
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-我乃中山靖王之后"><a href="#1-我乃中山靖王之后" class="headerlink" title="1 我乃中山靖王之后"></a>1 我乃中山靖王之后</h1><p>大家好，我叫李大锤，是一名不入流的演员，我即将参演一部名叫《三国演义》的舞台剧，导演是棺材板按不住的罗贯中老先生。而我，即将扮演三位主角之一的刘皇叔，嘿嘿，想想还有点小激动呢！</p>
<p>按照剧本，我是一名出生低微的屌丝，被嘲笑为“织席贩履”之辈，所以一开始，我长这个B样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，我开局就会收关张两位挂逼做小弟，于是，我变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">	int zhangFei&#x3D;123;&#x2F;&#x2F;张飞</span><br><span class="line">	Object guanYu&#x3D;new Object();&#x2F;&#x2F;关羽 为了嫌麻烦，就不给他们定制特定的类了，就int &amp; Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算了，就不追求麾下武将如云谋士如雨了，人太多写的也累，有二弟和三弟出场就够了。</p>
<p>当然，作为未来的汉昭烈帝，我开局还会一些特殊技能，不亏是主角之一，这技能真是别具一格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void shuaiErZi() &#123;&#x2F;&#x2F;摔儿子</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shouMaiRenXin() &#123;&#x2F;&#x2F;收买人心</span><br><span class="line">	shuaiErZi();</span><br><span class="line">&#125;</span><br><span class="line">public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">	System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">	guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，身残志坚，躺在棺材里还在coding的著名程序员罗贯中先生，已经通过他精湛的代码功底，为我编写了一个详（jian）细（lou）的开局设定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">    int zhangFei&#x3D;123;&#x2F;&#x2F;张飞</span><br><span class="line">    Object guanYu&#x3D;new Object();&#x2F;&#x2F;关羽 为了嫌麻烦，就不给他们定制特定的类了，就int &amp; Object</span><br><span class="line">    public void shuaiErZi() &#123;&#x2F;&#x2F;摔儿子</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shouMaiRenXin() &#123;&#x2F;&#x2F;收买人心</span><br><span class="line">        shuaiErZi();</span><br><span class="line">    &#125;</span><br><span class="line">    public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">        System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">        guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们去为舞台剧做一下准备吧！</p>
<h1 id="2-新手村"><a href="#2-新手村" class="headerlink" title="2 新手村"></a>2 新手村</h1><p>舞台剧开演在即，来，摄影机往前，我们先来俯瞰一下整个会场的布局吧（详细介绍见：<a href="https://cherish-ls.github.io/2019/10/23/JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener" title="JAVA内存结构和内存管理">JAVA内存结构和内存管理</a>）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b6cfe993d5877ce9f6a9bcbe30fa1eb5055.png" alt=""></p>
<p>首先，面积最为广大的，就是我们舞台的后台，我们唤作<strong>堆</strong>，所有有名有幸的三国豪杰们（对象们），都会在后台齐聚，各自准备。</p>
<p>然后，我们可以看到一块巨大的显示屏，我们唤作<strong>方法区</strong>，上面是本剧的台本，上面写着：</p>
<ul>
<li>各个英雄豪杰的设定/经历（类信息）等信息<ul>
<li>刘备会遇到关张，然后还会摔儿子技能（属性，方法）</li>
<li>曹操麾下有曹仁曹纯夏侯兄弟等挂逼，还有好人妻这个技能。（属性，方法）</li>
<li>….</li>
</ul>
</li>
<li>一些人尽皆知的信息（常量）<ul>
<li>比如现在是东汉末年，嗯，比如东汉末年是个常量。</li>
<li>…</li>
</ul>
</li>
<li>某位英雄广为人知的设定（类的静态变量）。<ul>
<li>刘备：说织席贩履的给老子滚出来啊魂淡！！</li>
<li>曹操：梦中杀伦什么的，我真不是故意的。</li>
<li>孙权：就不能不提合肥，不提孙十万吗。。</li>
</ul>
</li>
</ul>
<p>舞台之上，我们看到了有三束聚光灯各自照亮舞台一隅，这是以我们三位主角曹孙刘为视角的三个<strong>线程</strong>，然后被聚光灯照亮的三块方寸之地，主要是<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，还有一个小的牌子，叫做<strong>程序计数器</strong>，用来标记此间主角演到剧情的何处了。</p>
<h1 id="3-英雄要问出身"><a href="#3-英雄要问出身" class="headerlink" title="3 英雄要问出身"></a>3 英雄要问出身</h1><p>逛完了舞台以后，我得去看看我的台本，虽然我在接戏之前已经知道了罗贯中老先生为我量身定做的草稿：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">    int zhangFei&#x3D;123;&#x2F;&#x2F;张飞</span><br><span class="line">    Object guanYu&#x3D;new Object();&#x2F;&#x2F;关羽 为了嫌麻烦，就不给他们定制特定的类了，就int &amp; Object</span><br><span class="line">    public void shuaiErZi() &#123;&#x2F;&#x2F;摔儿子</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shouMaiRenXin() &#123;&#x2F;&#x2F;收买人心</span><br><span class="line">        shuaiErZi();</span><br><span class="line">    &#125;</span><br><span class="line">    public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">        System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">        guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但草稿只是草稿，正经的舞台剧，肯定不能用这么简陋的东西来演出，不说别的，看草稿我只知道我有关张两个小弟，但演出时，我至少得知道关张是谁来演，我到底和谁撘对手戏吧？是胡歌还是霍建华？</p>
<p>所以，还需要把草稿再加工，变成真正的台本，这个过程，叫做<strong>编译</strong>，这时，java文件会编译成class文件。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4ba7398c95ae3265cf9332d9761b6160b9a.png" alt=""></p>
<p>class文件的内容我们不再赘述，详情在<a href="https://cherish-ls.github.io/2019/12/03/Class%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener" title="JAVA Class文件和类加载机制">JAVA Class文件和类加载机制</a>一文中可见。我们只要记得几个核心要素：</p>
<ul>
<li><p>类型信息包含魔数，主次版本号等。</p>
</li>
<li><p>常量池里面存放着字面量和符号引用。</p>
<ul>
<li>常量池中每一项常量都是一个表，在JDK1.7之后共有14种表结构，这14种常量类型各自有自己的结构，下面列出每个常量项的结构及含义</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-49edc6b667c3b7b848c539852736ab72b9c.png" alt=""></li>
<li>字面量可以理解为就是字符文本，class文件中的其他信息要用到字符文本的时候，都是“引用”他，比如字段表中，刘备有关羽这个小弟，那“关羽”这个名字的文本就存放于常量池中。</li>
<li>符号引用包含下面三类：<ul>
<li>全限定名：就是类名全称,例如:org/xxx/class/testClass</li>
<li>简单名称：即没有类型和参数修饰的字段或者方法名称，例如方法test()的简单名称就是test，m字段的简单名称就是m。</li>
<li>描述符：描述符的作用是描述字段的数据类型、方法的参数列表（包括数量、类型及顺序）和返回值。根据描述符的规则，基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名表示<ul>
<li>如“viod main(String[] args)” 的描述符为“([Ljava/lang/String;)V</li>
<li>如“String[][]”,会被记录为”[[Ljava/lang/String”</li>
<li>“int[]”被记录为“[I”。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字段表集合，记录这个类的字段信息，比如我们刘备拥有关张两个小弟做对象，</p>
<ul>
<li>这里我们会记录关张的字段名称，如关羽的名称的值就是常量池中“关羽”常量的引用</li>
<li>记录描述符（descriptor_index中记录），描述这个字段的类型，我们这里是Object类型，那么这个值就是指向常量池中的“Ljava/lang/Object”常量的引用。</li>
<li>以及各种修饰符：类似于：汉寿亭侯·美髯公·武圣·刮骨疗法临床实验者·季汉扛把子·关羽=public transient volatile Object guanYu。</li>
</ul>
</li>
<li><p>方法表集合，记录这个类的方法信息，比如我们刘备拥有摔儿子和收买人心方法。</p>
<ul>
<li>这里我们会记录方法的名称，同样引用常量池。</li>
<li>记录描述符（descriptor_index中记录），描述这个方法的描述符，我们这里是void shuaiErZi()，那么这个值就是指向常量池中的“()V”常量的引用。（注意这里的V是指void，描述符不包括方法名称）</li>
<li>以及各种修饰符：类似于：作用全场的·效果拔群的·刘备角色固有的·摔儿子=public volatile static shuaiErZi</li>
<li>方法体里面有代码的，都会有一个code属性（引用属性表集合），里面有摔儿子说明文本长度（属性长度），操作数栈最大深度等，还有摔儿子的具体操作步骤（代码的字节码指令）。</li>
</ul>
</li>
</ul>
<p>来，我们使用javap工具</p>
<p><code>javap -c -v -p -l -constants /home/lisheng/IdeaProjects/learning/out/production/learning/com/company/LiuBei.class</code></p>
<p>将public class LiuBei的class文件反解析出来，如下，这就是刘备这个角色经过编译后的舞台剧脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;home&#x2F;lisheng&#x2F;IdeaProjects&#x2F;learning&#x2F;out&#x2F;production&#x2F;learning&#x2F;com&#x2F;company&#x2F;LiuBei.class</span><br><span class="line">  Last modified 2019-12-10; size 1018 bytes</span><br><span class="line">  MD5 checksum 7133ac0c7e83a62e1081db1945bc6cf9</span><br><span class="line">  Compiled from &quot;LiuBei.java&quot;</span><br><span class="line">public class com.company.LiuBei</span><br><span class="line">  minor version: 0 &#x2F;&#x2F;次版本</span><br><span class="line">  major version: 52 &#x2F;&#x2F;主版本</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER &#x2F;&#x2F;LiuBei类的修饰符</span><br><span class="line">Constant pool: &#x2F;&#x2F;类的常量池</span><br><span class="line">   #1 &#x3D; Methodref          #3.#32         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V </span><br><span class="line">   &#x2F;&#x2F;#1表示常量池index，此处是一个Methodref类型的常量。</span><br><span class="line">   &#x2F;&#x2F;《JAVA Class文件和类加载机制》一文我们知道Methodref类型内有两个index字段，又引用了两个常量。分别表示方法所属类全限定名，以及方法描述符。</span><br><span class="line">   &#x2F;&#x2F;所以#3.#32 即为#1 &#x3D; Methodref引用了index&#x3D;3和index&#x3D;32的常量。</span><br><span class="line">   &#x2F;&#x2F;我们知道#3是Class类型，引用了#34&#x3D; java&#x2F;lang&#x2F;Object，所以其实#3就是 java&#x2F;lang&#x2F;Object的类常量。这表示#1代表的方法是 java&#x2F;lang&#x2F;Object类的方法。</span><br><span class="line">   &#x2F;&#x2F;我们知道#32是NameAndType类型常量，又引用了 #20&#x3D;&lt;init&gt;，#21&#x3D;()V，合起来就是#32存储了#1代表的方法的方法描述符。</span><br><span class="line">&#x2F;&#x2F;如此，我们得到了一个完整的Methodref，其内容记录了方法所在类的全限定名以及方法描述符。</span><br><span class="line">&#x2F;&#x2F;下面以此类推，不再赘述</span><br><span class="line"></span><br><span class="line">   #2 &#x3D; Fieldref           #15.#33        &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei.zhangFei:I</span><br><span class="line">   #3 &#x3D; Class              #34            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #4 &#x3D; Fieldref           #15.#35        &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei.guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">   #5 &#x3D; Methodref          #15.#36        &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei.shuaiErZi:()V</span><br><span class="line">   #6 &#x3D; Fieldref           #37.#38        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #7 &#x3D; Class              #39            &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">   #8 &#x3D; Methodref          #7.#32         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 &#x3D; Methodref          #7.#40         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #10 &#x3D; String             #41            &#x2F;&#x2F;</span><br><span class="line">  #11 &#x3D; Methodref          #7.#42         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #12 &#x3D; Methodref          #7.#43         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #13 &#x3D; Methodref          #44.#45        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #14 &#x3D; Methodref          #3.#43         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #15 &#x3D; Class              #46            &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei</span><br><span class="line">  #16 &#x3D; Utf8               zhangFei</span><br><span class="line">  #17 &#x3D; Utf8               I</span><br><span class="line">  #18 &#x3D; Utf8               guanYu</span><br><span class="line">  #19 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">  #20 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">  #21 &#x3D; Utf8               ()V</span><br><span class="line">  #22 &#x3D; Utf8               Code</span><br><span class="line">  #23 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #24 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #25 &#x3D; Utf8               this</span><br><span class="line">  #26 &#x3D; Utf8               Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line">  #27 &#x3D; Utf8               shuaiErZi</span><br><span class="line">  #28 &#x3D; Utf8               shouMaiRenXin</span><br><span class="line">  #29 &#x3D; Utf8               geiWoShang</span><br><span class="line">  #30 &#x3D; Utf8               SourceFile</span><br><span class="line">  #31 &#x3D; Utf8               LiuBei.java</span><br><span class="line">  #32 &#x3D; NameAndType        #20:#21        &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #33 &#x3D; NameAndType        #16:#17        &#x2F;&#x2F; zhangFei:I</span><br><span class="line">  #34 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #35 &#x3D; NameAndType        #18:#19        &#x2F;&#x2F; guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">  #36 &#x3D; NameAndType        #27:#21        &#x2F;&#x2F; shuaiErZi:()V</span><br><span class="line">  #37 &#x3D; Class              #47            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #38 &#x3D; NameAndType        #48:#49        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #39 &#x3D; Utf8               java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">  #40 &#x3D; NameAndType        #50:#51        &#x2F;&#x2F; append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #41 &#x3D; Utf8</span><br><span class="line">  #42 &#x3D; NameAndType        #50:#52        &#x2F;&#x2F; append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #43 &#x3D; NameAndType        #53:#54        &#x2F;&#x2F; toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #44 &#x3D; Class              #55            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #45 &#x3D; NameAndType        #56:#57        &#x2F;&#x2F; printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #46 &#x3D; Utf8               com&#x2F;company&#x2F;LiuBei</span><br><span class="line">  #47 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #48 &#x3D; Utf8               out</span><br><span class="line">  #49 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #50 &#x3D; Utf8               append</span><br><span class="line">  #51 &#x3D; Utf8               (I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #52 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #53 &#x3D; Utf8               toString</span><br><span class="line">  #54 &#x3D; Utf8               ()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #55 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #56 &#x3D; Utf8               printf</span><br><span class="line">  #57 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">&#123;</span><br><span class="line">  int zhangFei;&#x2F;&#x2F;字段表，张飞这个字段，name_index指向的是常量池的#16&#x3D;zhangFei</span><br><span class="line">    descriptor: I&#x2F;&#x2F;descriptor_index指向的是常量池的#17&#x3D;I，表示类型是int</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  java.lang.Object guanYu;&#x2F;&#x2F;字段表，关羽这个字段，name_index指向的是常量池的#18&#x3D;guanYu</span><br><span class="line">    descriptor: Ljava&#x2F;lang&#x2F;Object;&#x2F;&#x2F;descriptor_index指向的是常量池的  #19&#x3D;Ljava&#x2F;lang&#x2F;Object;，表示类型是object类</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  public com.company.LiuBei();&#x2F;&#x2F;这里开始是方法表，LiuBei()是LiuBei类的默认构造器。name_index指向常量池LiuBei字面量。</span><br><span class="line">    descriptor: ()V&#x2F;&#x2F;descriptor_index指向常量池的#21 &#x3D; Utf8               ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:&#x2F;&#x2F;code属性，存储着构造器的字节码指令</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1&#x2F;&#x2F;</span><br><span class="line">         0: aload_0 </span><br><span class="line">		 &#x2F;&#x2F;从本地变量表中加载索引为0的变量的值，也即this的引用，压入栈</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">		 &#x2F;&#x2F;出栈，invokespecial表示调用方法，调用哪个方法呢，调用#1代表的java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V 方法初始化对象，就是this指定的对象的init()方法完成初始化</span><br><span class="line">         4: aload_0</span><br><span class="line">		 &#x2F;&#x2F;再一次从本地变量表中加载索引为0的变量的值，也即this的引用，压入栈</span><br><span class="line">         5: bipush        123</span><br><span class="line">		 &#x2F;&#x2F;将123常量压入栈，当int取值-128~127时,JVM采用bipush指令将常量压入操作数栈中。</span><br><span class="line">         7: putfield      #2                  &#x2F;&#x2F; Field zhangFei:I</span><br><span class="line">		 &#x2F;&#x2F; 将123赋值给zhangFei</span><br><span class="line">		 &#x2F;&#x2F;下面同理，new一个Object对象，再执行Object的&lt;init&gt;方法，然后赋值给guanyu，返回。</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: new           #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">        14: dup</span><br><span class="line">        15: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        18: putfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">        21: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">	  &#x2F;&#x2F;指令与代码行数的偏移对应关系，每一行第一个数字对应代码行数，第二个数字对应前面code中指令前面的数字</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 4</span><br><span class="line">        line 5: 10</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">	  &#x2F;&#x2F;局部变量表，start+length表示这个变量在字节码中的生命周期起始和结束的偏移位置</span><br><span class="line">	  &#x2F;&#x2F;slot就是这个变量在局部变量表中的槽位（槽位可复用），name就是变量名称，Signatur局部变量类型描述</span><br><span class="line"></span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      22     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line">&#x2F;&#x2F;下面同理，不再赘述</span><br><span class="line">  public void shuaiErZi();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;0, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       1     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line"></span><br><span class="line">  public void shouMaiRenXin();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokevirtual #5                  &#x2F;&#x2F; Method shuaiErZi:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line"></span><br><span class="line">  public void geiWoShang();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #6                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: new           #7                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: getfield      #2                  &#x2F;&#x2F; Field zhangFei:I</span><br><span class="line">        14: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        17: ldc           #10                 &#x2F;&#x2F; String</span><br><span class="line">        19: invokevirtual #11                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        22: invokevirtual #12                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        25: iconst_0</span><br><span class="line">        26: anewarray     #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">        29: invokevirtual #13                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        32: pop</span><br><span class="line">        33: aload_0</span><br><span class="line">        34: getfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">        37: invokevirtual #14                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        40: pop</span><br><span class="line">        41: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 14: 33</span><br><span class="line">        line 15: 41</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      42     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;LiuBei.java&quot;</span><br></pre></td></tr></table></figure>

<p>看完了上面的反解析内容，我们要明白：方法表和常量池里面Methodref的区别：</p>
<ul>
<li>前者包含包括代码在内的全部方法信息，而后者充其量翻译出来，只包含了方法名+方法描述符+所在类限定名。</li>
<li>Methodref顾名思义，只是一个引用，是作为字节码的参数而存在的，如<code>invokespecial #1</code>，#1就是一个Methodref。<ul>
<li>所以我们可以看到常量池中存在Methodref=com/company/LiuBei.shuaiErZi:()V，却不存在Methodref=com/company/LiuBei.shouMaiRenXin:()V，因为shouMaiRenXin方法在刘备类的代码中没有被调用，所以它不需要一个包含它基本信息的Methodref</li>
</ul>
</li>
<li>再通俗一点比喻，刘备有技能收买人心，而收买人心技能的发动步骤中包含“大声喊出’摔儿子’三个字，同时发动自己的摔儿子技能”，所以刘备需要像记口诀一样记住“摔儿子”这三个字（即需要在常量池里有这个ref），而因为自己根本不会有喊出“收买人心”四个字的机会，所以常量池里没有必要有“收买人心”的ref。</li>
</ul>
<h1 id="4-争天下也要排练"><a href="#4-争天下也要排练" class="headerlink" title="4 争天下也要排练"></a>4 争天下也要排练</h1><p>上面终于搞懂了我们的台本（类信息）的内容，我也终于理解了罗贯中老导演写的代码到底是什么意思了。舞台剧快开始了，大家赶紧排练（类加载）吧。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>排练的第一步，我们每个演员总得拿到我们各自的台本（类信息）吧？</p>
<p>加载的过程，就是将台本纸稿（class文件）的内容导入到<strong>方法区</strong>大屏幕上的过程，这样我们每个人在排练的时候就可以像看提词器一样，偷瞄我们的设定。</p>
<p> 通过一个台本（类）的名称（全限定名），将所有需要的台本文稿（class文件）内容导入到大屏幕，可以使用的导入方式有：</p>
<ul>
<li>目前可以从zip包获取，即jar，ear，war格式的基础。</li>
<li>从网络获取，即applet实现。</li>
<li>运行时计算生成，典型如动态代理。</li>
<li>由其他文件生成，典型如JSP应用，即为JSP文件生成的class类。</li>
<li>从数据库中读取，这种较少见。</li>
</ul>
<blockquote>
<p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。并没有明确存放于要在堆中，实际上它虽然是对象，但是HotSpot虚拟机仍将其存放在方法区中。</p>
</blockquote>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是为了确保台本信息符合这个舞台剧的需求（确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全），一场三国的舞台剧，你不可以乱入一个李逵吧！</p>
<p>验证会检查格式，规范，引用的验证。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>方法区</strong>大屏幕上已经显示出我们导入的台本内容了，我们可以看到上面写着刘备的一些信息，假设他有个“织席贩履”的设定（类变量），即 static String sheDing=“织席贩履”。那么我们要把这四个字摆到显眼的地方去，因为他是人尽皆知的设定（类变量），表演中被引用到的概率还是很高的。（实例变量不会在此时分配内存）</p>
<p>所以在<strong>方法区</strong>大屏幕找一个地方（分配内存），但是注意，只是留了一块空间给它，但是还没有将“织席贩履<br>四个字给写上去，所以它还只是初始值。</p>
<p>基本数据类型的初始值有这些</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7830ff0655c4438bf1d68d3ef786f834dcd.png" alt=""></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>我们之前介绍过，在台本里面存储的很多都是符号引用（全限定名，简单名称，描述符），比如我们只知道张飞和关羽这两个人的名字，类型而已，并不知道具体对应到哪一个演员。</p>
<p>解析就是将台本上的符号引用，跟真正的演员对应起来的过程。（虚拟机将常量池内的符号引用替换为直接引用的过程）</p>
<p>我们来分析一下刘备的解析过程：</p>
<p>首先，类加载器加载LiuBei这个类的信息。</p>
<p>然后，我们根据台本，知道刘备有“给我上”这个技能（真实解析顺序并非如此，但这里只是示例，逻辑是相通的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">		System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">		guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>geiWoShang方法的完整信息，存在方法表集合中（记录了各种修饰符，字段类型，和字段名称，以及各种属性）。</p>
<blockquote>
<p>我们看上文的反编译信息可以看到，常量池中存在shuaiErZi方法的Methodref，那么同样是刘备的方法，为什么常量池中没有geiWoShang方法的Methodref呢？我们要记住，只有作为字节码参数的目标（方法，或者字段），才有必要在常量池中放置他们的引用。shuaiErZi方法被shouMaiRenXin方法引用，所以有shuaiErZi方法的Methodref。</p>
</blockquote>
<p>方法表长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void geiWoShang();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #6                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: new           #7                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: getfield      #2                  &#x2F;&#x2F; Field zhangFei:I</span><br><span class="line">        14: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        17: ldc           #10                 &#x2F;&#x2F; String</span><br><span class="line">        19: invokevirtual #11                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        22: invokevirtual #12                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        25: iconst_0</span><br><span class="line">        26: anewarray     #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">        29: invokevirtual #13                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        32: pop</span><br><span class="line">        33: aload_0</span><br><span class="line">        34: getfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">        37: invokevirtual #14                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        40: pop</span><br><span class="line">        41: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 14: 33</span><br><span class="line">        line 15: 41</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      42     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br></pre></td></tr></table></figure>

<p>其中有一个属性叫做code，里面的内容就是方法体代码的字节码，它长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line">33: aload_0</span><br><span class="line">34: getfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">37: invokevirtual #14                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">40: pop</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>是的，我们忽略其他，只看调用了<code>guanYu.toString();</code>来作为例子。</p>
<p><code>getfield      #4</code>表示将常量池第四项压入栈。好，常量池第4项还没被解析，那么我们要向解析geiWoShang方法的code，就得先解析常量池第四项。</p>
<p>常量池第四项是啥呢，是个Fieldref，对，是关羽这个字段的Fieldref。</p>
<p>结构抽象后大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Fieldref&#123;</span><br><span class="line">	Class&#123;</span><br><span class="line">		index&#x3D;&quot;com&#x2F;company&#x2F;LiuBei&quot;;index指向的是常量池的  #15&#x3D;com&#x2F;company&#x2F;LiuBei;，表示关羽字段是属于LiuBei类的字段。</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameAndType&#123;</span><br><span class="line">		name_index&#x3D;&quot;guanYu&quot;;&#x2F;&#x2F;字段表，关羽这个字段，指向的是常量池的#18&#x3D;guanYu</span><br><span class="line">		descriptor_index&#x3D;&quot;Ljava&#x2F;lang&#x2F;Object&quot;;&#x2F;&#x2F;descriptor_index指向的是常量池的  #19&#x3D;Ljava&#x2F;lang&#x2F;Object;，表示关羽字段的类型是object类</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析字段，前提是它所属的类要被加载，我们根据Fieldref的Class_info知道他所属的类是LiuBei，这个已经加载过了，那忽略。（否则，就进入了别的类的加载过程，即用刘备类的加载器区加载别的类。）</p>
<p>然后根据Fieldref的name_index和descriptor_index得到该字段的名称和描述符，去所属类LiuBei的字段表中寻找名称和描述符完全一致的字段。好，找到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object guanYu;&#x2F;&#x2F;字段表，关羽这个字段，name_index指向的是常量池的#18&#x3D;guanYu</span><br><span class="line">  descriptor: Ljava&#x2F;lang&#x2F;Object;&#x2F;&#x2F;descriptor_index指向的是常量池的  #19&#x3D;Ljava&#x2F;lang&#x2F;Object;，表示类型是object类</span><br><span class="line">  flags:</span><br></pre></td></tr></table></figure>

<p><strong>那么把关羽这个字段表在刘备类中的偏移量当做直接引用，覆盖常量池的第四项，即#4=关羽这个字段表在刘备类中的偏移量</strong>，关羽字段解析完毕，做个标记，解析完成。</p>
<p>这样下次执行<code>getfield      #4</code>时，#4直接指向了关羽字段表的直接引用。</p>
<p>同理，我们接下来解析<code>invokevirtual #14</code>，表示调用#14指向的示例方法。</p>
<p>常量池中#14 = Methodref长这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Methodref&#123;</span><br><span class="line">	Class&#123;</span><br><span class="line">		index&#x3D;&quot;java&#x2F;lang&#x2F;Object&quot;;index指向的是常量池的  #3&#x3D;java&#x2F;lang&#x2F;Object;，表示该方法是Object的方法。</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameAndType&#123;</span><br><span class="line">		name_index&#x3D;&quot; toString&quot;;&#x2F;&#x2F;指向的是常量池的#53&#x3D;toString，表示名称</span><br><span class="line">		descriptor_index&#x3D;&quot;()Ljava&#x2F;lang&#x2F;String&quot;;&#x2F;&#x2F;descriptor_index指向的是常量池的  #54&#x3D;()Ljava&#x2F;lang&#x2F;String;，表示方法描述符</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，先解析所属的Object类，哦，也加载过了。</p>
<p>那么根据名称和描述符，去Object类的方法表中找到toString方法的偏移量，然后赋值给常量池第十四项。</p>
<p>以此类推，完成所有类的符号引用向直接引用的转变。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。<strong>给类变量赋初值</strong>，此时“织席贩履”可以赋值在之前留出的空间上了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/" itemprop="url">理解sql中的group by和having</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-06T22:22:26+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/" itemprop="url" rel="index">
                    <span itemprop="name">SQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/06/理解sql中的group-by和having/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>group by的可以帮助我们在特定场景下查询到我们需要的数据，但group by的用法一直给人一种“飘忽”感，究其原因，还是对于该关键字缺乏深入理解。</p>
<p>下面通过一个例子，来简单解释group by的原理。</p>
<h1 id="1-GROUP-BY"><a href="#1-GROUP-BY" class="headerlink" title="1. GROUP BY"></a>1. GROUP BY</h1><p>假设我们有表1，表名为test：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f560d6cf443d0db4819d8937d7578ea7c68.png" alt=""></p>
<p>如果我们执行如下SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM test GROUP BY name</span><br></pre></td></tr></table></figure>

<p>我们很容易可以得到运行的结果：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9551ddc4e56b11de88135ebbd526595cc93.png" alt=""></p>
<p>为了能够更好的理解“group by”多个列“和”聚合函数“的应用，这里可以在表1到表2的过程中，引入一个虚构的中间表：虚拟表3。</p>
<p>FROM test Group BY name：该句执行后，我们想象生成了虚拟表3，如下所图所示：</p>
<p>生成过程是这样的：group by name，那么找name那一列，具有相同name值的行，合并成一行，如对于name值为aa的，那么&lt;1 aa 2&gt;与&lt;2 aa 3&gt;两行合并成1行，所有的id值和number值写到一个单元格里面。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-edcd036013105bd3619a93114d35d78963c.png" alt=""></p>
<p>接下来再针对虚拟表3执行Select语句：</p>
<ol>
<li><p>如果执行<code>select *</code>的话，那么返回的结果应该是虚拟表3，可是id和number中有的单元格里面的内容是多个值的，而关系数据库就是基于关系的，单元格中是不允许有多个值的，所以，执行<code>select *</code> 语句是不允许的。</p>
<ul>
<li><blockquote>
<p>为了约束使用者在编写group by时select多值字段，设计DBMS的开发者也是伤透了脑筋。开发者并不知道将来这个数据库会被用来做什么，所以，他不可能从逻辑上来检查你的select上出现的语句是不是分组属性的一个子集。所以，最简单的方法就是看你的select上出现的属性在group by上出现过。出现过，就通过编译，否则不会。</p>
</blockquote>
</li>
<li><blockquote>
<p>mysql对group by 进行了非ANSI标准的扩展，允许select后含有非group by 的列。所以在mysql中，group by时执行<code>select *</code>不会报错 ，但也得不到我们想要的数据，只会select出原表中的第一个数据</p>
</blockquote>
</li>
</ul>
</li>
<li><p>我们再看name列，每个单元格只有一个数据，所以我们select name的话，就没有问题了。为什么name列每个单元格只有一个值呢，因为我们就是用name列来group by的。</p>
</li>
<li><p>那么对于id和number里面的单元格有多个数据的情况怎么办呢？答案就是用聚合函数，聚合函数就用来输入多个数据，输出一个数据的。如cout(id)，sum(number)，而每个聚合函数的输入就是每一个多数据的单元格。</p>
<ul>
<li>例如我们执行select name,sum(number) from test group by name，那么sum就对虚拟表3的number列的每个单元格进行sum操作，例如对name为aa的那一行的number列执行sum操作，即2+3，返回5，最后执行结果如下：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-3f894207fcec5efe321e2b909f0792ae5f8.png" alt=""></li>
</ul>
</li>
<li><p>group by 多个字段该怎么理解呢：如group by name,number，我们可以把name和number 看成一个整体字段，以他们整体来进行分组的。如下图</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-1489c508db4ee297aa099d9397969eb9e95.png" alt=""></li>
<li>接下来就可以配合select和聚合函数进行操作了。如执行select name,sum(id) from test group by name,number，结果如下图：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-6a3e63a11874a6f61681dcc8e09acd69bf2.png" alt="">- </li>
</ul>
</li>
</ol>
<h1 id="2-HAVING"><a href="#2-HAVING" class="headerlink" title="2. HAVING"></a>2. HAVING</h1><blockquote>
<p><strong>首先，不要错误的认为having必须和group by 配合使用。其实having可以单独使用</strong></p>
</blockquote>
<p>having关键字在我们的印象中，貌似和where关键字十分相似，那二者有什么区别呢？</p>
<ol>
<li>含义：<ul>
<li>“Where”是一个约束声明，在查询数据库的结果返回结果之前对数据库中的查询条件进行约束，<strong>即在结果返回之前起作用</strong>，且where后面不能使用“聚合函数”；<ul>
<li>where后面之所以不能使用聚合函数是因为where的执行顺序在聚合函数之前，所以在执行where的时候，还没有结果集，更别说对结果集做聚合了。</li>
</ul>
</li>
<li>Having”是一个过滤声明，所谓过滤是在查询数据库的结果返回之后进行过滤，<strong>即在结果返回之后起作用</strong>，并且having后面可以使用“聚合函数”。<ul>
<li>having既然是对查出来的结果进行过滤，那么就不能对没有select出来的字段使用having，如<code>select  id , name from student having score &gt;90;</code>这句话就是错误的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>where和having，一个是起作用在结果返回前，用来过滤记录；一个是起作用在结果返回后，用来过滤结果。这种场景的典型应用如这句：<code>SELECT region,count(school) FROM T02_Bejing_school WHERE region IN (&#39;海淀&#39; , &#39;西城&#39; , &#39;东城&#39;) GROUP BY region HAVING count(school) &gt; 10;</code>该句sql可以筛选出北京西城、东城、海淀三个区中学校数量超过10所的区及各区学校数量。即先用where把这三个区的中学过滤出来，然后对结果集做group by，得到一张组合后的虚拟表，最后通过having对虚拟表做二次过滤。</p>
</blockquote>
<ol start="2">
<li>使用的场景：<ul>
<li>只有WHERE可以使用的场景：<ul>
<li>除select外，where还可以用于update、delete和insert into values(select * from table where ..)语句中，having则不行。</li>
<li>select语句中，没有select出要被约束的字段的时候，也不可以使用having。就如上文提到的非法语句：<code>select  id , name from student having score &gt;90;</code></li>
</ul>
</li>
<li>只有HAVING可以使用的场景：<ul>
<li>如果要过滤的字段是原生表中不存在的字段，而是经过聚合函数计算后的字段，那么不可以使用where，只能用having。如：<ul>
<li>合法语句：<code>select id , avg(price) as ag from goods group by category having ag &gt; 1000</code><ul>
<li>非法语句：<code>select id , avg(price) as ag from goods where ag group by category &gt; 1000</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>二者都可以使用的场景：<ul>
<li>要约束的字段既是原生表的字段，又是sql中被select出来的字段，这时候where和having等效：<ul>
<li><code>select price , name from goods where price &gt; 100</code></li>
<li><code>select price , name from goods having price &gt; 100</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blog.csdn.net/hao1066821456/article/details/69556644" target="_blank" rel="noopener" title="理解group by">理解group by</a></li>
<li><a href="https://blog.csdn.net/suliangkuanjiayou/article/details/94337233" target="_blank" rel="noopener" title="Group by的理解">Group by的理解</a></li>
<li><a href="https://blog.csdn.net/yexudengzhidao/article/details/54924471" target="_blank" rel="noopener" title="正确理解MySQL中的where和having的区别">正确理解MySQL中的where和having的区别</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/MySQL%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/06/MySQL%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/" itemprop="url">MySQL核心要点汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-06T21:18:34+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/06/MySQL%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/06/MySQL核心要点汇总/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  11.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  43
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h1><h2 id="1-1-内-外-全联接"><a href="#1-1-内-外-全联接" class="headerlink" title="1.1 内/外/全联接"></a>1.1 内/外/全联接</h2><p>假设有两张表，一张本校的校友信息表 t1，一张两院院士信息表 t2，使用二者的身份证号码（ID字段）来关联（即<code>t1.ID=t2.ID</code>）。</p>
<ul>
<li>内联接：在两张表进行连接查询时，只保留两张表中完全匹配的结果集。<ul>
<li><code>select .... from t1 inner join t2 on t1.ID=t2.ID</code></li>
<li>结果是只保留既是本校校友，又是两院院士的人的信息。</li>
</ul>
</li>
<li>外联接：分为左联接和右联接两种<ol>
<li>左联接：在两张表进行连接查询时，会返回左表所有的行，即使左表在右表中没有匹配的记录。<ul>
<li><code>select .... from t1 left (outer) join t2 on t1.ID=t2.ID</code></li>
<li>结果是返回全部本校校友的记录，部分校友可能同时是院士，其他大部分校友，t2表的相关字段值都为null。</li>
</ul>
</li>
<li>右联接：在两张表进行连接查询时，会返回右表所有的行，即使右表在左表中没有匹配的记录。<ul>
<li><code>select .... from t1 right (outer) join t2 on t1.ID=t2.ID</code></li>
<li>结果是返回全部两院院士的记录，部分院士可能是我校校友，其他大部分院士，t1表的相关字段值都为null。</li>
</ul>
</li>
</ol>
</li>
<li>全联接：在两张表进行连接查询时，返回左表和右表中所有的行（即便没有匹配）。<ul>
<li><code>select .... from t1 full join t2 on t1.ID=t2.ID</code></li>
<li>结果是返回本校校友+两院院士所有人的记录（当然会去重）。</li>
<li>其实也就是left join和right join的并集。</li>
</ul>
</li>
</ul>
<blockquote>
<p>单纯的<code>select * from a,b</code>是笛卡尔乘积。比如a表有5条数据，b表有3条数据，那么最后的结果有5*3=15条数据。但是如果对两个表进行关联:<code>select * from a,b where a.id = b.id</code>意思就变了，此时就等价于：<code>select * from a inner join b on a.id = b.id</code>。即就是内连接。但是这种写法并不符合规范，可能只对某些数据库管用，如sqlserver。推荐最好不要这样写。最好写成inner join的写法。</p>
</blockquote>
<h2 id="1-2-drop、delete与truncate的区别"><a href="#1-2-drop、delete与truncate的区别" class="headerlink" title="1.2 drop、delete与truncate的区别"></a>1.2 drop、delete与truncate的区别</h2><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p>
<ol>
<li>delete和truncate只删除表的数据不删除表的结构，drop都删除。</li>
<li>一般来说，执行速度方面是 drop&gt; truncate &gt;delete</li>
<li>delete语句是dml，这个操作会放到rollback segement中，事务提交之后才生效; 如果有相应的trigger，执行的时候将被触发。</li>
<li>truncate、drop是ddl，操作立即生效，原数据不放到rollback segment中，不能回滚.。操作不触发trigger.</li>
</ol>
<h2 id="1-3-数据并发问题"><a href="#1-3-数据并发问题" class="headerlink" title="1.3 数据并发问题"></a>1.3 数据并发问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ol>
<li><p><strong>脏读（Dirty read）</strong>:</p>
<ul>
<li>针对同一个字段，一个事务（假设事务A）读到了另一个的事务（假设事务B）提交前的数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。</li>
</ul>
</li>
<li><p><strong>丢失修改（Lost to modify）</strong>:</p>
<ul>
<li>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 </li>
<li>例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
</ul>
</li>
<li><p><strong>不可重复读（Unrepeatableread）</strong>:</p>
<ul>
<li>一般发生在一个事务要在事务内读取一个字段多次的场景。</li>
<li>事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据和第一次读取的时候不一样了，就是所谓的不可重复读了。</li>
</ul>
</li>
<li><p><strong>幻读（Phantom read）</strong>:</p>
<ul>
<li>幻读与不可重复读类似。也发生在一个事务在事务内部针对某些记录多次查询的情况。</li>
<li>例如在一个事务（A）读取了几行数据，接着另一个并发事务（B）插入并提交了一些数据，并且这些数据符合事务A的where条件时。在第二次的查询中，事务（A）就会发现相比第一次查询，第二次多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
</li>
</ol>
<p>不可重复读和幻读两者有些相似，他们的区别是：<br>|  不可重复读 | 幻读  |<br>| ———— | ———— |<br>| 针对的是update或delete  | 针对的是insert  |<br>| 重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了  | 重点在于新增或者删除 (数据条数变化)：同样的条件, 第1次和第2次读出来的记录数不一样  |</p>
<h2 id="1-4-事务隔离级别"><a href="#1-4-事务隔离级别" class="headerlink" title="1.4 事务隔离级别"></a>1.4 事务隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p>
<ol>
<li>READ-UNCOMMITTED(读未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-6c4f27430f3b074f1f7eef3e2f7b7ef121e.png" alt=""></p>
<blockquote>
<p>MySQL InnoDB 存储引擎的默认的隔离级别是 REPEATABLE-READ（可重复读）。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看</p>
</blockquote>
<p>我们知道隔离级别越低，事务请求的锁越少，并发效率越高，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读） 并不会有任何性能损失。</p>
<p>与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是<strong>Next-Key Lock 锁算法</strong>，<strong>因此可以避免幻读的产生</strong>，这与其他数据库系统(如 SQL Server) 是不同的。</p>
<p>所以说InnoDB 存储引擎的默认的隔离级别是 REPEATABLE-READ（可重读） <strong>已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别</strong>。</p>
<h1 id="2-数据库设计的三范式"><a href="#2-数据库设计的三范式" class="headerlink" title="2 数据库设计的三范式"></a>2 数据库设计的三范式</h1><h2 id="2-1-第一范式（1NF）"><a href="#2-1-第一范式（1NF）" class="headerlink" title="2.1 第一范式（1NF）"></a>2.1 第一范式（1NF）</h2><p>1NF是对属性的原子性，要求每一列（或者叫字段，属性）具有原子性，不可再分解；</p>
<p>如</p>
<p><code>学生表（学号，姓名，性别，生日）</code></p>
<p>如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不满足第一范式了；</p>
<h2 id="2-2-第二范式（2NF）"><a href="#2-2-第二范式（2NF）" class="headerlink" title="2.2 第二范式（2NF）"></a>2.2 第二范式（2NF）</h2><blockquote>
<p>第二范式是指在满足第一范式的条件下，除主键外的每一列都完全依赖于主键（主要针对于<strong>联合主键</strong>而言）。</p>
</blockquote>
<p>2NF是对记录的惟一性，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；</p>
<p>举个反例：</p>
<p><code>表（学号、课程号、姓名、学分） 联合主键为学号和课程号</code></p>
<p>这个表明显涵盖了两个信息主体：</p>
<ol>
<li>学生信息：学号和姓名字段属于学生信息，且姓名依赖于学号（学生信息的唯一标识）</li>
<li>课程信息：课程号和学分字段属于课程信息，学分依赖课程号（课程信息的唯一标识）。</li>
</ol>
<p>姓名由学号即可唯一标识，是对主键的部分依赖；<br>学分由课程号即可唯一标示，是对主键的部分依赖；</p>
<p>由于2NF要求<strong>非主键字段必须完全依赖主键</strong>，所以不符合二范式。<br>可能会存在问题：</p>
<ul>
<li>数据冗余:，每条记录都含有相同信息；</li>
<li>删除异常：删除所有学生成绩，就把课程信息全删除了；</li>
<li>插入异常：学生未选课，无法记录进数据库；</li>
<li>更新异常：调整课程学分，所有行都调整。</li>
</ul>
<p>正确做法:</p>
<ul>
<li>学生表：Student(学号, 姓名)；</li>
<li>课程表：Course(课程号, 学分)；</li>
<li>选课关系表：StudentCourse(学号, 课程号, 成绩)。</li>
</ul>
<h2 id="2-3-第三范式（3NF）"><a href="#2-3-第三范式（3NF）" class="headerlink" title="2.3 第三范式（3NF）"></a>2.3 第三范式（3NF）</h2><blockquote>
<p>  第三范式是指在满足第二范式的基础上，每一条数据不能依赖于其他的非主属性，也就是消除了传递依赖关系。</p>
</blockquote>
<p>3NF是对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p>
<p>例如</p>
<p><code>表（学号, 姓名, 年龄, 学院名称, 学院电话）</code></p>
<p>因为存在依赖传递: (学号) → (学生)→(所在学院) → (学院电话) 。</p>
<p>可能会存在问题：</p>
<ul>
<li>数据冗余:有重复值；</li>
<li>更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况</li>
</ul>
<p>正确做法：</p>
<ul>
<li>学生：(学号, 姓名, 年龄, 所在学院)；</li>
<li>学院：(学院, 电话)。</li>
</ul>
<h2 id="2-4-反范式化"><a href="#2-4-反范式化" class="headerlink" title="2.4 反范式化"></a>2.4 反范式化</h2><p>一般说来，数据库只需满足第三范式（3NF）就行了。没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。达到以空间换时间的目的。</p>
<p>比如：有一张存放商品的基本表，“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</p>
<h1 id="3-MySql存储引擎简述"><a href="#3-MySql存储引擎简述" class="headerlink" title="3. MySql存储引擎简述"></a>3. MySql存储引擎简述</h1><p>简单来说，存储引擎就是指表的类型以及表在计算机上的存储方式。</p>
<p>存储引擎的概念是MySQL的特点，Oracle中没有专门的存储引擎的概念，Oracle有OLTP和OLAP模式的区分。不同的存储引擎决定了MySQL数据库中的表可以用不同的方式来存储。我们可以根据数据的特点来选择不同的存储引擎。</p>
<p>在MySQL中的存储引擎有很多种，可以通过<code>mysql&gt; show engines;</code>语句来查看。下面重点关注InnoDB、MyISAM、MEMORY这三种。</p>
<h2 id="3-1-InnoDB引擎"><a href="#3-1-InnoDB引擎" class="headerlink" title="3.1 InnoDB引擎"></a>3.1 InnoDB引擎</h2><p>MySQL默认的<strong>事务型</strong>引擎，也是最重要和使用最广泛的存储引擎。在MySQL从3.23.34a版本开始包含InnnoDB。</p>
<p>InnoDB给MySQL的表提供了<strong>事务处理、回滚、崩溃修复能力和多版本并发控制</strong>的事务安全。它是MySQL上<strong>第一个提供外键约束的存储引擎</strong>。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。</p>
<p>InnoDB的性能与<strong>自动崩溃恢复</strong>的特性，使得它在非事务存储需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该<strong>优先考虑InnoDB引擎</strong>。</p>
<h2 id="3-2-MyISAM引擎"><a href="#3-2-MyISAM引擎" class="headerlink" title="3.2 MyISAM引擎"></a>3.2 MyISAM引擎</h2><p>在MySQL 5.1 及之前的版本，MyISAM是默认引擎。MyISAM提供的大量的特性，包括<strong>全文索引</strong>、<strong>压缩</strong>、空间函数（GIS）等，但MyISAM并<strong>不支持事务以及行级锁</strong>，而且一个毫无疑问的缺陷是<strong>崩溃后无法安全恢复</strong>。正是由于MyISAM引擎的缘故，即使MySQL支持事务已经很长时间了，在很多人的概念中MySQL还是非事务型数据库。尽管这样，它并不是一无是处的。对于只读的数据，或者表比较小，可以忍受修复操作，则依然可以使用MyISAM（但请不要默认使用MyISAM，而是应该默认使用InnoDB）</p>
<h2 id="3-3-MEMORY引擎"><a href="#3-3-MEMORY引擎" class="headerlink" title="3.3 MEMORY引擎"></a>3.3 MEMORY引擎</h2><p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且<strong>数据全部放在内存中</strong>。这些特性与前面的两个很不同。</p>
<p>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p>
<p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p>
<p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p>
<h2 id="3-4-如何合适的选择存储引擎"><a href="#3-4-如何合适的选择存储引擎" class="headerlink" title="3.4 如何合适的选择存储引擎"></a>3.4 如何合适的选择存储引擎</h2><p><img src="https://oscimg.oschina.net/oscnet/up-3127dd066a45c9fa1de2c57f273d5d0df6b.png" alt=""></p>
<ul>
<li><p>有以下要求，则适合采用InnoDB：</p>
<ul>
<li>需要对事务的完整性要求比较高（比如银行）</li>
<li>要求实现并发控制（比如售票）</li>
<li>如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 </li>
</ul>
</li>
<li><p>有以下要求，则适合采用MyISAM：</p>
<ul>
<li>如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。</li>
<li>如果应用对数据的完整性、并发性要求比较低，也可以使用。</li>
</ul>
</li>
<li><p>有以下要求，则适合采用MEMORY：</p>
<ul>
<li>如果需要很快的读写速度，对数据的安全性要求较低，且数据量很小时，可以选择MEMOEY。</li>
</ul>
</li>
</ul>
<h2 id="3-5-MyISAM与InnoDB区别"><a href="#3-5-MyISAM与InnoDB区别" class="headerlink" title="3.5 MyISAM与InnoDB区别"></a>3.5 MyISAM与InnoDB区别</h2><table>
<thead>
<tr>
<th>项目</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</td>
<td>每个MyISAM在磁盘上存储成三个文件。分别为：表定义文件、数据文件、索引文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。</td>
</tr>
<tr>
<td>存储空间</td>
<td>需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</td>
<td>MyISAM支持支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</td>
<td>数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</td>
</tr>
<tr>
<td>事务支持</td>
<td>提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</td>
<td>强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</td>
<td>可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</td>
</tr>
<tr>
<td>锁</td>
<td>支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE中指定主键是有效的，非主键的WHERE都会锁全表的。</td>
<td>只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</td>
</tr>
<tr>
<td>全文索引</td>
<td>原来不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。后来从InnoDB1.2.x版本（MySQL 5.6版本）起，InnoDB存储引擎开始支持全文索引</td>
<td>支持 FULLTEXT类型的全文索引</td>
</tr>
<tr>
<td>表主键</td>
<td>如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</td>
<td>允许没有任何索引和主键的表存在，索引都是保存行的地址。</td>
</tr>
<tr>
<td>表的具体行数</td>
<td>没有保存表的总行数，如果使用<code>select count(*) from table；</code>就会遍历整个表，消耗相当大，但是在加了where条件后，myisam和innodb处理的方式都一样。</td>
<td>保存有表的总行数，如果<code>select count(*) from table;</code>会直接取出出该值。</td>
</tr>
<tr>
<td>CRUD操作</td>
<td>如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。</td>
<td>如果执行大量的SELECT，MyISAM是更好的选择。</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h1 id="4-MySql索引"><a href="#4-MySql索引" class="headerlink" title="4. MySql索引"></a>4. MySql索引</h1><p>我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。</p>
<p>在数据之外，数据库系统维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-289e357d2d12e60c93f6e63fcbcc69877e1.png" alt=""></p>
<p>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。</p>
<p>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<blockquote>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
</blockquote>
<h2 id="4-1-索引的优缺点"><a href="#4-1-索引的优缺点" class="headerlink" title="4.1 索引的优缺点"></a>4.1 索引的优缺点</h2><p>优点：</p>
<ul>
<li>可以快速检索，减少I/O次数，加快检索速度；</li>
<li>根据索引分组和排序，可以加快分组和排序；</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；</li>
<li>索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；</li>
<li>构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；</li>
</ul>
<h2 id="4-2-索引的分类"><a href="#4-2-索引的分类" class="headerlink" title="4.2 索引的分类"></a>4.2 索引的分类</h2><h3 id="4-2-1-按类型分类"><a href="#4-2-1-按类型分类" class="headerlink" title="4.2.1 按类型分类"></a>4.2.1 按类型分类</h3><ol>
<li>聚集索引<ul>
<li>主键索引；<ul>
<li>数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li>
</ul>
</li>
</ul>
</li>
<li>二级索引（又称辅助索引、非聚簇索引）<ul>
<li>唯一索引；<ul>
<li>约束数据列不允许重复，允许为NULL值</li>
<li>一个表允许组合多个列创建唯一索引，这时约束的是：不同记录，被唯一索引约束的这多个列不能让完全相同</li>
</ul>
</li>
<li>普通索引（又叫辅助索引）；<ul>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</li>
<li>会对该列创建索引。</li>
</ul>
</li>
<li>组合索引(又称联合索引，复合索引)；<ul>
<li>即普通索引的多字段版本</li>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</li>
<li>如下图，可以理解成把几个字段拼接起来的一个普通索引</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-c7dcce083913fdfd6536e40ec10b13ade5f.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-2-2-按按数据结构分类"><a href="#4-2-2-按按数据结构分类" class="headerlink" title="4.2.2 按按数据结构分类"></a>4.2.2 按按数据结构分类</h3><ul>
<li>BTree索引<ul>
<li>下文详解</li>
</ul>
</li>
<li>B+Tree索引；<ul>
<li>下文详解</li>
</ul>
</li>
<li>哈希索引；<ul>
<li>只有memory存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存储该值所在行数据的物理位置。</li>
<li>因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</li>
</ul>
</li>
<li>全文索引；<ul>
<li>通过建立倒排索引来实现，查询效率比like有很大提升。</li>
<li>5.6版本前的MySQL自带的全文索引只能用于MyISAM存储引擎，如果是其它数据引擎，那么全文索引不会生效。5.6版本之后InnoDB存储引擎开始支持全文索引</li>
<li>在MySQL中，全文索引支队英文有用，目前对中文还不支持。5.7版本之后通过使用ngram插件开始支持中文。</li>
</ul>
</li>
</ul>
<h3 id="4-2-3-聚簇索引和非聚簇索引的区别（针对InnoDB）"><a href="#4-2-3-聚簇索引和非聚簇索引的区别（针对InnoDB）" class="headerlink" title="4.2.3 聚簇索引和非聚簇索引的区别（针对InnoDB）"></a>4.2.3 聚簇索引和非聚簇索引的区别（针对InnoDB）</h3><p>假设我们有如下表</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b04827a8539b202102f96172b5913a65965.png" alt=""></p>
<p>mysql对ID生成了聚簇索引，我们再对k字段生成普通索引（非聚簇），如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3fcb682ce6c4f03d0698881525f3c32f251.png" alt=""></p>
<blockquote>
<p><strong>其中R代表一整行的记录</strong>。</p>
</blockquote>
<p>从图中不难看出，聚簇索引和非聚簇索引的区别是：非聚簇索引的叶子节点存放的是<strong>主键的值</strong>，而聚簇索引的叶子节点存放的是<strong>整行数据</strong>。</p>
<p>根据这两种结构我们来进行下查询，看看他们在查询上有什么区别。</p>
<ol>
<li><p>如果查询语句是 select * from table where ID = 100，即主键查询的方式，则只需要搜索 ID 这棵 B+树。</p>
</li>
<li><p>如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100，再到ID索引树搜索一次，这个过程也被称为<strong>回表</strong>。</p>
</li>
</ol>
<blockquote>
<p>回表是非常重要的概念，需要敲黑板划重点记住。其过程就如下图所示：<br><img src="https://oscimg.oschina.net/oscnet/up-f8dece791a80588e740e4bad6e8cccc607f.png" alt=""></p>
</blockquote>
<blockquote>
<p>什么非主键索引结构叶子节点存储的是主键值？<br>一是保证一致性，更新数据的时候只需要更新主键索引树，二是节省存储空间。</p>
</blockquote>
<h3 id="4-2-4-为什么建议使用主键自增的索引"><a href="#4-2-4-为什么建议使用主键自增的索引" class="headerlink" title="4.2.4 为什么建议使用主键自增的索引"></a>4.2.4 为什么建议使用主键自增的索引</h3><p>自增的主键，插入到索引的时候，直接在最右边插入就可以了</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d26d47c59b00d24a6bf8efc2fc3cf99d5bd.png" alt=""></p>
<p>但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间，如果刚好 R4 所在的数据页已经满了，需要进行页分裂操作，这样会更加糟糕。</p>
<p>所以使用自增主键，每次插入的 ID 都会比前面的大，那么就可以避免这种情况。</p>
<h2 id="4-3-索引的数据结构"><a href="#4-3-索引的数据结构" class="headerlink" title="4.3 索引的数据结构"></a>4.3 索引的数据结构</h2><p>索引的数据结构，常见的是B树和B+树，MySql的索引使用的是B+树，关于B树一家子的分析，可以详见下文：<a href="https://my.oschina.net/lscherish/blog/4257330" target="_blank" rel="noopener" title="B树/B+树分析">B树/B+树分析</a></p>
<p>不过虽然都是使用B+树来做数据结构，但在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的（不过至少都是B+树）。</p>
<h3 id="4-3-1-MyISAM索引实现"><a href="#4-3-1-MyISAM索引实现" class="headerlink" title="4.3.1 MyISAM索引实现"></a>4.3.1 MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，<strong>其主键索引和普通索引在结构上没有区别</strong>，叶节点的data域存放的是数据记录的地址。</p>
<h4 id="4-3-1-1-MyISAM主键索引"><a href="#4-3-1-1-MyISAM主键索引" class="headerlink" title="4.3.1.1 MyISAM主键索引"></a>4.3.1.1 MyISAM主键索引</h4><p>如下图，这时一个针对主键col1字段的索引结构图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-95589fff5abe03cb617fecfdc3bb7ca40e7.png" alt=""></p>
<p>可以看出MyISAM的索引文件仅仅保存数据记录的地址。</p>
<h4 id="4-3-1-2-MyISAM普通索引"><a href="#4-3-1-2-MyISAM普通索引" class="headerlink" title="4.3.1.2 MyISAM普通索引"></a>4.3.1.2 MyISAM普通索引</h4><p>在MyISAM中，主索引和普通索引（Secondary key）在结构上没有任何区别，<strong>只是主索引要求key是唯一的</strong>，而普通索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-cf329acb011c774d082ce93aff5943de24e.png" alt=""></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>发现没有？MyISAM的索引方式，跟我们上文说的非聚簇索引十分相像（一个是存放id，一个是存放地址）。所以MyISAM索引的实现方式是非聚簇索引。</p>
<h3 id="4-3-2-InnoDB索引实现"><a href="#4-3-2-InnoDB索引实现" class="headerlink" title="4.3.2 InnoDB索引实现"></a>4.3.2 InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。对，InnoDB的索引是聚簇式的：<strong>InnoDB的数据文件本身就是索引文件</strong>，树的叶节点data域保存了完整的数据记录。</p>
<h4 id="4-3-2-1-InnoDB主键索引实现"><a href="#4-3-2-1-InnoDB主键索引实现" class="headerlink" title="4.3.2.1 InnoDB主键索引实现"></a>4.3.2.1 InnoDB主键索引实现</h4><p>我们先来看 InnoDB的主键索引，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0febdd2fe5f4a8e1b6fb2682691f1809eef.png" alt=""></p>
<blockquote>
<p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
</blockquote>
<h4 id="4-3-2-2-InnoDB普通索引实现"><a href="#4-3-2-2-InnoDB普通索引实现" class="headerlink" title="4.3.2.2 InnoDB普通索引实现"></a>4.3.2.2 InnoDB普通索引实现</h4><p>在MyISAM中主索引和普通索引（Secondary key）在结构上没有任何区别，但InnoDB中，普通索引和主键索引是不同的，前文我们也介绍过，InnoDB的普通索引是非聚簇式的。</p>
<p>例如，图11为定义在Col3上的一个辅助索引：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e8635aba2790f0fd15594ce95bfb1dc97da.png" alt=""></p>
<p>图中的15,18这些数字，就是col3所对应的<strong>主键值</strong>，普通索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<blockquote>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
</blockquote>
<p>最后来一张图总结一下InnoDB和Mylsam两种不同索引的结构：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-36fd77ae6ff2ce44045e7c313f7c102add4.png" alt=""></p>
<h3 id="4-3-3-联合索引的数据结构"><a href="#4-3-3-联合索引的数据结构" class="headerlink" title="4.3.3 联合索引的数据结构"></a>4.3.3 联合索引的数据结构</h3><p>我们知道了Mysql的索引采用B+树，那么，联合索引的B+树长什么样呢？？</p>
<h4 id="4-3-3-1-MylSAM的联合索引"><a href="#4-3-3-1-MylSAM的联合索引" class="headerlink" title="4.3.3.1  MylSAM的联合索引"></a>4.3.3.1  MylSAM的联合索引</h4><p>假如我们有一张表</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-05ed253aaa6cac66ae76bd4d9c06610ffba.png" alt=""></p>
<p>那么，联合索引的B+树结构是长这样的：</p>
<pre><code>- ![](https://oscimg.oschina.net/oscnet/up-96d55ea6fae1c299fc33c64c57ece2ce911.png)</code></pre><blockquote>
<p>注意，这是MyISAM的联合索引，也就是说，叶子节点的key是索引列b,c,d的组合，value是指向表记录的内存地址。如果是InnoDB的联合索引，那么叶子结点应该key是b,c,d的组合，value是表的pk，也就是a字段。</p>
</blockquote>
<p>即每个元素的key，都是b,c,d三个字段的组合。那么不同元素之间的排序是依照什么规则呢？第一列的值大小吗？</p>
<p>答案是：先判断 b 再判断 c 然后是 d，即优先级为b&gt;c&gt;d。</p>
<h4 id="4-3-3-2-InnoDB的联合索引"><a href="#4-3-3-2-InnoDB的联合索引" class="headerlink" title="4.3.3.2  InnoDB的联合索引"></a>4.3.3.2  InnoDB的联合索引</h4><p>有一张表test，这张表除了主键id外，还有a，b,  c 三列</p>
<p>假设给这三个字段建一个复合索引 index_abc (a, b, c)，那么其B+树的结构如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b049e18954547cf3acdcd6866261f8c81ce.png" alt=""></p>
<p>key的排序同理，先判断 a 再判断 b 然后是 c，即优先级为b&gt;c&gt;d。</p>
<h2 id="4-4-索引生效条件"><a href="#4-4-索引生效条件" class="headerlink" title="4.4 索引生效条件"></a>4.4 索引生效条件</h2><p>我们创建了索引，但很多时候，我们发现我们的查询语句无法使用到索引，基于此，我们首先要了解索引的命中规则。</p>
<p>那么怎么知道我们写的sql语句是否有使用到索引呢，可以使用<code>explain</code>命令，直接在sql语句前加explain执行：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-835f37250d6a7bf6e9409110997e2494d0d.png" alt=""></p>
<p>explain执行结果关注以下几个字段：</p>
<ol>
<li>select_type:<ul>
<li>查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询<ul>
<li>SIMPLE：查询中不包含子查询或者UNION</li>
<li>查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY</li>
<li>在SELECT或WHERE列表中包含了子查询，该子查询被标记为：SUBQUERY</li>
</ul>
</li>
</ul>
</li>
<li>possible_keys<ul>
<li>表示查询时可能使用的索引。如果是空的，没有相关的索引。这时要提高性能，可通过检验WHERE子句，看是否引用某些字段，或者检查字段不是适合索引</li>
</ul>
</li>
<li>key<ul>
<li>显示sql执行过程中实际使用的键或索引，如果为null则表示未使用任何索引，必须进行优化。</li>
</ul>
</li>
<li>rows<ul>
<li>rows是指这次查找数据所内循环的次数。</li>
</ul>
</li>
<li>Extra:<ul>
<li>执行情况的说明和描述。包含不适合在其他列中显示但十分重要的额外信息</li>
</ul>
</li>
<li>type<ul>
<li>type意味着类型，这里的type官方全称是“join type”，意思是“连接类型”,这样很容易给人一种错觉觉得必须需要俩个表以上才有连接类型。事实上这里的连接类型并非字面那样的狭隘，</li>
<li>它更确切的说是一种数据库引擎查找表的一种方式，在《高性能mysql》一书中作者更是觉得称呼它为访问类型更贴切一些。</li>
<li>mysql5.7中type的类型达到了14种之多，这里只记录和理解最重要且经常遇见的六种类型，它们分别是<code>all&lt;index&lt;range&lt;ref&lt;eq_ref&lt;const</code>。从左到右，它们的效率依次是增强的。</li>
<li>撇开sql的具体应用环境以及其他因素，你应当尽量优化你的sql语句，使它的type尽量靠右，但实际运用中还是要综合考虑各个方面的。</li>
</ul>
</li>
</ol>
<h3 id="4-4-1-explain的type字段类型"><a href="#4-4-1-explain的type字段类型" class="headerlink" title="4.4.1 explain的type字段类型"></a>4.4.1 explain的type字段类型</h3><ol>
<li><strong>all</strong>：这便是所谓的“全表扫描”，如果是在一个查找数据项的sql中出现了all类型，那通常意味着你的sql语句处于一种最原生的状态，有很大的优化空间。all是一种非常暴力和原始的查找方法，非常的耗时而且低效。</li>
<li><strong>index</strong>：这种连接类型只是另外一种形式的全表扫描，<strong>只不过它的扫描顺序是按照索引的顺序</strong>。这种扫描根据索引然后回表取数据，和all相比，他们都是取得了全表的数据，而且index要先读索引而且要回表随机取数据</li>
<li><strong>range</strong>：range指的是有范围的索引扫描，相对于index的全索引扫描，它有范围限制，因此要优于index。关于range比较容易理解，需要记住的是出现了range，则一定是基于索引的。同时除了显而易见的between，and以及’&gt;’,’&lt;’外，in和or也是索引范围扫描。</li>
<li><strong>ref</strong>：出现该连接类型的条件是： 查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复（使用了普通索引的意思）。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</li>
<li><strong>ref_eq</strong>：ref_eq 与 ref相比牛的地方是，它知道这种类型的查找结果集只有一个。什么情况下结果集只有一个呢！那便是使用了<strong>主键或者唯一性索引</strong>进行查找的情况。比如根据学号查找某一学校的一名同学，在没有查找前我们就知道结果一定只有一个，所以当我们首次查找到这个学号，便立即停止了查询。这种连接类型每次都进行着精确查询，无需过多的扫描，因此查找效率更高，当然列的唯一性是需要根据实际情况决定的。</li>
<li><strong>const</strong>：通常情况下，如果将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量。即直接按主键或唯一键读取。</li>
<li><strong>NULL</strong>：不用访问表或者索引，直接就能得到结果，如select 1 from test where 1</li>
</ol>
<blockquote>
<p>看起来const和ref_eq貌似是一样的啊，都是使用主键或者唯一性索引，其实eq_ref是用于联表查询的情况，按联表的主键或唯一键联合查询。</p>
</blockquote>
<h3 id="4-4-2-索引失效场景"><a href="#4-4-2-索引失效场景" class="headerlink" title="4.4.2 索引失效场景"></a>4.4.2 索引失效场景</h3><p>很多时候，我们在列上建了索引，查询条件也是索引列，但最终执行计划没有走它的索引。那到底哪些场景，会导致索引失效呢？</p>
<ol>
<li><p>列与列对比</p>
<ul>
<li>某个表中，有两列（id和c_id）都建了单独索引，下面这种查询条件不会走索引</li>
<li><code>select * from test where id=c_id;</code></li>
</ul>
</li>
<li><p>存在NULL值条件</p>
<ul>
<li>我们在设计数据库表时，应该尽力避免NULL值出现，如果非要不可避免的要出现NULL值，也要给一个DEFAULT值</li>
<li><code>select * from test where id=c_id;</code></li>
</ul>
</li>
<li><p>NOT条件</p>
<ul>
<li>我们知道建立索引时，给每一个索引列建立一个条目，如果查询条件为等值或范围查询时，索引可以根据查询条件去找对应的条目。反过来当查询条件为非时，索引定位就困难了，执行计划此时可能更倾向于全表扫描，这类的查询条件有：&lt;&gt;、NOT、not exists<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>&lt;&gt;<span class="number">500</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test_02 <span class="keyword">where</span> test_02.id=test.id);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>LIKE通配符的前匹配</p>
<ul>
<li>当使用模糊搜索时，尽量采用后置的通配符，例如：name%，因为走索引时，其会从前去匹配索引列，这时候是可以找到的，如果采用前匹配，那么查索引就会很麻烦，比如查询所有姓张的人，就可以去搜索’张%’。相反如果你查询所有叫‘明’的人，那么只能是%明。这时候索引如何定位呢？前匹配的情况下，执行计划会更倾向于选择全表扫描。后匹配可以走INDEX RANGE SCAN。</li>
<li><code>select * from test where name like &#39;张%&#39;;</code></li>
</ul>
</li>
<li><p>条件上对列使用函数</p>
<ul>
<li>查询条件上尽量不要对索引列使用函数，比如下面这个SQL——这样是不会走索引的，因为索引在建立时会和计算后可能不同，无法定位到索引。</li>
<li><code>select * from test where upper(name)=&#39;SUNYANG&#39;;</code></li>
<li>但如果查询条件不是对索引列进行计算，那么依然可以走索引。比如</li>
<li><code>select * from test where name=upper(&#39;sunyang&#39;);</code></li>
</ul>
</li>
<li><p>数据类型的转换</p>
<ul>
<li>当查询条件存在隐式转换时，索引会失效。比如在数据库里id存的number类型，但是在查询时，却用了下面的形式：</li>
<li><code>select * from sunyang where id=&#39;123&#39;;</code></li>
</ul>
</li>
<li><p>谓词运算</p>
<ul>
<li>我们在上面说，不能对索引列进行函数运算，这也包括加减乘除的谓词运算，这也会使索引失效。建立一个sunyang表，索引为id，看这个SQL：</li>
<li><code>select * from sunyang where id/2=15;</code></li>
<li>这里很明显对索引列id进行了’/2’除二运算，这时候就会索引失效，这种情况应该改写为：</li>
<li><code>select * from sunyang where id=30;</code></li>
</ul>
</li>
<li><p>or连接中包含非独立索引</p>
<ul>
<li>先看如下这个sql：</li>
<li><code>SELECT * from t WHERE id = 1 or uid = 2;</code></li>
<li>如果id和uid都有单独的索引，那么mySql优化器会采用index merge 技术使其走索引。index merge 技术简单说就是在用OR，AND连接的多个查询条件时，可以分别使用前后查询中的索引，然后将它们各自的结果合并交集或并集。</li>
<li><strong>但如果uid列上没有单独的索引，那么这个sql将不会走索引，即便id上有主键索引。</strong></li>
</ul>
</li>
</ol>
<h3 id="4-4-3-联合索引生效条件（最左前缀原则）"><a href="#4-4-3-联合索引生效条件（最左前缀原则）" class="headerlink" title="4.4.3 联合索引生效条件（最左前缀原则）"></a>4.4.3 联合索引生效条件（最左前缀原则）</h3><p>上文中我们介绍了联合索引的数据结构，对于index(b,c,d)是长这样的：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-96d55ea6fae1c299fc33c64c57ece2ce911.png" alt=""></p>
<p>因为联合索引中的元素key都是一个组合值&lt;b,c,d&gt;，且排序依据的优先级是b&gt;c&gt;d，所以联合索引的生效条件，要满足最左前缀原则。我们看如下sql：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">2</span> <span class="keyword">and</span> d = <span class="number">3</span>; //走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">2</span>                  //走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b = <span class="number">1</span>                                  //走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> c = <span class="number">2</span> <span class="keyword">and</span> d = <span class="number">3</span>;                 //不走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> d = <span class="number">3</span>;                                 //走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b = <span class="number">1</span> <span class="keyword">and</span> d = <span class="number">3</span>                 //走部分索引，至少会走到b = <span class="number">1</span>的子树上。</span><br><span class="line"></span><br><span class="line">//范围查询</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b &lt; <span class="number">1</span>;                                  //走索引</span><br><span class="line">SELECT * from t1 WHERE b &lt; 1 and c &lt; 2 and d&gt;3;   //走部分索引，b&lt;1走了索引，后面两个条件无法走索引。（索引最多用于一个范围列）</span><br></pre></td></tr></table></figure>

<p>这就是最左前缀原则，还是比较好理解的，需要注意的是索引最多用于一个范围列（且只能是最左的列）。</p>
<p>不过大多数时候，mySql优化器会按照现有的索引来优化sql语句的where条件顺序，比如<code>SELECT * from t1 WHERE  c = 2 and b = 1</code>就会被优化为<code>SELECT * from t1 WHERE b = 1 and c = 2</code>，使得这条sql可以走索引。</p>
<h2 id="4-5-索引优化"><a href="#4-5-索引优化" class="headerlink" title="4.5 索引优化"></a>4.5 索引优化</h2><h3 id="4-5-1-索引的选择性"><a href="#4-5-1-索引的选择性" class="headerlink" title="4.5.1 索引的选择性"></a>4.5.1 索引的选择性</h3><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<ol>
<li><p>表记录比较少:</p>
<ul>
<li>例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</li>
</ul>
</li>
<li><p>索引的选择性较低。</p>
<ul>
<li>所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</li>
<li><code>Index Selectivity = Cardinality / #T</code></li>
<li>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</li>
<li><code>SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;</code></li>
</ul>
</li>
</ol>
<h3 id="4-5-2-前缀索引"><a href="#4-5-2-前缀索引" class="headerlink" title="4.5.2 前缀索引"></a>4.5.2 前缀索引</h3><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。</p>
<p>下面以employees.employees表为例介绍前缀索引的选择和使用。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1e10e78d3b5a8ab5317c3469f7b21c27edc.png" alt=""></p>
<p>如果我们需要频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(first_name))&#x2F;count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.0042 |</span><br><span class="line">+-------------+</span><br><span class="line">SELECT count(DISTINCT(concat(first_name, last_name)))&#x2F;count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9313 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p><first_name>显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))&#x2F;count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.7879 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))&#x2F;count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9007 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引建上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employees.employees</span><br><span class="line">ADD INDEX &#96;first_name_last_name4&#96; (first_name, last_name(4));</span><br></pre></td></tr></table></figure>

<p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：<a href="https://www.cnblogs.com/mydriverc/p/7086523.html" target="_blank" rel="noopener" title="MYSQL中使用SHOW PROFILE命令分析性能">MYSQL中使用SHOW PROFILE命令分析性能</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                                           |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br><span class="line">|       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<h3 id="4-5-3-覆盖索引"><a href="#4-5-3-覆盖索引" class="headerlink" title="4.5.3 覆盖索引"></a>4.5.3 覆盖索引</h3><p>我们知道，联合索引的B+树是长这个样子的(InnoDB版本，index_abc为(a,b,c)的联合索引)：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b049e18954547cf3acdcd6866261f8c81ce.png" alt=""></p>
<p>那么假如我们有如下的语句：</p>
<p><code>select a,b,c from test where b&gt;3</code></p>
<p>请问这句话走不走索引呢？</p>
<p>答案是：走索引</p>
<p>where b&gt;3 根据最左前缀原则明明不会命中index_abc啊，为什么这条语句会走索引呢？？</p>
<p>因为这句sql，不用回表，这会极大的提高查询性能。</p>
<p>为什么不用回表？因为对比联合索引的结构图我们可以看到，该句sql select的三个字段，都是联合索引的索引字段，这使得联合索引index_abc的叶子结点上就已经能够得到a,b,c三个字段了，用不着回表就足够把需要的a,b,c数据都查出来。</p>
<p>但where b&gt;3不满足最左前缀原则啊！那么索引是怎么走的呢？</p>
<p>答案是，<strong>遍历B+树上的所有节点</strong>。是的，因为不满足最左前缀，所以该句sql无法很高效的利用索引来将性能达到极致，但是遍历B+树上的所有节点仍然比全表扫描要快得多，因为B+树多叉的特性，其节点数量远远小于表记录的数量。</p>
<p>这种索引叫做<strong>覆盖索引</strong>，即现有的索引能够覆盖select的字段，那么就可以通过遍历索引树节点，且无需回表的方式，来提高查询性能。</p>
<p>理解了覆盖索引的含义，那么举一反三，我们可以知道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select a,b from test where c&gt;3     &#x2F;&#x2F;走索引</span><br><span class="line">select id,a,b from test where c&gt;3  &#x2F;&#x2F;走索引，别忘了联合索引的叶子节点上除了联合索引的索引列，还有主键id</span><br><span class="line">select a,b,d from test where c&gt;3   &#x2F;&#x2F;不走索引，因为d不在index_abc的覆盖范围内</span><br><span class="line">select a,b,c from test where a&gt;3   &#x2F;&#x2F;走索引，且还能满足最左前缀原则，性能最高。</span><br></pre></td></tr></table></figure>

<p>所以在select的字段不多的时候，我们可以考虑创建这几个字段的联合索引，来促使sql走覆盖索引，提高查询性能。</p>
<h3 id="4-5-4-索引下推"><a href="#4-5-4-索引下推" class="headerlink" title="4.5.4 索引下推"></a>4.5.4 索引下推</h3><p>对于user_table表，我们现在有（username,age）联合索引。</p>
<p>如果现在有一个需求，查出名称中以“张”开头且年龄小于等于10的用户信息，语句如下：</p>
<p><code>select * from user_table where username like &#39;张%&#39; and age &gt; 10</code></p>
<p>那么我们可以推测出来，语句有两种执行可能：</p>
<ol>
<li>根据（username,age）联合索引查询出所有满足名称以“张”开头的叶子节点，得到pk，<strong>然后回表查询出相应的全行数据</strong>，然后再在结果中筛选出满足年龄小于等于10的用户数据</li>
<li>根据（username,age）联合索引查询所有满足名称以“张”开头的叶子节点，<strong>然后再对这些叶子节点筛选出年龄小于等于10的叶子节点</strong>，得到pk，之后再回表查询全行数据。</li>
</ol>
<p>明显的，<strong>第二种方式需要回表查询的全行数据比较少</strong>，这就是mysql的索引下推，即<strong>where条件中的字段如果能被某个联合索引覆盖</strong>（和覆盖索引有点像），那么直接在联合索引中完成过滤操作，缩小范围，最后再做回表操作。</p>
<p>mysql默认启用索引下推，我们也可以通过修改系统变量optimizer_switch的index_condition_pushdown标志来控制<br><code>SET optimizer_switch = &#39;index_condition_pushdown=off&#39;;</code></p>
<hr>
<h1 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h1><ol>
<li><a href="https://segmentfault.com/a/1190000013695030" target="_blank" rel="noopener" title="数据库逻辑设计之三大范式通俗理解，一看就懂，书上说的太晦涩">数据库逻辑设计之三大范式通俗理解，一看就懂，书上说的太晦涩</a></li>
<li>《高性能MySQL》</li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener" title="MySQL索引背后的数据结构及算法原理">MySQL索引背后的数据结构及算法原理</a></li>
<li><a href="https://blog.csdn.net/dennis211/article/details/78170079" target="_blank" rel="noopener" title="mysql中explain的type的解释">mysql中explain的type的解释</a></li>
<li><a href="https://www.cnblogs.com/CNYYGJ/p/12677690.html" target="_blank" rel="noopener" title="左匹配原则，聚集索引，回表查询，索引覆盖 你真的懂了吗">左匹配原则，聚集索引，回表查询，索引覆盖 你真的懂了吗</a></li>
<li><a href="https://blog.csdn.net/mccand1234/article/details/95799942" target="_blank" rel="noopener" title="索引下推（5.6版本+）">索引下推（5.6版本+）</a></li>
<li><a href="https://www.jianshu.com/p/35588ecf33c1" target="_blank" rel="noopener" title="mysql的联合索引的B+树到底张什么样子？">mysql的联合索引的B+树到底张什么样子？</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/28/B%E6%A0%91-B-%E6%A0%91%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/B%E6%A0%91-B-%E6%A0%91%E5%88%86%E6%9E%90/" itemprop="url">B树/B+树分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-28T22:39:54+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91-%E5%A0%86/" itemprop="url" rel="index">
                    <span itemprop="name">树/堆</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/28/B%E6%A0%91-B-%E6%A0%91%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/04/28/B树-B-树分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  5.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前我们常见的动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树(Red-Black Tree )，这三者是典型的二叉树结构，利用二分法，可以使其查询的时间复杂度为O(log2N)，即与树的深度相关。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0dcba6005c20f21c6a6e966b9f239b7bc91.png" alt=""></p>
<p>但二叉树一个节点中包含有一个元素，和指向两个子节点的指针，在现实生活中，未免有些太“奢侈”了。为了降低树的深度，提高查找效率，我们完全可以采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）来得到一棵更加“矮胖”的树，以适应我们日益增长的数据量和查询性能要求，在这种背景下，B树和他的亲戚们应运而生。</p>
<h1 id="1-B树"><a href="#1-B树" class="headerlink" title="1. B树"></a>1. B树</h1><p>B-tree（B-tree树即B树，B即Balanced，平衡的意思）这棵神奇的树是在Rudolf Bayer, Edward M. McCreight(1970)写的一篇论文《Organization and Maintenance of Large Ordered Indices》中首次提出的（wikipedia中：<a href="http://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener" title="http://en.wikipedia.org/wiki/B-tree">http://en.wikipedia.org/wiki/B-tree</a>，阐述了B-tree名字来源以及相关的开源地址）。</p>
<p>B树属于多叉树，又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构。</p>
<blockquote>
<p>强调一下，有的文章里出现的B-树，就是B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是一种一种树。而事实上是，B-tree就是指的B树。</p>
</blockquote>
<p>什么是B树？抛出一大堆概念前，我们先看看他长什么样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4ab23420bac3cd2b0d9278357cf27adb754.png" alt=""></p>
<p>这里面，每个字母，都表示一个键值对<code>[key,value]</code>，在关系型数据库的使用场景中，<strong>key一般是索引值</strong>（如果是主键索引的话，那就是ID字段，如果是普通索引，那就是索引对应的字段值，如果是联合索引，可以简单理解为对应多个字段的拼接），<strong>value一般是指向行数据的指针（聚簇索引是这样）或者主键id（非聚簇索引）</strong>；</p>
<p>结合该图，我们可以归纳出B树的规则：</p>
<ol>
<li>节点容量：每个节点，都可以容纳多个键值对。</li>
<li>排序方式：所有节点键值对是按key递增次序排列，并遵循左小右大原则；</li>
<li>层级结构：所有叶子节点均在同一层</li>
<li>子树指针：节点中每个键值对的两侧，都可以放置指针（不一定都有值，可以是null），如果有值，则左边指向左子树（key都比当前key小），右边指向右子树（key都比当前key大）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-45013c901275cb3600f245d8c75f79590fd.png" alt=""></li>
</ul>
</li>
</ol>
<p>B树种，每个节点最多可以容纳多少个键值对呢？这当然不可能是无限的，在数据结构的定义中，我们引入如下概念来描述：</p>
<ol>
<li>度（degree），在树中，每个节点的子树个数就称为该节点的度。（注意是子树数量，而不是键值对的数量）</li>
<li>阶（order），在树中，一个节点可以拥有的最大子树数量称为阶。（注意是子树数量，而不是键值对的数量）</li>
</ol>
<p>然而上述的规则，只能得到一个B树，却不一定得到一个平衡的B树，极端一点，下图这样的树，它也可以是个B树，但这显然不是我们想要的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-11c5ae696f01bc75d91131d6ffb2a9dfeeb.png" alt=""></p>
<p>对于一个M阶的平衡的B树，除了上述的规则之外，我们还要加上如下的约束：</p>
<ol>
<li>根节点至少有两颗子树</li>
<li>除根节点和叶子结点外，其他节点至少应该有m/2个子树。</li>
<li>每个节点的键值对数量k，应该<code>m-1≥k≥ceil(m/2)-1</code>。</li>
</ol>
<blockquote>
<p>ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2</p>
</blockquote>
<p>如下图，就是一个5阶的平衡B树，4≥k≥2。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bb258827f7c35e85442858c7e596f2e2524.png" alt=""></p>
<p>注意，每个节点中的键值对，value都是指向实际data的指针，像下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1ebfa206ae65baff44ff3be6ad33826a6cb.png" alt=""></p>
<h2 id="1-1-B树的查询"><a href="#1-1-B树的查询" class="headerlink" title="1.1 B树的查询"></a>1.1 B树的查询</h2><p><img src="https://oscimg.oschina.net/oscnet/up-a9ce1d66b48acaafe781167587318d9c0f0.png" alt=""></p>
<p>如上图我要从上图中找到E字母，查找流程如下</p>
<ol>
<li><p>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</p>
</li>
<li><p>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</p>
</li>
<li><p>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</p>
</li>
</ol>
<h2 id="1-2-B树的插入"><a href="#1-2-B树的插入" class="headerlink" title="1.2 B树的插入"></a>1.2 B树的插入</h2><p>一棵平衡的B树之所以能维持其平衡性，B树的插入和删除算法功不可没，我们先来看下B树如何应对记录的插入。</p>
<p>对于一个m阶的平衡的B树，从上文我们知道，需要保持其每个节点的键值对数量k为：<code>m-1≥k≥ceil(m/2)-1</code>，新的记录一般是插入在叶子节点上，为了保持这个数量和树的平衡性，我们规定：</p>
<ol>
<li>还是按照key递增次序排列，遵循左小右大的原则，在叶子节点上找到新元素的定位。</li>
<li>若插入时，插入的节点元素个数小于m-1，则该元素直接插入。</li>
<li>否则，将该节点的元素分裂。</li>
</ol>
<p>我们下面以5阶B树为例子，在5阶B树中，结点最多有4个键值对，最少有2个键值对。（下面我们把键值对称为元素）</p>
<ol>
<li>插入树的第一批元素，A，C，G，N，因为数量不超过4，所以刚好能放在一个节点里面：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-0af274b789dd1f16f170fc83968f07eb356.png" alt=""></li>
</ul>
</li>
<li>当试着插入H时，节点发现空间不够（4阶B树，一个节点最多放4个元素），以致将其<strong>分裂</strong>成2个节点，移动中间元素G上移到新的根节点中，比G元素小的A和C留在当前节点中，而比G元素大的H和N放置新的其右邻居节点中。如下图：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-cbd8d929ac323b575bf7d75becdfacf44a8.png" alt=""></li>
</ul>
</li>
<li>接下来插入E，K，Q，因为都不触及上界，所以不需要任何分裂操作<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-e9af49d254a060491b461731484c692dc6c.png" alt=""></li>
</ul>
</li>
<li>插入M（在K和N之间）就会导致一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-a90c8160743bcd04518ca54bb903db6c700.png" alt=""></li>
</ul>
</li>
<li>插入F，W，L，T不需要任何分裂操作<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d0df1d26e4a539e449f182883079b6e000f.png" alt=""></li>
</ul>
</li>
<li>插入Z时，最右的叶子节点空间满了，需要进行分裂操作，中间元素T上移到父节点中。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-c901bb0b11e87bc7ce2f19966758b8f74e2.png" alt=""></li>
</ul>
</li>
<li>插入D时，导致最左边的叶子节点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P，R，X，Y陆续插入不需要任何分裂操作<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-33e4f1cbd03fa5a95705511b5fa003df45c.png" alt=""></li>
</ul>
</li>
<li>最后，当插入S时，含有[N,P,Q,R]的节点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，无法加入Q了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-6d015f6544f424661fdc345f7b017b3bbf4.png" alt=""></li>
</ul>
</li>
</ol>
<h2 id="1-3-B树的删除"><a href="#1-3-B树的删除" class="headerlink" title="1.3 B树的删除"></a>1.3 B树的删除</h2><p>B树的删除比插入要更复杂一些，但总体而言，为了保持树的平衡，还是有以下的原则：</p>
<p>分为如下几种情况：</p>
<ol>
<li><p>要删除的记录d在叶子节点上</p>
<ul>
<li><p>1.1  如果该节点删除了该元素d后元素数量k仍然大于等于ceil(m/2)-1</p>
<blockquote>
<p>那么这种情况最简单，直接删除元素d和其对应的指针即可。这种情况，我们称为<strong>元素直删</strong></p>
</blockquote>
</li>
<li><p>1.2 如果该节点删除了元素d后k小于ceil(m/2)-1，那么这时也分两种情况</p>
<ul>
<li><p>1.2.1 与该节点相邻的兄弟节点，有任一节点，其k大于等于ceil(m/2)。（这表示即便k-1，也仍然大于等于ceil(m/2)-1）</p>
<blockquote>
<p>那么这种情况，我们应该向兄弟节点，借一个元素过来，但不是简单的借，因为要保证B树元素从左到右递增的顺序，故而借法是有门道的，我们暂称为<strong>元素租借</strong>。</p>
</blockquote>
</li>
<li><p>1.2.2 与该节点相邻的兄弟节点，都没有多余的元素可以借出去，即其k都等于ceil(m/2)-1</p>
<blockquote>
<p>那么这种情况，删除元素d后，我们应该和兄弟节点合并，这样k1=ceil(m/2)-1-1和k2=ceil(m/2)-1,k1+k2还是小于m，符合B树的平衡约束（这也是为什么k的下限是ceil(m/2)-1的原因），这种情况，我们称为<strong>元素合并</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>要删除的记录d在非叶子节点上</p>
<ul>
<li><blockquote>
<p>那么这种情况，我们应该在d指针指向的子树中找到一个元素f来替代d的位置，同时在子树中删除f（如果f的删除引起了<code>m-1≥k≥ceil(m/2)-1</code>的不满足，那么操作方法按照<code>情况1：要删除的记录d在叶子节点上</code>来处理），这种情况，我们称为<strong>元素顶替</strong></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>总结之后，我们发现，删除记录的核心操作，就在<strong>元素直删</strong>，<strong>元素租借</strong>，<strong>元素合并</strong>和<strong>元素顶替</strong>这四个操作步骤之间，直删元素比较简单，我们不多说，剩下的，三种操作步骤，我们来理一下：</p>
<p>我们有一个5阶的b树，原始状态长这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dbe6fba9b6d67cc51aa034d00863633519b.png" alt=""></p>
<ol>
<li><strong>元素顶替</strong><ul>
<li>我们先反着来，先删除位于非叶子节点上的记录27</li>
<li>这时候，需要从27的左右指针指向的两棵子树中找元素来置换27，左子树是<code>23,24,26</code>，右子树是<code>28,29</code></li>
<li>为了保证b树从左到右增序的顺序，所以有资格被置换的元素只有26和28。</li>
<li>b树删除的大部分实现，都是采用<strong>后继顶替优先原则</strong>，即27被删除，则拿27的后继28来顶替。</li>
<li>将28元素替到27原来的位置，同时将右子节点中的28删去，如下图：<br><img src="https://oscimg.oschina.net/oscnet/up-85fdbd40c1a754b1940a8c3edf02992f702.png" alt=""></li>
<li><code>28,29</code>节点删去28之后，显然k小于了ceil(m/2)-1=2，这时候，<code>29</code>有两个兄弟节点：<code>23,24,26</code>和<code>31,32</code></li>
<li>如果<code>29</code>向<code>23,24,26</code>求援，就会引发<strong>元素租借</strong>的情况，反之，向<code>31,32</code>求援，就会引发<strong>元素合并</strong>的情况</li>
</ul>
</li>
</ol>
<blockquote>
<p>其实向哪边求援都可以，实现不同，最终最多导致B树的形态会稍不一样，但肯定的是，他们都是平衡的树。</p>
</blockquote>
<ol start="2">
<li><p><strong>元素租借</strong></p>
<ul>
<li>重申一下， <strong>元素顶替</strong>操作结束后，B树长这样</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-85fdbd40c1a754b1940a8c3edf02992f702.png" alt=""></li>
<li>假如<code>29</code>向<code>23,24,26</code>求援，那么<code>23,24,26</code>明显有“余粮”，就会触发租借元素的情况。</li>
<li><code>23,24,26</code>不能直接将任意一个元素放到<code>29</code>中来，<code>23,24,26</code>任意元素都比28元素小，如果放置在28元素的右子节点上，就违背了左小右大的原则。</li>
<li>那怎么借呢？既然两个当事人<code>23,24,26</code>和<code>29</code>分别是28元素的左右子节点，那就让28元素进入<code>29</code>，26元素替代28元素的位置，这样就皆大欢喜了。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-7e820bffda4330e8a49b4f6dcfe7761c2ad.png" alt=""></li>
</ul>
</li>
<li><p><strong>元素合并</strong></p>
<ul>
<li>重申一下， <strong>元素顶替</strong>操作结束后，B树长这样</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-85fdbd40c1a754b1940a8c3edf02992f702.png" alt=""></li>
<li>假如<code>29</code>向<code>31,32</code>求援，那么<code>31,32</code>明显没有“余粮”，那么就会引发<strong>元素合并</strong>的情况。</li>
<li><code>29</code>和<code>31,32</code>不能直接合并，因为30元素还在父节点上，按照左小右大的原则，30元素一定要在29元素和31元素之间</li>
<li>那怎么合并呢？既然两个当事人 <code>29</code>和<code>31,32</code>分别是30元素的左右子节点，那就让30元素与<code>29</code>和<code>31,32</code>一起加入合并，这样就皆大欢喜了。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-ff3953493f06bb17b382e8bc1a3d38adf6a.png" alt=""></li>
</ul>
</li>
</ol>
<hr>
<p>这就结束了么？不是的，大家注意到没有，合并元素操作，其实相当于在父节点中删去了一个元素，如果这一次的删除，导致了父节点的元素数量小于ceil(m/2)-1怎么办？</p>
<p>我们来看这种情况，现在我们的原图长这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ff3953493f06bb17b382e8bc1a3d38adf6a.png" alt=""></p>
<ol>
<li><p>接着删除key为40的记录，删除后结果如下图所示。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-7459240a23aa224c93bbfb382960001664c.png" alt=""></li>
</ul>
</li>
<li><p>删完后就剩39一个元素了，没话说，找个兄弟节点合并呗，合并结果如下，可以看到，对于原来的<code>36,41</code>节点来说，相当于36元素被删除了，导致<code>41</code>节点不符合约束。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-752976b81e53a4afd84139727851c16e5a3.png" alt=""></li>
</ul>
</li>
<li><p>这时候，其实有两种策略</p>
<ul>
<li>一种是采用<strong>元素顶替</strong>操作：删了我的36，那就拿39顶替呗。</li>
<li>还有一种是向兄弟节点<code>22,26</code>求援，这时要根据兄弟节点的“余粮”情况，酌情触发<strong>元素合并</strong>或者<strong>元素租借</strong>。</li>
<li>那到底是采用第一种方案好还是第二种方案好呢？</li>
<li><strong>答案是第二种，因为第二种情况，可能触发元素合并</strong>，只要触发元素合并，就有可能降低树的高度，使得B树不仅平衡，而且更加“矮胖”，使查找效率更高。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-71b65cb9f29444227d3fbb8a8e9b84d9130.png" alt=""></li>
</ul>
</li>
</ol>
<blockquote>
<p>所以总结一句话，因为元素合并导致的父节点元素数量不符合约束，执行策略时，优先向可能触发<strong>元素合并</strong>的方向靠拢，有利于使树的高度降低。</p>
</blockquote>
<h2 id="1-4-B树的优点"><a href="#1-4-B树的优点" class="headerlink" title="1.4 B树的优点"></a>1.4 B树的优点</h2><p>如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</p>
<h1 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h1><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别：</p>
<ol>
<li>B+树的<strong>非叶子节点不保存关键字记录的指针</strong>，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</li>
<li>B+树<strong>叶子节点保存了父节点的所有关键字记录的指针</strong>，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li>
<li>B+树<strong>叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针</strong>。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-d16ff524d920d5b2a808b41aedbd6c256b5.png" alt=""></p>
<h2 id="2-1-B-树的插入"><a href="#2-1-B-树的插入" class="headerlink" title="2.1 B+树的插入"></a>2.1 B+树的插入</h2><p>B+树的插入操作和B树的插入操作大同小异，即都满足：</p>
<ol>
<li>还是按照key递增次序排列，遵循左小右大的原则，在叶子节点上找到新元素的定位。</li>
<li>若插入时，插入的节点元素个数小于m-1，则该元素直接插入。</li>
<li>否则，将该节点的元素分裂。</li>
</ol>
<p>但B+树的叶子节点，会包含所有的元素（不像B树，有些元素在叶子节点上，有些元素在非叶子节点上），所以插入操作有一些许的差异。</p>
<p>我们下面还是以5阶B+树为例子，在5阶B+树中，结点最多有4个元素，最少有2个元素。</p>
<ol>
<li><p>空树中插入5：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-533ee1cfa033ba1ce6dd6e4fc9af90c2d7e.png" alt=""></li>
</ul>
</li>
<li><p>依次插入8，10，15：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-dd36b3e0400e00aea397caac07683e5014a.png" alt=""></li>
</ul>
</li>
<li><p>插入16，</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-22a6217fb1ebcb7245d74fb5b4b92659a2e.png" alt=""></li>
<li>这时超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左节点2个记录，右节点3个记录，中间key成为索引结点中的key，分裂后当前节点指向了父节点（根节点）。结果如下图所示：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-f03ece76b29d638675bbc7c937b7b34ee73.png" alt=""></li>
<li><blockquote>
<p>当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。不同实现而已，本质差不多。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>继续插入17</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d0a8d9b2c71ffd1a692dd88fc44ec6bca10.png" alt=""></li>
</ul>
</li>
<li><p>插入18，插入后当前节点的关键字个数大于5，进行分裂。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-0ea3104f7c970ceb6bba681de50de17f63d.png" alt=""></li>
<li>分裂成两个节点，左节点2个记录，右节点3个记录，关键字16进位到父节点（索引类型）中，将当前结点的指针指向父结点。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-f92dccd11f24b2ddbb8200c36386da6375d.png" alt=""></li>
</ul>
</li>
<li><p>插入若干数据后：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-40118bf9f9ac718d72d7512dab23e9e83d7.png" alt=""></li>
</ul>
</li>
<li><p>在上图中插入7，结果如下图所示</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d9bcc83498f32e2b879edfef356dafcaa62.png" alt=""></li>
<li>此时当前节点的关键字个数超过4，需要分裂。左节点2个记录，右节点3个记录。分裂后关键字7进入到父节点中，将当前结点的指针指向父节点</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-24fbbe8a4fa67721cc8a833a73f4d097ec8.png" alt=""></li>
<li>当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-c2532b2da7da86911713593d79715fbc13f.png" alt=""></li>
</ul>
</li>
</ol>
<h2 id="2-2-B-树的删除"><a href="#2-2-B-树的删除" class="headerlink" title="2.2 B+树的删除"></a>2.2 B+树的删除</h2><p>回顾上文的B树的删除，我们知道B树有元素直删，元素租借，元素合并和元素顶替这四个操作场景，B+树与B树大同小异，几乎没有区别。只不过B+树没有元素顶替</p>
<blockquote>
<p>B+树没有元素顶替，是因为B+树的叶子节点，有所有的键值对信息，所以不存在删除的键值对不是叶子节点的情况。</p>
</blockquote>
<p>我们下面还是以5阶B+树为例子，在5阶B+树中，结点最多有4个元素，最少有2个元素。</p>
<p>初始状态如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7a9ce40e582bd61f21ceea7a2c5c425afc3.png" alt=""></p>
<ol>
<li><p><strong>元素直删</strong></p>
<ul>
<li>在上图基础上删除22</li>
<li>删除后叶子结点中key的个数大于等于2，删除结束</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-cab4eaee78777158a52dca0e9a554519d4a.png" alt=""></li>
</ul>
</li>
<li><p><strong>元素租借</strong></p>
<ul>
<li>在元素直删完了之后的基础上，再删除15，得到下图：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-ccdd113bc8eaa609f57b6b27d1f8e094971.png" alt=""></li>
<li>删除后当前结点只有一个元素，不满足条件，而兄弟结点有三个元素（注意，当前节点的兄弟节点只有<code>[7,8,9]</code>），则可以向兄弟节点借一个元素过来。当然，根据排序原则，只能借9。</li>
<li>9元素去到<code>[10]</code>节点之后，那么索引也要相应的更改，否则也不满足排序原则，即原来非叶子节点中的10改为9：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-48d63a5170d2cece2d2e75cdabbd24d0cf9.png" alt=""></li>
</ul>
</li>
<li><p><strong>元素合并</strong></p>
<ul>
<li>在元素租借完了之后，我们再删除7，删除后的结果如下图所示：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-ea526d3b627c7f71a782ceec9b797b1da95.png" alt=""></li>
<li>可以看到，删除完了以后，当前节点元素个数小于2，且左右节点的元素数量都是2，即都没有富余的元素。</li>
<li>这时候我们选择元素合并，可以选择和左兄弟合并，也可以和右兄弟合并，这里我们选择左兄弟。</li>
<li>合并的时候我们前文说过，为了保证顺序，兄弟节点还会将父节点中对应的元素一起纳入合并，即<code>[5,6]</code>、<code>[8]</code>会和父节点中的7一起合并，不过这次删除的是7，所以7不存在了，故而，得到：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-bd7d531937d2ff85149f47b4cfa4abd8e33.png" alt=""></li>
<li>不过注意，因为7索引的删除，导致了父节点只剩下了一个元素9，这显然不符合数量约束。</li>
<li><code>[9]</code>的兄弟节点也没有余粮，则只能拉着父节点的元素16，和右兄弟<code>[18,20]</code>合并。得到下图：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-800c466ff5b23af3ababd1500a297fb1fc2.png" alt=""></li>
</ul>
</li>
</ol>
<blockquote>
<p>其实说是没有元素顶替，但为了便于理解，也可以用元素顶替的思路来看最后这个删除操作：<br>1.因为删除的是7，7也在非叶子节点上，所以7删除了，要从子节点中找一个元素来顶替。<br>2.不论是8顶替上去还是6顶替上去，都会使得有个子节点数量不符合，触发元素合并。<br>3.这时候左右节点的元素+他们关联的父节点的元素合并，得到的结果，还是<code>[5,6,8]</code></p>
</blockquote>
<h2 id="2-3-B-树的优点"><a href="#2-3-B-树的优点" class="headerlink" title="2.3 B+树的优点"></a>2.3 B+树的优点</h2><ol>
<li><p>B+树的层级更少：相较于B树，B+每个非叶子节点存储的元素数更多（因为B+树的非叶子节点不存data，相同容量下可容纳的元素更多），使得B+树相对于B树更加“矮胖”，即B+树的层级更少<strong>所以查询数据更快</strong>；</p>
</li>
<li><p>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定。不像B树，有时候在非叶子节点上找到，那就相对快，有时候在叶子节点上找到，那就相对慢。</p>
</li>
<li><p>B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p>
</li>
<li><p>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p>
</li>
</ol>
<h2 id="2-4-为什么B-树比B树更适合做数据库索引？"><a href="#2-4-为什么B-树比B树更适合做数据库索引？" class="headerlink" title="2.4 为什么B+树比B树更适合做数据库索引？"></a>2.4 为什么B+树比B树更适合做数据库索引？</h2><p>其实理由也正是基于上诉的优势而言，不过我们把语义按照数据库索引适配性的角度转化一下：</p>
<ol>
<li><p>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>
</li>
<li><p>B+树的查询效率更加稳定：由于非叶节点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
<li><p>对范围查询的适配性好：在数据库中基于范围的查询是非常频繁的，B树不支持这样的操作或者说效率太低。而B+树只需要去遍历叶子节点的链表，就可以实现整棵树的范围查询。</p>
</li>
<li><p>全节点遍历更快：由于B+树的数据都存储在叶子节点中，分支节点均为索引，方便扫库，只需要扫一遍叶子节点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/09/Redis%E7%9A%84%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/09/Redis%E7%9A%84%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%8B%E7%BB%8D/" itemprop="url">Redis的缓存雪崩/缓存穿透/缓存预热+布隆过滤器介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-09T23:10:36+08:00">
                2020-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/09/Redis%E7%9A%84%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%8B%E7%BB%8D/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/04/09/Redis的缓存雪崩-缓存穿透-缓存预热-布隆过滤器介绍/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis作为当下最主流的数据缓存中间件，在实际的运作过程中，有如下几个场景需要特别注意：</p>
<h1 id="1-缓存雪崩"><a href="#1-缓存雪崩" class="headerlink" title="1. 缓存雪崩"></a>1. 缓存雪崩</h1><ul>
<li>有时：<ul>
<li>缓存<strong>集中</strong>过期失效。(例如：我们短时间设置大量数据的缓存时采用了相同的过期时间，就会在同一时刻出现<strong>大面积</strong>的缓存过期)</li>
</ul>
</li>
<li>由于<ul>
<li>大量的原本应该访问缓存的请求都因为缓存失效而降级到查询数据库了</li>
</ul>
</li>
<li>导致<ul>
<li>短时间内对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</li>
</ul>
</li>
<li>解决办法<ul>
<li>加锁：大多数系统设计者考虑用加锁（ 最多的解决方案）或者请求队列的方式来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。</li>
<li>分散过期时间：还有一个简单方案就是将缓存失效时间分散开，比如加一个随机因子，使过期时间离散。</li>
</ul>
</li>
</ul>
<h1 id="2-缓存穿透"><a href="#2-缓存穿透" class="headerlink" title="2. 缓存穿透"></a>2. 缓存穿透</h1><p>缓存穿透又叫缓存击穿</p>
<ul>
<li>有时：<ul>
<li>请求查询一个数据库不存在的数据</li>
</ul>
</li>
<li>由于<ul>
<li>我们查询数据库结果为空的时候，不会把这个空结果放入缓存</li>
</ul>
</li>
<li>导致<ul>
<li>每次查询一个不存在的数据，都不会命中缓存（因为这样的缓存不存在）。促使请求都会降级到数据库上，就像缓存被击穿了一样。</li>
<li>假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行攻击。</li>
</ul>
</li>
<li>解决办法<ul>
<li>缓存空值：如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-285596d7081eb41f0b086b576e3c8c9f2dc.png" alt=""></li>
</ul>
</li>
<li><strong>布隆过滤器（Bloom Filter）</strong>：推荐！将所有可能存在的key都插入到Bloom Filter中，这样肯定不存在的key就可以被Bloom Filter过滤。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-bbe545bafc0b2bd1db268f4236a6779dd05.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-1-布隆过滤器"><a href="#2-1-布隆过滤器" class="headerlink" title="2.1 布隆过滤器"></a>2.1 布隆过滤器</h2><p>布隆过滤器（Bloom Filter）由Burton Howard Bloom在1970年提出，是一种<strong>空间效率高的概率型数据结构</strong>。它专门用来<strong>快速判断一个元素是否在一个集合中</strong>。听起来是很稀松平常的需求，为什么要使用BF这种数据结构呢？</p>
<h3 id="2-1-1-背景"><a href="#2-1-1-背景" class="headerlink" title="2.1.1 背景"></a>2.1.1 背景</h3><p>回想一下，我们平常在检测集合中是否存在某元素时，都会采用比较的方法。考虑以下情况：</p>
<ul>
<li>如果集合用线性表存储，查找的时间复杂度为<code>O(n)</code>。</li>
<li>如果用平衡BST（如AVL树、红黑树）存储，时间复杂度为<code>O(logn)</code>。</li>
<li>如果用哈希表存储，并用链地址法与平衡BST解决哈希冲突（参考JDK8的HashMap实现方法），时间复杂度也要有<code>O[log(n/m)]</code>，m为哈希分桶数。</li>
</ul>
<p>总而言之，当集合中元素的数量极多时，不仅查找会变得很慢，而且占用的空间也会大到无法想象。Bloom Filter就是解决这个矛盾的利器。</p>
<h3 id="2-1-2-原理"><a href="#2-1-2-原理" class="headerlink" title="2.1.2 原理"></a>2.1.2 原理</h3><ul>
<li><p>Bloom Filter是由一个长度为m的bit数组（bit array）与k个哈希函数（hash function）组成的数据结构。bit数组均初始化为0，所有哈希函数都可以分别把输入数据尽量均匀地散列。</p>
<ul>
<li><p>如下图：假设m=10，k=2，即有f1和f2两个哈希函数。</p>
</li>
<li><p><img src="https://oscimg.oschina.net/oscnet/up-d44d0129d59f8e447fc3a001b8b812ee5f7.png" alt=""></p>
</li>
</ul>
</li>
<li><p>当要插入一个元素时，将其数据分别输入k个哈希函数，产生k个哈希值。以哈希值作为位数组中的下标，将所有k个对应的比特置为1。</p>
<ul>
<li>如下图，假设输入的数据是N1，经过计算f1(N1)得到的数值得为2，f2(N1)得到的数值为5，则将数组下标为2和下表为5的位置置为1</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-f206e03a7c921beb284aecceef5f23c15bc.png" alt=""></li>
</ul>
</li>
<li><p>当要查询（即判断是否存在）一个元素时，同样将其数据输入哈希函数，然后检查对应的k个比特。如果有任意一个比特为0，表明该元素一定不在集合中。如果所有比特均为1，表明该集合有（较大的）可能性在集合中。</p>
<ul>
<li>假设这时候查询N存不存在，将其带入f1和f2，得到结果r1和r2，分别检查r1和r2下标对应的bit数组元素值，假设为b1和b2<ul>
<li>b1和b2有任意一个比特为0，表明该元素一定不在集合中。</li>
<li>b1和b2均为1，表明该集合有（较大的）可能性在集合中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么不是一定在集合中呢？因为一个比特被置为1有可能会受到其他元素的影响，这就是所谓“假阳性”（false positive）。相对地，“假阴性”（false negative）在BF中是绝不会出现的。</p>
</blockquote>
<p>下图示出一个m=18, k=3的BF示例。集合中的x、y、z三个元素通过3个不同的哈希函数散列到位数组中。当查询元素w时，因为有一个比特为0，因此w不在该集合中。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-84458ab74b6816feec64b038c115d9b28e3.png" alt=""></p>
<h3 id="2-1-3-优缺点"><a href="#2-1-3-优缺点" class="headerlink" title="2.1.3 优缺点"></a>2.1.3 优缺点</h3><p>BF的优点是显而易见的：</p>
<ol>
<li>不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；</li>
<li>时间效率也较高，插入和查询的时间复杂度均为O(k)；</li>
<li>哈希函数之间相互独立，可以在硬件指令层面并行计算。</li>
</ol>
<p>但是，它的缺点也同样明显：</p>
<ol>
<li>存在假阳性的概率，不适用于任何要求100%准确率的情境；（缓存击穿就不需要100%过滤不存在的key，所以适合）</li>
<li>只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的。我们可以简单地想到通过计数（即将一个比特扩展为计数值）来记录元素数，但仍然无法保证删除的元素一定在集合中。</li>
</ol>
<p>所以，Bloom Filter在对查准度要求没有那么苛刻，而对时间、空间效率要求较高的场合非常合适，另外，由于它不存在假阴性问题，所以用作“不存在”逻辑的处理时有奇效。目前来看，他有如下三个使用场景:</p>
<ul>
<li>网页爬虫对URL的去重，避免爬取相同的URL地址</li>
<li>反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）</li>
<li>缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。</li>
</ul>
<h3 id="2-1-4-假阳性率的计算"><a href="#2-1-4-假阳性率的计算" class="headerlink" title="2.1.4 假阳性率的计算"></a>2.1.4 假阳性率的计算</h3><p>假阳性是Bloom Filter最大的痛点，因此有必要权衡，比如计算一下假阳性的概率。为了简单一点，就假设我们的哈希函数选择位数组中的比特时，都是等概率的。当然在设计哈希函数时，也应该尽量满足均匀分布。</p>
<ul>
<li><p>在位数组长度m的BF中插入一个元素，它的其中一个哈希函数会将某个特定的比特置为1。因此，在插入元素后，该比特仍然为0的概率是：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-c6d9536a6350ebd08be15c8777a21b5d5a2.png" alt=""></li>
</ul>
</li>
<li><p>现有k个哈希函数，并插入n个元素，自然就可以得到该比特仍然为0的概率是：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-e7078b9bc6588c968d8027e79bd5d782915.png" alt=""></li>
</ul>
</li>
<li><p>反过来讲，它已经被置为1的概率就是：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-83013d18edb412ecc14882fe8bd098a2946.png" alt=""></li>
</ul>
</li>
<li><p>也就是说，如果在插入n个元素后，我们用一个不在集合中的元素来检测，那么被误报为存在于集合中的概率（也就是所有哈希函数对应的比特都为1的概率）为：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-948420588b11a4ab1cabb542d33676a7aa0.png" alt=""></li>
</ul>
</li>
<li><p>当n比较大时，根据重要极限公式，可以近似得出假阳性率：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-9ab7a60f7a6e8918ac55b27afe328f8a999.png" alt=""></li>
</ul>
</li>
</ul>
<p>所以，在哈希函数的个数k一定的情况下：</p>
<ul>
<li>位数组长度m越大，假阳性率越低；</li>
<li>已插入元素的个数n越大，假阳性率越高。</li>
</ul>
<blockquote>
<p>有一些框架内已经内建了BF的实现，免去了自己实现的烦恼。比如Guava 27.0.1版本的源码，BF的具体逻辑位于com.google.common.hash.BloomFilter类中</p>
</blockquote>
<h1 id="3-缓存预热"><a href="#3-缓存预热" class="headerlink" title="3. 缓存预热"></a>3. 缓存预热</h1><ul>
<li>定义<ul>
<li>缓存预热是一个比较常见的概念，即系统上线后，将相关的缓存数据直接加载到缓存系统。这样用户就可以直接查询事先被预热的缓存数据，避免在用户请求的时候，先查询数据库，然后再将数据缓存。</li>
</ul>
</li>
</ul>
<ul>
<li>解决思路<ol>
<li>直接写个缓存刷新开关，上线时手工操作下；</li>
<li>数据量不大，可以在项目启动的时候自动进行加载；</li>
<li>定时刷新缓存；</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/08/TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" itemprop="url">TCP协议分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-08T22:01:51+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/08/TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/04/08/TCP协议分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  16.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  59
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-TCP协议概述"><a href="#1-TCP协议概述" class="headerlink" title="1. TCP协议概述"></a>1. TCP协议概述</h1><p>TCP协议，全称Transmission Control Protocol（传输控制协议），是一种<strong>全双工通信</strong>、<strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流的</strong>传输层通信协议。</p>
<ol>
<li><p>全双工通信：即建立TCP连接之后，通信双方都可以发送数据。</p>
</li>
<li><p>面向连接：意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。</p>
<ul>
<li>这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。</li>
</ul>
</li>
<li><p>可靠：IP层并不保证数据报一定被正确地递交到接收方，TCP负责在超时或者传输失败后，重传没有递交成功的数据报。</p>
<ul>
<li>即使被正确递交的数据报，也可能存在错序的问题，这也是TCP的责任，它必须把接收到的数据报重新装配成正确的顺序。</li>
</ul>
</li>
<li><p>基于字节流：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序传来的数据块看成是一连串的无结构的字节流。由TCP传递给IP的信息单位称为报文段或段（segment）</p>
<ul>
<li>TCP有一个缓冲，TCP发送报文时，是将应用层数据写入TCP缓冲区中，然后由TCP协议来控制发送这里面的数据，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>发送的状态是按字节流的方式发送的，跟应用层写下来的报文长度没有任何关系，所以说是流。</li>
</ul>
</li>
</ol>
<blockquote>
<p>面向字节流的概念，打个比方：<br>一个蓄水池，有出水口和进水口，开几次进水口和开几次出水口是没有必然联系的，也就是说你可以只进一次水，然后分10次出完（即一次write，可以分10次read读取）。另外，水池里的水接多少就会少多少；往里面进多少水，就会增加多少水，但是不能超过水池的容量，多出的水会溢出。</p>
</blockquote>
<p>同时，作为网络协议中举足轻重的传输层协议，TCP协议有这些优秀的机制保证其最为重视的数据可靠性：</p>
<ol>
<li>超时重传</li>
<li>拥塞处理</li>
<li>滑动窗口</li>
</ol>
<p>我们将在后面的篇幅中介绍他们。</p>
<h2 id="1-1-TCP和UDP的区别"><a href="#1-1-TCP和UDP的区别" class="headerlink" title="1.1 TCP和UDP的区别"></a>1.1 TCP和UDP的区别</h2><p>和UDP相比，TCP协议有如下差异：</p>
<table>
<thead>
<tr>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>面向连接（如打电话要先拨号建立连接）</td>
<td>无连接（发送数据之前不需要建立连接）</td>
</tr>
<tr>
<td>传输可靠（通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达）</td>
<td>传输不可靠（尽最大努力交付，即不保证可靠交付）</td>
</tr>
<tr>
<td>面向字节流（把数据看成一连串无结构的字节流）</td>
<td>面向报文（无脑传递上下层的报文）</td>
</tr>
<tr>
<td>适合传输大量数据</td>
<td>适合传输少量数据</td>
</tr>
<tr>
<td>全双工的可靠信道</td>
<td>不可靠信道</td>
</tr>
<tr>
<td>首部开销20字节</td>
<td>首部开销8个字节</td>
</tr>
<tr>
<td>连接只能是点到点</td>
<td>支持一对一，一对多，多对一和多对多的交互通信</td>
</tr>
<tr>
<td>速度慢（需要建立连接、发送确认包等））</td>
<td>速度快</td>
</tr>
<tr>
<td>对系统资源的要求较多</td>
<td>对系统资源的要求较少</td>
</tr>
</tbody></table>
<h2 id="1-2-TCP协议应用场景"><a href="#1-2-TCP协议应用场景" class="headerlink" title="1.2 TCP协议应用场景"></a>1.2 TCP协议应用场景</h2><p>TCP协议是运输层协议，其服务对象自然是应用层。</p>
<p>TCP主要应用在：要求通信数据可靠时，即数据要准确无误地传递给对方如：</p>
<ol>
<li>传输文件：HTTP、HTTPS、FTP等协议；</li>
<li>传输邮件：POP、SMTP等协议</li>
<li>万维网：HTTP协议</li>
<li>文件传输：FTP协议</li>
<li>电子邮件：SMTP协议</li>
<li>远程终端接入：TELNET协议</li>
</ol>
<h2 id="1-3-如何保证可靠性"><a href="#1-3-如何保证可靠性" class="headerlink" title="1.3 如何保证可靠性"></a>1.3 如何保证可靠性</h2><p>TCP通过下列方式来提供可靠性：</p>
<ol>
<li><p>缓冲区：基于缓冲区，应用数据被分割成TCP认为最适合发送的数据块。</p>
</li>
<li><p>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
</li>
<li><p>接收确认：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</p>
</li>
<li><p>校验：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。</p>
</li>
<li><p>重新排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</p>
</li>
<li><p>既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。</p>
</li>
<li><p>TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</p>
</li>
</ol>
<h2 id="1-4-TCP连接的实质"><a href="#1-4-TCP连接的实质" class="headerlink" title="1.4 TCP连接的实质"></a>1.4 TCP连接的实质</h2><p>我们都知道TCP是面向连接的服务，所有要通过TCP进行通信的应用都要先建立连接才能通信，在通信完毕之后要记得关闭连接。但是TCP连接到底是什么东西呢？</p>
<p>这里先说结论，连接实际上是操作系统内核的一种数据结构，称为TCP控制块（TCB），对于linux而言是tcp_sock结构。不光连接，连数据包也是由一个数据结构来控制，linux里面称为sk_buff结构。</p>
<h3 id="1-4-1-为什么要有TCB"><a href="#1-4-1-为什么要有TCB" class="headerlink" title="1.4.1 为什么要有TCB"></a>1.4.1 为什么要有TCB</h3><ul>
<li><p>当应用希望写数据时，</p>
<ul>
<li>不是直接向网卡驱动发数据，而是经过先放入到一个socket发送缓冲区中</li>
<li>然后根据一定算法（达到一定数量或者调用flush之后），缓冲区中的数据就会被网卡从缓冲区中拷贝出来，再层层封装，最后经过物理层传输。</li>
</ul>
</li>
<li><p>当网卡收到数据时</p>
<ul>
<li>会通过DMA直接发送到内存缓冲区中（网卡驱动提前向操作系统申请的一块内存，并且驱动会提前告诉网卡这块内存的地址（注意是物理地址）和大小。如果没有这块内存缓冲区，那么网卡会直接将数据丢掉）</li>
<li>然后给CPU发送一个中断信号，通知操作系统一个数据包到了。</li>
<li>数据包要先经过校验，分用等操作，到了TCP层，处理程序此时根据TCP首部中的端口号选择一个socket，并将其载荷数据拷贝进socket接收缓冲区。</li>
<li>根据TCP首部中的端口号选择一个socket，如何选择呢？这里TCP是利用连接<strong>四元组&lt;源IP地址，源端口号，目标IP地址，目标端口号&gt;</strong>，并以这个四元组为key，查找hash表找到对应的socket的socket结构指针，并利用该指针找到对应socket的接收缓冲区，并将载荷数据拷贝进去。</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以到这里，我们就应该知道，每个socket结构必须要有自己独立的发送缓冲区和接收缓冲区</p>
</blockquote>
<h3 id="1-4-2-什么是Socket"><a href="#1-4-2-什么是Socket" class="headerlink" title="1.4.2 什么是Socket"></a>1.4.2 什么是Socket</h3><p>socket是什么呢，实际上socket是对TCP/IP协议的封装，它的出现只是使得程序员更方便地使用TCP/IP协议栈而已。socket本身并不是协议，它是<strong>应用层与TCP/IP协议族通信的中间软件抽象层，是一组调用接口（TCP/IP网络的API函数）</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-238e16f14108123af496a6e952926908689.png" alt=""></p>
<p>或者换句话说，<strong>socket是TCP/IP协议实现的封装，和暴露给应用层的函数</strong>。他将网络底层复杂的实现统统隐藏，给应用程序方便的使用接口。</p>
<p>在网络通信方面，socket也有很多种，根据不同协议的实现，也有TCP通信的Socket，UDP通信的DatagramSocket，以及与SSL相关JSSE中的SSLSocket，以及这些非阻塞的SocketChannel,DatagramChannel,SSLEngine在安全方面，JCA,JCE,JAAS等等</p>
<h3 id="1-4-3-HTTP短连接和长连接"><a href="#1-4-3-HTTP短连接和长连接" class="headerlink" title="1.4.3 HTTP短连接和长连接"></a>1.4.3 HTTP短连接和长连接</h3><p>对于HTTP 1.0的http标准而言，默认连接是短连接，什么是短连接？就是服务器当发送完最后一个字节的数据之后将关闭连接，也就是回收tcp_sock结构，这样，如果客户端再发送数据给服务器，将直接丢弃。即使此时客户端还有这样的结构，但是我们说连接已经关闭或者已经断了。</p>
<p>HTTP 1.1引入了长连接的概念，并把它搞成了默认的连接方式。什么是长连接？就是当完成一个业务之后，socket结构并不回收。这样，只要在socket结构还存在的时候，客户端发送的任何数据，服务器都可以收到，这就是所谓的长连接。</p>
<h1 id="2-TCP的首部"><a href="#2-TCP的首部" class="headerlink" title="2. TCP的首部"></a>2. TCP的首部</h1><p>TCP数据被封装在一个IP数据报中</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7c3a2ac388604594ca4646e53a3c1dbc488.png" alt=""></p>
<blockquote>
<p>注意：TCP的包是没有IP地址的，那是IP层上的事。TCP只负责源端口和目标端口的维护。</p>
</blockquote>
<h2 id="2-1-源端口和目的端口"><a href="#2-1-源端口和目的端口" class="headerlink" title="2.1 源端口和目的端口"></a>2.1 源端口和目的端口</h2><p><strong>源端口</strong>和<strong>目的端口</strong>：各占16位2个字节，分别存放源端口号和目的端口号。用于寻找发端和收端应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址，能唯一确定一个TCP连接。</p>
<h2 id="2-2-序号"><a href="#2-2-序号" class="headerlink" title="2.2 序号"></a>2.2 序号</h2><p><strong>序号</strong>：简称seq（sequence number），占32位4个字节。序号范围是[0，2^32 - 1]，共2^32 （即4294967296）个序号。序号增加到2^32-1后，下一个序号就又回到0。</p>
<ul>
<li>TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个<strong>字节</strong>都按顺序编号。</li>
<li>TCP会话建立后，会话的<strong>每一端</strong>都自己维护一个32位（bit）的序号，该序号被用来跟踪该端发送的数据量。这个端每发送一个字节的数据，它维护的序号+1；</li>
<li><strong>当一个TCP会话开启时，它两端的初始序号都是随机的，可能是0和2^32 - 1(即4,294,967,295)之间的任意值</strong></li>
<li>TCP会话的某一端在发送报文段时，会将计算出的报文段<strong>数据</strong>的第一个字节的序号写入首部的序号字段中。</li>
<li>首部中的序号字段值则是指的是<strong>本报文段所发送的数据的第一个字节的序号</strong>。</li>
<li>例如，一报文段的序号是301，而数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。<ul>
<li>显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。</li>
</ul>
</li>
</ul>
<blockquote>
<p>TCP会话建立后，每一端都要各自初始化一个seq，<strong>这个初始的seq称作ISN（Inital Sequence Number）</strong></p>
</blockquote>
<blockquote>
<p>TCP会话的任意端的ISN为什么要是随机的而不是写死的呢？试想：假如连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。</p>
</blockquote>
<blockquote>
<p>RFC793中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – Wikipedia语条），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</p>
</blockquote>
<h2 id="2-3-确认号"><a href="#2-3-确认号" class="headerlink" title="2.3 确认号"></a>2.3 确认号</h2><p><strong>确认号</strong>：简称Ack（acknowledgement number），占32位4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。仅当控制位ACK = 1时确认号字段才有效。</p>
<ul>
<li>例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。</li>
<li>因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。</li>
<li>总之：B给A发送的报文确认号为= N，则表明：到序号N-1为止的所有数据B都已正确收到。</li>
</ul>
<blockquote>
<p>确认号（acknowledgement number）简称Ack序号，不要将确认序号Ack与下面即将介绍的控制位中的ACK搞混了。</p>
</blockquote>
<h2 id="2-4-数据偏移"><a href="#2-4-数据偏移" class="headerlink" title="2.4 数据偏移"></a>2.4 数据偏移</h2><p><strong>数据偏移</strong>：占32位4个字节，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP<strong>报文段的首部长度</strong>。</p>
<ul>
<li>由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。</li>
<li>由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。<h2 id="2-4-保留"><a href="#2-4-保留" class="headerlink" title="2.4 保留"></a>2.4 保留</h2></li>
</ul>
<p><strong>保留</strong>：占6位，保留为今后使用，但目前应置为0 。</p>
<h2 id="2-6-6个控制位"><a href="#2-6-6个控制位" class="headerlink" title="2.6 6个控制位"></a>2.6 6个控制位</h2><p><strong>6个控制位</strong>：用来说明本报文段的性质。</p>
<ol>
<li><p><strong>紧急URG（URGent）</strong> 当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。</p>
<ul>
<li>例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。</li>
<li>当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</li>
</ul>
</li>
<li><p><strong>确认ACK（ACKnowledgment）</strong> 仅当ACK = 1时确认号字段才有效，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p>
</li>
<li><p><strong>推送 PSH（PuSH）</strong> 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。<strong>接收方TCP收到PSH=1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付</strong>。</p>
</li>
<li><p><strong>复位RST（ReSeT）</strong> 当RST=1时，表示TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p>
</li>
<li><p><strong>同步SYN（SYNchronization）</strong> 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p>
</li>
<li><p><strong>终止FIN（FINis，意思是“完”“终”）</strong> 用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>
</li>
</ol>
<blockquote>
<p>ACK和SYN将在下节详述。</p>
</blockquote>
<h2 id="2-7-窗口"><a href="#2-7-窗口" class="headerlink" title="2.7 窗口"></a>2.7 窗口</h2><p><strong>窗口</strong>：占16位2字节。窗口值是【0，2^16-1（65535）】之间的整数。<strong>窗口值告诉对方：从本报文段首部中的确认号算起，我目前允许你发送的数据量（以字节为单位）是这个值的量</strong>。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。TCP的流量控制由连接的每一端通过声明的窗口大小来提供。</p>
<h2 id="2-8-检验和"><a href="#2-8-检验和" class="headerlink" title="2.8 检验和"></a>2.8 检验和</h2><p><strong>检验和</strong>：占16位2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部（<strong>具体过程可见《UDP协议分析》一文的校验过程</strong>）。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。</p>
<h2 id="2-9-紧急指针"><a href="#2-9-紧急指针" class="headerlink" title="2.9 紧急指针"></a>2.9 紧急指针</h2><p><strong>紧急指针</strong>：占16位2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据排在数据的最前面，紧急数据结束后就是普通数据） 。</p>
<ul>
<li>因此，在紧急指针指出了紧急数据的末尾在报文段中的位置（紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。）。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。<h2 id="2-10-选项"><a href="#2-10-选项" class="headerlink" title="2.10 选项"></a>2.10 选项</h2></li>
</ul>
<p><strong>选项</strong>：长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p>
<ol>
<li>TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie），在连接建立的时候，即在发送SYN段的时候，同时会将MSS发送给对方（MSS选项只能出现在SYN段中！！！），<strong>告诉对端他期望接收的TCP报文段数据部分最大长度</strong>。<ul>
<li>注意MSS这个名词含义。MSS是每一个TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。</li>
</ul>
</li>
<li>窗口扩大选项：窗口扩大选项是为了扩大窗口。我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。<ul>
<li>窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2（16+14）-1=230-1。</li>
<li>窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S=0选项，使窗口大小回到16。</li>
</ul>
</li>
<li>时间戳选项：时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个概念：<ul>
<li>用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。</li>
<li>用于处理TCP序号超过2^32 的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加2 ^32 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。<ul>
<li>例如，当使用1.5Mbit/s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit/s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-7ada90d37ad88cecc0f6abc535d49d3afde.png" alt=""></p>
<p>每个选项的开始是1字节kind字段，说明选项的类型。kind字段为0和1的选项仅占1个字节。其他的选项在kind字节后还有len字节。它说明的长度是指总长度，包括kind字节和len字节。</p>
<h1 id="3-TCP连接的建立与终止"><a href="#3-TCP连接的建立与终止" class="headerlink" title="3. TCP连接的建立与终止"></a>3. TCP连接的建立与终止</h1><p>TCP是一个面向连接的协议。无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。</p>
<blockquote>
<p>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</p>
</blockquote>
<p>前面我们介绍的TCP的首部字段，其中有三个字段，和TCP的连接有密切关系，他们分别是</p>
<ol>
<li><p>序号（sequence number）：Seq序号，前面说过，tcp会话中的端会对它发送的每个字节进行编号，一个报文段的序号值=本报文段所发送的数据的第一个字节的序号。</p>
</li>
<li><p>确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p>
</li>
<li><p>标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。其中重点是：</p>
<ul>
<li>SYN：表示发起一个新连接。</li>
<li>ACK：表示确认序号有效。（其实是用来确认接收到的数据）（注意，这个ACK和确认号Ack不要搞混！！！！）</li>
<li>FIN：表示释放一个连接。</li>
</ul>
</li>
</ol>
<p>下图是Wireshark中截出的一段tcp交互的seq和ack变化过程。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-922d63a4f387ec7844f4e507d0da1728b37.png" alt=""></p>
<blockquote>
<p>Wireshark的seq展示的是相对序号，即以ISN=0为基准的序号相对值。并不是ISN就这么刚好是0</p>
</blockquote>
<h2 id="3-1-TCP连接的建立——三次握手"><a href="#3-1-TCP连接的建立——三次握手" class="headerlink" title="3.1 TCP连接的建立——三次握手"></a>3.1 TCP连接的建立——三次握手</h2><p>所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4c580376d1c99db1a4cfbf33fde066cbd49.png" alt=""></p>
<ul>
<li><p>客户端A的TCP向服务端发出连接请求报文段，其首部中的SYN控制位应置为1，并选择序号x（前面说过，一个端的序号初始值是随机的，我们姑且认为它是x），表明传送数据时的第一个数据字节的序号是x。</p>
<ul>
<li>此时客户端进入SYN-SENT状态。</li>
</ul>
</li>
<li><p>服务端B的TCP收到连接请求报文段后，如同意，则发回确认：</p>
<ul>
<li>服务端B在确认报文段中应将SYN置为 1，其确认号ACK置位为x + 1，同时自己这端也会给这个确认报文段写入序号=y。</li>
<li>此时服务端进入SYN-RCVD状态</li>
</ul>
</li>
<li><p>客户端A收到此报文段后，向服务端B给出确认，其确认号置为 y + 1。</p>
<ul>
<li>客户端的TCP通知上层应用进程，连接已经建立。客户端进入ESTABLISHED状态</li>
<li>当运行服务器进程的服务器主机B的TCP收到客户端主机A的确认后，也通知其上层应用进程，连接已经建立。服务端也进入ESTABLISHED状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于客户对报文段进行了编号，它知道哪些序号是期待的，哪些序号是过时的。当客户发现报文段的序号是一个过时的序号时，就会拒绝该报文段，这样就不会造成重复连接。</p>
</blockquote>
<h2 id="3-2-TCP连接的终止——四次分手"><a href="#3-2-TCP连接的终止——四次分手" class="headerlink" title="3.2 TCP连接的终止——四次分手"></a>3.2 TCP连接的终止——四次分手</h2><p>数据传输结束后，通信双方都可以释放连接。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4315377ecfaa3273f699ec6718dbf8e4d5a.png" alt=""></p>
<p>看起来比较简单，说是四次分手，<strong>其实就是FIN-ACK的交互，由主动方和被动方先后各执行了一次而已</strong>。上图已经直观展示的过程我们不再赘述，下面说一些比较值得注意的点：</p>
<h3 id="3-2-1-2MSL等待状态"><a href="#3-2-1-2MSL等待状态" class="headerlink" title="3.2.1 2MSL等待状态"></a>3.2.1 2MSL等待状态</h3><p>TIME_WAIT状态也称为2MSL等待状态。主动关闭的端（即上图中的客户端）在发送最后一个ACK的时候，没有立刻关闭，而是等待了2个MSL的时间才关闭。</p>
<p>MSL（Maximum Segment Lifetime），指的是一个报文段最大的生存时间，即一个报文段被丢弃前在网络内的最长时间。我们知道这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。不过不同的TCP实现由不同的MSL设置，我们不去管他到底是何值，只要知道它控制着报文段在网络中的最长生存时间，<strong>如果超过MSL时间报文段还没到达彼端，那么它将被丢弃</strong>。</p>
<p>之所以A端在发送最后一个ACK后还要等待2MSL的时间才关闭，<strong>是因为假如最后一个ACK丢失了，B端会等待ACK超时，然后再重发一个FIN过来，如果A端立刻关闭，它就可能无法响应到这个重发的FIN。只有等待2MSL后A段没有收到B端重发的FIN，A端才会关闭。</strong></p>
<h3 id="3-2-2-半关闭链接"><a href="#3-2-2-半关闭链接" class="headerlink" title="3.2.2 半关闭链接"></a>3.2.2 半关闭链接</h3><p>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭。</p>
<p>显示了一个半关闭的典型例子。假设左方的客户端开始半关闭。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3fb926c3cf588c58785d3d3c0eefd7c58bf.png" alt=""></p>
<ul>
<li><p>初始端发出的FIN，接着是另一端对这个FIN的ACK报文段。<strong>因为接收半关闭的一方仍能发送数据（这是半关闭的基础）</strong>。</p>
</li>
<li><p>我们只显示一个数据报文段和一个ACK报文段，但可能发送了许多数据报文段。</p>
</li>
<li><p>当收到半关闭的一端在完成它的数据传送后，将发送一个FIN关闭这个方向的连接，这将传送一个文件结束符给发起这个半关闭的应用进程。当对第二个FIN进行确认后，这个连接便彻底关闭了。</p>
</li>
</ul>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><ul>
<li><p>建连接为什么需要三次握手？</p>
<ul>
<li>因为通信的双方要互相通知对方自己的ISN（也就上图中的 x 和 y）——所以需要两端各发出一个SYN（全称Synchronize Sequence Numbers，顾名思义，就是用来同步对方自己的ISN的）。ISN后续要作为数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序。</li>
<li>而光有SYN还不够，<strong>发端还要确认对端真的收到了我SYN，而不是我发出去SYN就了事</strong>，所以还有最后一个ACK</li>
</ul>
</li>
<li><p>断连接为什么需要四次挥手</p>
<ul>
<li>因为TCP是全双工的，所以，发送方和接收方都需要各一次的Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。</li>
<li>其实仔细看，挥手比起握手之所以多了一次，主要是收到第一个fin包后单独回复了一个ack包，如果能回复fin+ack那么四次挥手也就变成三次了。</li>
<li>之所以被动端没有在收到fin后回复fin+ack，是因为在CLOSE_WAIT状态阶段，被动端需要去通知应用进程，会有一些时间消耗，所以先回发一个ack，等应用进程确定关闭后，再发送一个fin。否则如果应用进程没有关闭，至少还能维持一个半关闭链接。</li>
<li>如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-2d31a376256d1ac00ef996f1dd52e1a1716.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4-TCP数据的交互"><a href="#4-TCP数据的交互" class="headerlink" title="4 TCP数据的交互"></a>4 TCP数据的交互</h1><p>我们已经在前文的叙述中大概知道了TCP的数据传输，是通过数据和ack的相互交替来确认的，TCP连接的任意一端发送数据，都会捎带一个seq（数据的第一个字节的序号），接收端接收到数据后，返回ACK（控制位）=1，Ack（确认号）=seq+len</p>
<blockquote>
<p>注意，Ack=seq+len，表示的不是它要确认的data的最后一个字节的序号，而是它希望下次接收到的第一个序号。<br>比如，seq=90，len=1，那这唯一的1字节的data，它的序号就是90，Ack=90+1=91，表示它希望下次接受的第一个序号是从91开始。</p>
</blockquote>
<p><img src="https://oscimg.oschina.net/oscnet/up-b4dc1e5e539de60fa74de2a09388dc8eed0.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6c51c255feef37912a51dd9cd89563a46fc.png" alt=""></p>
<h2 id="4-1-捎带确认Delay-ACK"><a href="#4-1-捎带确认Delay-ACK" class="headerlink" title="4.1 捎带确认Delay ACK"></a>4.1 捎带确认Delay ACK</h2><p>通常TCP在接收到数据时并不立即发送ACK，相反，它推迟发送，以便将ACK与需要沿该方向发送的数据（<strong>这个数据可以是应用数据，也可以是另外一个同方向的ACK</strong>）一起发送（有时称这种现象为数据捎带确认），这样做的目的是尽量减少发往网络的报文，以提高传输的效率，节省网络资源。</p>
<p>为了防止产生超时重传，绝大多数情况下，这个等待时间为200ms，超过了200ms，如果没有数据要一起发送，就直接发送ACK报文。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-90e28e43ca3cd1c372709181d9faa0e1687.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2af49e8f61011242f212c658fcd97318e78.png" alt=""></p>
<h2 id="4-2-累计确认和Duplicate-ACK"><a href="#4-2-累计确认和Duplicate-ACK" class="headerlink" title="4.2 累计确认和Duplicate ACK"></a>4.2 累计确认和Duplicate ACK</h2><p>在TCP会话中，发送方对段的发送速度有时候非常快，比如发送方发了A,B,C,D四个段；段A含字节0到10，段B含字节11到20，段C含字节21到30，段D包含字节31到40</p>
<p>接受方成功收到段A，段B，段D，只有段C丢失了。那么接受方<strong>发回一个包含确认序号21的ACK</strong>（而不是分别给段A和段B都回复一个ACK，等于是把段A和段B的ACK合并了一样），发送方收到这个合并的ACK，就知道字节0到20(段A，段B)都成功收到。</p>
<p>通过累积确认的方式，在发送方快速发包的场景，一个ACK可以直接确认<strong>接收方接收到的连续序号的好几个段</strong>，这样减少报文段的传输。</p>
<blockquote>
<p>注意，如果段C没有收到，那么段D即便收到了，接收方也不会回复段D的ACK，因为一旦回复段D的ACK，就表示段D以前的数据都收到了，但其实段C还没收到。</p>
</blockquote>
<p>因为段C丢失，之后接收端即便接收到段E，段F等数据，也只会重复回复确认序号21的ACK，这时我们可以看到，因为段C丢失，接收端重复发送了很多次Ack=21，这种ACK我们称之为<strong>冗余ACK（duplicate ACK）</strong>。</p>
<h2 id="4-3-Nagle算法"><a href="#4-3-Nagle算法" class="headerlink" title="4.3 Nagle算法"></a>4.3 Nagle算法</h2><p>在TCP传输数据流中，存在两种类型的TCP报文段，一种包含成块数据（通常是满长度的，利用缓存，使报文一次发送就携带一个报文段最多容纳的字节数），另一种则包含交互数据（通常只有携带几个字节数据）。</p>
<p>对于成块数据的报文段，TCP采用正常的流程发送即可，因为数据利用率很高。而对于交互数据的报文段（也就是ACK），数据利用率就显得很低（因为ACK一般就一个IP头和TCP头），在网络环境不好的情况下容易加重网络负担。所以TCP必须对交互数据单独处理</p>
<p><strong>nagle算法用于处理小报文段（微小分组）的发送问题，其核心思想是允许网络中最多只能有一个小分组被发送，而待发送的其它小分组会被重新分组成一个”较大的”小分组，等收到上一个小分组的应答后再发送</strong>。</p>
<p>比如客户端需要依次向服务器发送大小为1,2,3,1,2字节的5个分组</p>
<p>在没有开启nagle算法的情况下，这些小分组会被依次发送（不需要等待上一个小分组的应答，因为没启动nagle），总共发送的报文段（分组）个数为5</p>
<p>当开启nagle算法时，客户端首先发送大小为1字节的第一个分组，随后其它分组到达发送缓冲区，由于上一个分组的应答还没有收到，所以TCP会先缓存新来的这4个小分组，并将其重新分组，组成一个大小为8(2+3+1+2)字节的”较大的”小分组。当第一个小分组的应答收到后，客户端将这个8字节的分组发送。总共发送的报文段（分组）个数为2。</p>
<blockquote>
<p>将套接字描述符设置TCP_NODELAY选项可以禁止nagle算法</p>
</blockquote>
<h2 id="4-4-超时重传"><a href="#4-4-超时重传" class="headerlink" title="4.4 超时重传"></a>4.4 超时重传</h2><p>TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。对任何实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传的频率。</p>
<p>下图是一个超时重传的例子：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-09a3bb4827e8903f8b42dacd0385e2d814c.png" alt=""></p>
<ul>
<li>第1、2和3行表示正常的TCP连接建立的过程</li>
<li>第4行是“hello,world”（12个字符加上回车和换行）的传输过程</li>
<li>第5行是其确认。接着我们从svr4拔掉了以太网电缆</li>
<li>第6行表示“andhi”将被发送。第7~18行是这个报文段的12次重传过程，</li>
<li>而第19行则是发送方的TCP最终放弃并发送一个复位信号的过程。</li>
</ul>
<p>连续重传之间不同的时间差，我们整理后发现他们分别为1.5、3、6、12、24、48和多个64秒。这个倍乘关系被称为“指数退避(exponentialbackoff)”。也就是说，每一次超时，等待的时间都会翻倍，直到等待时间为64秒为止。</p>
<p>首次分组传输（第6行，24.480秒）与复位信号传输（第19行，566.488秒）之间的时间差约为9分钟，该时间在目前的TCP实现中，大多数是不可变的。也就是大多数的TCP实现都要尝试9分钟才会放弃。</p>
<h2 id="4-5-选择确认"><a href="#4-5-选择确认" class="headerlink" title="4.5 选择确认"></a>4.5 选择确认</h2><h3 id="4-5-1-SACK"><a href="#4-5-1-SACK" class="headerlink" title="4.5.1 SACK"></a>4.5.1 SACK</h3><p>我们知道累计确认，不会越过接收方未接受到的序号进行确认，如前例中的ABCD四个段，段A含字节0到10，段B含字节11到20，段C含字节21到30，段D包含字节31到40。</p>
<p>段C未收到，那么是不会返回确认号为41的ACK的。即便接收方已经收到了段D。</p>
<p>这种情况下，发送方只接收到了ack=21，那对于发送方而言，它可以有两种理解：</p>
<ol>
<li>段C丢失了</li>
<li>段C和段D都丢失了</li>
</ol>
<p>这时为了保险起见，发送方可能会重传段C和段D，但我们知道其实段D是没有必要重传的。</p>
<p><strong>为了解决这个问题，TCP实现引入了选择确认机制。</strong></p>
<p>选择确认全称叫做Selective Acknowledgment(SACK)，这种方式需要在TCP首部的选项中里加一个SACK的字段，它的工作原理也十分简单，一目了然：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4b6f8eb48e958728610987dacca173647ef.png" alt=""></p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。</p>
<p>选择确认的数据包长这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0374b03864f3bd117915b947228b916fa2c.png" alt=""></p>
<ol>
<li>这个确认包只有tcp首部，没有数据部分</li>
<li>Kind：SACK（5）用来表示这是选择确认（SACK），该字段占用一个字节。</li>
<li>Length表示tcp选项长度，占用一个字节，左边界和右边界各占用4字节，也就是说这里总共用掉了10字节。</li>
<li>其中left edge表示接收方接收到的数据块中的左边界位置（起始字节）</li>
<li>right edge可以理解为接收方接收到的数据块中的结束位置（右边界）</li>
</ol>
<p>也就是说，通过左边界和右边界我们可以指明一个数据块的位置。那么我们可以根据捕获的数据报中的确认号丢失的数据块中的起始字节，也就是要重传的起始字节，再结合接收窗口，左边界和右边界。我们可以推出接收窗口中的已经接收到的数据块，和未接收到的数据块：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-de3184da09ab090ed97fa9c1d071303a2e9.png" alt=""></p>
<p>这样，发送方在进行选择性重传时，会从2336611189字节的位置开始重传。注意：对于已经接收到的字节数据块（2336631881 - 2336693150）是不会被重传的。</p>
<blockquote>
<p>在前面学习TCP首部的时候我们知道，TCP首部中的选项部分最大是40字节，选择确认选项左边界和右边界在指明一个数据块时就用掉了8字节，那么指明4个数据块就用掉了32字节，再加上Kind：SACK（5）和Length两个字段占用的2字节，最终只剩下了6字节，换句话说，TCP选项的选择确认选项最多也就只能指明4个数据块</p>
</blockquote>
<h3 id="4-5-2-Duplicate-SACK"><a href="#4-5-2-Duplicate-SACK" class="headerlink" title="4.5.2 Duplicate SACK"></a>4.5.2 Duplicate SACK</h3><p>Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。</p>
<p>作为对比，SACK是告诉发送方，接受方已经收到了哪些数据，不要混淆。</p>
<p>那什么样的SACK是D-SACK呢？</p>
<p>答案是：</p>
<ol>
<li><p>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</p>
<ul>
<li>假如发送端已经收到了一个ACK报文，内容为：[Ack=4000, SACK=5000-5500, 4500-5500]，Ack=4000表示序号为4000以前的字节都收到了，这时候再看选项中的SACK=3000-3500，那么很显然，SACK框定的字节范围是已经被确认的范围，那么这个SACK是D-SACK，3000-3500也就是被重传的数据段。</li>
</ul>
</li>
<li><p>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</p>
<ul>
<li>假如发送端收到一个[Ack=4000,SACK=5000-5500, 4500-5500]，那么第二个段的区间4500-5500，覆盖了第一个段的区间5000-5500，这表示该SACK是个D-SACK，5000-5499段是重复收到的。</li>
</ul>
</li>
</ol>
<p>D-SACK在如下场景发挥比较积极的作用：</p>
<ol>
<li>ACK丢包<ul>
<li>如果一个发送端发送序号为3000-3999的段，却没收到对应的ACK，那么过一段时间发送端重传该段，紧接着却收到了[Ack=4000,SACK=3000-3999]，那么发送端就知道，之前的那个ACK丢失了。</li>
</ul>
</li>
<li>发送延误<ul>
<li>发送端发送序号为1000-1499的段，这个段因为网络延迟，导致接收端迟迟没有收到。发送端继续发送后面的段，但接收端因为没有收到1000-1499的段，所以只会回复[Ack=1500]</li>
<li>发送端收到3次[Ack=1500]，就会重传这个1000-1499的段，在重传的期间，接收端也收到了姗姗来迟的原来的1000-1499的段，这时面对重传的新段，接收端返回了[Ack=4000, SACK=1000-1499]</li>
<li>发送端通过这个D-SACK，就知道之前发出去的段，是因为网络延迟才迟到的。</li>
</ul>
</li>
</ol>
<p>可见，引入了D-SACK，有这么几个好处：</p>
<ol>
<li><p>可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</p>
</li>
<li><p>是不是自己的timeout太小了，导致重传。</p>
</li>
<li><p>网络上出现了先发的包后到的情况（又称reordering）</p>
</li>
<li><p>网络上是不是把我的数据包给复制了。</p>
</li>
</ol>
<h1 id="5-RTT算法"><a href="#5-RTT算法" class="headerlink" title="5 RTT算法"></a>5 RTT算法</h1><p>从前文的TCP重传机制我们知道Timeout的设置对于重传非常重要：</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。</p>
<p>我们把这里的超时时间命名为RTO（Retransmission TimeOut），为了动态地设置RTO，TCP引入了RTT的概念——Round Trip Time，<strong>也就是一个数据包从发出去到回来的时间</strong>。</p>
<p>听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。但其实没那么简单，这只是一个<strong>采样</strong>，不能代表普遍情况。</p>
<h2 id="5-1-经典算法"><a href="#5-1-经典算法" class="headerlink" title="5.1 经典算法"></a>5.1 经典算法</h2><p>RFC793中定义的经典算法是这样的：</p>
<ol>
<li><p>首先，先<strong>采样</strong>RTT，记下最近好几次的RTT值。</p>
</li>
<li><p>然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）</p>
</li>
</ol>
<p><code>SRTT = ( α * SRTT ) + ((1- α) * RTT)</code></p>
<ol>
<li>开始计算RTO。公式如下：</li>
</ol>
<p><code>RTO = min [UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</code></p>
<pre><code>其中：
UBOUND是最大的timeout时间，上限值
LBOUND是最小的timeout时间，下限值
β 值一般在1.3到2.0之间。</code></pre><h2 id="5-2-Karn-Partridge-算法"><a href="#5-2-Karn-Partridge-算法" class="headerlink" title="5.2 Karn / Partridge 算法"></a>5.2 Karn / Partridge 算法</h2><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p>
<p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li><p>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</p>
</li>
<li><p>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。</p>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-e601aab8b8345e819d0be3da0cee0083ecb.png" alt=""></p>
<p>所以1987年的时候，搞了一个叫Karn / Partridge算法，这个算法的最大特点是——忽略重传，不把重传的RTT做采样（你看，你不需要去解决不存在的问题）。</p>
<p>但是，这样一来，又会引发一个大BUG——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重传所有的包（因为之前的RTO很小，所以很容易就超时），于是，因为重传的不算，所以，RTO就不会被更新，导致包仍非常容易超时，这是一个灾难。 </p>
<p>于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<h2 id="5-3-Jacobson-Karels-算法"><a href="#5-3-Jacobson-Karels-算法" class="headerlink" title="5.3 Jacobson / Karels 算法"></a>5.3 Jacobson / Karels 算法</h2><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看RFC6289）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。</p>
<p>我们每次<strong>采样</strong>，都能得到一个新的RTT，即RTT[新]，除此之外，还引入了</p>
<ol>
<li>SRTT（Smoothed RTT）——平滑 RTT</li>
<li>DevRTT（Deviation RTT）——滑 RTT 和真实的差距</li>
</ol>
<p>这二者的值，每次采样之后都会更新，于是得到公式如下：</p>
<p><code>SRTT[新] = SRTT[旧] + α ( RTT[新] – SRTT[旧] ) —— 计算平滑 RTT</code></p>
<p><code>DevRTT[新] = ( 1-β ) * DevRTT + β * ( | RTT[新] - SRTT[旧]  | ) ——计算平滑 RTT 和真实的差距（加权移动平均）</code></p>
<p><code>RTO= µ * SRTT + ∂ * DevRTT</code></p>
<p>其中：α、β、μ、∂ 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4；</p>
<blockquote>
<p>Jacobson / Karels算法在被用在今天的TCP协议中（Linux的源代码在：tcp_rtt_estimator）。</p>
</blockquote>
<h1 id="6-滑动窗口"><a href="#6-滑动窗口" class="headerlink" title="6 滑动窗口"></a>6 滑动窗口</h1><h2 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h2><p>我们知道TCP正常的交互是这样的：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d7f1cb4dffbb5fa40972503bbaec49f1503.png" alt=""></p>
<p>这带来了一个问题：吞吐量非常的低。我们发完包1，一定要等确认包1.我们才能发送第二个包。</p>
<p>那如何提高吞吐量？我们可不可以连发几个包等他一起确认呢？</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7692e692bb6f30ce6b27ee7c87b04e86023.png" alt=""></p>
<p>这样确实可以提高吞吐量，发送两个包，所花的时间只是原来一个来回的时间。</p>
<p>但是，新的问题又来了，如果我一次把太多的包连发，超过了接收端的处理上限，导致中途一直重传超时的包，即占用了带宽，又提高不了太多的吞吐量，如何制定最优解呢？TCP实现了一种被称为滑动窗口的流控机制</p>
<h2 id="6-2-发送窗口和接受窗口"><a href="#6-2-发送窗口和接受窗口" class="headerlink" title="6.2 发送窗口和接受窗口"></a>6.2 发送窗口和接受窗口</h2><p>滑动窗口解决的是TCP流量控制的问题，即如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。</p>
<p>我们知道TCP是全双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个<strong>发送窗口（本质是一个缓存）</strong> 和一个 <strong>接收窗口（本质是一个缓存）</strong> 。</p>
<ul>
<li>各自的<strong>接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）</strong>。</li>
<li>各自的发送窗口的大小，则取决于<strong>对端</strong>的接收窗口。</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-9679d08b92cf441e4e938245430a4aea2a9.png" alt=""></p>
<p>在TCP的首部中，我们知道有个窗口（Window Size）字段，它是指接收端的窗口大小（单位字节），即接收窗口的大小。用来告知发送端自己所能接收的数据量，从而达到一部分流控的目的。</p>
<p>同时，选项中还有一个窗口扩展选项（Window Scaling)，前文我们也简单介绍过。窗口扩展选项和窗口字段，这二者由接收端通知发送端，最终确定了发送端的发送窗口大小。</p>
<p>因为接受窗口不是恒定的，所以在会话中，接收端可以不断的通知发端改变窗口大小。</p>
<p>假设，我们设定两边的接受窗口为20*MSS（Maxitum Segment Size），那么我们一个窗口，就可以发送20个满数据的段。如下图（方框内的数字为段的编号）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dabdb246da118fbdb57ec82e179ecc68f64.png" alt=""></p>
<p>其中发送端的段可以分成以下四类</p>
<ol>
<li>已发送，已收到ACK</li>
<li><strong>已发送，未收到ACK</strong>（属于发送窗口）</li>
<li><strong>未发送，但允许发送</strong>（属于发送窗口）</li>
<li>未发送，但不允许发送</li>
</ol>
<p>接收端的段可以分成以下三类</p>
<ol>
<li>已接收</li>
<li><strong>未接收但允许接收</strong>（属于接收窗口）</li>
<li>未接收而且不允许接收</li>
</ol>
<h2 id="6-3-滑动机制"><a href="#6-3-滑动机制" class="headerlink" title="6.3 滑动机制"></a>6.3 滑动机制</h2><ol>
<li><p>发送窗口只有收到发送窗口内的段的ACK确认，才会移动发送窗口的左边界。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-946e095931c35d0a80c6c45f6e0cb5ec7d2.png" alt=""></li>
</ul>
</li>
<li><p>接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有段未接收到，但先收到后面段的情况下，窗口不会移动，也不对窗口外的段进行确认。以此确保对端会对这些数据重传。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-4afa13df8020772655f1b44a468790dfda8.png" alt=""></li>
<li>没有收到G的情况下，窗口不会左移，就算收到窗口外的段，也不会进行确认</li>
</ul>
</li>
<li><p>遵循累计确认、选择确认等规则。</p>
</li>
</ol>
<h2 id="6-4-滑动过程"><a href="#6-4-滑动过程" class="headerlink" title="6.4 滑动过程"></a>6.4 滑动过程</h2><p>flash来自一个模拟TCP滑动窗口的动画：<a href="http://www.exa.unicen.edu.ar/catedras/comdat1/material/Filminas3_Practico3.swf" target="_blank" rel="noopener" title="动画地址">动画地址</a></p>
<ol>
<li><p>假定窗口大小为4*MSS，首先发送端发送A,B,C,D四个包，但是A,B丢失，只有C,D到达接收端。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-8109151f2ca10f0c6c5abd0c8774be9c575.png" alt=""></li>
</ul>
</li>
<li><p>接收端没有收到A，所以不回复ACK包。发送端重传的A,B,C,D四个包。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-e2b5a2ab1460977ca81a8e7c2b06a95df45.png" alt=""></li>
</ul>
</li>
<li><p>这次发送端重传的A,B,C,D四个包全都到达了，接收端先获得A，发ACK包A，但是中途丢失；接收端获得B后，根据累计确认的原则，发D的ACK包，然后窗口滑动。再次获得C,D后，连续回复2个D的ACK包，其中C对应的ACK包丢失。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-f1a81ca52edc05a9f46dcb444c3824b9d60.png" alt=""></li>
</ul>
</li>
<li><p>发送端连收2个D的ACK包，说明4个包对方都已收到，窗口滑动，发E,F,G,H包，其中G包丢失。现在整个序列的状态：ABCD是已发送已确认，EFGH是已发送未确认，I~S是不能发送。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-3555fd95fd6e8faeffdeb0ae13375cae18f.png" alt=""></li>
</ul>
</li>
<li><p>收端先收到E，发E的ACK包；收到F后发F的ACK包；未收到G；收到H，还是发F的ACK包。不幸的是，后两个ACK包全都丢失。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-6623f269f126fd0fb5cd19f1baaaf954e8b.png" alt=""></li>
</ul>
</li>
<li><p>送端收到E的ACK包，窗口向右滑动一位，发送I包，然后再发送F,G,H，其中F丢失。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-e8f2ba5ab327822f79d50e6e967fdd25895.png" alt=""></li>
</ul>
</li>
<li><p>接收端获得I，因为没有G，只好回复F的ACK包(不过紧接着这个包丢了)。还好，接收端相继收到G,H包。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-de01d1b06c6fc7422615569cf37c00c7798.png" alt=""></li>
</ul>
</li>
<li><p>接收端根据累计确认，连发两个I包，其中H的ACK丢失。窗口向右滑动。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-dbe0cb2f7a9b9c97322a234015aeeb02c60.png" alt=""></li>
</ul>
</li>
<li><p>发送端接收I的ACK包后，向右滑动四位。发送J,K,L,M四个包，后面不再分析。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-673c5f49f65170fec5d562a36873a83c936.png" alt=""></li>
</ul>
</li>
</ol>
<p>我们之前说过，在会话过程中，窗口大小也是随时可能发生改变的，下图就展示了一次动态的滑动窗口变动过程：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e0a4aec2b9558a73c2e5ad4ca06c6899a3e.png" alt=""></p>
<p>我们可以看到：</p>
<ol>
<li>发送方不必发送一个全窗口大小的数据。</li>
<li>正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的右边沿却不能够向左移动</li>
<li>接收方在发送一个 ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。</li>
</ol>
<h2 id="6-5-零窗口（Zero-Window）"><a href="#6-5-零窗口（Zero-Window）" class="headerlink" title="6.5 零窗口（Zero Window）"></a>6.5 零窗口（Zero Window）</h2><p><img src="https://oscimg.oschina.net/oscnet/up-7a3eaba1fbc9ee71fb59571821a6c77b3f2.png" alt=""></p>
<p>上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第一次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<h2 id="6-6-糊涂窗口综合症（Silly-Window-Syndrome）"><a href="#6-6-糊涂窗口综合症（Silly-Window-Syndrome）" class="headerlink" title="6.6 糊涂窗口综合症（Silly Window Syndrome）"></a>6.6 糊涂窗口综合症（Silly Window Syndrome）</h2><p>我们知道，发送端的发送窗口大小是受馈于接收端通知的接收窗口大小的，如果接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方窗口越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送<strong>这几个字节</strong>。</p>
<p>要知道，我们的TCP+IP头有40个字节，为了<strong>几个字节</strong>，要达上这么大的开销，这太不经济了。糊涂窗口综合症这个现象<strong>就像是你本来可以坐200人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li>如果这个问题是由Receiver端引起的，那么就会使用David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS（以太网MSS为1500字节），或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</li>
<li>如果这个问题是由Sender端引起的，那么就会使用前文介绍的Nagle’s算法。我们知道这个算法的思路也是延时处理，积攒数据，等于一架飞机在等待客人，以便一次能多拉一些人。</li>
</ul>
<h1 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7 拥塞控制"></a>7 拥塞控制</h1><p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。</p>
<p>TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。</p>
<p>试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。这是一个灾难。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了</strong>。</p>
<p>拥塞控制为发送方增加了另一个窗口：<strong>拥塞窗口</strong>(congestionwindow)，记为cwnd。它以字节为单位，和接收方通告发送方的窗口（我们叫做通告窗口）一起，控制发送方的窗口大小——<strong>发送方取拥塞窗口与通告窗口中的最小值作为发送上限</strong>。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</p>
<p>TCP拥塞控制算法发展的过程中出现了如下几种不同的思路：</p>
<ol>
<li>基于丢包的拥塞控制：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如Reno、Cubic等。</li>
<li>基于时延的拥塞控制：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如Vegas、FastTCP等。</li>
<li>基于链路容量的拥塞控制：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如BBR。</li>
<li>基于学习的拥塞控制：没有特定的拥塞信号，而是借助评价函数，基于训练数据，使用机器学习的方法形成一个控制策略，如Remy。</li>
</ol>
<h2 id="7-1-Reno算法"><a href="#7-1-Reno算法" class="headerlink" title="7.1 Reno算法"></a>7.1 Reno算法</h2><p>Reno现有的众多拥塞控制算法的基础，它将拥塞控制的过程分为四个阶段：</p>
<ol>
<li><strong>慢启动</strong></li>
<li><strong>拥塞避免</strong></li>
<li><strong>快速重传</strong></li>
<li><strong>快速恢复</strong></li>
</ol>
<p>这四个阶段的相关算法和处理策略不是一天都搞出来的，这个四阶段算法的发展经历了很多时间，到今天都还在优化中。</p>
<p>Reno算法将收到ACK这一信号作为拥塞窗口增长的依据，在早期低带宽、低时延的网络中能够很好的发挥作用，但是随着网络带宽和延时的增加，Reno的缺点就渐渐体现出来了，发送端从发送报文到收到ACK经历一个RTT，在高带宽延时（High Bandwidth-Delay Product，BDP）网络中，RTT很大，导致拥塞窗口增长很慢，传输速度需要经过很长时间才能达到最大带宽，导致带宽利用率将低。</p>
<p>适用场景：适用于低延时、低带宽的网络。</p>
<h3 id="7-1-1-慢启动（Slow-Start）"><a href="#7-1-1-慢启动（Slow-Start）" class="headerlink" title="7.1.1 慢启动（Slow Start）"></a>7.1.1 慢启动（Slow Start）</h3><p>首先，我们来看一下TCP的慢启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来便无脑向网络发送多个报文段，把现有的传输秩序搞乱。</p>
<p>慢启动的算法如下：</p>
<ol>
<li><p>连接建好的开始先初始化cwnd = 1个MSS，表明可以传一个MSS大小的数据。</p>
</li>
<li><p>每当收到一个ACK，cwnd+1，即相当于每轮次（一个RTT，无拥塞情况下共可收到cwnd个ACK）发送窗口增加一倍，呈指数增长</p>
<ul>
<li><strong>换句话说，一次交互cwnd * 2;</strong></li>
</ul>
</li>
<li><p>还有一个慢启动门限ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（下文介绍）</p>
</li>
</ol>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-48981739b1cce1dabb79d1837b1e0f20583.png" alt=""></p>
<blockquote>
<p>这里需要提一下的是一篇Google的论文《An Argument for Increasing TCP’s Initial Congestion Window》（<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf）" target="_blank" rel="noopener">http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf）</a><br>Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。<br>而Linux 3.0以前，比如2.6，Linux采用了RFC3390，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p>
</blockquote>
<h3 id="7-1-2-拥塞避免"><a href="#7-1-2-拥塞避免" class="headerlink" title="7.1.2 拥塞避免"></a>7.1.2 拥塞避免</h3><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<ul>
<li>收到一个ACK时，cwnd = cwnd + 1/cwnd，即相当于每轮次（一个RTT，无拥塞情况下共可收到cwnd个ACK）发送窗口+1 * MSS，呈线性增长<ul>
<li><strong>换句话说，一次交互cwnd + 1 * MSS ;</strong></li>
</ul>
</li>
</ul>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<p>所以我们可以看到：</p>
<ul>
<li>当cwnd&lt;ssthresh时，使用慢开始算法。</li>
<li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li>
</ul>
<h3 id="7-1-3快速重传"><a href="#7-1-3快速重传" class="headerlink" title="7.1.3快速重传"></a>7.1.3快速重传</h3><p>在介绍拥塞发生时tcp选择的策略时，我们要先了解快速重传策略。</p>
<h4 id="7-1-3-1-快速重传策略"><a href="#7-1-3-1-快速重传策略" class="headerlink" title="7.1.3.1 快速重传策略"></a>7.1.3.1 快速重传策略</h4><p>现有的超时重传机制，还有一些问题：</p>
<ul>
<li>当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。</li>
<li>当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li>
</ul>
<p>幸运的是，由于TCP采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）。<br>如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7536f9cee4486e13802d9341b33ceb16d0b.png" alt=""></p>
<p>这样，<strong>如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK</strong>（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是<strong>重发该报文段，不需要等待超时重传定时器溢出</strong>，大大提高了效率。这便是快速重传机制。</p>
<blockquote>
<p>为什么需要3次冗余ACK才会触发快速重传？因为即使发送端是按序发送，由于TCP包是封装在IP包内，IP包在传输时乱序，意味着TCP包到达接收端也是乱序的，乱序的话也会造成接收端发送冗余ACK。如果阈值设置的过小，那么快速重传机制很容易被乱序引发的冗余ACK干扰。</p>
</blockquote>
<h4 id="7-1-3-2-拥塞发生时的策略选择"><a href="#7-1-3-2-拥塞发生时的策略选择" class="headerlink" title="7.1.3.2 拥塞发生时的策略选择"></a>7.1.3.2 拥塞发生时的策略选择</h4><p>如果慢启动和拥塞避免算法，仍然无法避免TCP连接进入拥塞状态（发生丢包的情况），那么这时，就要采取非常手段了。</p>
<p>对于丢包，我们知道有两种情况会发生：</p>
<ol>
<li>收到3个duplicate ACK</li>
<li>还没收到3个duplicate ACK，就RTO超时</li>
</ol>
<p>这两种情况下，TCP选择的算法也不一样，我们先讲比较严重的情况2，再讲程度稍好的情况1。（情况1还能收到3个ACK，情况2直接连ACK都超时或者丢了，网络拥塞更严重）</p>
<ul>
<li>情况2：还没收到3个duplicate ACK，就RTO超时<ul>
<li>设置sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>如此一来，cwnd必然小于sshthresh，进入慢启动过程</li>
</ul>
</li>
<li>情况1：收到3个duplicate ACK<ul>
<li>那毫无疑问，快速重传继续，重发数据段。</li>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减少一半，然后等cwnd又很快地以指数级增长爬到cwnd=sshthresh这个地方时，就会成慢慢的线性增长。</p>
<p>我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fce15fccd5fb400c4e7c3731a978b75171e.png" alt=""></p>
<h3 id="7-1-4-快速恢复（Fast-Recovery）"><a href="#7-1-4-快速恢复（Fast-Recovery）" class="headerlink" title="7.1.4 快速恢复（Fast Recovery）"></a>7.1.4 快速恢复（Fast Recovery）</h3><p>这个算法定义在RFC5681。快速重传和快速恢复算法一般同时使用（都在情况1中），因为情况1还有ACK能回来，说明了网络还不是那么的糟糕，所以没有必要像RTO超时那么强烈。</p>
<blockquote>
<p>注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：<code>cwnd = cwnd /2</code>以及<code>sshthresh = cwnd</code></p>
</blockquote>
<p>然后，真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包，这时会有两种结果<ul>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
</li>
</ul>
<h2 id="7-2-Vegas算法"><a href="#7-2-Vegas算法" class="headerlink" title="7.2 Vegas算法"></a>7.2 Vegas算法</h2><p>该算法的论文是《<a href="http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf" target="_blank" rel="noopener" title="TCP Vegas: End to End Congestion Avoidance on a Global Internet">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》</p>
<p>Vegas将时延RTT的增加作为网络出现拥塞的信号，RTT增加，拥塞窗口减小，RTT减小，拥塞窗口增加。</p>
<p>具体来说，Vegas通过比较实际吞吐量和期望吞吐量来调节拥塞窗口的大小：</p>
<p>期望吞吐量：<code>Expected  = cwnd /  BaseRTT</code><br>实际吞吐量：<code>Actual = cwnd / RTT，diff = (Expected-Actual) * BaseRTT</code></p>
<p>其中，BaseRTT是所有观测来回响应时间的最小值，一般是建立连接后所发的第一个数据包的RTT，cwnd是目前的拥塞窗口的大小。</p>
<p>Vegas定义了两个阈值a，b，当diff &gt; b时，拥塞窗口减小，当a &lt;= diff &lt;=b时，拥塞窗口不变，当diff &lt; a时，拥塞窗口增加。</p>
<p>Vegas算法采用RTT的改变来判断网络的可用带宽，能精确地测量网络的可用带宽，效率比较好。但是，网络中Vegas与其它算法共存的情况下，基于丢包的拥塞控制算法会尝试填满网络中的缓冲区，导致Vegas计算的RTT增大，进而降低拥塞窗口，使得传输速度越来越慢，因此Vegas未能在Internet上普遍采用。</p>
<p>适用场景：适用于网络中只存在Vegas一种拥塞控制算法，竞争公平的情况。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener" title="TCP 的那些事儿（上）">TCP 的那些事儿（上）</a></li>
<li><a href="http://jm.taobao.org/2017/06/08/20170608/" target="_blank" rel="noopener" title="就是要你懂 TCP">就是要你懂 TCP</a></li>
<li><a href="https://blog.csdn.net/yao5hed/article/details/81046945" target="_blank" rel="noopener" title="解析TCP之滑动窗口(动画演示)">解析TCP之滑动窗口(动画演示)</a></li>
<li><a href="https://blog.csdn.net/qq_35733751/article/details/80157509" target="_blank" rel="noopener" title="tcp可靠传输——选择确认选项（SACK）">tcp可靠传输——选择确认选项（SACK）</a></li>
<li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener" title="TCP 的那些事儿（下）">TCP 的那些事儿（下）</a></li>
<li><a href="https://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="noopener" title="Congestion Avoidance and Control">Congestion Avoidance and Control</a></li>
<li><a href="https://blog.csdn.net/smilesundream/article/details/71149434" target="_blank" rel="noopener" title="TCP拥塞控制——慢开始与拥塞避免算法">TCP拥塞控制——慢开始与拥塞避免算法</a></li>
<li><a href="https://www.cnblogs.com/lolau/p/9188476.html" target="_blank" rel="noopener" title="浅谈TCP拥塞控制算法">浅谈TCP拥塞控制算法</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/UDP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/18/UDP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" itemprop="url">UDP协议分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-18T23:08:31+08:00">
                2020-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/18/UDP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/03/18/UDP协议分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-UDP的概述"><a href="#1-UDP的概述" class="headerlink" title="1. UDP的概述"></a>1. UDP的概述</h1><p>UDP是User Datagram Protocol（用户数据报协议）的缩写，它是传输层的协议，功能即为在IP的数据报服务之上增加了最基本的服务：复用和分用以及差错检测。</p>
<p>UDP提供<strong>不可靠</strong>的服务（它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。），具有TCP所没有的优势：</p>
<ol>
<li><p>UDP无连接，时间上不存在建立连接需要的时延。空间上，TCP需要在端系统中维护连接状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。</p>
<ul>
<li>举个例子：</li>
<li>DNS如果运行在TCP之上而不是UDP，那么DNS的速度将会慢很多。</li>
<li>HTTP使用TCP而不是UDP，是因为对于基于文本数据的Web网页来说，可靠性很重要。</li>
<li>同一种专用应用服务器在支持UDP时，一定能支持更多的活动客户机。</li>
</ul>
</li>
<li><p>分组首部开销小，TCP首部20字节，UDP首部8字节。</p>
</li>
<li><p>UDP没有拥塞控制，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但是不能允许有较大的时延（比如实时视频，直播等）</p>
</li>
<li><p>UDP提供尽最大努力的交付，不保证可靠交付。所有维护传输可靠性的工作需要用户在应用层来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息</p>
</li>
<li><p>UDP是<strong>面向报文</strong>的，对应用层交下来的报文，添加首部后直接向下交付为IP层，<strong>既不合并，也不拆分，保留这些报文的边界</strong>。对IP层交上来UDP用户数据报，在去除首部后就<strong>原封不动</strong>地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。</p>
<ul>
<li>正是因为这样，UDP显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送100个字节的报文，我们调用一次sendto函数就会发送100字节，对端也需要用recvfrom函数一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</li>
</ul>
</li>
</ol>
<blockquote>
<p>UDP常用于一次性传输比较少量数据的网络应用，如DNS，SNMP等，因为对于这些应用，若是采用TCP，为连接的创建，维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP的拥塞控制会使他们有较大的延迟，也是不可容忍的</p>
</blockquote>
<h1 id="2-UDP首部格式"><a href="#2-UDP首部格式" class="headerlink" title="2. UDP首部格式"></a>2. UDP首部格式</h1><p>UDP数据报分为首部和用户数据部分，整个UDP数据报作为IP数据报的数据部分封装在IP数据报中，UDP数据报文结构如图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e908c0de675aebde70a8526a34b0a8b28b4.png" alt=""><br><img src="https://oscimg.oschina.net/oscnet/up-e8ab3a0fb55985d612c74f805d60ac2d071.png" alt=""></p>
<p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，</p>
<ol>
<li><strong>源端口</strong>： 源端口号，需要对方回信时选用，不需要时全部置0.</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文的时候需要用到。</li>
<li><strong>长度</strong>：记录UDP的数据报的长度（包括首部+数据），单位是字节，其最小值为8（表示只有首部，没有数据）</li>
<li><strong>校验和</strong>：UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间是否发生变动，有则丢弃。UDP中该字段是可选的（TCP是必须的），当源主机不想计算校验和，则直接令该字段全为0。</li>
</ol>
<blockquote>
<p>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方</p>
</blockquote>
<h1 id="3-UDP校验"><a href="#3-UDP校验" class="headerlink" title="3 UDP校验"></a>3 UDP校验</h1><p>UDP检验和的基本计算方法与IP首部检验和计算方法相类似（16bit字的二进制反码和）。</p>
<p>在计算校验和的时候，<strong>需要在UDP数据报之前增加12字节的伪首部</strong>，伪首部并不是UDP真正的首部。只是在计算校验和，<strong>临时添加在UDP数据报的前面，得到一个临时的UDP数据报</strong>。校验和就是按照这个临时的UDP数据报计算的。<strong>伪首部既不向下传送也不向上递交，而仅仅是为了计算校验和</strong>。这样的校验和，既检查了UDP数据报，又对IP数据报的源IP地址和目的IP地址进行了检验。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0aa926db9d0b0919605e1f1b85dfb9593fc.png" alt=""></p>
<p>校验过程如下：</p>
<ol>
<li><p>发送方首先把全零放入校验和字段并且添加伪首部</p>
</li>
<li><p>把UDP数据报看成是由许多16位的子串连接起来，若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个填充字节(全零字节，此字节不发送）。</p>
</li>
<li><p>按照二进制反码计算出这些16位字的和。</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-ee8f3ba02186185dec3ca2f68ddd542ea22.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/TCP-IP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/TCP-IP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%A7%88/" itemprop="url">TCP/IP协议学习导览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-17T23:04:04+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/17/TCP-IP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%A7%88/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/03/17/TCP-IP协议学习导览/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  7.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  26
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从字面意义上讲，有人可能会认为TCP/IP是指TCP和IP两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用IP进行通信时所必须用到的协议群的统称。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP协议。</p>
<blockquote>
<p>该文章主要为《TCP-IP详解卷1：协议》归纳笔记</p>
</blockquote>
<h1 id="1-网络的分层"><a href="#1-网络的分层" class="headerlink" title="1. 网络的分层"></a>1. 网络的分层</h1><p>网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如TCP/IP，是一组不同层次上的多个协议的组合。TCP/IP通常被认为是一个四层的协议系统。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b92eb0a4ab7d64b99b88d4acb7760baed51.png" alt=""></p>
<ol>
<li><p>链路层</p>
<ul>
<li>有时也称作<strong>数据链路层或网络接口层</strong>，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。</li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li>有时也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括<strong>IP</strong>协议（网际协议），<strong>ICMP协议</strong>（Internet互联网控制报文协议），以及<strong>IGMP协议</strong>（Internet组管理协议）。</li>
</ul>
</li>
<li><p>运输层</p>
<ul>
<li>主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：<strong>TCP（传输控制协议）和UDP（用户数据报协议）。</strong></li>
<li>TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。</li>
<li>而另一方面，UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。</li>
</ul>
</li>
<li><p>应用层</p>
<ul>
<li>负责处理特定的应用程序细节。几乎各种不同的TCP/IP实现都会提供下面这些通用的应用程序：<ul>
<li>Telnet 远程登录。</li>
<li>FTP 文件传输协议。</li>
<li>SMTP 简单邮件传送协议。</li>
<li>SNMP 简单网络管理协议。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="2-TCP-IP协议的分层"><a href="#2-TCP-IP协议的分层" class="headerlink" title="2. TCP/IP协议的分层"></a>2. TCP/IP协议的分层</h1><p>在TCP/IP协议族中，有很多种协议。如下图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-11d2a0a828cf310ade2987c70bc46b159d1.png" alt=""></p>
<ul>
<li><strong>TCP</strong>和<strong>UDP</strong>是两种最为著名的运输层协议，二者都使用IP作为网络层协议。TCP提供一种可靠的运输层服务，而UDP是不可靠的，它不能保证数据报能安全无误地到达最终目的。</li>
<li><strong>IP</strong>是网络层上的主要协议，同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。</li>
<li><strong>ICMP</strong>是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。</li>
<li><strong>IGMP</strong>是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</li>
<li><strong>ARP</strong>（地址解析协议）和<strong>RARP</strong>（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</li>
</ul>
<h1 id="3-网络基础概念"><a href="#3-网络基础概念" class="headerlink" title="3. 网络基础概念"></a>3. 网络基础概念</h1><h2 id="3-1-IP地址——互联网的地址"><a href="#3-1-IP地址——互联网的地址" class="headerlink" title="3.1 IP地址——互联网的地址"></a>3.1 IP地址——互联网的地址</h2><p>互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）。IP地址长32bit。IP地址具有一定的结构，五类不同的互联网地址格式如图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a3dda773efe24cf65854d9da0a2a76db966.png" alt=""></p>
<p>总体来说，IP地址由<strong>网络号</strong>和<strong>主机号</strong>组成，网络号相当于某个网络的编号，主机号相当于<strong>相同网络内</strong>的主机编号。只有相同网络地址的两台主机才能通信，因此不同网络地址的主机，需要借助路由器转发才能通信。</p>
<p>这些32位的地址通常写成四个十进制的数，其中每个整数对应一个字节。这种表示方法称作“点分十进制表示法（Dotteddecimalnotation）”。例如，140.252.13.33就是一个B类地址。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-35ef928a25d5723986baf23183d9b16a8c7.png" alt=""></p>
<h3 id="3-1-1-子网寻址"><a href="#3-1-1-子网寻址" class="headerlink" title="3.1.1 子网寻址"></a>3.1.1 子网寻址</h3><p>现在所有的主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，<strong>而是把主机号再分成一个子网号和一个主机号</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6fd30a8d60771bbc85cffb0224c664c47ae.png" alt=""></p>
<p>子网的出现是基于以下原因：</p>
<ul>
<li>因为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为2^24-2和2^16-2。事实上，在一个网络中人们并不安排这么多的主机</li>
<li>随着互联的发展IPV4地址资源可能会耗尽，如果不划分子网直接将一个C类地址分给一个企业，C类地址可容纳256台主机，但是可能该企业只有20台计算机，这就造成极大浪费</li>
<li>减少网络流量，优化网络性能：隔离数据在整个网络内广播，提高信息传输速率。</li>
</ul>
<h3 id="3-1-2-子网掩码"><a href="#3-1-2-子网掩码" class="headerlink" title="3.1.2 子网掩码"></a>3.1.2 子网掩码</h3><p>子网掩码又叫网络掩码，我们现在把主机号拆分成子网号和主机号了，那拆分后，<strong>IP地址的哪些位是表示子网号，哪些位是表示主机号呢</strong>？我们需要有一种方式来标识它。这就是子网掩码。</p>
<p>子网掩码是一个32bit的值，其中值为1的比特用来标识网络号和子网号，为0的比特用来标识主机号。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4a592bcafbb0ae0fe4df866829865ce0b03.png" alt=""></p>
<h2 id="3-2-域名"><a href="#3-2-域名" class="headerlink" title="3.2 域名"></a>3.2 域名</h2><p>尽管通过IP地址可以识别主机上的网络接口，进而访问主机，但是人们最喜欢使用的还是主机名。在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</p>
<h2 id="3-3-封装"><a href="#3-3-封装" class="headerlink" title="3.3 封装"></a>3.3 封装</h2><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b91718c00fef8cde14bf35da7006952d67a.png" alt=""></p>
<blockquote>
<p>TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP segment）。IP传给链路层的数据单元称作IP数据报(IP datagram)。通过以太网传输的比特流称作帧(Frame)。</p>
</blockquote>
<h2 id="3-4分用"><a href="#3-4分用" class="headerlink" title="3.4分用"></a>3.4分用</h2><p>当目的主机收到一个以太网数据帧时，<strong>数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部</strong>。每层协议盒都要去<strong>检查报文首部中的协议标识，以确定接收数据的上层协议</strong>。这个过程称作分用（Demultiplexing）。如下图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2d7f05206f7e8ce1ac051eaf8449c9df6dc.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-990eeeb4d3a2545ae5170522df23b2dc87f.png" alt=""></p>
<h2 id="3-5-端口"><a href="#3-5-端口" class="headerlink" title="3.5 端口"></a>3.5 端口</h2><p>正常情况下，IP能锁定一台物理机器，对应着一张网卡，外界发来的数据包网卡都会接收。网卡给程序提供了接口，你监听一下我，要是有消息来了，我就转发给你。这样应用程序就能收到数据了。</p>
<p>紧接着问题来了，一台物理机器上有无数个程序，每个程序都需要监听网卡接发数据，如果网卡把接收到的数据都转发给所有的程序，那么程序将会被大量本不是发送给自己的数据淹没。</p>
<p>为了隔离不同程序的数据，我们添加了一个标识：端口，来作为区分。如果程序A的端口是8080，那么我收到有8080标识的数据，就只会转发给程序A，以此类推。</p>
<h2 id="3-6-MTU"><a href="#3-6-MTU" class="headerlink" title="3.6 MTU"></a>3.6 MTU</h2><p>最大传输单元（Maximum Transmission Unit，MTU）是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。</p>
<p>如果在IP层要传输一个数据报比链路层的MTU还大，那么IP层就会对这个数据报进行分片。一个数据报会被分为若干片，每个分片的大小都小于或者等于链路层的MTU值。</p>
<p>当同一网络上的主机互相进行通信时，该网络的MTU对通信双方非常重要。但当主机间要通过很多网络才能通信时，对通信双方最重要的是通信路径中最小的MTU，因为在通信路径上不同网络的链路层MTU不同。<strong>通信路径中最小的MTU被称为路径MTU</strong>(木桶原理)。</p>
<p>网络中一些常见链路层协议MTU的缺省数值如下：</p>
<ul>
<li>FDDI协议：4352字节</li>
<li>以太网（Ethernet）协议：1500字节</li>
<li>PPPoE（ADSL）协议：1492字节</li>
<li>X.25协议（Dial Up/Modem）：576字节</li>
<li>Point-to-Point：4470字节</li>
</ul>
<h2 id="3-7-IP分片"><a href="#3-7-IP分片" class="headerlink" title="3.7 IP分片"></a>3.7 IP分片</h2><p>因为有MTU的存在，我们要对长度大于MTU的IP数据报进行分片。</p>
<p>任何时候<strong>IP层</strong>接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</p>
<p>把一份IP数据报分片以后，只有到达目的地才进行重新组装。重新组装由<strong>目的端的IP层</strong>来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的。</p>
<p>IP首部中，有如下这些字段和分片操作有关：</p>
<ol>
<li><p>标识字段：标识字段是IP数据报的唯一主键，同一个数据报分出来的分片，拥有相同的标识字段。在重新组装的时候，通过这个字段，目的端IP层可以知道哪些分片原来是一体的。</p>
</li>
<li><p>片偏移字段：该字段指的是该片的数据在原始数据报中，离开始处的偏移量。通过它，在组装时，可以确定各个分片的次序。</p>
</li>
<li><p>标志字段“不分片”位：还是标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。这时如果遇到IP数据报长度大于MTU的场景，则会把数据报丢弃并发送一个ICMP差错报文给起始端。</p>
</li>
</ol>
<h1 id="4-链路层协议"><a href="#4-链路层协议" class="headerlink" title="4. 链路层协议"></a>4. 链路层协议</h1><p>在TCP/IP协议族中，链路层主要有三个目的：</p>
<ol>
<li>为IP模块发送和接收IP数据报；</li>
<li>为ARP模块发送ARP请求和接收ARP应答；</li>
<li>为RARP发送RARP请求和接收RARP应答。</li>
</ol>
<p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路</p>
<p>链路层的协议数据单元是<strong>帧</strong>——IP层（网络层）的数据报添加首部和尾部，即可封装成帧。</p>
<p>帧主要有两种封装格式IEEE 802封装和以太网封装，其中<strong>以太网封装格式是目前的主流</strong>。除此之外，还有SLIP（Serial Line IP）封装和PPP（点对点协议）封装。</p>
<h2 id="4-1-IEEE-802封装和以太网封装"><a href="#4-1-IEEE-802封装和以太网封装" class="headerlink" title="4.1 IEEE 802封装和以太网封装"></a>4.1 IEEE 802封装和以太网封装</h2><p><img src="https://oscimg.oschina.net/oscnet/up-0f5eeeb15e0ff49992da35f360f7eb1838f.png" alt=""></p>
<ul>
<li><p><strong>IEEE802.2/802.3封装协议</strong></p>
<ol>
<li>两个<strong>6字节</strong>的<strong>目的地址和源地址</strong>，这个地址指的是物理地址，也就是MAC地址(48bit)。ARP和RARP协议对32bit的IP地址和48bit的硬件地址进行映射。</li>
<li><strong>2字节</strong>的<strong>长度字段</strong>，值为后续数据的字节长度，但不包括CRC检验码。</li>
<li>3字节的802.2LLC，<ol>
<li><strong>目的服务访问点</strong>（DestinationServiceAccessPoint,DSAP）和<strong>源服务访问点</strong>（SourceServiceAccessPoint,SSAP）的值都设为0xaa。</li>
<li><strong>Ctrl字段</strong>的值设为3。</li>
</ol>
</li>
<li>一共5字节的802.2SNAP。<ol>
<li>3个字节<strong>orgcode字段</strong>都置为0。</li>
<li>2字节的<strong>类型字段</strong>，和以太网帧格式一样，其比较常见的类型字段为：0X0800（IP帧），0X0806（ARP请求/应答帧），0X8035（PARP请求/应答帧），0X8137（NovellIPX），0X809b（AppleTalk）。</li>
</ol>
</li>
<li>数据</li>
<li>CRC，<strong>CRC字段</strong>用于帧内后续字节差错的循环冗余码检验（检验和）（它也被称为FCS或帧检验序列）。</li>
</ol>
</li>
<li><p><strong>以太网封装协议（RFC 894）</strong></p>
<ol>
<li>两个<strong>6字节</strong>的<strong>目的地址和源地址</strong>，这个地址指的是物理地址，也就是MAC地址(48bit)。ARP和RARP协议对32bit的IP地址和48bit的硬件地址进行映射。</li>
<li>2字节的<strong>类型字段</strong>，其比较常见的类型字段为：0X0800（IP帧），0X0806（ARP请求/应答帧），0X8035（PARP请求/应答帧），0X8137（NovellIPX），0X809b（AppleTalk）。</li>
<li>数据</li>
<li>CRC，<strong>CRC字段</strong>用于帧内后续字节差错的循环冗余码检验（检验和）（它也被称为FCS或帧检验序列）。</li>
</ol>
</li>
</ul>
<h2 id="4-2-SLIP：串行线路IP封装协议"><a href="#4-2-SLIP：串行线路IP封装协议" class="headerlink" title="4.2 SLIP：串行线路IP封装协议"></a>4.2 SLIP：串行线路IP封装协议</h2><p>SLIP的全称是Serial Line IP。它是一种在串行线路上对IP数据报进行封装的简单形式，在RFC1055中有详细描述。SLIP适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet。</p>
<p>其封装规则十分简单，一图道尽：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5edf018ce466031e243f2c0ec1c5dd6c485.png" alt=""></p>
<ol>
<li>给IP数据报的前后端都加上一个称作END（0xc0）的特殊字符。</li>
<li>END（0xc0）SLIP协议中是特殊字符，所以如果IP报文中某个字符为END（0xc0），那么就要连续传输两个字节0xdb和0xdc来取代它。</li>
<li>0xdb这个特殊字符被称作SLIP的ESC字符，如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。</li>
</ol>
<p>SLIP是一种简单的帧封装方法，还有一些值得一提的<strong>缺陷</strong>：</p>
<ol>
<li>因为缺少源地址字段，SLIP没有办法把本端的IP地址通知给另一端，所以每一端必须知道对方的IP地址。。</li>
<li>数据帧中没有类型字段，如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li>
<li>SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SLIP传输的报文被线路噪声影响而发生错误，只能通过上层协议来发现</li>
</ol>
<h2 id="4-3-PPP：点对点封装协议"><a href="#4-3-PPP：点对点封装协议" class="headerlink" title="4.3 PPP：点对点封装协议"></a>4.3 PPP：点对点封装协议</h2><p>同样作为常用于低速的串行链路的封装协议，PPP（Point to Point Protocol）点对点协议修改了SLIP协议中的所有缺陷。如图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-292e5ecec943da43f8c798b1558e0f3f64e.png" alt=""></p>
<ol>
<li>每一帧都以<strong>标志字符</strong>0x7e开始和结束。</li>
<li>一个字节的<strong>地址字段</strong>，值始终是0xff。</li>
<li>一个字节的<strong>控制字段</strong>，值始终是0x03。</li>
<li><strong>协议字段</strong>，类似于以太网中类型字段的功能。<ul>
<li>值为0x0021时，表示信息字段是一个IP数据报；</li>
<li>值为0xc021时，表示信息字段是链路控制数据；</li>
<li>值为0x8021时，表示信息字段是网络控制数据。</li>
</ul>
</li>
<li>数据</li>
<li><strong>CRC字段</strong>（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
</ol>
<p>PPP比SLIP具有下面这些优点：</p>
<ol>
<li>PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li>
<li>每一帧都有循环冗余检验；</li>
<li>通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li>
<li>与CSLIP类似，对TCP和IP报文首部进行压缩；</li>
<li>链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li>
</ol>
<h1 id="5-网络层协议"><a href="#5-网络层协议" class="headerlink" title="5. 网络层协议"></a>5. 网络层协议</h1><h2 id="5-1-IP协议"><a href="#5-1-IP协议" class="headerlink" title="5.1 IP协议"></a>5.1 IP协议</h2><p>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。</p>
<p>IP提供<strong>不可靠</strong>、<strong>无连接</strong>的数据报传送服务</p>
<ul>
<li>不可靠（unreliable）的意思是它<strong>不能保证IP数据报能成功地到达目的地</strong>。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。</li>
<li>无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。<strong>每个数据报的处理是相互独立的</strong>。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</li>
</ul>
<h3 id="5-1-1-IP首部"><a href="#5-1-1-IP首部" class="headerlink" title="5.1.1 IP首部"></a>5.1.1 IP首部</h3><p>IP数据报的格式如下图所示。普通的IP首部长为20个字节，即160位（不包含选项字段）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b5c16d7c7963e9a676df4af41971b566f1e.png" alt=""></p>
<ol>
<li><strong>版本号</strong>，目前是4或者6，我们平常看到的IPv4和IPv6由此区分。</li>
<li><strong>首部长度</strong>，指的是首部（包括任何选项）有多少个4字节（32bit）的数目（也就是首部总位数/32）。由于它每个bit位代表4个字节，且是一个4bit字段，因此首部最长为60个字节。</li>
<li><strong>服务类型</strong>，共8bit，其中：<ul>
<li>3bit优先权字段(现在已被忽略)，默认值是000</li>
<li>4bit的TOS子字段，其值分布和含义如下：<ul>
<li>1000 – minimize delay #<strong>最小延迟</strong>：对应于对延迟敏感的应用，如telnet和人login</li>
<li>0100 – maximize throughput #<strong>最大吞吐量</strong>：对应于对吞吐量要求比较高的应用，如FTP文件应用，对文件传输吞吐量有比较高的要求。</li>
<li>0010 – maximize reliability #<strong>最高可靠性</strong>：对网络传输可靠性要求高的应用，如使用SNMP的应用、路由协议等等。</li>
<li>0001 – minimize monetary cost #<strong>最小费用</strong>：如NNTP这种用户网络新闻等。</li>
<li>0000 – normal service #一般服务</li>
</ul>
</li>
<li>1bit未用位，但必须置0。</li>
</ul>
</li>
<li><strong>总长度字段</strong>，16bit，是指整个IP数据报的长度，以字节为单位。</li>
<li><strong>标识字段</strong>，16bit，唯一地标识主机发送的每一份数据报，也就是主机发送报文的id，通常每发送一份报文它的值就会加1。如果IP报文在数据链路层被分片了，那么每一个片里面的这个id字段相同。</li>
<li><strong>标志字段</strong>，3bit，第一位保留，第二位置为1，标识禁止分片，这时候如果IP报文大于MTU，IP模块就会丢弃报文；第3位表示更多分片，如果分片了的话，最后一个分片置为1，其他都是0，类似于一个结束标记</li>
<li><strong>分片偏移字段</strong>，是分片相对于原始IP报文开始处的偏移，单位是bit，故而实际偏移的字节数为该值 * 8，因此，除了最后一个报文之外，其它的报文长度必须是8的整数倍，否则报文不连续。</li>
<li><strong>TTL（time-to-live）生存时间字段</strong>，表示数据报可以经过最多多少个路由器。其初始值由源主机设置（通常为32或64），每经过一个路由器，值减1。值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。该字段是为了防止出现路由循环而设。</li>
<li><strong>协议字段</strong>，指在上层（TCP/IP的传输层）使用的协议，可能的协议有UDP、TCP、ICMP、IGMP、IGP等。TCP协议为6，UDP协议为17，ICMP为1。</li>
<li><strong>首部校验和</strong>，用于检验IP报文头部在传播的过程中是否出错，主要校验报文头中是否有某一个或几个bit被污染或修改了。<ul>
<li>首先把检验和字段置为0。以抓包得到的该首部为例：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-56ae92b4a4735c455e500848f2c66430fa7.png" alt=""></li>
</ul>
</li>
<li>然后，对首部中<strong>每16bit</strong>进行二进制反码求和，结果存在检验和字段中。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d28dd4972d26fdd4772ad77b4f0c83e1f1b.png" alt=""></li>
</ul>
</li>
<li>当收到一份IP数据报后，同样对首部中每个16bit进行二进制反码的求和。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d9b94b7a21ca5204a4aa50bf7a468a6d61f.png" alt=""></li>
</ul>
</li>
<li>由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1（也就是0xffff）。如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。</li>
<li>ICMP、IGMP、UDP和TCP都采用相同的检验和算法</li>
</ul>
</li>
<li><strong>源IP地址</strong>，32位，4个字节，每一个字节为0～255之间的整数</li>
<li><strong>目的IP地址</strong>，32位，4个字节，每一个字节为0～255之间的整数</li>
<li><strong>选项</strong>，是数据报中的一个可变长的可选信息。选项可用于：<ul>
<li>安全和处理限制（用于军事领域）</li>
<li>记录路径（让每个路由器都记下它的IP地址）</li>
<li>时间戳（让每个路由器都记下它的IP地址和时间）</li>
<li>宽松的源站选路（为数据报指定一系列必须经过的IP地址）</li>
<li>严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>选项字段很少被使用，并非所有的主机和路由器都支持这些选项。选项字段一直都是以32bit作为界限，在必要的时候插入值为0的填充字节。这样就保证IP首部始终是32bit的整数倍（这是首部长度字段所要求的）。</p>
</blockquote>
<h2 id="5-2-ARP协议和RARP协议"><a href="#5-2-ARP协议和RARP协议" class="headerlink" title="5.2 ARP协议和RARP协议"></a>5.2 ARP协议和RARP协议</h2><p>ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址，ARP协议的作用是<strong>将已知的IP地址转换为MAC地址</strong>。</p>
<p>RARP协议是“Reverse Address Resolution Protocol”（反向地址转换协议）的缩写。具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取 IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。RARP协议的作用就是<strong>将已知的MAC地址转换为IP地址</strong></p>
<h3 id="5-2-1-协议原理"><a href="#5-2-1-协议原理" class="headerlink" title="5.2.1 协议原理"></a>5.2.1 协议原理</h3><h4 id="5-2-1-1-APR原理"><a href="#5-2-1-1-APR原理" class="headerlink" title="5.2.1.1 APR原理"></a>5.2.1.1 APR原理</h4><p>ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播，如下图的虚线所示。ARP请求数据帧中包含目的主机的IP地址（假设主机名为bsdi），其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-18c73d5a678a5c9fff90572f89992f48f5f.png" alt=""></p>
<p>目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。</p>
<h4 id="5-2-1-2-RAPR原理"><a href="#5-2-1-2-RAPR原理" class="headerlink" title="5.2.1.2 RAPR原理"></a>5.2.1.2 RAPR原理</h4><p>同理：</p>
<p>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响应这个无盘系统的IP地址（在RARP应答中）。从而得到这个MAC地址对应的IP地址</p>
<h3 id="5-2-2-ARP高速缓存"><a href="#5-2-2-ARP高速缓存" class="headerlink" title="5.2.2 ARP高速缓存"></a>5.2.2 ARP高速缓存</h3><p>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录，从中直接读取，缓解链路压力。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起</p>
<p>我们可以用arp命令来检查ARP高速缓存。参数-a的意思是显示高速缓存中所有的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ arp -a</span><br><span class="line">&gt; sun (140.252.13.33) at 8:0:20:3:f6:42</span><br><span class="line">&gt; svr4 (140.252.13.34) at 0:0:c0:c2:9b:26</span><br></pre></td></tr></table></figure>

<p><img src="https://oscimg.oschina.net/oscnet/up-a74affe098a2b2dcb35b0974ea9fdfdb920.png" alt=""></p>
<h3 id="5-2-3-ARP-RARP的分组格式"><a href="#5-2-3-ARP-RARP的分组格式" class="headerlink" title="5.2.3 ARP/RARP的分组格式"></a>5.2.3 ARP/RARP的分组格式</h3><p>在以太网上解析IP地址时，ARP/RARP请求和应答分组的格式如图所示</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-83112c312c9096d76aaca2d6f38bf459b20.png" alt=""></p>
<ol>
<li><strong>目标mac地址</strong>：ARP请求的目的以太网地址，全1时，代表广播地址。</li>
<li><strong>源mac地址</strong>：发送ARP请求的以太网地址。</li>
<li><strong>帧类型</strong>：以太网帧类型表示后面的数据类型，ARP请求和ARP应答此字段为：0x0806。</li>
<li><strong>硬件类型</strong>：硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。</li>
<li><strong>协议类型</strong>：表示要映射的协议地址类型。它的值为0x0800即表示IP地址。它的值与包含IP数据报的以太网数据帧中的类型字段的值相同，这是有意设计的</li>
<li><strong>硬件地址长度、协议地址长度</strong>：表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节。</li>
<li><strong>操作类型</strong>：值为1，表示进行ARP请求；值为2，表示进行ARP应答；值为3，表示进行RARP请求；值为4，表示进行RARP应答。</li>
<li><strong>发送端以太网地址和协议地址</strong>：发送端的硬件地址（在本例中是以太网地址）和协议地址（IP地址）</li>
<li><strong>目的端的硬件地址和目的端的协议地址</strong>：目的端的硬件地址（在本例中是以太网地址）和协议地址（IP地址）。（这是重复数据，在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址。）</li>
</ol>
<blockquote>
<p>对于一个ARP/RARP请求来说，除<strong>目的端硬件地址</strong>外的所有其他的字段，都已经有填充值。当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。</p>
</blockquote>
<blockquote>
<p>ARP/RARP二者的分组格式，除了操作类型字段以外，其他字段都一样</p>
</blockquote>
<h2 id="5-3-ICMP协议"><a href="#5-3-ICMP协议" class="headerlink" title="5.3 ICMP协议"></a>5.3 ICMP协议</h2><p>ICMP协议，全称是Internet Control Message Protocol，意思是Internet控制消息协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息（可以理解为回来报信的信鸽）。<strong>控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息</strong>。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p>ICMP 的内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP 是IP 的上层协议。但是，正如RFC所记载的，ICMP是分担了IP的一部分功能。所以，被认为是与IP 同层的协议。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c77afda8e8ee65a9872da5f221ef6696631.png" alt=""></p>
<h3 id="5-3-1-ICMP的分类"><a href="#5-3-1-ICMP的分类" class="headerlink" title="5.3.1 ICMP的分类"></a>5.3.1 ICMP的分类</h3><p>在RFC，将ICMP 大致分成两种功能：</p>
<ol>
<li>差错报文：在IP数据包被对方的计算机处理的过程中，发生了某些错误时被使用。不仅传送发生了错误这个事实，也传送错误原因等消息。</li>
<li>查询报文：是在送信方的计算机向对方计算机询问信息时被使用。被询问内容的种类非常丰富，如：目标IP地址的机器是否存在，调查自己网络的子网掩码，取得对方机器的时间信息等。</li>
</ol>
<h3 id="5-3-2-ICMP的报文"><a href="#5-3-2-ICMP的报文" class="headerlink" title="5.3.2 ICMP的报文"></a>5.3.2 ICMP的报文</h3><p><img src="https://oscimg.oschina.net/oscnet/up-de1e6079bd0c3c227e27a4f1d830e2219fe.png" alt=""></p>
<p>如上图，我们将完整的IP首部+ICMP报文都展示了出来，IP首部各字段，前文已经有过描述。</p>
<p>用来传送ICMP报文的IP数据包上实际上有不少字段。但是实际上与ICMP协议相关的只有7个子段。</p>
<ol>
<li>协议：ICMP协议的IP数据包，该字段为1；</li>
<li>源IP 地址：顾名思义，不再赘述。</li>
<li>目的IP 地址：顾名思义，不再赘述。</li>
<li>生存时间：TTL，不再赘述。</li>
</ol>
<p>上述这四个包含在IP 首部的字段。</p>
<ol start="5">
<li>类型；</li>
<li>代码；</li>
<li>选项数据；</li>
</ol>
<p>上述这三个包含在ICMP数据部分的字段。</p>
<p>其中<strong>类型</strong>和<strong>代码</strong>字段是ICMP报文的核心，这两个字段的组合，可以用来标识ICMP的差错报文和查询报文的大多数场景，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-80196ab227699291306a266fcf45c9b7c36.png" alt=""></p>
<p>至于选项数据字段，当ICMP需要传送额外数据时，则放置在选项数据字段中。</p>
<h1 id="6-运输层协议"><a href="#6-运输层协议" class="headerlink" title="6. 运输层协议"></a>6. 运输层协议</h1><h2 id="6-1-TCP协议"><a href="#6-1-TCP协议" class="headerlink" title="6.1 TCP协议"></a>6.1 TCP协议</h2><p>详见文章《TCP协议分析》</p>
<h2 id="6-2-UDP协议"><a href="#6-2-UDP协议" class="headerlink" title="6.2 UDP协议"></a>6.2 UDP协议</h2><p>详见文章《UDP协议分析》</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.51cto.com/art/201906/597961.htm" target="_blank" rel="noopener" title="太厉害了，终于有人能把TCP/IP协议讲的明明白白了！">太厉害了，终于有人能把TCP/IP协议讲的明明白白了！</a></p>
<p><a href="https://blog.csdn.net/sj349781478/article/details/74058939" target="_blank" rel="noopener" title="以太网协议封装格式">以太网协议封装格式</a></p>
<p><a href="https://www.cnblogs.com/iiiiher/p/8513748.html" target="_blank" rel="noopener" title="完全理解icmp协议">完全理解icmp协议</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/20/ElasticSearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3%EF%BC%88index-type-doc-node-shard-replica-segment%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/20/ElasticSearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3%EF%BC%88index-type-doc-node-shard-replica-segment%EF%BC%89/" itemprop="url">ElasticSearch核心概念详解（index/type/doc/node/shard/replica/segment）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-20T23:01:01+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">ElasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/20/ElasticSearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3%EF%BC%88index-type-doc-node-shard-replica-segment%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/02/20/ElasticSearch核心概念详解（index-type-doc-node-shard-replica-segment）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  9.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ElasticSearch，简称ES，是一个基于Lucene的搜索服务器。要想了解ES，必须先了解Lucene。</p>
<h2 id="数据和搜索"><a href="#数据和搜索" class="headerlink" title="数据和搜索"></a>数据和搜索</h2><p>我们知道，生活中我们有两类的数据：</p>
<ol>
<li><strong>结构化数据</strong>：也称作行数据，是由二维表结构来逻辑表达和实现的数据，严格地遵循数据格式与长度规范，主要通过关系型数据库进行存储和管理。指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li><strong>非结构化数据</strong>：又可称为全文数据，不定长或无固定格式，不适于由数据库二维表来表现，包括所有格式的办公文档、XML、HTML、word文档，邮件，各类报表、图片和咅频、视频信息等。</li>
</ol>
<p>根据两种数据分类，搜索也相应的分为两种：<strong>结构化数据搜索</strong>和<strong>非结构化数据搜索</strong>。对于结构化数据，因为它们具有特定的结构，所以我们一般都是可以通过关系型数据库（mysql，oracle等）的二维表（table）的方式存储和搜索，也可以建立索引。</p>
<p>对于非结构化数据，也即对全文数据的搜索主要有两种方法：<strong>顺序扫描法</strong>，<strong>全文检索</strong>。</p>
<ol>
<li><strong>顺序扫描</strong>：通过文字名称也可了解到它的大概搜索方式，即按照顺序扫描的方式查询特定的关键字。例如给你一张报纸，让你找到该报纸中“平安”的文字在哪些地方出现过。你肯定需要从头到尾把报纸阅读扫描一遍然后标记出关键字在哪些版块出现过以及它的出现位置。</li>
</ol>
<p>这种方式无疑是最耗时的最低效的，如果报纸排版字体小，而且版块较多甚至有多份报纸，等你扫描完你的眼睛也差不多了。</p>
<ol start="2">
<li><strong>全文搜索</strong>：对非结构化数据顺序扫描很慢，我们是否可以进行优化？把我们的非结构化数据想办法弄得有一定结构不就行了吗？将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</li>
</ol>
<p>这种方式就构成了全文检索的基本思路。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之<strong>索引</strong>。这种方式的主要工作量在前期索引的创建，但是对于后期搜索却是快速高效的。</p>
<h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><p>通过对生活中数据的类型作了一个简短了解之后，我们知道关系型数据库的SQL检索是处理不了这种非结构化数据的。这种非结构化数据的处理需要依赖全文搜索，而目前市场上开放源代码的最好全文检索引擎工具包就属于 apache 的 Lucene了。</p>
<p>但是 Lucene 只是一个工具包，它不是一个完整的全文检索引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。</p>
<p>目前以 Lucene 为基础建立的开源可用全文搜索引擎主要是 Solr 和 Elasticsearch。</p>
<p>Solr 和 Elasticsearch 都是比较成熟的全文搜索引擎，能完成的功能和性能也基本一样。但是 ES 本身就具有分布式的特性和易安装使用的特点，而Solr的分布式需要借助第三方来实现，例如通过使用ZooKeeper来达到分布式协调管理。</p>
<p>不管是 Solr 还是 Elasticsearch 底层都是依赖于 Lucene，而 Lucene 能实现全文搜索主要是因为它实现了<strong>倒排索引</strong>的查询结构。（稍后展开）</p>
<h1 id="1-ES基本概念详解"><a href="#1-ES基本概念详解" class="headerlink" title="1. ES基本概念详解"></a>1. ES基本概念详解</h1><p>ElasticSearch提供了一个分布式多用户能力的<strong>全文搜索引擎</strong>，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。</p>
<p>ElasticSearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。其官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。</p>
<p>不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：</p>
<ul>
<li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>
<li>分布式的实时分析搜索引擎</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>
</ul>
<p>es和lucene，solr一样，都是无模式的基于列式的存储格式，这和大多数的NoSQL数据库是一样的，非常灵活，下面我们通过一张图，来看下关系型数据库映射到es里面，对应的名词关系</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6d546ac1f5a76da02b2d7b943ca778010e9.png" alt=""></p>
<h2 id="1-1-Index"><a href="#1-1-Index" class="headerlink" title="1.1 Index"></a>1.1 Index</h2><p>Index，索引，是文档(Document)的容器，是一类文档的集合。</p>
<p>ElasticSearch将它的数据存储在一个或多个索引（index）中。索引就像数据库，可以向索引写入文档或者从索引中读取文档</p>
<p>索引这个词在 ElasticSearch 会有两种意思:</p>
<ol>
<li><p>索引(名词)</p>
<ul>
<li>类比传统的关系型数据库领域来说，<strong>索引相当于SQL中的一个数据库(Database)</strong>。索引由其名称(<strong>必须为全小写字符</strong>)进行标识。</li>
</ul>
</li>
<li><p>索引(动词)</p>
<ul>
<li><strong>保存一个文档到索引(名词)的过程</strong>。这非常类似于SQL语句中的 INSERT关键词。如果该文档已存在时那就相当于数据库的UPDATE。</li>
</ul>
</li>
</ol>
<h2 id="1-2-Type"><a href="#1-2-Type" class="headerlink" title="1.2 Type"></a>1.2 Type</h2><p>Type，类型，可以理解成关系数据库中Table（虽然不完全一致）。用于区分同一个集合中的不同细分。</p>
<p>但和Table不同的是，不同表中的字段可以同名，但他们还是独立的，比如表A的a字段可以是VARCHAR类型，表B的a字段可以是INT类型。</p>
<p>而不同类型的同名字段，他们其实是同一个字段，所以无法独立，实际上，es在底层，也是将不同type的字段都映射为扁平的模式。而不是为每种type分配单独的映射空间。</p>
<p>这导致了type不适合于描述完全不同类型的数据 ，如type A有a，b，c三个字段，type B有d，e，f三个字段，那么这种情况建议不要使用type。</p>
<p>A { a,b,c}和B{b,c,d}这种情况才适用，即<strong>二者间大部分的数据是相同的</strong>，这种情况下，es的扁平化映射，可以复用这部分重合的数据。</p>
<p>之前的版本中，索引和文档中间还有个类型的概念，每个索引下可以建立多个类型，文档存储时需要指定index和type。从6.0.0开始单个索引中只能有一个类型，</p>
<p>7.0.0以后将将不建议使用，8.0.0 以后完全不支持。</p>
<h3 id="1-2-1弃用该概念的原因："><a href="#1-2-1弃用该概念的原因：" class="headerlink" title="1.2.1弃用该概念的原因："></a>1.2.1弃用该概念的原因：</h3><p>我们虽然可以通俗的去理解Index比作 SQL 的 Database，Type比作SQL的Table。但这并不准确，因为如果在SQL中，Table 之前相互独立，同名的字段在两个表中毫无关系。</p>
<p>但是在ES中，同一个Index 下不同的 Type 如果有同名的字段，他们会被Luecence当作同一个字段 ，并且他们的定义必须相同。所以我觉得Index现在更像一个表，而Type字段则并没有多少意义。</p>
<p>目前Type已经被Deprecated，在7.0开始，一个索引只能建一个Type为<code>_doc</code></p>
<h2 id="1-3-Document"><a href="#1-3-Document" class="headerlink" title="1.3 Document"></a>1.3 Document</h2><p>Document，文档，Index 里面单条的记录称为Document。<strong>等同于关系型数据库表中的行</strong>。</p>
<p>我们来看下一个文档的源数据</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fb0733a15d98fe88fbb22b4ea3898cc37c0.png" alt=""></p>
<ul>
<li><p><code>_index</code>文档所属索引名称。</p>
</li>
<li><p><code>_type</code>文档所属类型名。</p>
</li>
<li><p><code>_id</code>Doc的主键。在写入的时候，可以指定该Doc的ID值，如果不指定，则系统自动生成一个唯一的UUID值。</p>
</li>
<li><p><code>_version</code>文档的版本信息。Elasticsearch通过使用version来保证对文档的变更能以正确的顺序执行，避免乱序造成的数据丢失。</p>
</li>
<li><p><code>_seq_no</code>严格递增的顺序号，每个文档一个，Shard级别严格递增，保证后写入的Doc的<code>_seq_no</code>大于先写入的Doc的_seq_no。</p>
</li>
<li><p><code>primary_term</code>primary_term也和<code>_seq_no</code>一样是一个整数，每当Primary Shard发生重新分配时，比如重启，Primary选举等，_primary_term会递增1</p>
</li>
<li><p><code>found</code>查询的ID正确那么ture, 如果 Id 不正确，就查不到数据，found字段就是false。</p>
</li>
<li><p><code>_source</code>文档的原始JSON数据。</p>
</li>
</ul>
<h1 id="2-ES分布式概念详解"><a href="#2-ES分布式概念详解" class="headerlink" title="2. ES分布式概念详解"></a>2. ES分布式概念详解</h1><h2 id="2-1-集群-cluster"><a href="#2-1-集群-cluster" class="headerlink" title="2.1 集群(cluster)"></a>2.1 集群(cluster)</h2><p>ElasticSearch集群实际上是一个分布式系统，它需要具备两个特性：</p>
<ul>
<li><p>高可用性</p>
<ul>
<li>服务可用性：允许有节点停止服务；</li>
<li>数据可用性：部分节点丢失，不会丢失数据；</li>
</ul>
</li>
<li><p>可扩展性</p>
<ul>
<li>随着请求量的不断提升，数据量的不断增长，系统可以将数据分布到其他节点，实现水平扩展；</li>
</ul>
</li>
</ul>
<p>一个集群中可以有一个或者多个节点；</p>
<p>我们采用集群健康值来衡量一个集群的状态</p>
<ol>
<li><code>green</code>：所有主要分片和复制分片都可用</li>
<li><code>yellow</code>：所有主要分片可用，但不是所有复制分片都可用</li>
<li><code>red</code>：不是所有的主要分片都可用</li>
</ol>
<blockquote>
<p>当集群状态为 red，它仍然正常提供服务，它会在现有存活分片中执行请求，我们需要尽快修复故障分片，防止查询数据的丢失；</p>
</blockquote>
<h2 id="2-2-节点-Node"><a href="#2-2-节点-Node" class="headerlink" title="2.2 节点(Node)"></a>2.2 节点(Node)</h2><p>es集群是通过多台服务器来搭建，它们拥有一个共同的clustername比如叫做“escluster”，每台服务器叫做一个节点，用于存储数据并提供集群的搜索和索引功能。</p>
<p>节点拥有自己的唯一名字，默认在节点启动时会生成一个uuid作为节点名，该名字也可以手动指定。</p>
<p>单个集群可以由任意数量的节点组成。如果只启动了一个节点，则会形成一个单节点的集群。其配置文件如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">集群名称，用于定义哪些<span class="selector-tag">elasticsearch</span>节点属同一个集群。</span><br><span class="line"><span class="selector-tag">cluster</span><span class="selector-class">.name</span>: <span class="selector-tag">bigdata</span></span><br><span class="line">节点名称，用于唯一标识节点，不可重名</span><br><span class="line"><span class="selector-tag">node</span><span class="selector-class">.name</span>: <span class="selector-tag">server3</span></span><br><span class="line">设置索引的分片数,默认为5 </span><br><span class="line"><span class="selector-tag">index</span><span class="selector-class">.number_of_shards</span>: 5 </span><br><span class="line">设置索引的副本数,默认为1: </span><br><span class="line"><span class="selector-tag">index</span><span class="selector-class">.number_of_replicas</span>: 1</span><br></pre></td></tr></table></figure>

<p>节点是一个ElasticSearch的实例，其本质就是一个Java进程；一台机器上可以运行多个ElasticSearch实例，但是建议在生产环境中一台机器上只运行一个ElasticSearch实例；</p>
<h3 id="2-2-3-节点的类型"><a href="#2-2-3-节点的类型" class="headerlink" title="2.2.3 节点的类型"></a>2.2.3 节点的类型</h3><h3 id="2-2-1-四种普通节点"><a href="#2-2-1-四种普通节点" class="headerlink" title="2.2.1 四种普通节点"></a>2.2.1 四种普通节点</h3><p>在es节点的yml文件中可以配置节点的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf&#x2F;elasticsearch.yml:</span><br><span class="line">	node.master: true&#x2F;false</span><br><span class="line">	node.data: true&#x2F;false</span><br></pre></td></tr></table></figure>

<p>其中node.master配置表示节点是否具有成为主节点的资格节点。</p>
<blockquote>
<p>此属性的值为true，并不意味着这个节点就是主节点。因为真正的主节点，是由多个具有主节点资格的节点进行选举产生的。所以，这个属性只是代表这个节点是不是具有主节点选举资格。</p>
</blockquote>
<p>node.data配置表示节点是否存储数据。</p>
<p>node.master和node.data的取值可以有四种情况，表示四种节点类型。</p>
<ul>
<li><p><code>node.master: true</code>并且<code>node.data: true</code></p>
<ul>
<li>这种组合表示这个节点即有成为主节点的资格，又存储数据。这个时候如果某个节点被选举成为了真正的主节点，那么他还要存储数据，这样对于这个节点的压力就比较大了。<strong>elasticsearch默认每个节点都是这样的配置</strong>，在测试环境下这样做没问题。实际工作中建议不要这样设置，这样相当于主节点和数据节点的角色混合到一块了。</li>
</ul>
</li>
<li><p><code>node.master: false</code>并且<code>node.data: true</code></p>
<ul>
<li>这种组合表示这个节点没有成为主节点的资格，也就不参与选举，只会存储数据。这个节点我们称为<strong>data(数据)节点</strong>。在集群中需要单独设置几个这样的节点负责存储数据，后期提供存储和查询服务</li>
</ul>
</li>
<li><p><code>node.master: true</code>并且<code>node.data: false</code></p>
<ul>
<li>这种组合表示这个节点不会存储数据，有成为主节点的资格，可以参与选举，有可能成为真正的主节点。对于master节点而言，这样的配置是最适合的。</li>
</ul>
</li>
<li><p><code>node.master: false</code>并且<code>node.data: false</code></p>
<ul>
<li>这种组合表示这个节点即不会成为主节点，也不会存储数据，这个节点的意义是作为一个<strong>client(客户端)节点</strong>，主要是针对海量请求的时候，这些节点负责处理用户请求，实现请求转发，负载均衡等功能。</li>
</ul>
</li>
</ul>
<h3 id="2-2-2-master节点"><a href="#2-2-2-master节点" class="headerlink" title="2.2.2 master节点"></a>2.2.2 master节点</h3><p>拥有选举成为master节点资格的节点经过选举，成为了master节点，</p>
<p>Elasticsearch中的master并不像mysql、hadoop集群的master那样，它既不是集群数据的唯一流入点，也不是所有元数据的存放点。所以，一般情况下Elasticsearch的Master负载是很低的。</p>
<p>master集群的主要工作有：</p>
<ol>
<li><p>同步集群状态：集群状态信息，由master节点进行维护，并且同步到集群中所有节点。也就是说集群中的任何节点都存储着集群状态信息（经过master的同步），但只有Master能够改变信息。我们可以通过接口读取它，如：/_cluster/state</p>
<ul>
<li><p>集群状态中包括：</p>
<ol>
<li>集群层面的设置</li>
<li>集群内有哪些节点的信息</li>
<li>各索引的设置，映射，分析器和别名等设置</li>
<li>索引内各分片所在的节点位置</li>
</ol>
</li>
</ul>
</li>
<li><p>集群状态的修改：集群状态的修改通过Master节点完成，比如索引的创建删除，mapping的修改等等。</p>
<ul>
<li>我们知道配置项dynamic=true表示对于未mapping的新字段，es会尝试猜测该字段的类型，并mapping它。此时数据节点需要跟Master通信，通知Master修改Mapping。这个时候的index写入是阻塞的。等Master修改了集群状态之后，再同步到所有节点，才可以继续写入。</li>
</ul>
</li>
</ol>
<h3 id="2-2-4-master选举"><a href="#2-2-4-master选举" class="headerlink" title="2.2.4 master选举"></a>2.2.4 master选举</h3><p>详见另一篇文章<a href="https://my.oschina.net/lscherish/blog/3167953" target="_blank" rel="noopener" title="ElasticSearch Master选举机制浅析">ElasticSearch Master选举机制浅析</a></p>
<h2 id="2-3-分片-Shared"><a href="#2-3-分片-Shared" class="headerlink" title="2.3 分片(Shared)"></a>2.3 分片(Shared)</h2><p>分片是什么？简单来讲就是咱们在ES中所有数据的文件块，也是<strong>数据的最小单元块</strong>，整个ES集群的核心就是对所有分片进行分布、索引、负载、路由等操作，来达到惊人的速度。</p>
<p>文档存储在分片中，然后分片分配到集群中的节点上。当集群扩容或缩小，Elasticsearch 将会自动在节点间迁移分片，以使集群保持平衡。</p>
<blockquote>
<p>假设 IndexA 有2个分片，我们向 IndexA 中插入10条数据 (10个文档)，那么这10条数据会尽可能平均的分为5条存储在第一个分片，剩下的5条会存储在另一个分片中。</p>
</blockquote>
<p>一个分片(shard)是一个最小级别“<strong>工作单元(worker unit)</strong>”，大多数情况下，它只是保存了索引中所有数据的<strong>一部分</strong>。</p>
<blockquote>
<p>这类似于 MySql 的分库分表。</p>
</blockquote>
<h3 id="2-3-1-分片的种类"><a href="#2-3-1-分片的种类" class="headerlink" title="2.3.1 分片的种类"></a>2.3.1 分片的种类</h3><p><strong>一个分片就是一个运行的 lucene 实例</strong>，一个节点可以包含多个分片，这些分片可以是：</p>
<ul>
<li><p>主分片（<strong>primary shard</strong>）</p>
<ul>
<li>用于解决数据<strong>水平扩展</strong>的问题，一个索引的所有数据是分布在所有主分片之上的（<strong>每个主分片承担一部分数据</strong>，主分片又分布在不同的节点上）</li>
<li>一个索引的主分片数量只能在创建时指定，<strong>es默认情况下数量为5</strong>，主分片数量一经指定<strong>后期无法修改</strong>，除非对数据进行重新构建索引（reindex操作）。</li>
</ul>
</li>
<li><p>副分片（<strong>replica shard</strong>）</p>
<ul>
<li>用于解决<strong>数据高可用</strong>的问题，一个副本分片即一个主分片的拷贝，其数量可以动态调整，通过增加副本分片也可以实现提升系统<strong>读性能</strong>的作用。</li>
<li>副本分片还可以实现es的<strong>故障转移</strong>，如果持有主分片的节点挂掉了，一个副本分片就会晋升为主分片的角色。<ul>
<li>为了达到故障转移的作用，主分片和其<strong>对应的</strong>副本分片是不会在同一个节点上的。</li>
</ul>
</li>
<li>对文档的新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片。<ul>
<li>为了提高写入的能力，ES这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，ES 通过乐观锁的方式控制，每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功。</li>
</ul>
</li>
<li>es默认情况下为每个主分片创造一个副本</li>
</ul>
</li>
</ul>
<h3 id="2-3-2-分片的优势"><a href="#2-3-2-分片的优势" class="headerlink" title="2.3.2 分片的优势"></a>2.3.2 分片的优势</h3><ol>
<li><strong>突破单节点容量上限</strong>，例如我们有10TB大小的总文档，分成20个分片分布于10台节点上，那么每个节点只需要1T的容量即可。</li>
<li><strong>服务高可用</strong>，由于有副本分片的存在，只要不是存储某个文档的node全挂了，那么这个文档数据就不会丢。副本分片提供了灾备的能力。</li>
<li><strong>故障转移</strong>，当主分片节点故障后，可升级一个副分片为新的主分片来应对节点故障。</li>
<li><strong>扩展性能</strong>，通过在所有replicas上并行搜索来提高读性能.由于replicas上的数据是近实时的(near realtime),因此所有replicas都能提供搜索功能,通过设置合理的replicas数量可以极高的提高搜索吞吐量</li>
</ol>
<h3 id="2-3-3-分片的配置"><a href="#2-3-3-分片的配置" class="headerlink" title="2.3.3 分片的配置"></a>2.3.3 分片的配置</h3><p>创建 IndexName 索引时候，在 Mapping 中可以如下设置分片 (curl)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT indexName</span><br><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;: &#123;</span><br><span class="line">		...</span><br><span class="line">		&quot;number_of_shards&quot;: 5,</span><br><span class="line">		&quot;number_of_replicas&quot;: 1</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Content-Type: application/json" -XPUT localhost:9200/indexName -d '</span><br><span class="line">&#123;</span><br><span class="line">	"settings": &#123;</span><br><span class="line">		...</span><br><span class="line">		"number_of_shards": 5,</span><br><span class="line">		"number_of_replicas": 1</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>

<p>当索引创建完成的时候，主分片的数量就固定了，但是复制分片的数量可以随时调整，根据需求扩大或者缩小规模。如把复制分片的数量从原来的 1 增加到 2 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Content-Type: application/json" -XPUT localhost:9200/indexName/_settings -d '</span><br><span class="line">&#123;</span><br><span class="line">    "number_of_replicas": 2</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-分片数量"><a href="#2-3-4-分片数量" class="headerlink" title="2.3.4 分片数量"></a>2.3.4 分片数量</h3><p>对于生产环境中分片的设定，需要提前做好容量规划，因为主分片数是在索引创建时预先设定的，后续无法修改。</p>
<p>那么分片的数量是否越大越好呢？答案当然是否定的。</p>
<ul>
<li><strong>分片数设置过小</strong><ul>
<li>导致后续无法通过增加节点进行水平扩展。</li>
<li>导致分片的数据量太大，数据在重新分配时耗时；</li>
</ul>
</li>
<li><strong>分片数设置过大</strong><ul>
<li>每个分片都是一个小的lucene索引，会消耗相应的资源;</li>
<li>影响搜索结果的相关性打分，影响统计结果的准确性；</li>
<li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能（每个搜索请求会调度到索引的每个分片中.但当分片位于同一个节点，就会开始竞争相同的硬件资源时, 性能便会逐步下降）；</li>
</ul>
</li>
</ul>
<blockquote>
<p>默认情况下，ES会为每个索引创建5个分片，即使是在单机环境下。这种冗余被称作过度分配（Over Allocation），目前看来这么做完全没有必要，仅在散布文档到分片和处理查询的过程中就增加了更多的复杂性，好在ES的优秀性能掩盖了这一点。但我们要知道在单机环境下配置5个分片是没有必要的。</p>
</blockquote>
<p>分片的数量和大小没有定例，可以参考官方的文档<a href="https://www.elastic.co/cn/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster" target="_blank" rel="noopener" title="我在 Elasticsearch 集群内应该设置多少个分片？">我在 Elasticsearch 集群内应该设置多少个分片？</a>，提取核心要素就是：</p>
<ol>
<li>“我应该有多少个分片？”<ul>
<li>答： 每个节点的分片数量应该保持在保持在低于每1GB堆内存对应集群的分片在20-25之间。</li>
<li>也就是shared number/node GBs &lt;20 或shared number/node GBs &lt;25，即shared number&lt;20 * node GBs 或 shared number&lt;25 * node GBs</li>
</ul>
</li>
<li>“我的分片应该有多大”？ <ul>
<li>答：分片大小为50GB通常被界定为适用于各种用例的极限，即不应该超过50GB。但实际上，根据经验，小于30GB更为合理</li>
</ul>
</li>
</ol>
<h3 id="2-3-5-分片和副本的分布"><a href="#2-3-5-分片和副本的分布" class="headerlink" title="2.3.5 分片和副本的分布"></a>2.3.5 分片和副本的分布</h3><p>配置一套高可用的集群，我们必须要了解es集群的数据分布和负载原理，我们先来看下es如何分布分片。</p>
<h4 id="2-3-5-1-主分片分布"><a href="#2-3-5-1-主分片分布" class="headerlink" title="2.3.5.1 主分片分布"></a>2.3.5.1 主分片分布</h4><p>假设我们只有三个主分片：</p>
<ul>
<li><strong>单机分片分布：</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-a0972163fdd585eb36a511f6bef04b07db1.png" alt=""></li>
</ul>
</li>
<li><strong>2个节点分片分布：</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-3469208ba209324551593faa0deb7686a3a.png" alt=""></li>
</ul>
</li>
<li><strong>3个节点分片分布：</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-c3b26a1f81c483e827284c297fa003681bd.png" alt=""></li>
</ul>
</li>
<li><strong>9个节点分片分布：</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-b9ed932890be90ea010a491301df5e2f41a.png" alt=""></li>
</ul>
</li>
</ul>
<p>可以看到，<strong>es尽量根据我们指定的分片数来平均分配到各个节点上</strong></p>
<h4 id="2-3-5-2-副本分布"><a href="#2-3-5-2-副本分布" class="headerlink" title="2.3.5.2 副本分布"></a>2.3.5.2 副本分布</h4><p>假设我们有3个节点，3个主分片，和若干个副本（下图边框有粗有细，粗的是主分片，细的是副本分片）</p>
<ul>
<li><strong>1个副本</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-a7dfac0e040e4da5ebefcc631c88dd7d111.png" alt=""></li>
</ul>
</li>
<li><strong>2个副本</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-275de0214674ffdb42ea21c4ef76ab192bf.png" alt=""></li>
</ul>
</li>
<li><strong>3个副本</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-daf2170fb6ed87cc747bc86c97849c09d42.png" alt=""></li>
</ul>
</li>
</ul>
<p>可以看到，es依旧尽量根据我们指定的主副分片数来平均分配到各个节点上，但是<strong>不会把存着相同数据的主副分片放在同一个节点上</strong>。</p>
<p>如果分片数量太多（如3个副本的情况），由于此时每台机器都已经占满自己的3个分片了，所以此时需要增加新的机器来存放每个主分片的第三个副本，如果没有新的机器。es不会允许同一个节点有多余的分片，所以提示了Unassigned，表示这些分片未指定。</p>
<h4 id="2-3-5-3-多个索引的分片分布"><a href="#2-3-5-3-多个索引的分片分布" class="headerlink" title="2.3.5.3 多个索引的分片分布"></a>2.3.5.3 多个索引的分片分布</h4><p><img src="https://oscimg.oschina.net/oscnet/up-638c00b3e77cfcf2ac50f3213fde5ad0454.png" alt=""></p>
<h3 id="2-3-6-分片分配策略和原理"><a href="#2-3-6-分片分配策略和原理" class="headerlink" title="2.3.6 分片分配策略和原理"></a>2.3.6 分片分配策略和原理</h3><p>详见<a href="https://www.easyice.cn/archives/248#gatewayAllocator" target="_blank" rel="noopener" title="ELASTICSEARCH ALLOCATION 分析">ELASTICSEARCH ALLOCATION 分析</a></p>
<h3 id="2-3-7-读写数据时的分片路由"><a href="#2-3-7-读写数据时的分片路由" class="headerlink" title="2.3.7 读写数据时的分片路由"></a>2.3.7 读写数据时的分片路由</h3><p>加入我们有一个拥有3个节点的集群，共拥有12个分片，其中有4个主分片（S0、S1、S2、S3）和8个副本分片（R0、R1、R2、R3），每个主分片对应两个副本分片，节点1是主节点（Master节点）负责整个集群的状态。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0e2de5975f04452b7f5d9a6192da6db57aa.png" alt=""></p>
<h4 id="2-3-7-1-对特定doc的读写操作"><a href="#2-3-7-1-对特定doc的读写操作" class="headerlink" title="2.3.7.1 对特定doc的读写操作"></a>2.3.7.1 对特定doc的读写操作</h4><p>写数据是只能写在主分片上，然后同步到副本分片。这里有四个主分片，<strong>数据是根据什么规则写到特定分片上的呢？这条索引数据为什么被写到S0上而不写到S1或S2上？那条数据为什么又被写到S3上而不写到S0上了？</strong></p>
<p>首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p>
<p><code>shard = hash(routing) % number\_of\_primary_shards</code></p>
<p>routing 是一个可变值，默认是文档的 <code>_id</code> ，也可以设置成一个自定义的值。routing 通过 hash 函数生成一个数字，然后这个数字再除以 <code>number_of_primary_shards</code> （主分片的数量）后得到余数 。这个在 0 到 numberofprimary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
<blockquote>
<p><strong>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</strong></p>
</blockquote>
<p>由于在ES集群中每个节点通过上面的计算公式都知道集群中的文档的存放位置，所以每个节点都有处理读写请求的能力。</p>
<p>在一个写请求被发送到某个节点后，该节点即为前面说过的协调节点，协调节点会根据路由公式计算出需要写到哪个分片上，再将请求转发到该分片的主分片节点上。</p>
<p>假如此时数据通过路由计算公式取余后得到的值是 shard = hash(routing) % 4 = 0，则具体流程如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bc10db22d8ebc5cf5d2b6e4d40d25faebc7.png" alt=""></p>
<ol>
<li><p>客户端向ES1节点（协调节点）发送写请求，通过路由计算公式得到值为0，则当前数据应被写到主分片S0上。</p>
</li>
<li><p>ES1节点将请求转发到S0主分片所在的节点ES3，ES3接受请求并写入到磁盘。</p>
</li>
<li><p>并发将数据复制到两个副本分片R0上，其中通过乐观并发控制数据的冲突。一旦所有的副本分片都报告成功，则节点ES3将向协调节点报告成功，协调节点向客户端报告成功。</p>
</li>
</ol>
<h4 id="2-3-7-2-搜索时的读操作"><a href="#2-3-7-2-搜索时的读操作" class="headerlink" title="2.3.7.2 搜索时的读操作"></a>2.3.7.2 搜索时的读操作</h4><p>es最强大的是做全文检索</p>
<ol>
<li><p>客户端发送请求到一个coordinate node。</p>
</li>
<li><p>协调节点将搜索请求转发到所有的shard对应的primary shard 或 replica shard ，都可以。</p>
</li>
<li><p>query phase：每个shard将自己的搜索结果（其实就是一些doc id）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</p>
</li>
<li><p>fetch phase：接着由协调节点根据doc id去各个节点上拉取实际的document数据，最终返回给客户端。</p>
</li>
</ol>
<p>写请求是写入primary shard，然后同步给所有的replica shard</p>
<p>读请求可以从primary shard 或者 replica shard 读取，采用的是随机轮询算法。</p>
<h2 id="2-4-段（segment）"><a href="#2-4-段（segment）" class="headerlink" title="2.4 段（segment）"></a>2.4 段（segment）</h2><p>数据被分配到特定的分片和副本上之后，最终是存储到磁盘上的，这样在断电的时候就不会丢失数据。</p>
<p>具体的存储路径可在配置文件 <code>../config/elasticsearch.yml</code>中进行设置，默认存储在安装目录的data文件夹下。建议不要使用默认值，因为若ES进行了升级，则有可能导致数据全部丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.data: &#x2F;path&#x2F;to&#x2F;data  &#x2F;&#x2F;索引数据</span><br><span class="line">path.logs: &#x2F;path&#x2F;to&#x2F;logs  &#x2F;&#x2F;日志记录</span><br></pre></td></tr></table></figure>

<p>segment是实现ES近实时搜索的关键，是数据索引（动词）过程中的重要载体。在说segment前，我们先要了解ES数据的存储和检索原理。</p>
<h3 id="2-4-1-倒排索引"><a href="#2-4-1-倒排索引" class="headerlink" title="2.4.1 倒排索引"></a>2.4.1 倒排索引</h3><ul>
<li><p>倒排索引的不可变好处</p>
<ul>
<li>不需要锁，提升了并发能力，避免锁的问题  </li>
<li>数据不变，一直保存在OS cache中，只要cache内存足够  </li>
<li>filter cache一直驻留在内存  </li>
<li>可以压缩，节省cpu和io开销<br>这个对应的就是primary shard的数量不变，不能修改field的属性（将date改成text）</li>
</ul>
</li>
<li><p>倒排索引不可变的坏处</p>
<ul>
<li>每次都需要重新构建整个索引</li>
</ul>
</li>
</ul>
<h3 id="2-4-2-倒排索引的不变性"><a href="#2-4-2-倒排索引的不变性" class="headerlink" title="2.4.2 倒排索引的不变性"></a>2.4.2 倒排索引的不变性</h3><p>写到磁盘的倒序索引是不变的：<strong>写到磁盘后，倒排索引就再也不变</strong>。</p>
<p>这会有很多好处：</p>
<ol>
<li>不需要添加锁。如果你从来不用更新索引，那么你就不用担心多个进程在同一时间改变索引。</li>
<li>因为不变，所以可以很好的做缓存。只要内核有足够的缓存空间，绝大多数的读操作会直接从内存而不需要经过磁盘。这大大提升了性能。</li>
<li>写一个单一的大的倒序索引可以让数据压缩，减少了磁盘I/O的消耗以及缓存索引所需的RAM。</li>
</ol>
<p>然而，索引的不变性也有缺点。<strong>如果你想让新修改过的文档可以被搜索到，你必须重新构建整个索引</strong>。</p>
<p>我们来试想一下这样一个场景：对于一个索引内的所有文档，我们将其分词，建立了一个很大的倒排索引，并将其写入磁盘中。</p>
<p>如果索引有更新，那就需要重新全量创建一个索引来替换原来的索引。这种方式在数据量很大时效率很低，并且由于创建一次索引的成本很高，更无法保证时效性。</p>
<h3 id="2-4-3-分段存储"><a href="#2-4-3-分段存储" class="headerlink" title="2.4.3 分段存储"></a>2.4.3 分段存储</h3><p>如何在不丢失不变形的好处下让倒序索引可以更改？答案是：使用不只一个的索引。 新添额外的索引来反映新的更改来替代重写所有倒序索引的方案。</p>
<p>为了解决这个问题，Lucene引入了段（segment）的概念，简单来说，一个段segment存储着若干个文档，以及这些文档的索引信息（如词频，词向量，域（field）索引等），也就是说，一个segment是一个完整的倒序索引的子集。</p>
<blockquote>
<p>segment文件中存储的内容，可见<a href="https://www.cnblogs.com/buxiangbuliang/p/9275501.html" target="_blank" rel="noopener" title="【Lucene】Lucene 学习之索引文件结构">【Lucene】Lucene 学习之索引文件结构</a></p>
</blockquote>
<p>所以现在index在Lucene中的含义就是多个segments的集合。文档被成功存储的整个过程如下：</p>
<ol>
<li><p><strong>延迟写策略</strong></p>
<ul>
<li>如果每次将数据写入磁盘，磁盘的I/O消耗会严重影响性能。故而Lucene采用延迟写策略，新的文档建立时首先在内存中建立索引buffer：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-155993f01f84b6ca529f6cd82232533cebd.png" alt=""></li>
</ul>
</li>
<li><p><strong>Refresh</strong></p>
<ul>
<li>当达到默认的时间（1秒钟）或者内存的数据达到一定量时，会触发一次刷新（Refresh），将内存中的数据整合，生成到一个新的段。</li>
<li>此时，按理来说，应该将新生成的段刷进磁盘当中，但是将新的segment提交到磁盘需要fsync来保障物理写入。fsync是很耗时的，它不能在每次文档更新时就被调用，否则性能会很低。</li>
<li><strong>在内存和磁盘之间是文件系统缓存</strong>，于是，ES先将新生成的段先写入到内核的文件系统缓存中，这个过程很轻量。</li>
<li>默认情况下每个分片会每秒自动refresh一次。可以通过参数<code>index.refresh_interval</code>来修改这个刷新间隔</li>
<li>我们也可以手动触发 refresh，<ul>
<li><code>POST/_refresh</code> 刷新所有索引。</li>
<li><code>POST/nba/_refresh</code>刷新指定的索引。</li>
</ul>
</li>
<li>在这个阶段，新生成的segment（下图灰色）虽然还未写入磁盘，但已经能够被搜索了，这也是es近实时搜索的原理。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-9d79bd8369c408074f7c5b1d09428f33e0d.png" alt=""></li>
</ul>
</li>
<li><p><strong>Flush</strong></p>
<ul>
<li><strong>新增的段被刷新到磁盘中</strong>。</li>
<li>段被写入到磁盘后会生成一个<strong>提交点</strong>，提交点是一个用来记录所有提交后段信息的文件。</li>
<li>一般Flush的时间间隔会比较久，默认30分钟，或者当translog（后文介绍）达到了一定的大小（超过512M），也会触发flush操作。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-71b2db0e3ad2006e3ddb191c753d5621d81.png" alt=""></li>
</ul>
</li>
</ol>
<blockquote>
<p>这里的<strong>内存使用的是ES的JVM内存</strong>，而<strong>文件缓存系统使用的是操作系统的内存</strong>。</p>
</blockquote>
<blockquote>
<p>新的数据会继续的被写入内存，但内存中的数据并不是以段的形式存储的，因此不能提供检索功能。由内存刷新到文件缓存系统的时候会生成了新的段，并将段打开以供搜索使用，而不需要等到被刷新到磁盘。</p>
</blockquote>
<blockquote>
<p>注意，在内存中的新文档不一定能够被索引，只有生成段后，新文档才可以被索引。</p>
</blockquote>
<p>以上是新增文档操作，删除和更新操作过程有些类似：</p>
<ul>
<li>删除，由于不可修改，所以对于删除操作，不会把文档从旧的段中移除，而是通过新增一个 <code>.del</code>文件，文件中会列出这些被删除文档的段信息。<ul>
<li>这个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。</li>
</ul>
</li>
<li>更新，不能修改旧的段来进行反映文档的更新，其实更新相当于是删除和新增这两个动作组成。<ul>
<li>会将旧的文档在 <code>.del</code>文件中标记删除，然后文档的新版本被索引到一个新的段中。</li>
<li>可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就会被移除。</li>
</ul>
</li>
</ul>
<h3 id="2-4-4-事务日志（Translog）"><a href="#2-4-4-事务日志（Translog）" class="headerlink" title="2.4.4 事务日志（Translog）"></a>2.4.4 事务日志（Translog）</h3><p>虽然通过延时写的策略可以减少数据往磁盘上写的次数，提升了整体的写入能力，但是我们知道文件缓存系统也是内存空间，属于操作系统的内存，只要是内存都存在断电或异常情况下丢失数据的危险。</p>
<p>为了避免丢失数据，Elasticsearch添加了<strong>事务日志（Translog）</strong>，事务日志记录了所有还没有持久化到磁盘的数据。添加了事务日志后整个写索引的流程如下图所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-de73b4c4125c117ac994bf3fba7c249e0d1.png" alt=""></p>
<ul>
<li>一个新文档被索引（动词）之后，先被写入到内存中，但是为了防止数据的丢失，会<strong>追加一份数据到事务日志中</strong>。不断有新的文档被写入到内存，同时也会不断被记录到事务日志中。这时新数据还不能被检索和查询。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-1d8d535fcccc9ffa0ad322e32c2a4126b91.png" alt=""></li>
</ul>
</li>
<li>当达到默认的刷新时间或内存中的数据达到一定量后，<strong>会触发一次refresh</strong>，将内存中的数据以一个新段形式刷新到文件缓存系统中并清空内存。这时虽然新段未被提交到磁盘，但是可以提供文档的检索功能且不能被修改。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-75e39cae236d7e2b714df71c59110211639.png" alt=""></li>
</ul>
</li>
<li>随着新文档索引不断被写入，当日志数据大小超过512M或者时间超过30分钟时，<strong>会触发一次flush</strong>。内存中的数据被写入到一个新段同时被写入到文件缓存系统，文件系统缓存中数据通过 fsync 刷新到磁盘中，生成提交点，日志文件被删除，创建一个空的新日志。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-67cd1c2287040e1cb59cc4051dc2b56b6f0.png" alt=""><h3 id="2-4-5-es写操作总结"><a href="#2-4-5-es写操作总结" class="headerlink" title="2.4.5 es写操作总结"></a>2.4.5 es写操作总结</h3></li>
</ul>
</li>
</ul>
<ol>
<li>先写入内存buffer，在buffer里的时候数据是搜索不到的；同时将数据写入translog日志文件。</li>
<li>如果buffer快满了，或者到一定时间，就会将内存buffer数据refresh 到一个新的segment file中，但是此时数据不是直接进入segment file磁盘文件，而是先进入os cache。这个过程就是 refresh。</li>
<li>每隔1秒钟，es将buffer中的数据写入一个新的segment file，每秒钟会写入一个新的segment file，这个segment file中就存储最近1秒内 buffer中写入的数据。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-45714517c4af324ce1eba2f227ef81df32f.png" alt=""></p>
<h3 id="2-4-6-段合并"><a href="#2-4-6-段合并" class="headerlink" title="2.4.6 段合并"></a>2.4.6 段合并</h3><p>由于自动刷新流程（refresh）每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦，比如每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段然后合并查询结果，所以段越多，搜索也就越慢。</p>
<p>Elasticsearch通过在后台定期进行<strong>段合并</strong>来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。段合并的时候会将那些<strong>旧的已删除文档从文件系统中清除</strong>。被删除的文档不会被拷贝到新的大段中。合并的过程中不会中断索引和搜索。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3d4c071b8381e9828b93a3036abb886dfed.png" alt=""></p>
<p>段合并在进行索引和搜索时会自动进行，合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中，这些段既可以是未提交的也可以是已提交的。合并结束后老的段会被删除，新的段被 flush 到磁盘，同时写入一个包含新段且排除旧的和较小的段的新提交点，新的段被打开可以用来搜索。</p>
<p>段合并的计算量庞大， 而且还要吃掉大量磁盘 I/O，段合并会拖累写入速率，如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。</p>
<h2 id="2-5-集群健康状态"><a href="#2-5-集群健康状态" class="headerlink" title="2.5 集群健康状态"></a>2.5 集群健康状态</h2><ul>
<li><p>green</p>
<ul>
<li>所有的主分片和副本分片都正常运行。</li>
</ul>
</li>
<li><p>yellow</p>
<ul>
<li>所有的主分片都正常运行，但不是所有的副本分片都正常运行。这意味着存在单点故障风险</li>
</ul>
</li>
<li><p>red</p>
<ul>
<li>有主分片没能正常运行。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/getting-started.html" target="_blank" rel="noopener" title="Elasticsearch权威指南">Elasticsearch权威指南</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/28d5e38e3ca7" target="_blank" rel="noopener" title="elasticsearch5.x集群HA原理(shards、replicas)">elasticsearch5.x集群HA### 2.3.3 分片和副本的分布</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/qdhxhz/p/11448451.html" target="_blank" rel="noopener" title="Elasticsearch(4)--- 基本概念(Index、Type、Document、集群、节点、分片及副本、倒排索引)">Elasticsearch(4)— 基本概念(Index、Type、Document、集群、节点、分片及副本、倒排索引)</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/cc06f9adbe82" target="_blank" rel="noopener" title="【ES】ElasticSearch 深入分片">【ES】ElasticSearch 深入分片</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_33775582/article/details/91425787" target="_blank" rel="noopener" title="Elasticsearch分片">Elasticsearch分片</a></p>
</li>
<li><p><a href="https://blog.csdn.net/J_bean/article/details/80147277" target="_blank" rel="noopener" title="elasticsearch节点(角色)类型解释：node.master和node.data">elasticsearch节点(角色)类型解释：node.master和node.data</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1488535" target="_blank" rel="noopener" title="全文搜索引擎Elasticsearch，这篇文章给讲透了">全文搜索引擎Elasticsearch，这篇文章给讲透了</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-hand-o-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-hand-o-right" aria-label="accessibility.next_page"></i></a>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">425.4k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
