<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/17/shell-notes-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/17/shell-notes-tips/" itemprop="url">shell notes&tips</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-17T18:56:32+08:00">
                2019-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/Linux%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">Linux相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/17/shell-notes-tips/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/07/17/shell-notes-tips/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  8.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  31
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><blockquote>
<p>ps：下文中，我们使用$ 表示终端提示符表示输入命令的符号，- 表示多行命令的换行（多行命令不挤在一行以便美观），&gt; 表示终端的输出。</p>
</blockquote>
<blockquote>
<p>右侧边有导航栏，可进行跳转</p>
</blockquote>
<hr>
<ul>
<li>shell脚本通常以shebang起始，/bin/bash是Bash的解释器命令路径 <code>#!/bin/bash</code></li>
</ul>
<h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><h3 id="fork模式"><a href="#fork模式" class="headerlink" title="fork模式"></a>fork模式</h3><p>我们所执行的任何程序，都是由父进程(parent process)所产生出来的一个子进程(child process)，子进程在结束后，将返回到父进程去。此一现像在Linux系统中被称为 fork。当子进程被产生的时候，将会从父进程那里获得一定的资源分配、及(更重要的是)继承父进程的环境。</p>
<ul>
<li><p>fork模式，脚本的执行方式有两种。</p>
<ul>
<li><p>将脚本名作为命令行参数（无须设置权限）</p>
<p>  <code>$ bash myScript.sh</code></p>
</li>
<li><p>授予脚本执行权限，将其变为可执行文件：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 755 myScript.sh</span><br><span class="line">$ .&#x2F;myScript.sh.</span><br></pre></td></tr></table></figure>
<h3 id="source模式"><a href="#source模式" class="headerlink" title="source模式"></a>source模式</h3><p>source方式的特点是，在不另外创建子进程，而是在当前的的Shell环境中执行。</p>
</li>
</ul>
</li>
<li><p>source模式，脚本的执行方式有两种。</p>
<ul>
<li><p>source命令+文件路径</p>
<p>  <code>$ source myScript.sh 或 source ./myScript.sh</code></p>
</li>
<li><p>. 命令</p>
<p>  <code>$ . myScript.sh 或 . ./myScript.sh</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="exec模式"><a href="#exec模式" class="headerlink" title="exec模式"></a>exec模式</h3><p>exec模式和source方式一样，不另外创建子进程，而是在当前的的Shell环境中执行脚本，但是执行完后会终止当前的shell进程，如果使用终端，可以看见执行exec后终端退出。</p>
<ul>
<li><p>exec命令</p>
<p>  <code>exec ./mytest.sh 或 exec myScript.sh</code></p>
</li>
</ul>
<hr>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>你在命令行中输入的绝大部分命令都可以放置在一个特殊的文件中，留待登录或启动新的bash会话时执行。将函数定义、别名以及环境变量设置放置在这种特殊文件中，是一种定制shell的常用方法。</p>
<ul>
<li>当用户登录shell时，会执行下列文件：<ul>
<li>/etc/profile</li>
<li>$HOME/.profile</li>
<li>$HOME/.bash_login</li>
<li>$HOME/.bash_profile<blockquote>
<p>注意，如果你是通过图形化登录管理器登入的话，是不会执行/etc/profile、$HOME/.profile和$HOME/.bash_profile这3个文件的。这是因为图形化窗口管理器并不会启动shell。当你打开终端窗口时才会创建shell，但这个shell也不是登录shell。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果.bash_profile或.bash_login文件存在，则不会去读取.profile文件。</p>
</blockquote>
<ul>
<li>交互式shell（如X11终端会话）或ssh执行单条命令（如ssh 192.168.1.1 ls /tmp）时，<br>会读取并执行以下文件：<ul>
<li>/etc/bash.bashrc</li>
<li>$HOME/.bashrc</li>
</ul>
</li>
<li>调用ssh登录会话<br>  <code>ssh 192.168.1.100</code><br>  这会创建一个新的登录bash shell，该shell会读取并执行以下文件：<ul>
<li>/etc/profile</li>
<li>/etc/bash.bashrc</li>
<li>$HOME/.profile</li>
<li>.bashrc_profile</li>
</ul>
</li>
<li>运行脚本  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果运行如下脚本：</span><br><span class="line">$&gt; cat myscript.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;Running&quot;</span><br></pre></td></tr></table></figure>
  不会执行任何配置文件，除非定义了环境变量BASH_ENV：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; export BASH_ENV&#x3D;~&#x2F;.bashrc </span><br><span class="line">$&gt; .&#x2F;myscript.sh</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li>
</ul>
<p>Shell变量大致可以分为3种类型： </p>
<ul>
<li><p>内部变量：系统提供，不用定义，不能修改，比如$#，$?，$*，$0等 </p>
</li>
<li><p>环境变量：系统提供，不用定义，可以修改，当前进程及其子进程中使用，比如PATH，PWD，SHELL等 </p>
</li>
<li><p>用户变量（本地变量）：用户定义，可以修改，在当前进程使用，比如var=123等</p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量有如下几种形式</p>
<ul>
<li>不加符号的等号操作符赋值</li>
</ul>
<p><code>varName=value</code>  </p>
<blockquote>
<p>如果value不包含任何空白字符（例如空格），那么就不需要将其放入引号中，否则必须使用单引号或双引号。</p>
</blockquote>
<ul>
<li>单引号的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;单引号不扩展或解释任何变量和符号</span><br><span class="line">$ test&#x3D;&#39;ps$?&#39;</span><br><span class="line">$ echo $test</span><br><span class="line">&gt; ps$?</span><br></pre></td></tr></table></figure></li>
<li>双引号的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;双引号会扩展解释变量和符号，其中$?为上条命令执行的结果</span><br><span class="line">$ test&#x3D;&quot;ps$?&quot;</span><br><span class="line">$ echo $test</span><br><span class="line">&gt; ps0</span><br></pre></td></tr></table></figure></li>
<li>反引号的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;反引号（键盘上的~键），将内容命令的输出存入变量，该例中将ps命令的输出存入test</span><br><span class="line">$ test&#x3D;&#96;ps&#96;</span><br><span class="line">$ echo $test</span><br><span class="line">PID TTY TIME CMD 2856 pts&#x2F;0 00:00:00 bash 3234 pts&#x2F;0 00:00:00 ps</span><br></pre></td></tr></table></figure></li>
<li>子shell的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用$()，将开启子shell，或者说子进程执行内容命令，并将内容命令的输出存入变量，该例中将ps命令的输出存入test</span><br><span class="line">$ test&#x3D;$(ps)</span><br><span class="line">$ echo $test</span><br><span class="line">PID TTY TIME CMD 2856 pts&#x2F;0 00:00:00 bash 3234 pts&#x2F;0 00:00:00 ps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，var = value不同于var=value。两边没有空格的等号是赋值操作符，加上空格的等号表示的是等量关系测试。</p>
</blockquote>
</li>
<li>export命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> HTTP_PROXY=192.168.1.23:3128</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HTTP_PROXY</span></span><br><span class="line">//export命令声明了将由子进程所继承的一个或多个变量。</span><br><span class="line">//这些变量被导出后，当前shell脚本所执行的任何应用程序都会获得这个变量。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要append变量，例如对PATH中添加一条新路径，可以使用如下命令：</p>
<figure class="highlight plain"><figcaption><span>export PATH</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 常见的环境变量</span><br><span class="line">- SHELL：环境变量SHELL获知当前使用的是哪种shell </span><br></pre></td></tr></table></figure>
<p>$ echo $SHELL<br>$ echo $0<br>/bin/bash</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- UID：环境变量UID中保存的是用户ID。root用户的UID是0。</span><br><span class="line">- PS1：当我们打开终端或是运行shell时，会看到类似于user@hostname:&#x2F;home&#x2F;$ 的提示字符串。不同的GNU&#x2F;Linux发布版中的提示字符串及颜色各不相同。我们可以利用PS1环境变量来定义主提示字符串。</span><br><span class="line">- PATH：PATH环境变量通常保存了可用于搜索可执行文件的路径列表。&#96;PATH&#x3D;&#x2F;usr&#x2F;bin; &#x2F;bin&#96;这意味着只要shell执行应用程序（二进制文件或脚本）时，它就会首先查找&#x2F;usr&#x2F;bin，然后查找&#x2F;bin。</span><br><span class="line">- LD_LIBRARY_PATH：LD_LIBRARY_PATH环境变量通常保存了可用于搜索库文件的路径列表。&#96;LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;lib; &#x2F;lib&#96;这意味着只要shell执行库文件时，它就会首先查找&#x2F;usr&#x2F;lib，然后查找&#x2F;lib。</span><br><span class="line">- IFS:内部字段分隔符（internal field separator）。IFS环境变量保存了用于分隔的字符。它是当前shell环境使用的默认定界字符串。IFS的默认值为空白字符（换行符、制表符或者空格）。</span><br></pre></td></tr></table></figure>
$ oldIFS=$IFS </li>
<li>IFS=, #IFS现在被设置为, </li>
<li>for item in $data; </li>
<li>do </li>
<li>echo Item: $item </li>
<li>done </li>
<li>IFS=$oldIFS</li>
</ul>
<blockquote>
<p>Item: name<br>Item: gender<br>Item: rollno<br>Item: location</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SHLVL：保存当前shell的层级</span><br><span class="line">### 访问变量</span><br><span class="line">- 和编译型语言不同，大多数脚本语言不要求在创建变量之前声明其类型。用到什么类型就是什么类型。在变量名前面加上一个美元符号就可以访问到变量的值。也可以使用$&#123;var&#125;。其分别如下：</span><br></pre></td></tr></table></figure>
<p>$ fruit=apple<br>$ count=5<br>$ echo “We have $count ${fruit}s”</p>
<blockquote>
<p>We have 5 apples<br>//因为shell使用空白字符来分隔单词，<br>//所以我们需要加上一对花括号来告诉shell这里的变量名是fruit，<br>//而不是fruits。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 获得字符串的长度</span><br><span class="line">- 可以用下面的方法获得变量值的长度：</span><br></pre></td></tr></table></figure>
<p>$ var=12345678901234567890<br>$ echo $操作符</p>
</li>
</ul>
<p>% %% # ## 操作符可以得到变量var删除特定的值后的结果：</p>
<p>假设我们定义file=/dir1/dir2/dir3/my.file.txt</p>
<p>可以用${ }分别替换得到不同的值：</p>
<ul>
<li>${file#*/}：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt</li>
<li>${file##*/}：删掉最后一个 /  及其左边的字符串：my.file.txt</li>
<li>${file#*.}：删掉第一个 .  及其左边的字符串：file.txt</li>
<li>${file##*.}：删掉最后一个 .  及其左边的字符串：txt</li>
<li>${file%/*}：删掉最后一个  /  及其右边的字符串：/dir1/dir2/dir3</li>
<li>${file%%/*}：删掉第一个 /  及其右边的字符串：(空值)</li>
<li>${file%.*}：删掉最后一个  .  及其右边的字符串：/dir1/dir2/dir3/my.file</li>
<li>${file%%.*}：删掉第一个  .   及其右边的字符串：/dir1/dir2/dir3/my</li>
</ul>
<blockquote>
<p>记忆方法：  </p>
<h1 id="是去掉左边（键盘上-在-的左边）去掉左边的时候，通配符-就要在指定的符号左边"><a href="#是去掉左边（键盘上-在-的左边）去掉左边的时候，通配符-就要在指定的符号左边" class="headerlink" title="是去掉左边（键盘上#在 $ 的左边）去掉左边的时候，通配符*就要在指定的符号左边"></a>是去掉左边（键盘上#在 $ 的左边）去掉左边的时候，通配符*就要在指定的符号左边</h1><p>% 是去掉右边（键盘上% 在$ 的右边）去掉右边的时候，通配符*就要在指定的符号右边<br>单一符号是最小匹配；吝啬匹配<br>两个符号是最大匹配；贪婪匹配</p>
</blockquote>
<hr>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="${::}操作符"></a>${::}操作符</h4><ul>
<li>${file:0:5} ：提取从第0个开始的连续5个字节：/dir1</li>
<li>${file:5:5} ：提取第5个开始的连续5个字节：/dir2<h4 id=""><a href="#" class="headerlink" title="${//}"></a>${//}</h4></li>
<li>${file/dir/path}：将第一个dir替换为path：/path1/dir2/dir3/my.file.txt</li>
<li>${file//dir/path}：将全部dir 替换为 path：/path1/path2/path3/my.file.txt<blockquote>
<p>同样的：单一符号是最小匹配；吝啬匹配<br>两个符号是最大匹配；贪婪匹配</p>
</blockquote>
<h3 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp;和||"></a>&amp;&amp;和||</h3></li>
<li>shell 在执行某个命令的时候，会返回一个返回值，该返回值保存在 shell 变量 $? 中。当 $? == 0 时，表示执行成功；当 $? == 1 时（我认为是非0的数，返回值在0-255间），表示执行失败。</li>
<li>有时候，下一条命令依赖前一条命令是否执行成功。如：在成功地执行一条命令之后再执行另一条命令，或者在一条命令执行失败后再执行另一条命令等。shell 提供了 &amp;&amp; 和 || 来实现命令执行控制的功能，shell 将根据 &amp;&amp; 或 || 前面命令的返回值来控制其后面命令的执行。</li>
<li>无论是&amp;&amp;还是||，联合命令行都会尽量执行至成功为止。（这才有了短路的意义）  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2 [&amp;&amp; command3 ...]</span><br><span class="line">&#x2F;&#x2F;命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。</span><br><span class="line">&#x2F;&#x2F;只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? &#x3D;&#x3D; 0），&amp;&amp; 右边的命令才会被执行。</span><br><span class="line">&#x2F;&#x2F;只要有一个命令返回假（命令返回值 $? &#x3D;&#x3D; 1），后面的命令就不会被执行。</span><br><span class="line"></span><br><span class="line">command1 || command2 [|| command3 ...]</span><br><span class="line">&#x2F;&#x2F;命令之间使用 || 连接，实现逻辑或的功能。</span><br><span class="line">&#x2F;&#x2F;只有在 || 左边的命令返回假（命令返回值 $? &#x3D;&#x3D; 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。</span><br><span class="line">&#x2F;&#x2F;只要有一个命令返回真（命令返回值 $? &#x3D;&#x3D; 0），后面的命令就不会被执行。 –直到返回真的地方停止执行。</span><br></pre></td></tr></table></figure>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h3></li>
</ul>
<p>Unix shell脚本最棒的特性之一就是可以轻松地将多个命令组合起来生成输出。一个命令的输出可以作为另一个命令的输入，而这个命令的输出又会传递至下一个命令，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这里我们组合了3个命令。cmd1的输出传递给cmd2，cmd2的输出传递给cmd3，最终的输出 12（来自cmd3）会出现在显示器中或被导入某个文件。</span><br><span class="line">$ cmd1 | cmd2 | cmd3</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="shell代码执行顺序"><a href="#shell代码执行顺序" class="headerlink" title="shell代码执行顺序"></a>shell代码执行顺序</h2><h3 id="重定向执行顺序"><a href="#重定向执行顺序" class="headerlink" title="重定向执行顺序"></a>重定向执行顺序</h3><ul>
<li><p>先读取输入重定向符&lt;后的内容做为输入，如果一条命令有多个&lt;，会读取最后一个&lt;后的内容<br>输入重定向符&lt;放在命令前后都可以，例如【&lt; /etc/hosts cat】相当于【cat /etc/hosts】</p>
</li>
<li><p>执行命令</p>
</li>
<li><p>如果有&gt;或&gt;&gt;会将结果进行重定向，如果输出重定向多个文件，只会将内容重定向到最后一个文件<br>例如 cat /etc/hosts &gt; test1.txt &gt;test2.txt，只有test2.txt会出现内容，test1.txt内容是空的<br>输出重定向&gt;和&gt;&gt;的位置放在哪里都可以，例如【&gt; test.txt  cat /etc/hosts】，表示将/etc/hosts的内容输入到test.txt中</p>
</li>
</ul>
<h3 id="管道符执行顺序"><a href="#管道符执行顺序" class="headerlink" title="管道符执行顺序"></a>管道符执行顺序</h3><p><code>command1 | command2</code><br>命令1必须要有输出，且是正确的。命令2才会执行。命令1的输出作为命令2的输入</p>
<hr>
<h2 id="数学运算-let、-和"><a href="#数学运算-let、-和" class="headerlink" title="数学运算-let、(( ))和[]"></a>数学运算-let、(( ))和[]</h2><p>Bash shell使用let、(( ))和[]执行基本的算术操作。工具expr和bc可以用来执行高级操作。</p>
<ul>
<li>let命令<ul>
<li>let命令可以直接执行基本的算术操作。当使用let时，变量名之前不需要再添加$，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ no1&#x3D;4; </span><br><span class="line">$ no2&#x3D;5;</span><br><span class="line">$ let result&#x3D;no1</span><br><span class="line">$ echo $result</span><br><span class="line">&gt; 9</span><br></pre></td></tr></table></figure></li>
<li>let自操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ let no1++</span><br><span class="line">$ let no1--</span><br><span class="line">$ let no+&#x3D;6</span><br><span class="line">$ let no-&#x3D;6</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>操作符$[]和$(())<ul>
<li>操作符[]的使用方法和let命令一样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ result&#x3D;$[ no1 + no2 ]</span><br><span class="line">&#x2F;&#x2F;在[]中也可以使用$前缀，例如：</span><br><span class="line">$ result&#x3D;$[ $no1 + 5 ]</span><br><span class="line">&#x2F;&#x2F;也可以使用操作符(())</span><br><span class="line">$ result&#x3D;$(( no1 + 50 ))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>expr<ul>
<li>expr同样可以用于基本算术操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ result&#x3D;&#96;expr 3 + 4&#96;</span><br><span class="line">$ result&#x3D;$(expr $no1 + 5)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>bc<ul>
<li>上述命令不支持浮点数计算，浮点数计算需要使用bc命令，bc是一个用于数学运算的高级实用工具，这个精密的计算器包含了大量的选项。我们可以借助它执行浮点数运算并使用一些高级函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;4 * 0.56&quot; | bc</span><br><span class="line">&gt; 2.24</span><br><span class="line">$ no&#x3D;54; </span><br><span class="line">$ result&#x3D;&#96;echo &quot;$no * 1.5&quot; | bc&#96;</span><br><span class="line">$ echo $result</span><br><span class="line">&gt; 81.0</span><br></pre></td></tr></table></figure></li>
<li>设定小数精度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在下面的例子中，参数scale&#x3D;2将小数位个数设置为2。因此，bc将会输出包含两个小数位的数值：</span><br><span class="line">$ echo &quot;scale&#x3D;2;22&#x2F;7&quot; | bc</span><br><span class="line">&gt; 3.14</span><br></pre></td></tr></table></figure></li>
<li>进制转换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用bc可以将一种进制系统转换为另一种。来看看下面的代码是如何在十进制与二进制之间相互转换的：</span><br><span class="line">$ no&#x3D;100 </span><br><span class="line">$ echo &quot;obase&#x3D;2;$no&quot; | bc</span><br><span class="line">&gt; 1100100</span><br><span class="line">$ no&#x3D;1100100 </span><br><span class="line">$ echo &quot;obase&#x3D;10;ibase&#x3D;2;$no&quot; | bc</span><br><span class="line">&gt; 100</span><br></pre></td></tr></table></figure></li>
<li>计算平方以及平方根。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;sqrt(100)&quot; | bc #Square root </span><br><span class="line">$ echo &quot;10^10&quot; | bc #Square</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="文件描述符与重定向"><a href="#文件描述符与重定向" class="headerlink" title="文件描述符与重定向"></a>文件描述符与重定向</h2><p>文件描述符是与输入和输出流相关联的整数。最广为人知的文件描述符是stdin、stdout和stderr。文件描述符0、1以及2是系统预留的。</p>
<ul>
<li><p>文件描述符</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 —— stdin （标准输入）。</span><br><span class="line">1 —— stdout（标准输出）。</span><br><span class="line">2 —— stderr（标准错误）。</span><br></pre></td></tr></table></figure></li>
<li><p>重定向符号</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt; file</td>
<td align="center">输入重定向，将&lt;后的file文件内容作为command执行前的输入</td>
</tr>
<tr>
<td align="center">&gt; file 或1&gt;file</td>
<td align="center">输出重定向，将标准正确输出覆盖到后面的file文件内</td>
</tr>
<tr>
<td align="center">&gt;&gt; file或1&gt;&gt;file</td>
<td align="center">输出重定向，将标准正确输出追加到后面的file文件内</td>
</tr>
<tr>
<td align="center">2&gt;file</td>
<td align="center">输出重定向，将标准错误输出覆盖到后面的file文件内</td>
</tr>
<tr>
<td align="center">2&gt;&gt;file</td>
<td align="center">输出重定向，将标准错误输出追加到后面的file文件内</td>
</tr>
<tr>
<td align="center">&amp;&gt;file 或 &gt;file 2&gt;&amp;1</td>
<td align="center">输出重定向，将标准正确输出和标准错误输出覆盖到后面的file文件内</td>
</tr>
<tr>
<td align="center">&amp;&gt;&gt;file 或 &gt;&gt;file 2&gt;&amp;1</td>
<td align="center">输出重定向，将标准正确输出和标准错误输出追加到后面的file文件内</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>如果你不想看到或保存错误信息，那么可以将stderr的输出重定向到/dev/null，保证一切都<br>会被清除得干干净净。</p>
</blockquote>
<blockquote>
<p>cat&lt;<EOF>log.txt，注意，&lt;&lt;EOF是固定用法，&lt;&lt;不是指输入重定向两次，命令&lt;&lt;EOF会将键入的、以EOF输入字符为标准输入结束的流内容作为输入。然后按照重定向执行顺序，第二步骤执行cat命令，输出&lt;&lt;EOF键入的内容，最后将其重定向进log.txt</p>
</blockquote>
<hr>
<h2 id="数组与关联数组"><a href="#数组与关联数组" class="headerlink" title="数组与关联数组"></a>数组与关联数组</h2><p>数组允许脚本利用索引将数据集合保存为独立的条目。Bash支持普通数组和关联数组，前者使用整数作为数组索引，后者使用字符串作为数组索引。当数据以数字顺序组织的时候，应该使用普通数组，例如一组连续的迭代。当数据以字符串组织的时候，关联数组就派上用场了，例如主机名称。</p>
<h3 id="值序列"><a href="#值序列" class="headerlink" title="值序列"></a>值序列</h3><p>值序列在循环中经常使用，我们可以使用{1..5}来得到1-5的数字序列,也可以使用{1,2,3,4,5}得到同样的序列，也可以用{a..z}得到a-z的集合。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;1..5&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1,2,3,4,5,6&#125;;</span></span><br><span class="line">- do</span><br><span class="line">-  echo $i </span><br><span class="line">- done</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><ul>
<li><p>定义数组</p>
<ul>
<li>可以在单行中使用数值列表来定义一个数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这些值将会存储在以0为起始索引的连续位置上</span><br><span class="line">$ array_var&#x3D;(test1 test2 test3 test4)</span><br></pre></td></tr></table></figure></li>
<li>定义特定索引数组值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ array_var[2]&#x3D;&quot;test3&quot;</span><br></pre></td></tr></table></figure></li>
<li>定义空数组并加值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ array_var&#x3D;();</span><br><span class="line">&#x2F;&#x2F;加入someVar变量值 </span><br><span class="line">$ array_var+&#x3D;(&quot;$someVar&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>访问数组</p>
<ul>
<li>访问特定索引的数组元素内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;array_var[0]&#125; </span><br><span class="line">&gt; test1 </span><br><span class="line">$ index&#x3D;5 </span><br><span class="line">$ echo $&#123;array_var[$index]&#125; </span><br><span class="line">&gt; test6</span><br></pre></td></tr></table></figure></li>
<li>以列表形式打印出数组中的所有值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;array_var[*]&#125; </span><br><span class="line">&gt; test1 test2 test3 test4 test5 test6</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">$ echo $&#123;array_var[@]&#125; </span><br><span class="line">&gt; test1 test2 test3 test4 test5 test6</span><br></pre></td></tr></table></figure></li>
<li>打印数组长度（即数组中元素的个数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;#array_var[*]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3>关联数组从Bash 4.0版本开始被引入。当使用字符串（站点名、用户名、非顺序数字等）作为索引时，关联数组要比数字索引数组更容易使用。</li>
</ul>
</li>
<li><p>定义关联数组</p>
<p>  在关联数组中，我们可以用任意的文本作为数组索引。首先，需要使用声明语句将一个变量定义为关联数组</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ declare -A fruits_value</span><br><span class="line">$ fruits_value&#x3D;([apple]&#x3D;&#39;100 dollars&#39; [orange]&#x3D;&#39;150 dollars&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>访问数组</p>
<ul>
<li>用下面的方法显示数组内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;Apple costs $&#123;fruits_value[apple]&#125;&quot;</span><br><span class="line">&gt; Apple costs 100 dollars</span><br></pre></td></tr></table></figure></li>
<li>列出数组索引(对于普通数组，这个方法同样可行。)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;!fruits_value[*]&#125;</span><br><span class="line">&gt; orange apple</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">$ echo $&#123;!fruits_value[@]&#125;</span><br><span class="line">&gt; orange apple</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数和别名乍一看很相似，不过两者在行为上还是略有不同。alias是使用纯文本代替命令名，它在命令解析阶段就会把内容进行替换，由于替换过程完全是基于文本的，因而别名可以改变shell的语法；</p>
<p>函数的函数体是复合命令(bash)，函数名在命令解析阶段并不会被替换，只是在命令执行阶段调用相应的函数处理对应的复合命令。</p>
<p>函数参数可以在函数体中任意位置上使用，而别名只能将参数放在命令尾部。</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>函数的定义包括function命令、函数名、开/闭括号以及包含在一对花括号中的函数体。</p>
<ul>
<li>function 关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fname()</span><br><span class="line">&#123;</span><br><span class="line"> statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>无 function 关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fname()</span><br><span class="line">&#123;</span><br><span class="line"> statements;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">fname() &#123; statement; &#125;</span><br></pre></td></tr></table></figure></li>
<li>返回值<br>在定义函数时，可以在函数体中使用return来定义返回值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fname() </span><br><span class="line">&#123; </span><br><span class="line"> if [ $1 -eq 0 ];</span><br><span class="line"> then</span><br><span class="line"> 	return 0; #返回值</span><br><span class="line"> else</span><br><span class="line"> 	return 1; #返回值</span><br><span class="line"> fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们知道，在使用&amp;&amp;和||连接符时，判断依据即为符号前后命令的成功与否，返回值等于0为成功，大于0为失败。</p>
</blockquote>
</li>
</ul>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ fname ; &#x2F;&#x2F;执行函数</span><br><span class="line">或者</span><br><span class="line">$ fname arg1 arg2 ; &#x2F;&#x2F;函数参数可以按位置访问，$1是第一个参数，$2是第二个参数，</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数体中，要活用$1,$2,$*,$@等符号</p>
</blockquote>
<ul>
<li><p>递归调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fname() &#123;</span><br><span class="line">	echo $1; fname hello;</span><br><span class="line">	sleep 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义函数示例"><a href="#自定义函数示例" class="headerlink" title="自定义函数示例"></a>自定义函数示例</h3><blockquote>
<p>自定义函数需要定义在rc或者profile文件中，此文件的作用可详见<a href="https://wido.me/sunteya/understand-bashrc-and-profile/" target="_blank" rel="noopener" title="理解 bashrc 和 profile">理解 bashrc 和 profile</a></p>
</blockquote>
</li>
<li><p>对于<code>export PATH=/opt/myapp/bin:$PATH</code>，我们可以在.bashrc文件中定义一个新的函数，来简化这一追加路径的功能，使得<code>export PATH=/opt/myapp/bin:$PATH</code>等价于<code>prepend PATH /opt/myapp/bin</code>，其中$1=PATH,$2=/opt/myapp/bin：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prepend() &#123; [ -d &quot;$2&quot; ] &amp;&amp; eval $1&#x3D;\&quot;$2\$\&#123;$1:+&#39;:&#39;\$$1\&#125;\&quot; &amp;&amp; export $1 ; &#125;</span><br><span class="line">&#x2F;&#x2F; [ -d &quot;$2&quot; ]含义为先确认该函数第二个参数所指定的目录是否存在。</span><br><span class="line">&#x2F;&#x2F;如果存在，eval表达式将第一个参数所指定的变量值设置成第二个参数的值加上$\&#123;$1:+&#39;:&#39;\$$1\&#125;表达式的值</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;\&quot;$2\$\&#123;$1:+&#39;:&#39;\$$1\&#125;\&quot;</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;&quot;$2$&#123;PATH:+&#39;:&#39;$PATH&#125;&quot;   &#x2F;&#x2F;$1&#x3D;PATH有值</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;&quot;$2&#39;:&#39;$PATH&quot;</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;&quot;&#x2F;opt&#x2F;myapp&#x2F;bin:$PATH&quot;</span><br><span class="line">&#x2F;&#x2F;如果第二步执行成功，第三步，export，完成</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="逻辑关键字"><a href="#逻辑关键字" class="headerlink" title="逻辑关键字"></a>逻辑关键字</h2><h3 id="循环-for、while、until"><a href="#循环-for、while、until" class="headerlink" title="循环-for、while、until"></a>循环-for、while、until</h3><ul>
<li><p>面向列表的for循环</p>
<pre><code>list可以是一个字符串，也可以是一个值序列。</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in &#123;1..50&#125;;</span><br><span class="line">do</span><br><span class="line">	commands;#使用变量$var</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>迭代指定范围的数字</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for((i&#x3D;0;i&lt;10;i++))</span><br><span class="line">&#123;</span><br><span class="line">	commands; #使用变量$i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>循环到条件满足为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当条件为真时，while循环继续执行；当条件不为真时，until循环继续执行。</span><br><span class="line">&#x2F;&#x2F;用true或者:作为循环条件能够产生无限循环。</span><br><span class="line">while condition</span><br><span class="line">do</span><br><span class="line"> commands;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>until循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在Bash中还可以使用一个特殊的循环until。它会一直循环，直到给定的条件为真。例如：</span><br><span class="line">x&#x3D;0; </span><br><span class="line">until [ $x -eq 9 ]; #条件是[$x -eq 9 ] </span><br><span class="line">do</span><br><span class="line"> let x++; echo $x; </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="判断-if-else"><a href="#判断-if-else" class="headerlink" title="判断-if else"></a>判断-if else</h3></li>
<li><p>if条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if condition; </span><br><span class="line">then </span><br><span class="line">   commands; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
</li>
<li><p>else if和else</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if condition; </span><br><span class="line">then </span><br><span class="line">  commands; </span><br><span class="line">else if condition; then </span><br><span class="line">  commands; </span><br><span class="line">else </span><br><span class="line">  commands; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>if和else语句能够嵌套使用。if的条件判断部分可能会变得很长，但可以用<br>逻辑运算符将它变得简洁一些：<br>[ condition ] &amp;&amp; action; # 如果condition为真，则执行action<br>[ condition ] || action; # 如果condition为假，则执行action</p>
</blockquote>
</li>
</ul>
<h2 id="判断条件-和"><a href="#判断条件-和" class="headerlink" title="判断条件- [] 和 [[]]"></a>判断条件- [] 和 [[]]</h2><p>判断条件通常被放置在封闭的中括号内。一定要注意在 [ 和 ] 与操作数<strong>之间有一个空格</strong>。如果忘记了这个空格，脚本就会报错。<code>[$var -eq 0 ] or [ $var -eq 0]会报错</code></p>
<blockquote>
<p>在[]和[[ ]]中，其实任何一个符号两边都要有空格，所以在判断的时候，不要吝啬空格。</p>
</blockquote>
<ul>
<li><p>对数字变量或值进行算术条件比较</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ $var -eq 0 ] #当$var等于0时，返回真</span><br><span class="line">[ $var -ne 0 ] #当$var不为0时，返回真</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其他重要的操作符如下</p>
<ul>
<li><p>-gt：大于。</p>
</li>
<li><p>-lt：小于。</p>
</li>
<li><p>-ge：大于或等于。 </p>
</li>
<li><p>-le：小于或等于。</p>
<blockquote>
<p>这些操作符只适用于数值。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- 文件系统相关判断</span><br><span class="line"></span><br><span class="line">	我们可以使用不同的条件标志测试各种文件系统相关的属性。</span><br><span class="line">	- [ -f $file_var ]：如果给定的变量包含正常的文件路径或文件名，则返回真。</span><br><span class="line">	- [ -x $var ]：如果给定的变量包含的文件可执行，则返回真。</span><br><span class="line">	- [ -d $var ]：如果给定的变量包含的是目录，则返回真。</span><br><span class="line">	- [ -e $var ]：如果给定的变量包含的文件存在，则返回真。</span><br><span class="line">	- [ -c $var ]：如果给定的变量包含的是一个字符设备文件的路径，则返回真。</span><br><span class="line">	- [ -b $var ]：如果给定的变量包含的是一个块设备文件的路径，则返回真。</span><br><span class="line">	- [ -w $var ]：如果给定的变量包含的文件可写，则返回真。</span><br><span class="line">	- [ -r $var ]：如果给定的变量包含的文件可读，则返回真。</span><br><span class="line">	- [ -L $var ]：如果给定的变量包含的是一个符号链接，则返回真</span><br><span class="line">	- [ -s $var ]：如果给定的变量包含的文件大小大于0字节，则返回真</span><br><span class="line">	- [ $var1 -nt $var2 ]：new than操作，如果给定的变量包含的文件1比文件2新，则返回真</span><br><span class="line">	- [ $var1 -ot $var2 ]：old than操作，如果给定的变量包含的文件1比文件2旧，则返回真</span><br><span class="line">	- [ $var1 -ef $var2 ]：equal file操作，如果给定的变量包含的文件1和文件2为同一文件，则返回真</span><br><span class="line">- 字符串比较</span><br><span class="line"></span><br><span class="line">	**进行字符串比较时，最好用双中括号**，因为有时候采用单个中括号会产生错误。</span><br><span class="line">	- 测试两个字符串是否相同</span><br></pre></td></tr></table></figure>
//当str1等于str2时，返回真。也就是说，str1和str2包含的文本是一模一样的。
[[ $str1 = $str2 ]]

//这是检查字符串是否相同的另一种写法。
[[ $str1 == $str2 ]]

//如果str1和str2不相同，则返回真。
[[ $str1 != $str2 ]]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		&gt; 注意在&#x3D;前后各有一个空格。如果忘记加空格，那就不是比较关系了，而是变成了赋值语句。</span><br><span class="line">	- 字符串比较</span><br><span class="line">	</span><br><span class="line">		字符串是依据字符的ASCII值进行比较的。例如，A的值是0x41，a的值是0x61。因此，A</span><br><span class="line">小于a，AAa小于Aaa。</span><br></pre></td></tr></table></figure>
//如果str1的字母序比str2大，则返回真。
 [[ $str1 &gt; $str2 ]]
//如果str1的字母序比str2小，则返回真。
 [[ $str1 &lt; $str2 ]]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 判断空串</span><br></pre></td></tr></table></figure>
 [[ -z $str1 ]]    //如果str1为空串，则返回真。
 [[ ! -z $str1 ]]   //如果str1为空串，则返回假。与-n 等价
 [[ -n $str1 ]     //如果str1不为空串，则返回真。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 逻辑与和逻辑或</span><br><span class="line"></span><br><span class="line">	- -a是逻辑与操作符，-o是逻辑或操作符。可以按照下面的方法结合多个条件进行</span><br></pre></td></tr></table></figure>
[ $var1 -ne 0 -a $var2 -gt 2 ] #使用逻辑与-a
[ $var1 -ne 0 -o $var2 -gt 2 ] #逻辑或-o
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- [] 和 [[ ]]的区别</span><br><span class="line"></span><br><span class="line">二者基本相等，除了下述几点</span><br><span class="line"></span><br><span class="line">- 逻辑运算符不同</span><br><span class="line">	- []使用 -a 和 -o 来表达 与 和 或，不识别&amp;&amp; 和 ||</span><br><span class="line">	- [[ ]]使用 &amp;&amp; 和 || 来表达 与 和 或，不识别-a 和 -o</span><br><span class="line"></span><br><span class="line">- &#x3D;&#x3D;含义不同</span><br><span class="line"></span><br><span class="line">	- 在[[ ]]中，表达式&quot;&#x3D;&#x3D;&quot;和&quot;!&#x3D;&quot;的右边其实会被当做pattern匹配，只不过不是正则匹配，是通配符匹配（即？表示匹配单个字符，*表示匹配零个一个或多个字符）。</span><br><span class="line"></span><br><span class="line">- [[ ]]支持正则匹配</span><br><span class="line"></span><br><span class="line">	- 在[[ ]]中，表达式&quot;&#x3D;~&quot;的右边会被当做正则匹配</span><br><span class="line">		- 不过要注意，使用&quot;&#x3D;~&quot;时，右边表达式不需要引号，如：[[ &#39;$var&#39; &#x3D;~ a* ]]</span><br><span class="line"></span><br><span class="line">&gt; 使用建议，无论是[]还是[[ ]]，都建议对其变量使用双引号包围，换句话说，能做字符比较的时候，不要做数值比较。例如&#96;var&#x3D;&#39;shell script&#39; [ $var &#x3D; &quot;shell script&quot; ]&#96; 会报错，因为变量不加双引号，相当于[ shell script &#x3D; &quot;shell script&quot; ],这显然是错误的，所以应该加上引号&#96;[ &quot;$var&quot; &#x3D; &quot;shell script&quot; ]&#96;</span><br><span class="line"></span><br><span class="line">&gt; 使用建议，使用-eq数值比较的时候，可以在操作符两边同时+0，避免变量为空报错，当日，一边为常数的话可以不用+0：&#96; [ $((a+0)) -le 1]&#96;</span><br><span class="line"></span><br><span class="line">&gt; test命令可以用来测试条件。用test可以避免使用过多的括号，增强代码的可读性。[]中的测试条件同样可以用于test命令。&#96;if [ $var -eq 0 ]; then echo &quot;True&quot;; fi&#96; 等价于 &#96;if test $var -eq 0 ; then echo &quot;True&quot;; fi&#96;</span><br><span class="line">---</span><br><span class="line">## Linux&#x2F;unix文件系统</span><br><span class="line">### 文件权限</span><br><span class="line"></span><br><span class="line">文件权限和所有权是Unix&#x2F;Linux文件系统的显著特性之一。这些特性能够在多用户环境中保护你的个人信息。每一个文件都拥有多种类型的权限。在这些权限中，我们通常要和三组权限打交道：用户、用户组以及其他用户。</span><br><span class="line"></span><br><span class="line">用户（user）是文件的所有者，通常拥有所有的访问权。用户组（group）是多个用户的集合（由系统管理员指定），可能拥有文件的部分访问权。其他用户（others）是除文件所有者或用户组成员之外的任何人。</span><br><span class="line"></span><br><span class="line">ls命令的-l选项可以显示出包括文件类型、权限、所有者以及组在内的多方面信息：</span><br></pre></td></tr></table></figure></code></pre><p>$ ls -l </p>
<blockquote>
<p>-rw-r–r– 1 slynux users 2497 2010-02-28 11:22 bot.py<br>drwxr-xr-x 2 slynux users 4096 2010-05-27 14:31 a.py<br>-rw-r–r– 1 slynux users 539 2010-02-10 09:11 cl.pl</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">上述代码中，第1列表明了文件类型。字符串slynux users分别对应用户和用户组。在这里，slynux是文件所有者，也是组成员之一。</span><br><span class="line"></span><br><span class="line">其中文件类型有如下几种：</span><br><span class="line">- -：普通文件。</span><br><span class="line">- d：目录。</span><br><span class="line">- c：字符设备。</span><br><span class="line">- b：块设备。</span><br><span class="line">- l：符号链接。</span><br><span class="line">- s：套接字。</span><br><span class="line">- p：管道</span><br><span class="line"></span><br><span class="line">接下来的9个字符可以划分成三组，每组3个字符（--- --- ---）第一组的3个字符对应用户权限（所有者），第二组对应用户组权限，第三组对应其他用户权限。这9个字符（即9个权限）中的每一个字符指明是否其设置了某种权限。如果已设置，对应位置上会出现一个字符，否则出现一个-，表明没有设置对应的权限。</span><br><span class="line"></span><br><span class="line">有3种常见的字符。</span><br><span class="line"></span><br><span class="line">- r（read）：如果设置，表明该文件、设备或目录可读。</span><br><span class="line">- w（write）：如果设置，表明该文件、设备或目录可以被修改。对于目录而言，此权限指定了是否可以在目录下创建或删除文件。</span><br><span class="line">- x（execute）：如果设置，表明该文件可执行。对于目录而言，此权限指定了能否访问目录下的文件。</span><br><span class="line"></span><br><span class="line">同时这三组权限含义如下：</span><br><span class="line"></span><br><span class="line">- 用户（权限序列：rwx------）：定义了用户权限。通常来说，对于数据文件，用户权限是rw-；对于脚本或可执行文件，用户权限是rwx。用户还有一个称为setuid（S）的特殊权限，它出现在执行权限（x）的位置。setuid权限允许可执行文件以其拥有者的权限来执行，即使这个可执行文件是由其他用户运行的。具有setuid权限文件的权限序列可以是这样的：-rwS------。</span><br><span class="line">- 用户组（权限序列：---rwx---）：第二组字符指定了组权限。组权限中并没有setuid，但是有一个setgid（S）位。它允许使用与可执行文件所属组权限相同的有效组来运行该文件。但是这个组和实际发起命令的用户组未必相同。例如，组权限的权限序列可以是这样的：----rwS---。</span><br><span class="line">- 其他用户（权限序列：------rwx）：最后3个字符是其他用户权限。如果设置了相应的权限，其他用户也可以访问特定的文件或目录。作为一种规则，通常将这组权限设置为---。</span><br><span class="line"></span><br><span class="line">&gt; 目录有一个叫作粘滞位（sticky bit）的特殊权限。如果目录设置了粘滞位，只有创建该目录的用户才能删除目录中的文件，就算用户组和其他用户也有写权限，仍无能无力。粘滞位出现在其他用户权限组中的执行权限（x）位置。它使用t或T来表示。如果没有设置执行权限，但设置了粘滞位，就使用T；如果同时设置了执行权限和粘滞位，就使用t。例如：  </span><br><span class="line">&gt; &#96;------rwt , ------rwT&#96;  </span><br><span class="line">&gt; 设置目录粘滞位的一个典型例子就是&#x2F;tmp，也就是说任何人都可以在该目录中创建文件，</span><br><span class="line">&gt; 但只有文件的所有者才能删除其所创建的文件。</span><br><span class="line"></span><br><span class="line">&gt; 可使用chmod命令设置文件权限。具体参见博文 [常用shell命令导航（Linux shell脚本攻略笔记）](https:&#x2F;&#x2F;my.oschina.net&#x2F;u&#x2F;4133922&#x2F;blog&#x2F;3077074 &quot;常用shell命令导航（Linux shell脚本攻略笔记）&quot;)</span><br><span class="line"></span><br><span class="line">## 有用的函数或者脚本</span><br><span class="line"></span><br><span class="line">### 持续运行命令直至执行成功</span><br><span class="line">有时候命令只有在满足某些条件时才能够成功执行。例如，在下载文件之前必须先创建该文件。这种情况下，你可能希望重复执行命令，直到成功为止。</span><br></pre></td></tr></table></figure>
<p>//定义如下函数：<br>repeat()<br>{<br> while true<br> do<br> $@ &amp;&amp; return<br> done<br>}<br>//函数repeat()中包含了一个无限while循环，该循环执行以函数参数形式（通过$@访问）传入的命令。如果命令执行成功，则返回，进而退出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在大多数现代系统中，true是作为&#x2F;bin中的一个二进制文件来实现的。</span><br><span class="line">这就意味着每执行一次之前提到的while循环，shell就不得不生成一个进程。为了避免这种情况，可以使用shell的内建命令:，该命令的退出状态总是为0：</span><br></pre></td></tr></table></figure>
<p>repeat() { while :; do $@ &amp;&amp; return; done }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加入延时</span><br></pre></td></tr></table></figure>
<p>//每30秒才会运行一次<br>repeat() { while :; do $@ &amp;&amp; return; sleep 30; done }</p>
<pre><code>---</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/git%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%EF%BC%88Linux-Ubuntu%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/git%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%EF%BC%88Linux-Ubuntu%EF%BC%89/" itemprop="url">git安装集成（Linux Ubuntu）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-17T21:41:16+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">工具&软件安装集成相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/17/git%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%EF%BC%88Linux-Ubuntu%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/17/git安装集成（Linux-Ubuntu）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  41
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>git 拥有官方的安装指导页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;git-scm.com&#x2F;download&#x2F;linux</span><br></pre></td></tr></table></figure>

<p>ubuntu中我们使用<br><code>apt install git</code><br><img src="https://oscimg.oschina.net/oscnet/5b073f890c52cf1086a47b7649f9d9c035c.jpg" alt=""></p>
<p>安装完成后执行</p>
<p><code>git --version</code></p>
<p>得到</p>
<p><img src="https://oscimg.oschina.net/oscnet/66a3e034fecab46135045cb751a71d6977a.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/gradle%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/gradle%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90/" itemprop="url">Gradle安装集成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-16T21:34:57+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">工具&软件安装集成相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/16/gradle%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/16/gradle安装集成/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网寻找资源 <a href="https://gradle.org/releases/" target="_blank" rel="noopener">https://gradle.org/releases/</a> 红框部分得到下载链接<br><img src="https://oscimg.oschina.net/oscnet/8ffdfd582da547044513263a75684c10a73.jpg" alt=""></p>
<p>在Ubuntu环境下，使用<br><code>wget https://downloads.gradle.org/distributions/gradle-3.4.1-bin.zip</code><br>下载gradle</p>
<p>根据Gradle官方推荐，我们将安装包的内容解压至想要的路径（千万不要放在高权限路径）。<br><code>sudo unzip -d /home/lisheng/tools/gradle gradle-3.4.1-bin.zip</code></p>
<p>修改环境变量</p>
<p><code>sudo vim /etc/profile</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;$PATH:&#x2F;home&#x2F;lisheng&#x2F;tools&#x2F;gradle&#x2F;gradle-3.4.1&#x2F;bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>配置生效</p>
<p><code>source /etc/profile</code></p>
<p>输入gradle -v检查gradle是否安全完成，以及查看其版本号。<br><img src="https://oscimg.oschina.net/oscnet/97541a0ea7ae241c549c8ff65460c020209.jpg" alt=""></p>
<p>使用，直接创建gradle项目即可<br><img src="https://oscimg.oschina.net/oscnet/781840e501ad6e329cd99badf00692733cf.jpg" alt=""></p>
<h1 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a>wrapper</h1><p>当我们平时使用gradle来构建项目的时候，可以现在电脑上安装gradle，在配置环境变量之后就能正常使用了</p>
<p>不过当我们把项目分享给一个电脑上没安装gradle的人时，整体的项目构建还需要配置，显得麻烦。</p>
<p>由此就有了今天的主角：gradle wrapper 一个gradle的封装体，即使电脑上没有安装gradle也能构建。</p>
<p>初衷是因为gradle处于快速迭代阶段，经常发布新版本，如果我们的项目直接去引用，那么更改版本等会变得无比麻烦。而且每个项目又有可能用不一样的gradle版本，这样去手动配置每一个项目对应的gradle版本就会变得麻烦，gradle的引入本来就是想让大家构建项目变得轻松，如果这样的话，岂不是又增加了新的麻烦？所以android想到了包装，引入gradle-wrapper，通过读取配置文件中gradle的版本，为每个项目自动的下载和配置gradle，就是这么简单。</p>
<p>gradle建议开发者为每一个项目创建wrapper，以便其他人在没有gradle环境的机器上运行该项目。</p>
<p>如何创建wrapper呢？使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle wrapper</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/19e49b805f3219d5d183af9b616af9e6acf.jpg" alt=""></p>
<p>目录下会生成以下目录结构<br>Project-name/<br>  gradlew<br>  gradlew.bat<br>  gradle/wrapper/<br>    gradle-wrapper.jar<br>    gradle-wrapper.properties</p>
<p>因为就像wrapper本身的意义，gradle命令行也是善变的，所以wrapper对命令行也进行了一层封装，使用同一的gradlew命令，wrapper会自动去执行具体版本对应的gradle命令。需要使用gradle wrapper的时候，我们就直接在项目根目录下直接执行gradlew(gradle wrapper的简写), 使用gradlew的方式和gradle一模一样, 例如通过gradlew tasks来查看所有的任务。事实上，执行gradlew命令的时候，gradlew会委托gradle命令来做相应的事情，所以gradlew真的只是一个壳而已。</p>
<p>当执行gradlew的时候，wrapper会检查当前机器是否已经安装了对应版本的gradle，如果安装了那么gradlew就会委托gradle执行用户输入的命令。如果还未安装的话，那么首先会自动帮我们从gradle repository下载安装。当然你也可以在配置文件中指定想要下载的server来替代默认的gradle repo。</p>
<p>那么我们如何去修改要下载的gradle版本呢？通过修改gradle-wrapper.properties文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Fri May 17 00:24:36 CST 2019</span><br><span class="line">distributionBase&#x3D;GRADLE_USER_HOME</span><br><span class="line">distributionPath&#x3D;wrapper&#x2F;dists</span><br><span class="line">zipStoreBase&#x3D;GRADLE_USER_HOME</span><br><span class="line">zipStorePath&#x3D;wrapper&#x2F;dists</span><br><span class="line">distributionUrl&#x3D;https\:&#x2F;&#x2F;services.gradle.org&#x2F;distributions&#x2F;gradle-0.9-preview-1-bin.zip</span><br></pre></td></tr></table></figure>

<p>distributionUrl:要下载的gradle地址以及版本，gradle-wrapper会去wrapper/list目录下查找，如果没有对应版本的gradle就调用url资源采取下载</p>
<p>gradle的3种版本：</p>
<ul>
<li><p>gradle-xx-all.zip是完整版，包含了各种二进制文件，源代码文件，和离线的文档。例如，<a href="https://services.gradle.org/distributions/gradle-3.1-all.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-all.zip</a></p>
</li>
<li><p>gradle-xx-bin.zip是二进制版，只包含了二进制文件（可执行文件），没有文档和源代码。例如，<a href="https://services.gradle.org/distributions/gradle-3.1-bin.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-bin.zip</a></p>
</li>
<li><p>gradle-xx-src.zip是源码版，只包含了Gradle源代码，不能用来编译你的工程。例如，<a href="https://services.gradle.org/distributions/gradle-3.1-src.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-src.zip</a></p>
</li>
</ul>
<p>gradle-wrapper.properties各项属性的整体含义，如下：</p>
<ol>
<li><p>去 <a href="https://services.gradle.org/distributions/gradle-3.1-bin.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-bin.zip</a> 下载gradle的3.1版本，只包含binary的版本。</p>
</li>
<li><p>下载的gradle-3.1-bin.zip存放到C:\Users&lt;user_name&gt;.gradle\wrapper\dists目录中。（注：具体还有2级目录，即全路径为C:\Users&lt;user_name&gt;.gradle\wrapper\dists\gradle-3.1-bin&lt;url-hash&gt;\，gradle-3.1-bin目录是根据下载的gradle的文件名来定的，<url-hash>目录是根据distribution url路径字符串计算md5值得来的</p>
</li>
<li><p>解压gradle-3.1-bin.zip，将解压后的文件存放到C:\Users&lt;user_name&gt;.gradle\wrapper\dists中。（注：具体还有2级目录，同上）</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/" itemprop="url">ElasticSearch升级记录 ver.1.4.5→ver.5.2.0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-02T22:03:06+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">ElasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/02/ElasticSearch升级记录-ver-1-4-5→ver-5-2-0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目中的es由ver.1.4.5升级至ver.5.2.0。</p>
<h1 id="安装elasticSearch"><a href="#安装elasticSearch" class="headerlink" title="安装elasticSearch"></a>安装elasticSearch</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#下载</span><br><span class="line">wget https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;elasticsearch&#x2F;elasticsearch-5.2.0.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar zxvf elasticsearch-5.5.0.tar.gz</span><br></pre></td></tr></table></figure>
<h1 id="修改elasticsearch-yml"><a href="#修改elasticsearch-yml" class="headerlink" title="修改elasticsearch.yml"></a>修改elasticsearch.yml</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ES_HOME&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure>
<p>在这里不详细展开elasticsearch.yml的各个配置项，附上链接。<br><a href="https://www.cnblogs.com/zlslch/p/6419948.html" target="_blank" rel="noopener">配置es外部链接</a></p>
<h1 id="安装elasticsearch-head"><a href="#安装elasticsearch-head" class="headerlink" title="安装elasticsearch-head"></a>安装elasticsearch-head</h1><p>lasticsearch-head是一个很好的可视化前端框架，方便用可视化界面对es进行调用。elasticsearch-head在Github的地址如下：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a><br>安装也不复杂，由于它是一个前端的工具，因此需要我们预先安装了node和npm，之后执行下面的步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>安装完成后，运行命令npm run start就行。</p>
<h1 id="调整弃用api的兼容问题"><a href="#调整弃用api的兼容问题" class="headerlink" title="调整弃用api的兼容问题"></a>调整弃用api的兼容问题</h1><h2 id="1-setting"><a href="#1-setting" class="headerlink" title="1.setting"></a>1.setting</h2><p>1.4.5的org.elasticsearch.common.settings.ImmutableSettings已经弃用，生成配置对象setting的方式改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings settings &#x3D; Settings.builder().put(&quot;cluster.name&quot;, clusterName).put(&quot;client.transport.sniff&quot;, true).build();</span><br></pre></td></tr></table></figure>

<h2 id="2-InetSocketTransportAddress"><a href="#2-InetSocketTransportAddress" class="headerlink" title="2.InetSocketTransportAddress"></a>2.InetSocketTransportAddress</h2><p>org.elasticsearch.common.transport.InetSocketTransportAddress#InetSocketTransportAddress(java.lang.String, int)方法已经弃用，注入集群地址的方式改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clusterNodeAddressList.add(new InetSocketTransportAddress(InetAddress.getByName(host), 9300));</span><br></pre></td></tr></table></figure>
<h2 id="3-TransportClient"><a href="#3-TransportClient" class="headerlink" title="3.TransportClient"></a>3.TransportClient</h2><p>org.elasticsearch.client.transport.TransportClient#TransportClient(org.elasticsearch.common.settings.Settings)，该构造方法已经弃用，生成TransportClient实例的方式改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transportClient &#x3D; new PreBuiltTransportClient(settings);</span><br></pre></td></tr></table></figure>
<h2 id="4-ClusterHealthStatus"><a href="#4-ClusterHealthStatus" class="headerlink" title="4.ClusterHealthStatus"></a>4.ClusterHealthStatus</h2><p>org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus类已经弃用，相同功能由org.elasticsearch.cluster.health.ClusterHealthStatus继承</p>
<h2 id="5-ScriptSortBuilder调整"><a href="#5-ScriptSortBuilder调整" class="headerlink" title="5.ScriptSortBuilder调整"></a>5.ScriptSortBuilder调整</h2><p>原版写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Integer&gt; optionalSortMap &#x3D; manualSortMapBuilder.put(&quot;other&quot;, sortIndex + 1).build();</span><br><span class="line"></span><br><span class="line">String script &#x3D; &quot;paramsMap.containsKey(doc[\&quot;%s\&quot;].value) ? paramsMap.get(doc[\&quot;%s\&quot;].value) : paramsMap.get(&#39;other&#39;)&quot;;</span><br><span class="line"></span><br><span class="line">script &#x3D; String.format(script, sort.getFieldName(), sort.getFieldName());</span><br><span class="line"></span><br><span class="line">sortBuilder &#x3D; SortBuilders.scriptSort(script, &quot;number&quot;).param(&quot;paramsMap&quot;, optionalSortMap).order(SortOrder.ASC).missing(optionalSortMap.get(&quot;other&quot;));</span><br></pre></td></tr></table></figure>

<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Integer&gt; optionalSortMap &#x3D; manualSortMapBuilder.put(&quot;other&quot;, sortIndex + 1).build();</span><br><span class="line"></span><br><span class="line">String script &#x3D; &quot;paramsMap.containsKey(doc[\&quot;%s\&quot;].value) ? paramsMap.get(doc[\&quot;%s\&quot;].value) : paramsMap.get(&#39;other&#39;)&quot;;</span><br><span class="line"></span><br><span class="line">script &#x3D; String.format(script, sort.getFieldName(), sort.getFieldName());</span><br><span class="line">Map&lt;String, Object&gt; params &#x3D; Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">params.put(&quot;paramsMap&quot;, optionalSortMap);</span><br><span class="line"></span><br><span class="line">Script scriptObject &#x3D; new Script(Script.DEFAULT_SCRIPT_TYPE, Script.DEFAULT_SCRIPT_LANG, script, params);</span><br><span class="line"></span><br><span class="line">sortBuilder &#x3D; SortBuilders.scriptSort(scriptObject, ScriptSortBuilder.ScriptSortType.fromString(&quot;number&quot;)).order(SortOrder.ASC);</span><br></pre></td></tr></table></figure>
<h2 id="6-FilterBuilder调整"><a href="#6-FilterBuilder调整" class="headerlink" title="6.FilterBuilder调整"></a>6.FilterBuilder调整</h2><p>org.elasticsearch.index.query.FilterBuilder类已经弃用，基本上从2.x版本开始，Filter就已经弃用了（不包括bool查询内的filter），所有FilterBuilder全都要用QueryBuilder的各种子类来调整：</p>
<h3 id="1-org-elasticsearch-index-query-BoolFilterBuilder"><a href="#1-org-elasticsearch-index-query-BoolFilterBuilder" class="headerlink" title="1.org.elasticsearch.index.query.BoolFilterBuilder"></a>1.org.elasticsearch.index.query.BoolFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoolFilterBuilder boolFilterBuilder &#x3D; FilterBuilders.boolFilter();</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoolQueryBuilder boolFilterBuilder &#x3D; new BoolQueryBuilder();</span><br></pre></td></tr></table></figure>

<h3 id="2-org-elasticsearch-index-query-NestedFilterBuilder"><a href="#2-org-elasticsearch-index-query-NestedFilterBuilder" class="headerlink" title="2.org.elasticsearch.index.query.NestedFilterBuilder"></a>2.org.elasticsearch.index.query.NestedFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; FilterBuilders.nestedFilter(param.getPath(), boolFilterBuilder);</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; new NestedQueryBuilder(param.getPath(), boolFilterBuilder, ScoreMode.None);</span><br></pre></td></tr></table></figure>

<h3 id="3-org-elasticsearch-index-query-MissingFilterBuilder"><a href="#3-org-elasticsearch-index-query-MissingFilterBuilder" class="headerlink" title="3.org.elasticsearch.index.query.MissingFilterBuilder"></a>3.org.elasticsearch.index.query.MissingFilterBuilder</h3><p>5.x版本中，missing关键字已经弃用，其功能由其逆运算exist继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MissingFilterBuilder missingFilterBuilder &#x3D; FilterBuilders.missingFilter(paramName);</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.EXISTS) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.boolFilter().mustNot(missingFilterBuilder);</span><br><span class="line">&#125;</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.MISSING) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.boolFilter().must(missingFilterBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExistsQueryBuilder existsQueryBuilder &#x3D; new ExistsQueryBuilder(paramName);</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.EXISTS) &#123;</span><br><span class="line">    filterBuilder &#x3D; new BoolQueryBuilder().must(existsQueryBuilder);</span><br><span class="line">&#125;</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.MISSING) &#123;</span><br><span class="line">    filterBuilder &#x3D; new BoolQueryBuilder().mustNot(existsQueryBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-org-elasticsearch-index-query-TermFilterBuilder"><a href="#4-org-elasticsearch-index-query-TermFilterBuilder" class="headerlink" title="4.org.elasticsearch.index.query.TermFilterBuilder"></a>4.org.elasticsearch.index.query.TermFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; FilterBuilders.termFilter(paramName, param.getEqValue());</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; new TermQueryBuilder(paramName, param.getEqValue());</span><br></pre></td></tr></table></figure>

<h3 id="5-org-elasticsearch-index-query-TermsFilterBuilder"><a href="#5-org-elasticsearch-index-query-TermsFilterBuilder" class="headerlink" title="5.org.elasticsearch.index.query.TermsFilterBuilder"></a>5.org.elasticsearch.index.query.TermsFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; FilterBuilders.inFilter(paramName, param.getInValues());</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; new TermsQueryBuilder(paramName, param.getInValues());</span><br></pre></td></tr></table></figure>

<h3 id="6-org-elasticsearch-index-query-RangeFilterBuilder"><a href="#6-org-elasticsearch-index-query-RangeFilterBuilder" class="headerlink" title="6.org.elasticsearch.index.query.RangeFilterBuilder"></a>6.org.elasticsearch.index.query.RangeFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;gte</span><br><span class="line">if (null !&#x3D; param.getGteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).gte(param.getGteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;gt</span><br><span class="line">if (null !&#x3D; param.getGtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).gt(param.getGtValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lte</span><br><span class="line">if (null !&#x3D; param.getLteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).lte(param.getLteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lt</span><br><span class="line">if (null !&#x3D; param.getLtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).lt(param.getLtValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;gte</span><br><span class="line">if (null !&#x3D; param.getGteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).gte(param.getGteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;gt</span><br><span class="line">if (null !&#x3D; param.getGtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).gt(param.getGtValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lte</span><br><span class="line">if (null !&#x3D; param.getLteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).lte(param.getLteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lt</span><br><span class="line">if (null !&#x3D; param.getLtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).lt(param.getLtValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-search-type-count"><a href="#7-search-type-count" class="headerlink" title="7.search_type=count"></a>7.search_type=count</h2><p>原来我们想要计算文档的需要用到search_type=count，现在5.0已经将该API移除，取而代之你只需将size置于0即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;my_index&#x2F;_search?search_type&#x3D;count</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;my_terms&quot;: &#123;</span><br><span class="line">       &quot;terms&quot;: &#123;</span><br><span class="line">         &quot;field&quot;: &quot;foo&quot;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#5.0以后</span><br><span class="line">GET &#x2F;my_index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;my_terms&quot;: &#123;</span><br><span class="line">       &quot;terms&quot;: &#123;</span><br><span class="line">         &quot;field&quot;: &quot;foo&quot;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-RangeBuilder"><a href="#8-RangeBuilder" class="headerlink" title="8.RangeBuilder"></a>8.RangeBuilder</h2><p>org.elasticsearch.search.aggregations.bucket.range.RangeBuilder已经弃用，相应功能由org.elasticsearch.search.aggregations.bucket.range.RangeAggregationBuilder实现，直接替换即可。</p>
<h2 id="9-TopHitsAggregationBuilder"><a href="#9-TopHitsAggregationBuilder" class="headerlink" title="9.TopHitsAggregationBuilder"></a>9.TopHitsAggregationBuilder</h2><p>org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder已经弃用，相应功能由org.elasticsearch.search.aggregations.metrics.tophits.TopHitsAggregationBuilder实现，直接替换即可。</p>
<h2 id="10-FiltersAggregationBuilder"><a href="#10-FiltersAggregationBuilder" class="headerlink" title="10.FiltersAggregationBuilder"></a>10.FiltersAggregationBuilder</h2><p>org.elasticsearch.search.aggregations.bucket.filters.FiltersAggregationBuilder构造报文调整</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FiltersAggregationBuilder filtersAggregationBuilder &#x3D; AggregationBuilders.filters(aggregationField.getAggName());</span><br><span class="line">LufaxSearchConditionBuilder tmpConditionBuilder &#x3D; new LufaxSearchConditionBuilder();</span><br><span class="line">for (String key : aggregationField.getFiltersMap().keySet()) &#123;</span><br><span class="line">    LufaxFilterCondition tmpLufaxFilterCondition &#x3D; aggregationField.getFiltersMap().get(key);</span><br><span class="line">    FilterBuilder tmpFilterBuilder &#x3D; tmpConditionBuilder.constructFilterBuilder(tmpLufaxFilterCondition.getAndParams(),tmpLufaxFilterCondition.getOrParams(),tmpLufaxFilterCondition.getNotParams());</span><br><span class="line">    filtersAggregationBuilder.filter(key, tmpFilterBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调整成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;FiltersAggregator.KeyedFilter&gt; keyedFilters &#x3D; new LinkedList&lt;FiltersAggregator.KeyedFilter&gt;();</span><br><span class="line">LufaxSearchConditionBuilder tmpConditionBuilder &#x3D; new LufaxSearchConditionBuilder();</span><br><span class="line">for (String key : aggregationField.getFiltersMap().keySet()) &#123;</span><br><span class="line">    LufaxFilterCondition tmpLufaxFilterCondition &#x3D; aggregationField.getFiltersMap().get(key);</span><br><span class="line">    QueryBuilder tmpFilterBuilder &#x3D; tmpConditionBuilder.constructFilterBuilder(tmpLufaxFilterCondition.getAndParams(),tmpLufaxFilterCondition.getOrParams(),tmpLufaxFilterCondition.getNotParams());</span><br><span class="line">    keyedFilters.add(new FiltersAggregator.KeyedFilter(key, tmpFilterBuilder));</span><br><span class="line">&#125;</span><br><span class="line">FiltersAggregationBuilder filtersAggregationBuilder &#x3D; AggregationBuilders.filters(aggregationField.getAggName(), keyedFilters.toArray(new FiltersAggregator.KeyedFilter[]&#123;&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="11-HighlightBuilder"><a href="#11-HighlightBuilder" class="headerlink" title="11.HighlightBuilder;"></a>11.HighlightBuilder;</h2><p>org.elasticsearch.search.highlight.HighlightBuilder弃用，相关功能由org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder实现。</p>
<h2 id="12-OptimizeRequestBuilder"><a href="#12-OptimizeRequestBuilder" class="headerlink" title="12.OptimizeRequestBuilder"></a>12.OptimizeRequestBuilder</h2><p>org.elasticsearch.action.admin.indices.optimize.OptimizeRequestBuilder 已经弃用，聚合索引的功能由org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequestBuilder来实现。</p>
<h2 id="13-IndicesAliasesRequestBuilder"><a href="#13-IndicesAliasesRequestBuilder" class="headerlink" title="13.IndicesAliasesRequestBuilder"></a>13.IndicesAliasesRequestBuilder</h2><h3 id="1-newAddAliasAction"><a href="#1-newAddAliasAction" class="headerlink" title="1.newAddAliasAction"></a>1.newAddAliasAction</h3><p>旧版删除了AliasAction类的newAddAliasAction方法，故而IndicesAliasesRequestBuilder添加AliasActions应该：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(AliasAction.newAddAliasAction(toIndex, indexAlias));</span><br></pre></td></tr></table></figure>

<p>调整成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(IndicesAliasesRequest.AliasActions.add().index(toIndex).alias(indexAlias));</span><br></pre></td></tr></table></figure>

<h3 id="2-newRemoveAliasAction"><a href="#2-newRemoveAliasAction" class="headerlink" title="2.newRemoveAliasAction"></a>2.newRemoveAliasAction</h3><p>旧版删除了AliasAction类的newRemoveAliasAction方法，故而IndicesAliasesRequestBuilder删除AliasActions应该：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(AliasAction.newRemoveAliasAction(fromIdx, indexAlias));</span><br></pre></td></tr></table></figure>

<p>调整成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(IndicesAliasesRequest.AliasActions.remove().index(fromIdx).alias(indexAlias));</span><br></pre></td></tr></table></figure>

<h2 id="14-AbstractAggregationBuilder的子类变更"><a href="#14-AbstractAggregationBuilder的子类变更" class="headerlink" title="14.AbstractAggregationBuilder的子类变更"></a>14.AbstractAggregationBuilder的子类变更</h2><h3 id="1-org-elasticsearch-search-aggregations-bucket-terms-TermsBuilder"><a href="#1-org-elasticsearch-search-aggregations-bucket-terms-TermsBuilder" class="headerlink" title="1.org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder"></a>1.org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder</h3><p>org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder更名为<br>org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder</p>
<h3 id="2-org-elasticsearch-search-aggregations-bucket-range-date-DateRangeBuilder"><a href="#2-org-elasticsearch-search-aggregations-bucket-range-date-DateRangeBuilder" class="headerlink" title="2.org.elasticsearch.search.aggregations.bucket.range.date.DateRangeBuilder"></a>2.org.elasticsearch.search.aggregations.bucket.range.date.DateRangeBuilder</h3><p>org.elasticsearch.search.aggregations.bucket.range.date.DateRangeBuilder更名为<br>org.elasticsearch.search.aggregations.bucket.range.date.DateRangeAggregationBuilder</p>
<h3 id="3-org-elasticsearch-search-aggregations-metrics-tophits-TopHitsBuilder"><a href="#3-org-elasticsearch-search-aggregations-metrics-tophits-TopHitsBuilder" class="headerlink" title="3.org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder"></a>3.org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder</h3><p>org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder更名为<br>org.elasticsearch.search.aggregations.metrics.tophits.TopHitsAggregationBuilder</p>
<h2 id="15-SearchHit类"><a href="#15-SearchHit类" class="headerlink" title="15.SearchHit类"></a>15.SearchHit类</h2><p>org.elasticsearch.search.SearchHit#isSourceEmpty方法改为org.elasticsearch.search.SearchHit#hasSource方法，反向替换。</p>
<h2 id="16-DeleteByQueryResponse"><a href="#16-DeleteByQueryResponse" class="headerlink" title="16.DeleteByQueryResponse"></a>16.DeleteByQueryResponse</h2><p>org.elasticsearch.action.deletebyquery.DeleteByQueryResponse已经弃用，</p>
<h1 id="调整关键字等结构性问题"><a href="#调整关键字等结构性问题" class="headerlink" title="调整关键字等结构性问题"></a>调整关键字等结构性问题</h1><h2 id="1-String数据类型弃用"><a href="#1-String数据类型弃用" class="headerlink" title="1. String数据类型弃用"></a>1. String数据类型弃用</h2><p>在 ES2.x 版本字符串数据是没有 keyword 和 text 类型的，只有string类型，ES更新到5版本后，取消了 string 数据类型，代替它的是 keyword 和 text 数据类型。区别在于：</p>
<p>text类型定义的文本会被分析，在建立索引前会将这些文本进行分词，转化为词的组合，建立索引。允许 ES来检索这些词语。text 数据类型不能用来排序和聚合。</p>
<p>keyWord类型表示精确查找的文本，不需要进行分词。可以被用来检索过滤、排序和聚合。keyword 类型字段只能用本身来进行检索。</p>
<p>在没有显性定义时，es默认为“text”类型。</p>
<h2 id="2-multi-field关键字弃用"><a href="#2-multi-field关键字弃用" class="headerlink" title="2. multi_field关键字弃用"></a>2. multi_field关键字弃用</h2><p>相关mapping方式改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#对需要设置的字段，在&#39;type&#39;属性后增加&quot;fields&quot;: </span><br><span class="line">#其中的&quot;raw&quot;为自定义的名称,想象它是city的一个分身。</span><br><span class="line">PUT &#x2F;my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;city&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;raw&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">查询raw字段时，使用city.raw表示</span><br></pre></td></tr></table></figure>
<h2 id="3-analyzer"><a href="#3-analyzer" class="headerlink" title="3. analyzer"></a>3. analyzer</h2><h3 id="1-改版后，设置了search-analyzer的情况下，analyzer也要设置，否则会报："><a href="#1-改版后，设置了search-analyzer的情况下，analyzer也要设置，否则会报：" class="headerlink" title="1.改版后，设置了search_analyzer的情况下，analyzer也要设置，否则会报："></a>1.改版后，设置了search_analyzer的情况下，analyzer也要设置，否则会报：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyzer on field [name] must be set when search_analyzer is set。</span><br></pre></td></tr></table></figure>
<h3 id="2-改版后，index-analyzer设置被弃用，如果设置，会报"><a href="#2-改版后，index-analyzer设置被弃用，如果设置，会报" class="headerlink" title="2.改版后，index_analyzer设置被弃用，如果设置，会报"></a>2.改版后，index_analyzer设置被弃用，如果设置，会报</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapperParsingException[Mapping definition for [fields] has unsupported parameters:  [index_analyzer : ik_max_word]];</span><br></pre></td></tr></table></figure>


<p><img src="https://oscimg.oschina.net/oscnet/17d3a80c1adff9f8b379c9006036a58cdb0.jpg" alt=""></p>
<p>这里扩展一下，在原来的版本中，index_analyzer负责建立索引时的分词器定义，search_analyzer负责搜索时的分词器定义。</p>
<p>索引期间查找解析器的完整顺序是这样的：</p>
<ul>
<li>定义在字段映射中的index_analyzer</li>
<li>定义在字段映射中的analyzer</li>
<li>定义在文档_analyzer字段中的解析器</li>
<li>type的默认index_analyzer</li>
<li>type的默认analyzer</li>
<li>索引设置中default_index对应的解析器</li>
<li>索引设置中default对应的解析器</li>
<li>节点上default_index对应的解析器</li>
<li>节点上default对应的解析器</li>
<li>standard解析器</li>
</ul>
<p>而查询期间的完整顺序则是：</p>
<ul>
<li>直接定义在查询中的analyzer</li>
<li>定义在字段映射中的search_analyzer</li>
<li>定义在字段映射中的analyzer</li>
<li>type的默认search_analyzer</li>
<li>type的默认analyzer</li>
<li>索引设置中的default_search对应的解析器</li>
<li>索引设置中的default对应的解析器</li>
<li>节点上default_search对应的解析器</li>
<li>节点上default对应的解析器</li>
<li>standard解析器</li>
</ul>
<p><strong>现在新版删除index_analyzer，具体功能由analyzer关键字承担，analyzer关键字生效与index时和search时（除非search_analyzer已经被显性定义）。</strong></p>
<h2 id="3-timestamp在2-0弃用"><a href="#3-timestamp在2-0弃用" class="headerlink" title="3. _timestamp在2.0弃用"></a>3. _timestamp在2.0弃用</h2><p>_timestamp官方建议自定义一个字段，自己赋值用来表示时间戳。</p>
<p><img src="https://oscimg.oschina.net/oscnet/83fad879140e27f9bdece1502d0076ef9db.jpg" alt=""></p>
<h2 id="4-嵌套字段排序时字段名称调整"><a href="#4-嵌套字段排序时字段名称调整" class="headerlink" title="4. 嵌套字段排序时字段名称调整"></a>4. 嵌套字段排序时字段名称调整</h2><p>对于如下的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;my_index&#x2F;blogpost&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Investment secrets&quot;,</span><br><span class="line">  &quot;body&quot;:  &quot;What they don&#39;t tell you ...&quot;,</span><br><span class="line">  &quot;tags&quot;:  [ &quot;shares&quot;, &quot;equities&quot; ],</span><br><span class="line">  &quot;comments&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;Mary Brown&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;Lies, lies, lies&quot;,</span><br><span class="line">      &quot;age&quot;:     42,</span><br><span class="line">      &quot;stars&quot;:   1,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-10-18&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;John Smith&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;You&#39;re making it up!&quot;,</span><br><span class="line">      &quot;age&quot;:     28,</span><br><span class="line">      &quot;stars&quot;:   2,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-10-16&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老版本中，对stars字段进行排序时，直接可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;stars&quot; : &#123;</span><br><span class="line">      &quot;order&quot; : &quot;desc&quot;,</span><br><span class="line">      &quot;mode&quot; : &quot;min&quot;,</span><br><span class="line">      &quot;nested_path&quot; : &quot;comments&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>但在新版中，上述报文会报</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No mapping found for [stars] in order to sort on</span><br></pre></td></tr></table></figure>
<p>需要改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;comments.stars&quot; : &#123;</span><br><span class="line">       &quot;order&quot; : &quot;desc&quot;,</span><br><span class="line">       &quot;mode&quot; : &quot;min&quot;</span><br><span class="line">     &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>

<h2 id="5-script脚本参数名变更"><a href="#5-script脚本参数名变更" class="headerlink" title="5. _script脚本参数名变更"></a>5. _script脚本参数名变更</h2><p>老版中，_script可以这样定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_script&quot; : &#123;</span><br><span class="line">        &quot;script&quot; : &#123;</span><br><span class="line">          &quot;inline&quot; : &quot;paramsMap.containsKey(doc[\&quot;id\&quot;].value) ? params.paramsMap.get(doc[\&quot;id\&quot;].value) : params.paramsMap.get(&#39;other&#39;)&quot;,</span><br><span class="line">          &quot;lang&quot; : &quot;painless&quot;,</span><br><span class="line">          &quot;params&quot; : &#123;</span><br><span class="line">            &quot;paramsMap&quot; : &#123;</span><br><span class="line">              &quot;1&quot; : 1,</span><br><span class="line">              &quot;2&quot; : 1,</span><br><span class="line">              &quot;3&quot; : 2,</span><br><span class="line">              &quot;other&quot; : 3</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;type&quot; : &quot;number&quot;,</span><br><span class="line">        &quot;order&quot; : &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>新版中，对于params的参数paramsMap必须用params.paramsMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_script&quot; : &#123;</span><br><span class="line">        &quot;script&quot; : &#123;</span><br><span class="line">          &quot;inline&quot; : &quot;params.paramsMap.containsKey(doc[\&quot;productCategory\&quot;].value) ? params.paramsMap.get(doc[\&quot;productCategory\&quot;].value) : params.paramsMap.get(&#39;other&#39;)&quot;,</span><br><span class="line">          &quot;lang&quot; : &quot;painless&quot;,</span><br><span class="line">          &quot;params&quot; : &#123;</span><br><span class="line">            &quot;paramsMap&quot; : &#123;</span><br><span class="line">              &quot;901&quot; : 1,</span><br><span class="line">              &quot;902&quot; : 1,</span><br><span class="line">              &quot;701&quot; : 2,</span><br><span class="line">              &quot;other&quot; : 3</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;type&quot; : &quot;number&quot;,</span><br><span class="line">        &quot;order&quot; : &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>注意：<strong>es 5.2.0默认禁用了动态语言，所以lang为painless之外的语言</strong>，默认情况下会报</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScriptException[scripts of type [inline], operation [update] and lang [groovy] are disabled];</span><br></pre></td></tr></table></figure>

<p>需要在yml文件中添加配置（如groovy）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">script.engine.groovy.inline:true </span><br><span class="line">script.engine.groovy.stored.search:true </span><br><span class="line">script.engine.groovy.stored.aggs:true</span><br></pre></td></tr></table></figure>

<h2 id="6-获取特定字段返回"><a href="#6-获取特定字段返回" class="headerlink" title="6 .获取特定字段返回"></a>6 .获取特定字段返回</h2><p>在旧版本中，获取特定文档特定字段返回，可以使用stored_fields：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;from&quot; : 0,</span><br><span class="line">  &quot;size&quot; : 1,</span><br><span class="line">  &quot;query&quot; : &#123;&#125;,</span><br><span class="line">  &quot;stored_fields&quot; : &quot;timestamp&quot;,</span><br><span class="line">  &quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;order&quot; : &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版本中，引入了更为强大的_source过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;from&quot; : 0,</span><br><span class="line">  &quot;size&quot; : 1,</span><br><span class="line">  &quot;query&quot; : &#123;&#125;,</span><br><span class="line">  &quot;_source&quot; : &quot;timestamp&quot;,</span><br><span class="line">  &quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;order&quot; : &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot; : 0,</span><br><span class="line">  &quot;size&quot; : 1,</span><br><span class="line">  &quot;query&quot; : &#123;&#125;,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;includes&quot; : [ &quot;timestamp&quot; ],</span><br><span class="line">    &quot;excludes&quot; : [ &quot;&quot; ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;order&quot; : &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java的api主要调用SearchRequestBuilder的setFetchSource方法</p>
<h2 id="7-date字段的format定义"><a href="#7-date字段的format定义" class="headerlink" title="7. date字段的format定义"></a>7. date字段的format定义</h2><p>改版后，date字段最好再mapping时定义好format信息，以防止在请求前后因为格式转换问题报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElasticsearchParseException[failed to parse date field [Thu Jun 18 00:00:00 CST 2015] with format [strict_date_optional_time||epoch_millis]]; nested: IllegalArgumentException[Parse failure at index [0] of [Thu Jun 18 00:00:00 CST 2015]]; &#125;</span><br></pre></td></tr></table></figure>
<p>[strict_date_optional_time||epoch_millis]是es默认的date字段解析格式</p>
<h2 id="8-UncategorizedExecutionException"><a href="#8-UncategorizedExecutionException" class="headerlink" title="8. UncategorizedExecutionException"></a>8. UncategorizedExecutionException</h2><p>改版前，transport client发送数据之前将java代码中的字段序列化成了json然后进行传输和请求，而在5.x以后，es改用使用的内部的transport protocol，这时候，如果定义一个比如bigDecimal类型，es不支持bigDecimal，数据类型不匹配会抛错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UncategorizedExecutionException[Failed execution]; nested: IOException[can not write type [class java.math.BigDecimal]];</span><br></pre></td></tr></table></figure>


<p>es支持的格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Writer&gt; writers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    writers.put(String.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 0);</span><br><span class="line">        o.writeString((String) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Integer.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 1);</span><br><span class="line">        o.writeInt((Integer) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Long.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 2);</span><br><span class="line">        o.writeLong((Long) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Float.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 3);</span><br><span class="line">        o.writeFloat((float) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Double.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 4);</span><br><span class="line">        o.writeDouble((double) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Boolean.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 5);</span><br><span class="line">        o.writeBoolean((boolean) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(byte[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 6);</span><br><span class="line">        final byte[] bytes &#x3D; (byte[]) v;</span><br><span class="line">        o.writeVInt(bytes.length);</span><br><span class="line">        o.writeBytes(bytes);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(List.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 7);</span><br><span class="line">        final List list &#x3D; (List) v;</span><br><span class="line">        o.writeVInt(list.size());</span><br><span class="line">        for (Object item : list) &#123;</span><br><span class="line">            o.writeGenericValue(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Object[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 8);</span><br><span class="line">        final Object[] list &#x3D; (Object[]) v;</span><br><span class="line">        o.writeVInt(list.length);</span><br><span class="line">        for (Object item : list) &#123;</span><br><span class="line">            o.writeGenericValue(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Map.class, (o, v) -&gt; &#123;</span><br><span class="line">        if (v instanceof LinkedHashMap) &#123;</span><br><span class="line">            o.writeByte((byte) 9);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o.writeByte((byte) 10);</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        final Map&lt;String, Object&gt; map &#x3D; (Map&lt;String, Object&gt;) v;</span><br><span class="line">        o.writeVInt(map.size());</span><br><span class="line">        for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            o.writeString(entry.getKey());</span><br><span class="line">            o.writeGenericValue(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Byte.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 11);</span><br><span class="line">        o.writeByte((Byte) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Date.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 12);</span><br><span class="line">        o.writeLong(((Date) v).getTime());</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(ReadableInstant.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 13);</span><br><span class="line">        final ReadableInstant instant &#x3D; (ReadableInstant) v;</span><br><span class="line">        o.writeString(instant.getZone().getID());</span><br><span class="line">        o.writeLong(instant.getMillis());</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(BytesReference.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 14);</span><br><span class="line">        o.writeBytesReference((BytesReference) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Text.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 15);</span><br><span class="line">        o.writeText((Text) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Short.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 16);</span><br><span class="line">        o.writeShort((Short) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(int[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 17);</span><br><span class="line">        o.writeIntArray((int[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(long[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 18);</span><br><span class="line">        o.writeLongArray((long[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(float[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 19);</span><br><span class="line">        o.writeFloatArray((float[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(double[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 20);</span><br><span class="line">        o.writeDoubleArray((double[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(BytesRef.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 21);</span><br><span class="line">        o.writeBytesRef((BytesRef) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(GeoPoint.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 22);</span><br><span class="line">        o.writeGeoPoint((GeoPoint) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    WRITERS &#x3D; Collections.unmodifiableMap(writers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ThreadPoolExecutor/" itemprop="url">线程池源码分析--ThreadPoolExecutor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-27T21:54:11+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA线程与并发控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ThreadPoolExecutor/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/27/线程池源码分析-ThreadPoolExecutor/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  12.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  56
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>我们知道，线程池帮我们重复管理线程，避免创建大量的线程增加开销。<br>合理的使用线程池能够带来3个很明显的好处：</p>
<ol>
<li>降低资源消耗：通过重用已经创建的线程来降低线程创建和销毁的消耗</li>
<li>提高响应速度：任务到达时不需要等待线程创建就可以立即执行。</li>
<li>提高线程的可管理性：线程池可以统一管理、分配、调优和监控。<br>java源生的线程池，实现于ThreadPoolExecutor类，这也是我们今天讨论的重点<h1 id="1-ThreadPoolExecutor类构造方法"><a href="#1-ThreadPoolExecutor类构造方法" class="headerlink" title="1. ThreadPoolExecutor类构造方法"></a>1. ThreadPoolExecutor类构造方法</h1>Jdk使用ThreadPoolExecutor类来创建线程池，我们来看看它的构造方法。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial</span><br><span class="line">     * parameters.</span><br><span class="line">     *</span><br><span class="line">     * @param corePoolSize the number of threads to keep in the pool, even</span><br><span class="line">     *        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set</span><br><span class="line">     * @param maximumPoolSize the maximum number of threads to allow in the</span><br><span class="line">     *        pool</span><br><span class="line">     * @param keepAliveTime when the number of threads is greater than</span><br><span class="line">     *        the core, this is the maximum time that excess idle threads</span><br><span class="line">     *        will wait for new tasks before terminating.</span><br><span class="line">     * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument</span><br><span class="line">     * @param workQueue the queue to use for holding tasks before they are</span><br><span class="line">     *        executed.  This queue will hold only the &#123;@code Runnable&#125;</span><br><span class="line">     *        tasks submitted by the &#123;@code execute&#125; method.</span><br><span class="line">     * @param threadFactory the factory to use when the executor</span><br><span class="line">     *        creates a new thread</span><br><span class="line">     * @param handler the handler to use when execution is blocked</span><br><span class="line">     *        because the thread bounds and queue capacities are reached</span><br><span class="line">     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;</span><br><span class="line">     *         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code maximumPoolSize &lt;&#x3D; 0&#125;&lt;br&gt;</span><br><span class="line">     *         &#123;@code maximumPoolSize &lt; corePoolSize&#125;</span><br><span class="line">     * @throws NullPointerException if &#123;@code workQueue&#125;</span><br><span class="line">     *         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        if (corePoolSize &lt; 0 ||</span><br><span class="line">            maximumPoolSize &lt;&#x3D; 0 ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.corePoolSize &#x3D; corePoolSize;</span><br><span class="line">        this.maximumPoolSize &#x3D; maximumPoolSize;</span><br><span class="line">        this.workQueue &#x3D; workQueue;</span><br><span class="line">        this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);</span><br><span class="line">        this.threadFactory &#x3D; threadFactory;</span><br><span class="line">        this.handler &#x3D; handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>int corePoolSize,    //核心线程的数量</p>
</li>
<li><p>int maximumPoolSize,    //最大线程数量</p>
</li>
<li><p>long keepAliveTime,    //超出核心线程数量以外的线程空闲时，线程存活的时间</p>
</li>
<li><p>TimeUnit unit,    //存活时间的单位，有如下几种选择</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               &#x2F;&#x2F;天</span><br><span class="line">TimeUnit.HOURS;             &#x2F;&#x2F;小时</span><br><span class="line">TimeUnit.MINUTES;           &#x2F;&#x2F;分钟</span><br><span class="line">TimeUnit.SECONDS;           &#x2F;&#x2F;秒</span><br><span class="line">TimeUnit.MILLISECONDS;      &#x2F;&#x2F;毫秒</span><br><span class="line">TimeUnit.MICROSECONDS;      &#x2F;&#x2F;微妙</span><br><span class="line">TimeUnit.NANOSECONDS;       &#x2F;&#x2F;纳秒</span><br></pre></td></tr></table></figure></li>
<li><p>BlockingQueue<Runnable> workQueue,    //保存待执行任务的队列，常见的也有如下几种：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br><span class="line">PriorityBlockingQueue</span><br></pre></td></tr></table></figure>
</li>
<li><p>ThreadFactory threadFactory,    //创建新线程使用的工厂</p>
</li>
<li><p>RejectedExecutionHandler handler // 当任务无法执行时的处理器（线程拒绝策略）</p>
<h1 id="2-核心类变量"><a href="#2-核心类变量" class="headerlink" title="2. 核心类变量"></a>2. 核心类变量</h1><h2 id="2-1-ctl变量"><a href="#2-1-ctl变量" class="headerlink" title="2.1 ctl变量"></a>2.1 ctl变量</h2><p>ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量，它一个int值可以储存两个概念的信息：</p>
</li>
<li><p>workerCount：表明当前池中有效的线程数，通过workerCountOf方法获得，workerCount上限是(2^29)-1。（最后存放在ctl的低29bit）</p>
</li>
<li><p>runState：表明当前线程池的状态，通过workerCountOf方法获得，最后存放在ctl的高3bit中，他们是整个线程池的运行生命周期，有如下取值，分别的含义是：</p>
<ol>
<li>RUNNING：可以新加线程，同时可以处理queue中的线程。线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，</li>
<li>SHUTDOWN：不增加新线程，但是处理queue中的线程。调用线程池的shutdown()方法时，线程池由RUNNING -&gt; SHUTDOWN。</li>
<li>STOP 不增加新线程，同时不处理queue中的线程。调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</li>
<li>TIDYING 当所有的任务已终止，ctl记录的”任务数量”为0，阻塞队列为空，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 </li>
<li>TERMINATED 线程池彻底终止，就变成TERMINATED状态。线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Packing and unpacking ctl</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br></pre></td></tr></table></figure>
COUNT_BITS=32（integer的size）-3=29，于是五种状态左移29位分别是：</li>
</ol>
</li>
<li><p>RUNNING：   <strong>111</strong>00000000000000000000000000000 </p>
</li>
<li><p>SHUTDOWN：  <strong>000</strong>00000000000000000000000000000</p>
</li>
<li><p>STOP：      <strong>001</strong>00000000000000000000000000000</p>
</li>
<li><p>TIDYING：   <strong>010</strong>00000000000000000000000000000</p>
</li>
<li><p>TERMINATED：<strong>011</strong>00000000000000000000000000000<br>而ThreadPoolExecutor是通过runStateOf和workerCountOf获得者两个概念的值的。</p>
</li>
</ul>
<p>runStateOf和workerCountOf方法是如何剥离出ctl变量的两个有效值呢？这其中我们可以看到CAPACITY是实现一个字段存两个值的最重要的字段。</p>
<h2 id="2-2-CAPACITY变量"><a href="#2-2-CAPACITY变量" class="headerlink" title="2.2 CAPACITY变量"></a>2.2 CAPACITY变量</h2><p>CAPACITY=(1 &lt;&lt; COUNT_BITS) – 1 转成二进制为：000 11111111111111111111111111111，他是线程池理论上可以允许的最大的线程数。<br>所以很明显，它的重点在于，其高3bit为0，低29bit为1；<br>这样，workderCountOf方法中，CAPACITY和ctl进行&amp;运算时，它能获得高3位都是0，低29位和ctl低29位相同的值，<strong>这个值就是workerCount</strong>；<br>同理，runStateOf方法，CAPACITY的取反和ctl进行&amp;操作，获得高3位和ctl高三位相等，低29位都为0的值，<strong>这个值就是runState</strong>；</p>
<h2 id="2-3-workQueue"><a href="#2-3-workQueue" class="headerlink" title="2.3 workQueue"></a>2.3 workQueue</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * The queue used for holding tasks and handing off to worker</span><br><span class="line">     * threads.  We do not require that workQueue.poll() returning</span><br><span class="line">     * null necessarily means that workQueue.isEmpty(), so rely</span><br><span class="line">     * solely on isEmpty to see if the queue is empty (which we must</span><br><span class="line">     * do for example when deciding whether to transition from</span><br><span class="line">     * SHUTDOWN to TIDYING).  This accommodates special-purpose</span><br><span class="line">     * queues such as DelayQueues for which poll() is allowed to</span><br><span class="line">     * return null even if it may later return non-null when delays</span><br><span class="line">     * expire.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure>
<p>一个BlockingQueue<Runnable>队列，本身的结构可以保证访问的线程安全（这里不展开了）。这是一个排队等待队列。当我们线程池里线程达到corePoolSize的时候，一些需要等待执行的线程就放在这个队列里等待。</p>
<h2 id="2-4-workers"><a href="#2-4-workers" class="headerlink" title="2.4 workers"></a>2.4 workers</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Set containing all worker threads in pool. Accessed only when</span><br><span class="line">     * holding mainLock.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final HashSet&lt;Worker&gt; workers &#x3D; new HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>
<p>一个HashSet<Worker>的集合。线程池里所有可以立即执行的线程都放在这个集合里。这也是我们直观理解的<strong>线程的池子</strong>。</p>
<h2 id="2-5-mainLock"><a href="#2-5-mainLock" class="headerlink" title="2.5 mainLock"></a>2.5 mainLock</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final ReentrantLock mainLock &#x3D; new ReentrantLock();</span><br></pre></td></tr></table></figure>

<p>mainLock是线程池的主锁，是可重入锁，当要操作workers set这个保持线程的HashSet时，需要先获取mainLock，还有当要处理largestPoolSize、completedTaskCount这类统计数据时需要先获取mainLock</p>
<h2 id="2-6-其他重要属性"><a href="#2-6-其他重要属性" class="headerlink" title="2.6 其他重要属性"></a>2.6 其他重要属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private int largestPoolSize;   &#x2F;&#x2F;用来记录线程池中曾经出现过的最大线程数</span><br><span class="line"> </span><br><span class="line">private long completedTaskCount;   &#x2F;&#x2F;用来记录已经执行完毕的任务个数</span><br><span class="line"></span><br><span class="line">private volatile boolean allowCoreThreadTimeOut;   &#x2F;&#x2F;是否允许为核心线程设置存活时间</span><br></pre></td></tr></table></figure>

<h1 id="3-核心内部类"><a href="#3-核心内部类" class="headerlink" title="3 核心内部类"></a>3 核心内部类</h1><h2 id="3-1-Worker"><a href="#3-1-Worker" class="headerlink" title="3.1 Worker"></a>3.1 Worker</h2><p>Worker类是线程池中具化一个线程的对象，是线程池的核心，我们来看看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Class Worker mainly maintains interrupt control state for</span><br><span class="line">     * threads running tasks, along with other minor bookkeeping.</span><br><span class="line">     * This class opportunistically extends AbstractQueuedSynchronizer</span><br><span class="line">     * to simplify acquiring and releasing a lock surrounding each</span><br><span class="line">     * task execution.  This protects against interrupts that are</span><br><span class="line">     * intended to wake up a worker thread waiting for a task from</span><br><span class="line">     * instead interrupting a task being run.  We implement a simple</span><br><span class="line">     * non-reentrant mutual exclusion lock rather than use</span><br><span class="line">     * ReentrantLock because we do not want worker tasks to be able to</span><br><span class="line">     * reacquire the lock when they invoke pool control methods like</span><br><span class="line">     * setCorePoolSize.  Additionally, to suppress interrupts until</span><br><span class="line">     * the thread actually starts running tasks, we initialize lock</span><br><span class="line">     * state to a negative value, and clear it upon start (in</span><br><span class="line">     * runWorker).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * This class will never be serialized, but we provide a</span><br><span class="line">         * serialVersionUID to suppress a javac warning.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 6138294804551838833L;</span><br><span class="line">        &#x2F;** Thread this worker is running in.  Null if factory fails. *&#x2F;</span><br><span class="line">        final Thread thread;</span><br><span class="line">        &#x2F;** Initial task to run.  Possibly null. *&#x2F;</span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        &#x2F;** Per-thread task counter *&#x2F;</span><br><span class="line">        volatile long completedTasks;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Creates with given first task and thread from ThreadFactory.</span><br><span class="line">         * @param firstTask the first task (null if none)</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            &#x2F;&#x2F;设置AQS的同步状态private volatile int state，是一个计数器，大于0代表锁已经被获取</span><br><span class="line">            &#x2F;&#x2F; 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()&gt;&#x3D;0</span><br><span class="line">            setState(-1); &#x2F;&#x2F; inhibit interrupts until runWorker</span><br><span class="line">            this.firstTask &#x3D; firstTask;</span><br><span class="line">            this.thread &#x3D; getThreadFactory().newThread(this);&#x2F;&#x2F;根据当前worker创建一个线程对象</span><br><span class="line">            &#x2F;&#x2F;当前worker本身就是一个runnable任务，也就是不会用参数的firstTask创建线程，而是调用当前worker.run()时调用firstTask.run()</span><br><span class="line">            &#x2F;&#x2F;后面在addworker中，我们会启动worker对象中组合的Thread，而我们的执行逻辑runWorker方法是在worker的run方法中被调用。</span><br><span class="line">            &#x2F;&#x2F;为什么执行thread的run方法会调用worker的run方法呢，原因就是在这里进行了注入，将worker本身this注入到了thread中</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;** Delegates main run loop to outer runWorker  *&#x2F;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            runWorker(this);</span><br><span class="line">        &#125;&#x2F;&#x2F;runWorker()是ThreadPoolExecutor的方法</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Lock methods</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; The value 0 represents the unlocked state. 0代表“没被锁定”状态</span><br><span class="line">        &#x2F;&#x2F; The value 1 represents the locked state. 1代表“锁定”状态</span><br><span class="line">        protected boolean isHeldExclusively() &#123;</span><br><span class="line">            return getState() !&#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 尝试获取锁</span><br><span class="line">         * 重写AQS的tryAcquire()，AQS本来就是让子类来实现的</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected boolean tryAcquire(int unused) &#123;</span><br><span class="line">            &#x2F;&#x2F;尝试一次将state从0设置为1，即“锁定”状态，但由于每次都是state 0-&gt;1，而不是+1，那么说明不可重入</span><br><span class="line">            &#x2F;&#x2F;且state&#x3D;&#x3D;-1时也不会获取到锁</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 尝试释放锁</span><br><span class="line">         * 不是state-1，而是置为0</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected boolean tryRelease(int unused) &#123;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            setState(0);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void lock()        &#123; acquire(1); &#125;</span><br><span class="line">        public boolean tryLock()  &#123; return tryAcquire(1); &#125;</span><br><span class="line">        public void unlock()      &#123; release(1); &#125;</span><br><span class="line">        public boolean isLocked() &#123; return isHeldExclusively(); &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 中断（如果运行）</span><br><span class="line">         * shutdownNow时会循环对worker线程执行</span><br><span class="line">         * 且不需要获取worker锁，即使在worker运行时也可以中断</span><br><span class="line">         *&#x2F;</span><br><span class="line">        void interruptIfStarted() &#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            &#x2F;&#x2F;如果state&gt;&#x3D;0、t!&#x3D;null、且t没有被中断</span><br><span class="line">            &#x2F;&#x2F;new Worker()时state&#x3D;&#x3D;-1，说明不能中断</span><br><span class="line">            if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们看worker类时，会发现最重要的几个部分在于它里面定义了一个Thread thread和Runnable firstTask。看到这里，我们可能会比较奇怪，我们只是要一个可以执行的线程，这里放一个Thread和一个Runnable的变量做什么呢？  </p>
<p>其实之所以Worker自己实现Runnable，并创建Thread，在firstTask外包一层，是因为要通过Worker负责控制中断，而firstTask这个工作任务只是负责执行业务，worker的run方法调用了runWorker方法，在这里面，worker里的firstTask的run方法被执行。稍后我们会聚焦这个执行任务的runWorker方法。</p>
<h1 id="4-核心方法"><a href="#4-核心方法" class="headerlink" title="4 核心方法"></a>4 核心方法</h1><p>好了，基本上我们将线程池的几个主角，ctl，workQueue，workers，Worker简单介绍了一遍，现在，我们来看看线程池是怎么玩的。</p>
<h2 id="4-1-线程的运行"><a href="#4-1-线程的运行" class="headerlink" title="4.1 线程的运行"></a>4.1 线程的运行</h2><h3 id="4-1-1-execute方法"><a href="#4-1-1-execute方法" class="headerlink" title="4.1.1 execute方法"></a>4.1.1 execute方法</h3><p>这是线程池实现类外露供给外部实现提交线程任务command的核心方法，对于无需了解线程池内部的使用者来说，<strong>这个方法就是把某个任务交给线程池，正常情况下，这个任务会在未来某个时刻被执行</strong>，实现和注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Executes the given task sometime in the future.  The task</span><br><span class="line"> * may execute in a new thread or in an existing pooled thread.</span><br><span class="line"> * * 在未来的某个时刻执行给定的任务。这个任务用一个新线程执行，或者用一个线程池中已经存在的线程执行</span><br><span class="line"> *</span><br><span class="line"> * If the task cannot be submitted for execution, either because this</span><br><span class="line"> * executor has been shutdown or because its capacity has been reached,</span><br><span class="line"> * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;.</span><br><span class="line"> * 如果任务无法被提交执行，要么是因为这个Executor已经被shutdown关闭，要么是已经达到其容量上限，任务会被当前的RejectedExecutionHandler处理</span><br><span class="line"> *</span><br><span class="line"> * @param command the task to execute</span><br><span class="line"> * @throws RejectedExecutionException at discretion of</span><br><span class="line"> *         &#123;@code RejectedExecutionHandler&#125;, if the task</span><br><span class="line"> *         cannot be accepted for execution</span><br><span class="line"> * @throws NullPointerException if &#123;@code command&#125; is null</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Proceed in 3 steps:</span><br><span class="line">     *</span><br><span class="line">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">     * start a new thread with the given command as its first</span><br><span class="line">     * task.  The call to addWorker atomically checks runState and</span><br><span class="line">     * workerCount, and so prevents false alarms that would add</span><br><span class="line">     * threads when it shouldn&#39;t, by returning false.</span><br><span class="line">     * 如果运行的线程少于corePoolSize，尝试开启一个新线程去运行command，command作为这个线程的第一个任务</span><br><span class="line">     *</span><br><span class="line">     * 2. If a task can be successfully queued, then we still need</span><br><span class="line">     * to double-check whether we should have added a thread</span><br><span class="line">     * (because existing ones died since last checking) or that</span><br><span class="line">     * the pool shut down since entry into this method. So we</span><br><span class="line">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">     * stopped, or start a new thread if there are none.</span><br><span class="line">     *  如果任务成功放入队列，我们仍需要一个双重校验去确认是否应该新建一个线程（因为可能存在有些线程在我们上次检查后死了）</span><br><span class="line">     *  或者 从我们进入这个方法后，pool被关闭了</span><br><span class="line">     *  所以我们需要再次检查state，如果线程池停止了需要回滚入队列，如果池中没有线程了，新开启 一个线程</span><br><span class="line">     *</span><br><span class="line">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">     * and so reject the task.</span><br><span class="line">     * 如果无法将任务入队列（可能队列满了），需要新开区一个线程（自己：往maxPoolSize发展）</span><br><span class="line">    * 如果失败了，说明线程池shutdown 或者 饱和了，所以我们拒绝任务</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    &#x2F;&#x2F; 1、如果当前线程数少于corePoolSize（可能是由于addWorker()操作已经包含对线程池状态的判断，如此处没加，而入workQueue前加了）</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 没有成功addWorker()，再次获取c（凡是需要再次用ctl做判断时，都会再次调用ctl.get()）</span><br><span class="line">         * 失败的原因可能是：</span><br><span class="line">         * 1、线程池已经shutdown，shutdown的线程池不再接收新任务</span><br><span class="line">         * 2、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;&#x3D;corePoolSize</span><br><span class="line">         *&#x2F;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 2、如果线程池RUNNING状态，且入队列成功</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 再次校验放入workerQueue中的任务是否能被执行</span><br><span class="line">         * 1、如果线程池不是运行状态了，应该拒绝添加新任务，从workQueue中删除任务</span><br><span class="line">         * 2、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），</span><br><span class="line">         * 确保还有线程执行任务（只要有一个就够了）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        &#x2F;&#x2F;如果再次校验过程中，线程池不是RUNNING状态，并且remove(command)--workQueue.remove()成功，拒绝当前command</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null</span><br><span class="line">        &#x2F;&#x2F;为什么只检查运行的worker数量是不是0呢？？ 为什么不和corePoolSize比较呢？？</span><br><span class="line">        &#x2F;&#x2F;只保证有一个worker线程可以从queue中获取任务执行就行了？？</span><br><span class="line">        &#x2F;&#x2F;因为只要还有活动的worker线程，就可以消费workerQueue中的任务</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);&#x2F;&#x2F;第一个参数为null，说明只为新建一个worker线程，没有指定firstTask</span><br><span class="line">                                   &#x2F;&#x2F;&#x2F;&#x2F;第二个参数为true代表占用corePoolSize，false占用maxPoolSize</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 3、如果线程池不是running状态 或者 无法入队列</span><br><span class="line">     *   尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command</span><br><span class="line">     *&#x2F;</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以简单归纳如下（注：图来源见水印，谢谢大神的归纳）：<br><img src="https://oscimg.oschina.net/oscnet/c7f7e9ea8b1c04f7c662794a2f166596e42.jpg" alt=""></p>
<h3 id="4-1-2-addWorker"><a href="#4-1-2-addWorker" class="headerlink" title="4.1.2 addWorker"></a>4.1.2 addWorker</h3><p>在execute方法中，我们看到核心的逻辑是由addWorker方法来实现的，当我们将一个任务提交给线程池，线程池会如何处理，就是主要由这个方法加以规范：</p>
<p><img src="https://oscimg.oschina.net/oscnet/de623c63ae5fbf518b0b43d176165ef28d2.jpg" alt=""></p>
<p>该方法有两个参数：</p>
<ol>
<li>firstTask：    worker线程的初始任务，可以为空</li>
<li>core：       true：将corePoolSize作为上限，false：将maximumPoolSize作为上限  </li>
</ol>
<p>排列组合，addWorker方法有4种传参的方式：  </p>
<ol>
<li>addWorker(command, true)  </li>
<li>addWorker(command, false)  </li>
<li>addWorker(null, false)  </li>
<li>addWorker(null, true)  </li>
</ol>
<p>在execute方法中就使用了前3种，结合这个核心方法进行以下分析  </p>
<ul>
<li>第一个：线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false  </li>
<li>第二个：当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false  </li>
<li>第三个：放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务  </li>
<li>第四个：这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Checks if a new worker can be added with respect to current</span><br><span class="line"> * pool state and the given bound (either core or maximum). If so,</span><br><span class="line"> * the worker count is adjusted accordingly, and, if possible, a</span><br><span class="line"> * new worker is created and started, running firstTask as its</span><br><span class="line"> * first task. This method returns false if the pool is stopped or</span><br><span class="line"> * eligible to shut down. It also returns false if the thread</span><br><span class="line"> * factory fails to create a thread when asked.  If the thread</span><br><span class="line"> * creation fails, either due to the thread factory returning</span><br><span class="line"> * null, or due to an exception (typically OutOfMemoryError in</span><br><span class="line"> * Thread.start()), we roll back cleanly.</span><br><span class="line"> * 检查根据当前线程池的状态和给定的边界(core or maximum)是否可以创建一个新的worker</span><br><span class="line"> * 如果是这样的话，worker的数量做相应的调整，如果可能的话，创建一个新的worker并启动，参数中的firstTask作为worker的第一个任务</span><br><span class="line"> * 如果方法返回false，可能因为pool已经关闭或者调用过了shutdown</span><br><span class="line"> * 如果线程工厂创建线程失败，也会失败，返回false</span><br><span class="line"> * 如果线程创建失败，要么是因为线程工厂返回null，要么是发生了OutOfMemoryError</span><br><span class="line"> *</span><br><span class="line"> * @param firstTask the task the new thread should run first (or</span><br><span class="line"> * null if none). Workers are created with an initial first task</span><br><span class="line"> * (in method execute()) to bypass queuing when there are fewer</span><br><span class="line"> * than corePoolSize threads (in which case we always start one),</span><br><span class="line"> * or when the queue is full (in which case we must bypass queue).</span><br><span class="line"> * Initially idle threads are usually created via</span><br><span class="line"> * prestartCoreThread or to replace other dying workers.</span><br><span class="line"> *</span><br><span class="line"> * @param core if true use corePoolSize as bound, else</span><br><span class="line"> * maximumPoolSize. (A boolean indicator is used here rather than a</span><br><span class="line"> * value to ensure reads of fresh values after checking other pool</span><br><span class="line"> * state).</span><br><span class="line"> * @return true if successful</span><br><span class="line"> *&#x2F;</span><br><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    &#x2F;&#x2F;外层循环，负责判断线程池状态</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check if queue empty only if necessary.</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 线程池的state越小越是运行状态，runnbale&#x3D;-1，shutdown&#x3D;0,stop&#x3D;1,tidying&#x3D;2，terminated&#x3D;3</span><br><span class="line">         * 要想这个if为true，线程池state必须已经至少是shutdown状态了</span><br><span class="line">         * 这时候以下3个条件任意一个是false都会进入if语句，即无法addWorker()：</span><br><span class="line">         *   1，rs &#x3D;&#x3D; SHUTDOWN         （隐含：rs&gt;&#x3D;SHUTDOWN）false情况： 线程池状态已经超过shutdown，</span><br><span class="line">         *                               可能是stop、tidying、terminated其中一个，即线程池已经终止</span><br><span class="line">         *  2，firstTask &#x3D;&#x3D; null      （隐含：rs&#x3D;&#x3D;SHUTDOWN）false情况： firstTask不为空，rs&#x3D;&#x3D;SHUTDOWN 且 firstTask不为空，</span><br><span class="line">         *                               return false，场景是在线程池已经shutdown后，还要添加新的任务，拒绝</span><br><span class="line">         *  3，! workQueue.isEmpty()  （隐含：rs&#x3D;&#x3D;SHUTDOWN，firstTask&#x3D;&#x3D;null）false情况： workQueue为空，</span><br><span class="line">         *                               当firstTask为空时是为了创建一个没有任务的线程，再从workQueue中获取任务，</span><br><span class="line">         *                               如果workQueue已经为空，那么就没有添加新worker线程的必要了</span><br><span class="line">         * return false，</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line">        &#x2F;&#x2F;内层循环，负责worker数量+1</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line">            &#x2F;&#x2F;入参core在这里起作用，表示加入的worker是加入corePool还是非corepool，换句话说，受到哪个size的约束</span><br><span class="line">            &#x2F;&#x2F;如果worker数量&gt;线程池最大上限CAPACITY（即使用int低29位可以容纳的最大值）</span><br><span class="line">            &#x2F;&#x2F;或者( worker数量&gt;corePoolSize 或  worker数量&gt;maximumPoolSize )，即已经超过了给定的边界,不添加worker</span><br><span class="line">            if (wc &gt;&#x3D; CAPACITY ||</span><br><span class="line">                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F;CAS尝试增加线程数，,如果成功加了wc，那么break跳出检查</span><br><span class="line">            &#x2F;&#x2F;如果失败，证明有竞争，那么重新到retry。</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                break retry;</span><br><span class="line">            &#x2F;&#x2F;如果不成功，重新获取状态继续检查</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl</span><br><span class="line">            &#x2F;&#x2F;如果状态不等于之前获取的state，跳出内层循环，继续去外层循环判断</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">            &#x2F;&#x2F; else CAS失败时因为workerCount改变了，继续内层循环尝试CAS对worker数量+1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     &#x2F;&#x2F;worker数量+1成功的后续操作</span><br><span class="line">     &#x2F;&#x2F; 添加到workers Set集合，并启动worker线程</span><br><span class="line">    boolean workerStarted &#x3D; false;</span><br><span class="line">    boolean workerAdded &#x3D; false;</span><br><span class="line">    Worker w &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;新建worker&#x2F;&#x2F;构造方法做了三件事&#x2F;&#x2F;1、设置worker这个AQS锁的同步状态state&#x3D;-1</span><br><span class="line">        w &#x3D; new Worker(firstTask);  &#x2F;&#x2F;2、将firstTask设置给worker的成员变量firstTask</span><br><span class="line">                                    &#x2F;&#x2F;3、使用worker自身这个runnable，调用ThreadFactory创建一个线程，并设置给worker的成员变量thread</span><br><span class="line">        final Thread t &#x3D; w.thread;</span><br><span class="line">        if (t !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取重入锁，并且锁上</span><br><span class="line">            final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                int rs &#x3D; runStateOf(ctl.get());</span><br><span class="line">                 &#x2F;&#x2F; rs!&#x3D;SHUTDOWN ||firstTask!&#x3D;null</span><br><span class="line">                 &#x2F;&#x2F; 如果线程池在运行running&lt;shutdown 或者</span><br><span class="line">                 &#x2F;&#x2F; 线程池已经shutdown，且firstTask&#x3D;&#x3D;null（可能是workQueue中仍有未执行完成的任务，创建没有初始任务的worker线程执行）</span><br><span class="line">                 &#x2F;&#x2F; worker数量-1的操作在addWorkerFailed()</span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                    if (t.isAlive()) &#x2F;&#x2F; &#x2F;&#x2F; precheck that t is startable   线程已经启动，抛非法线程状态异常</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    &#x2F;&#x2F;设置最大的池大小largestPoolSize，workerAdded设置为true</span><br><span class="line">                    int s &#x3D; workers.size();</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize &#x3D; s;</span><br><span class="line">                    workerAdded &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            if (workerAdded) &#123;&#x2F;&#x2F;如果往HashSet中添加worker成功，启动线程</span><br><span class="line">                &#x2F;&#x2F;通过t.start()方法正式执行线程。在这里一个线程才算是真正的执行起来了。</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;如果启动线程失败</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，我们可以归纳一下：<br><img src="https://oscimg.oschina.net/oscnet/55b3f4a3ea7eacc4dfddbba6628e0ade821.jpg" alt=""></p>
<h3 id="4-1-3-runWorker-方法"><a href="#4-1-3-runWorker-方法" class="headerlink" title="4.1.3 runWorker 方法"></a>4.1.3 runWorker 方法</h3><p>在addWorker方法中，我们将一个新增进去的worker所组合的线程属性thread启动了，但我们知道，在worker的构造方法中，它将自己本身注入到了thread的target属性里，所以绕了一圈，线程启动后，调用的还是worker的run方法，而在这里面，runWorker定义了线程执行的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Main worker run loop.  Repeatedly gets tasks from queue and</span><br><span class="line">     * executes them, while coping with a number of issues:</span><br><span class="line">     *</span><br><span class="line">     * 1. We may start out with an initial task, in which case we</span><br><span class="line">     * don&#39;t need to get the first one. Otherwise, as long as pool is</span><br><span class="line">     * running, we get tasks from getTask. If it returns null then the</span><br><span class="line">     * worker exits due to changed pool state or configuration</span><br><span class="line">     * parameters.  Other exits result from exception throws in</span><br><span class="line">     * external code, in which case completedAbruptly holds, which</span><br><span class="line">     * usually leads processWorkerExit to replace this thread.</span><br><span class="line">     * 我们可能使用一个初始化任务开始，即firstTask为null</span><br><span class="line">     * 然后只要线程池在运行，我们就从getTask()获取任务</span><br><span class="line">     * 如果getTask()返回null，则worker由于改变了线程池状态或参数配置而退出</span><br><span class="line">     * 其它退出因为外部代码抛异常了，这会使得completedAbruptly为true，这会导致在processWorkerExit()方法中替换当前线程</span><br><span class="line">     *</span><br><span class="line">     * 2. Before running any task, the lock is acquired to prevent</span><br><span class="line">     * other pool interrupts while the task is executing, and then we</span><br><span class="line">     * ensure that unless pool is stopping, this thread does not have</span><br><span class="line">     * its interrupt set.</span><br><span class="line">     * 在任何任务执行之前，都需要对worker加锁去防止在任务运行时，其它的线程池中断操作</span><br><span class="line">     * clearInterruptsForTaskRun保证除非线程池正在stoping，线程不会被设置中断标示</span><br><span class="line">     *</span><br><span class="line">     * 3. Each task run is preceded by a call to beforeExecute, which</span><br><span class="line">     * might throw an exception, in which case we cause thread to die</span><br><span class="line">     * (breaking loop with completedAbruptly true) without processing</span><br><span class="line">     * the task.</span><br><span class="line">     * 每个任务执行前会调用beforeExecute()，其中可能抛出一个异常，这种情况下会导致线程die（跳出循环，且completedAbruptly&#x3D;&#x3D;true），没有执行任务</span><br><span class="line">     * 因为beforeExecute()的异常没有cache住，会上抛，跳出循环</span><br><span class="line">     *</span><br><span class="line">     * 4. Assuming beforeExecute completes normally, we run the task,</span><br><span class="line">     * gathering any of its thrown exceptions to send to afterExecute.</span><br><span class="line">     * We separately handle RuntimeException, Error (both of which the</span><br><span class="line">     * specs guarantee that we trap) and arbitrary Throwables.</span><br><span class="line">     * Because we cannot rethrow Throwables within Runnable.run, we</span><br><span class="line">     * wrap them within Errors on the way out (to the thread&#39;s</span><br><span class="line">     * UncaughtExceptionHandler).  Any thrown exception also</span><br><span class="line">     * conservatively causes thread to die.</span><br><span class="line">     *</span><br><span class="line">     * 5. After task.run completes, we call afterExecute, which may</span><br><span class="line">     * also throw an exception, which will also cause thread to</span><br><span class="line">     * die. According to JLS Sec 14.20, this exception is the one that</span><br><span class="line">     * will be in effect even if task.run throws.</span><br><span class="line">     *</span><br><span class="line">     * The net effect of the exception mechanics is that afterExecute</span><br><span class="line">     * and the thread&#39;s UncaughtExceptionHandler have as accurate</span><br><span class="line">     * information as we can provide about any problems encountered by</span><br><span class="line">     * user code.</span><br><span class="line">     *</span><br><span class="line">     * @param w the worker</span><br><span class="line">     *&#x2F;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt &#x3D; Thread.currentThread();</span><br><span class="line">    Runnable task &#x3D; w.firstTask;</span><br><span class="line">    w.firstTask &#x3D; null;</span><br><span class="line">    w.unlock(); &#x2F;&#x2F; allow interrupts</span><br><span class="line">    &#x2F;&#x2F;标识线程是不是异常终止的</span><br><span class="line">    boolean completedAbruptly &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;task不为null情况是初始化worker时，如果task为null，则去队列中取线程---&gt;getTask()</span><br><span class="line">        &#x2F;&#x2F;可以看到，只要getTask方法被调用且返回null，那么worker必定被销毁，而确定一个线程是否应该被销毁的逻辑，在getTask方法中</span><br><span class="line">        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;线程开始执行之前执行此方法，可以实现Worker未执行退出，本类中未实现</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown &#x3D; null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();&#x2F;&#x2F;runWorker方法最本质的存在意义，就是调用task的run方法</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown &#x3D; x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F;线程执行后执行，可以实现标识Worker异常中断的功能，本类中未实现</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task &#x3D; null;&#x2F;&#x2F;运行过的task标null</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;标识线程不是异常终止的,是因为不满足while条件，被迫销毁的</span><br><span class="line">        completedAbruptly &#x3D; false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;处理worker退出的逻辑</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们归纳：<br><img src="https://oscimg.oschina.net/oscnet/eb572be61e780fff0d6af69d42a832ef41b.jpg" alt=""></p>
<h3 id="4-1-4-getTask方法"><a href="#4-1-4-getTask方法" class="headerlink" title="4.1.4 getTask方法"></a>4.1.4 getTask方法</h3><p>runWorker方法中的getTask()方法是线程处理完一个任务后，从队列中获取新任务的实现，也是处理判断一个线程是否应该被销毁的逻辑所在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Performs blocking or timed wait for a task, depending on</span><br><span class="line"> * current configuration settings, or returns null if this worker</span><br><span class="line"> * must exit because of any of:  以下情况会返回null</span><br><span class="line"> * 1. There are more than maximumPoolSize workers (due to</span><br><span class="line"> *    a call to setMaximumPoolSize).</span><br><span class="line"> *    超过了maximumPoolSize设置的线程数量（因为调用了setMaximumPoolSize()）</span><br><span class="line"> * 2. The pool is stopped.</span><br><span class="line"> *    线程池被stop</span><br><span class="line"> * 3. The pool is shutdown and the queue is empty.</span><br><span class="line"> *    线程池被shutdown，并且workQueue空了</span><br><span class="line"> * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="line"> *    workers are subject to termination (that is,</span><br><span class="line"> *    &#123;@code allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="line"> *    both before and after the timed wait.</span><br><span class="line"> *    线程等待任务超时</span><br><span class="line"> *</span><br><span class="line"> * @return task, or null if the worker must exit, in which case</span><br><span class="line"> *         workerCount is decremented</span><br><span class="line"> *         返回null表示这个worker要结束了，这种情况下workerCount-1</span><br><span class="line"> *&#x2F;</span><br><span class="line">private Runnable getTask() &#123;</span><br><span class="line">    &#x2F;&#x2F; timedOut 主要是判断后面的poll是否要超时</span><br><span class="line">    boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用于判断线程池状态</span><br><span class="line">     *&#x2F;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check if queue empty only if necessary.</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 对线程池状态的判断，两种情况会workerCount-1，并且返回null</span><br><span class="line">         * 1，线程池状态为shutdown，且workQueue为空（反映了shutdown状态的线程池还是要执行workQueue中剩余的任务的）</span><br><span class="line">         * 2，线程池状态为&gt;&#x3D;stop（只有TIDYING和TERMINATED会大于stop）（shutdownNow()会导致变成STOP）（此时不用考虑workQueue的情况）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();&#x2F;&#x2F;循环的CAS减少worker数量，直到成功</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Are workers subject to culling?</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;allowCoreThreadTimeOut字段，表示是否允许核心线程超过闲置时间后被摧毁，默认为false</span><br><span class="line">        &#x2F;&#x2F;我们前面说过，如果getTask方法返回null，那么这个worker只有被销毁一途</span><br><span class="line">        &#x2F;&#x2F;于是这个timed有3种情况</span><br><span class="line">        &#x2F;&#x2F;(1)当线程数没有超过核心线程数，且默认allowCoreThreadTimeOut为false时</span><br><span class="line">        &#x2F;&#x2F;          timed值为false。看下面if的判断逻辑，除非目前线程数大于最大值,否则下面的if始终进不去，该方法不可能返回null，worker也就不会被销毁。</span><br><span class="line">        &#x2F;&#x2F;          因为前提&quot;线程数不超过核心线程数&quot;与&quot;线程数大于最大值&quot;两个命题互斥，所以（1）情况，逻辑进入下面的if（返回null的线程销毁逻辑）的可能性不存在。</span><br><span class="line">        &#x2F;&#x2F;          也就是说，当线程数没有超过核心线程数时，线程不会被销毁。</span><br><span class="line">        &#x2F;&#x2F;(2)当当前线程数超过核心线程数，且默认allowCoreThreadTimeOut为false时&#x2F;&#x2F;timed值为true。</span><br><span class="line">        &#x2F;&#x2F;(3)如果allowCoreThreadTimeOut为true，则timed始终为true</span><br><span class="line">        boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;wc &gt; maximumPoolSize则必销毁，因为这情况下，wc&gt;1也肯定为true</span><br><span class="line">        &#x2F;&#x2F;wc &lt;&#x3D; maximumPoolSize,且(timed &amp;&amp; timedOut) &#x3D; true，这种情况下一般也意味着worker要被销毁，因为超时一般是由阻塞队列为空造成的，所以workQueue.isEmpty()也大概率为真，进入if逻辑。</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;一般情况是这样，那不一般的情况呢？阻塞队列没有为空，但是因为一些原因，还是超时了，这时候取决于wc &gt; 1，它为真就销毁，为假就不销毁。</span><br><span class="line">        &#x2F;&#x2F; 也就是说，如果阻塞队列还有任务，但是wc&#x3D;1，线程池里只剩下自己这个线程了，那么就不能销毁,这个if不满足，我们的代码继续往下走</span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;如果timed为true那么使用poll取线程。否则使用take()</span><br><span class="line">            Runnable r &#x3D; timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                &#x2F;&#x2F;workQueue.poll()：如果在keepAliveTime时间内，阻塞队列还是没有任务，返回null</span><br><span class="line">                workQueue.take();</span><br><span class="line">                &#x2F;&#x2F;workQueue.take()：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务</span><br><span class="line">            &#x2F;&#x2F;如果正常返回，那么返回取到的task。</span><br><span class="line">            if (r !&#x3D; null)</span><br><span class="line">                return r;</span><br><span class="line">            &#x2F;&#x2F;否则，设为超时，重新执行循环,</span><br><span class="line">            timedOut &#x3D; true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">        &#x2F;&#x2F;在阻塞从workQueue中获取任务时，可以被interrupt()中断，代码中捕获了InterruptedException，重置timedOut为初始值false，再次执行第1步中的判断，满足就继续获取任务，不满足return null，会进入worker退出的流程</span><br><span class="line">            timedOut &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>归纳：<br><img src="https://oscimg.oschina.net/oscnet/a398f6d2a65424c1aa570c76cabaf381209.jpg" alt=""></p>
<h3 id="4-1-5-processWorkerExit方法"><a href="#4-1-5-processWorkerExit方法" class="headerlink" title="4.1.5 processWorkerExit方法"></a>4.1.5 processWorkerExit方法</h3><p>在runWorker方法中，我们看到当不满足while条件后，线程池会执行退出线程的操作，这个操作，就封装在processWorkerExit方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Performs cleanup and bookkeeping for a dying worker. Called</span><br><span class="line"> * only from worker threads. Unless completedAbruptly is set,</span><br><span class="line"> * assumes that workerCount has already been adjusted to account</span><br><span class="line"> * for exit.  This method removes thread from worker set, and</span><br><span class="line"> * possibly terminates the pool or replaces the worker if either</span><br><span class="line"> * it exited due to user task exception or if fewer than</span><br><span class="line"> * corePoolSize workers are running or queue is non-empty but</span><br><span class="line"> * there are no workers.</span><br><span class="line"> *</span><br><span class="line"> * @param w the worker</span><br><span class="line"> * @param completedAbruptly if the worker died due to user exception</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">    &#x2F;&#x2F;参数：</span><br><span class="line">        &#x2F;&#x2F;worker：                      要结束的worker</span><br><span class="line">        &#x2F;&#x2F;completedAbruptly： 是否突然完成（是否因为异常退出）</span><br><span class="line">        </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 1、worker数量-1</span><br><span class="line">     * 如果是突然终止，说明是task执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的worker线程数量需要-1</span><br><span class="line">     * 如果不是突然终止，说明是worker线程没有task可执行了，不用-1，因为已经在getTask()方法中-1了</span><br><span class="line">     *&#x2F;</span><br><span class="line">    if (completedAbruptly) &#x2F;&#x2F; If abrupt, then workerCount wasn&#39;t adjusted 代码和注释正好相反啊</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 2、从Workers Set中移除worker</span><br><span class="line">     *&#x2F;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        completedTaskCount +&#x3D; w.completedTasks; &#x2F;&#x2F;把worker的完成任务数加到线程池的完成任务数</span><br><span class="line">        workers.remove(w); &#x2F;&#x2F;从HashSet&lt;Worker&gt;中移除</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 3、在对线程池有负效益的操作时，都需要“尝试终止”线程池</span><br><span class="line">     * 主要是判断线程池是否满足终止的状态</span><br><span class="line">     * 如果状态满足，但线程池还有线程，尝试对其发出中断响应，使其能进入退出流程</span><br><span class="line">     * 没有线程了，更新状态为tidying-&gt;terminated</span><br><span class="line">     *&#x2F;</span><br><span class="line">    tryTerminate();</span><br><span class="line"> </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 4、是否需要增加worker线程</span><br><span class="line">     * 线程池状态是running 或 shutdown</span><br><span class="line">     * 如果当前线程是突然终止的，addWorker()</span><br><span class="line">     * 如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()</span><br><span class="line">     * 故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程</span><br><span class="line">     *&#x2F;</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    &#x2F;&#x2F;如果状态是running、shutdown，即tryTerminate()没有成功终止线程池，尝试再添加一个worker</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        &#x2F;&#x2F;不是突然完成的，即没有task任务可以获取而完成的，计算min，并根据当前worker数量判断是否需要addWorker()</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min &#x3D; allowCoreThreadTimeOut ? 0 : corePoolSize; &#x2F;&#x2F;allowCoreThreadTimeOut默认为false，即min默认为corePoolSize</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;如果min为0，即不需要维持核心线程数量，且workQueue不为空，至少保持一个线程</span><br><span class="line">            if (min &#x3D;&#x3D; 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min &#x3D; 1;</span><br><span class="line">             </span><br><span class="line">            &#x2F;&#x2F;如果线程数量大于最少数量，直接返回，否则下面至少要addWorker一个</span><br><span class="line">            if (workerCountOf(c) &gt;&#x3D; min)</span><br><span class="line">                return; &#x2F;&#x2F; replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        &#x2F;&#x2F;添加一个没有firstTask的worker</span><br><span class="line">        &#x2F;&#x2F;只要worker是completedAbruptly突然终止的，或者线程数量小于要维护的数量，就新添一个worker线程，即使是shutdown状态</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总而言之：如果线程池还没有完全终止，就仍需要保持一定数量的线程。  </p>
<p>线程池状态是running 或 shutdown的情况下：  </p>
<ul>
<li>如果当前线程是突然终止的，addWorker()</li>
<li>如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()  </li>
</ul>
<p>故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程</p>
<hr>
<h3 id="4-1-6-submit方法"><a href="#4-1-6-submit方法" class="headerlink" title="4.1.6 submit方法"></a>4.1.6 submit方法</h3><p>前面我们讲过execute方法，其作用是将一个任务提交给线程池，以期在未来的某个时间点被执行。  </p>
<p>submit方法在作用上，和execute方法是一样的，将某个任务提交给线程池，让线程池调度线程去执行它。  </p>
<p>那么它和execute方法有什么区别呢？我们来看看submit方法的源码：<br>submit方法的实现在ThreadPoolExecutor的父类AbstractExecutorService类中，有三种重载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line">     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该Future的get方法在成功完成时将会返回null。</span><br><span class="line">     * submit 参数： task - 要提交的任务 返回：表示任务等待完成的 Future</span><br><span class="line">     * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">     * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 提交一个Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。</span><br><span class="line">     * submit 参数： task - 要提交的任务 result - 完成任务时要求返回的结果 </span><br><span class="line">     * 返回： 表示任务等待完成的 Future</span><br><span class="line">     * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">     * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 提交一个Callable的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get </span><br><span class="line">方法在成功完成时将会返回该任务的结果。 </span><br><span class="line">     * 如果想立即阻塞任务的等待，则可以使用 result &#x3D; </span><br><span class="line">exec.submit(aCallable).get(); 形式的构造。</span><br><span class="line">     * 参数： task - 要提交的任务 返回： 表示任务等待完成的Future</span><br><span class="line">     * @throws RejectedExecutionException &#123;@inheritDoc&#125;</span><br><span class="line">     * @throws NullPointerException       &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">        if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        return ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>源码很简单，submit方法，将任务task封装成FutureTask(newTaskFor方法中就是new了一个FutureTask)，然后调用execute。<strong>所以submit方法和execute的所有区别，都在这FutureTask所带来的差异化实现上</strong>。  </p>
<p>总而言之，submit方法将一个任务task用future模式封装成FutureTask对象，提交给线程执行，并将这个FutureTask对象返回，以供<strong>主线程</strong>在<strong>该任务被线程池执行之后</strong>得到<strong>执行结果</strong>。  </p>
<p>注意，获得执行结果的方法FutureTask.get()，会阻塞执行该方法的线程，尤其是当任务被DiscardPolicy策略和DiscardOldestPolicy拒绝的时候，get方法会一直阻塞在那里，所以我们最好使用自带超时时间的future。</p>
<h2 id="4-2-线程池的关闭"><a href="#4-2-线程池的关闭" class="headerlink" title="4.2 线程池的关闭"></a>4.2 线程池的关闭</h2><h3 id="4-2-1-shutdown方法"><a href="#4-2-1-shutdown方法" class="headerlink" title="4.2.1 shutdown方法"></a>4.2.1 shutdown方法</h3><p>讲完了线程池的基本运转过程，在方法章的最后，我们来看看负责线程池生命周期最后收尾工作的几个重要方法，首先是shutdown方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Initiates an orderly shutdown in which previously submitted</span><br><span class="line">     * tasks are executed, but no new tasks will be accepted.</span><br><span class="line">     * Invocation has no additional effect if already shut down.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method does not wait for previously submitted tasks to</span><br><span class="line">     * complete execution.  Use &#123;@link #awaitTermination awaitTermination&#125;</span><br><span class="line">     * to do that.</span><br><span class="line">     * 开始一个顺序的shutdown操作，shutdown之前被执行的已提交任务，新的任务不会再被接收了。如果线程池已经被shutdown了，该方法的调用没有其他任何效果了。</span><br><span class="line">     * **该方法不会等待之前已经提交的任务执行完毕**，awaitTermination方法才有这个效果。</span><br><span class="line">     *</span><br><span class="line">     * @throws SecurityException &#123;@inheritDoc&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void shutdown() &#123;</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">             &#x2F;&#x2F;判断是否可以操作关闭目标线程。</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            &#x2F;&#x2F;advanceRunState方法，参数：目标状态；作用：一直执行，直到成功利用CAS将状态置为目标值。            </span><br><span class="line">            &#x2F;&#x2F;设置线程池状态为SHUTDOWN,此处之后，线程池中不会增加新Task</span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            &#x2F;&#x2F;中断所有的空闲线程</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown(); &#x2F;&#x2F; hook for ScheduledThreadPoolExecutor</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;尝试进行terminate操作，但其实我们上面将状态置为shutdown，就已经算是“中止”了一个线程池了，它不会再执行任务，于外部而言，已经失去了作用。而这里，也只是尝试去将线程池的状态一撸到底而已，并不是一定要terminate掉。该方法我们后面会说到。</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，shutdown方法只不过是中断唤醒了所有阻塞的线程，并且把线程池状态置为shutdown，正如注释所说的，它没有等待所有正在执行任务的线程执行完任务，把状态置为shutdown，已经足够线程池丧失基本的功能了。 </p>
<p>在该方法中，线程池如何中断线程是我们最需要关心的，我们来看一下interruptIdleWorkers方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void interruptIdleWorkers(boolean onlyOne) &#123;&#x2F;&#x2F;参数onlyOne表示是否值中断一个线程就退出，在shutdown中该值为false。</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;遍历workers 对所有worker做中断处理。</span><br><span class="line">            for (Worker w : workers) &#123;</span><br><span class="line">                Thread t &#x3D; w.thread;</span><br><span class="line">                &#x2F;&#x2F; w.tryLock()对Worker获取锁，因为正在执行的worker已经加锁了(见runWorker方法，w.lock()语句)</span><br><span class="line">                &#x2F;&#x2F;所以这保证了正在运行执行Task的Worker不会被中断。只有阻塞在getTask方法的空闲线程才会进这个if判断（被中断），但中断不代表线程立刻停止，它要继续处理到阻塞队列为空时才会被销毁。</span><br><span class="line">                if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; catch (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (onlyOne)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在中断方法中，我们调用了worker的tryLock方法去尝试获取worker的锁，<strong>所以我们说，worker类这一层的封装，是用来控制线程中断的</strong>，正在执行任务的线程已经上了锁，无法被中断，只有在获取阻塞队列中的任务的线程（我们称为空闲线程）才会有被中断的可能。  </p>
<p>之前我们看过getTask方法，在这个方法中， worker是不加锁的，所以可以被中断。我们为什么说“中断不代表线程立刻停止，它要继续处理到阻塞队列为空时才会被销毁”呢？具体逻辑，我们再来看一下getTask的源码，以及我们的注释（我们模拟中断发生时的场景）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">        boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 当执行过程中抛出InterruptedException 的时候，该异常被catch住，逻辑重新回到这个for循环</span><br><span class="line">         * catch块在getTask方法的最后。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c &#x3D; ctl.get();</span><br><span class="line">            int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Check if queue empty only if necessary.</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 因为逻辑是在抛出中断异常后来到这里的，那说明线程池的状态已经在shutdown方法中被置为shutdown了，rs &gt;&#x3D; SHUTDOWN为true，rs &gt;&#x3D;STOP为false(只有TIDYING和TERMINATED状态会大于stop)</span><br><span class="line">             * 这时候，如果workQueue为空，判断为真，线程被销毁。</span><br><span class="line">             * 否则，workQueue为非空，判断为假，线程不会进入销毁逻辑。</span><br><span class="line">             *&#x2F;</span><br><span class="line">            if (rs &gt;&#x3D; SHUTDOWN &amp;&amp; (rs &gt;&#x3D; STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();&#x2F;&#x2F;循环的CAS减少worker数量，直到成功</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Are workers subject to culling?</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;因为在catch块中，timeOut已经为false了。</span><br><span class="line">            &#x2F;&#x2F;所以只要不发生当前线程数超过最大线程数这种极端情况，命题(wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)一定为false，线程依旧不被销毁。</span><br><span class="line">            if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">                if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    return null;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;继续执行正常的从阻塞队列中取任务的逻辑，直到阻塞队列彻底为空，这时候，上面第一个if判断符合，线程被销毁，寿命彻底结束。</span><br><span class="line">                Runnable r &#x3D; timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                &#x2F;&#x2F;如果正常返回，那么返回取到的task。</span><br><span class="line">                if (r !&#x3D; null)</span><br><span class="line">                    return r;</span><br><span class="line">                &#x2F;&#x2F;否则，设为超时，重新执行循环,</span><br><span class="line">                timedOut &#x3D; true;</span><br><span class="line">            &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">                &#x2F;&#x2F;捕获中断异常</span><br><span class="line">                timedOut &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总结：<strong>正阻塞在getTask()获取任务的worker在被中断后，会抛出InterruptedException，不再阻塞获取任务。捕获中断异常后，将继续循环到getTask()最开始的判断线程池状态的逻辑，当线程池是shutdown状态，且workQueue.isEmpty时，return null，进行worker线程退出逻辑</strong>。</p>
<p>所以，这就是我们为什么说，shutdown方法不会立刻停止线程池，它的作用是阻止新的任务被添加进来（逻辑在addWorker方法的第一个if判断中，可以返回去看一下），并且继续处理完剩下的任务，然后tryTerminated，尝试关闭。</p>
<h3 id="4-2-2-tryTerminate方法"><a href="#4-2-2-tryTerminate方法" class="headerlink" title="4.2.2 tryTerminate方法"></a>4.2.2 tryTerminate方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="line"> * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="line"> * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="line"> * idle worker to ensure that shutdown signals propagate. This</span><br><span class="line"> * method must be called following any action that might make</span><br><span class="line"> * termination possible -- reducing worker count or removing tasks</span><br><span class="line"> * from the queue during shutdown. The method is non-private to</span><br><span class="line"> * allow access from ScheduledThreadPoolExecutor.</span><br><span class="line"> * 在以下情况将线程池变为TERMINATED终止状态</span><br><span class="line"> * shutdown 且 正在运行的worker 和 workQueue队列 都empty</span><br><span class="line"> * stop 且  没有正在运行的worker</span><br><span class="line"> * </span><br><span class="line"> * 这个方法必须在任何可能导致线程池终止的情况下被调用，如：</span><br><span class="line"> * 减少worker数量</span><br><span class="line"> * shutdown时从queue中移除任务</span><br><span class="line"> * </span><br><span class="line"> * 这个方法不是私有的，所以允许子类ScheduledThreadPoolExecutor调用</span><br><span class="line"> *&#x2F;</span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 线程池是否需要终止</span><br><span class="line">         * 如果以下3中情况任一为true，return，不进行终止</span><br><span class="line">         * 1、还在运行状态</span><br><span class="line">         * 2、状态是TIDYING、或 TERMINATED，已经终止过了</span><br><span class="line">         * 3、SHUTDOWN 且 workQueue不为空</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) &#x3D;&#x3D; SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 只有shutdown状态 且 workQueue为空，或者 stop状态能执行到这一步</span><br><span class="line">             * 如果此时线程池还有线程（正在运行任务或正在等待任务，总之count不等于0）</span><br><span class="line">             * 中断唤醒一个正在等任务的空闲worker</span><br><span class="line">             *（中断唤醒的意思就是让阻塞在阻塞队列中的worker抛出异常，然后重新判断状态，getTask方法逻辑）</span><br><span class="line">             * 线程被唤醒后再次判断线程池状态，会return null，进入processWorkerExit()流程（runWorker逻辑）</span><br><span class="line">             *&#x2F;</span><br><span class="line">        if (workerCountOf(c) !&#x3D; 0) &#123; &#x2F;&#x2F; Eligible to terminate</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);&#x2F;&#x2F;中断workers集合中的空闲任务，参数为true，只中断一个。（该逻辑的意义应该在于通知被阻塞在队列中的线程：别瞎jb等了，这个线程池都要倒闭了，赶紧收拾铺盖准备销毁吧你个逼玩意儿）。</span><br><span class="line">            &#x2F;&#x2F;尝试终止失败，返回。可能大家会有疑问，shutdown只调用了一次tryTerminate方法，如果一次尝试失败了，是不是就意味着shutdown方法很可能最终无法终止线程池？</span><br><span class="line">            &#x2F;&#x2F;其实看注释，我们知道线程池在进行所有负面效益的操作时都会调用该方法尝试终止，上面我们中断了一个阻塞线程让他被销毁，他销毁时也会尝试终止（这其中又唤醒了一个阻塞线程去销毁），以此类推，直到最后一个线程执行tryTerminate时，逻辑才有可能走到下面去。</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 如果状态是SHUTDOWN，workQueue也为空了，正在运行的worker也没有了，开始terminated</span><br><span class="line">         *&#x2F;</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;CAS：将线程池的ctl变成TIDYING（所有的任务被终止，workCount为0，为此状态时将会调用terminated()方法），期间ctl有变化就会失败，会再次for循环</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F;方法为空，需子类实现</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F;将状态置为TERMINATED</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    &#x2F;&#x2F;最后执行termination.signalAll()，并唤醒所有等待线程池终止这个Condition的线程（也就是调用了awaitTermination方法的线程，这个方法的作用是阻塞调用它的线程，直到调用该方法的线程池真的已经被终止了。）</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下：tryTerminate被调用的时机主要有：  </p>
<ol>
<li>shutdown方法时</li>
<li>processWorkerExit方法销毁一个线程时</li>
<li>addWorkerFailed方法添加线程失败或启动线程失败时</li>
<li>remove方法，从阻塞队列中删掉一个任务时</li>
</ol>
<h3 id="4-2-3-shutdownNow方法"><a href="#4-2-3-shutdownNow方法" class="headerlink" title="4.2.3 shutdownNow方法"></a>4.2.3 shutdownNow方法</h3><p>我们知道，shutdown后线程池将变成shutdown状态，此时不接收新任务，但会处理完正在运行的 和 在阻塞队列中等待处理的任务。</p>
<p>我们接下来要说的shutdownNow方法，作用是：shutdownNow后线程池将变成stop状态，此时不接收新任务，不再处理在阻塞队列中等待的任务，还会尝试中断正在处理中的工作线程。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Attempts to stop all actively executing tasks, halts the</span><br><span class="line"> * processing of waiting tasks, and returns a list of the tasks</span><br><span class="line"> * that were awaiting execution. These tasks are drained (removed)</span><br><span class="line"> * from the task queue upon return from this method.</span><br><span class="line"> * 尝试停止所有活动的正在执行的任务，停止等待任务的处理，并返回正在等待被执行的任务列表</span><br><span class="line"> * 这个任务列表是从任务队列中排出（删除）的</span><br><span class="line"> * &lt;p&gt;This method does not wait for actively executing tasks to</span><br><span class="line"> * terminate.  Use &#123;@link #awaitTermination awaitTermination&#125; to</span><br><span class="line"> * do that.</span><br><span class="line"> * 这个方法不用等到正在执行的任务结束，要等待线程池终止可使用awaitTermination()</span><br><span class="line"> * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span><br><span class="line"> * processing actively executing tasks.  This implementation</span><br><span class="line"> * cancels tasks via &#123;@link Thread#interrupt&#125;, so any task that</span><br><span class="line"> * fails to respond to interrupts may never terminate.</span><br><span class="line"> * 除了尽力尝试停止运行中的任务，没有任何保证</span><br><span class="line"> * 取消任务是通过Thread.interrupt()实现的，所以任何响应中断失败的任务可能永远不会结束</span><br><span class="line"> * @throws SecurityException &#123;@inheritDoc&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;判断调用者是否有权限shutdown线程池</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        &#x2F;&#x2F;CAS+循环设置线程池状态为stop</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        &#x2F;&#x2F;中断所有线程，包括正在运行任务的</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        &#x2F;&#x2F;将workQueue中的元素放入一个List并返回</span><br><span class="line">        tasks &#x3D; drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;尝试终止线程池</span><br><span class="line">    tryTerminate();</span><br><span class="line">    &#x2F;&#x2F;返回workQueue中未执行的任务</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interruptWorkers 很简单，循环对所有worker调用 interruptIfStarted，其中会判断worker的AQS state是否大于0，即worker是否已经开始运作，再调用Thread.interrupt</p>
<p>需要注意的是，对于运行中的线程调用Thread.interrupt并不能保证线程被终止，task.run内部可能捕获了InterruptException，没有上抛，导致线程一直无法结束</p>
<h3 id="4-2-4-awaitTermination方法"><a href="#4-2-4-awaitTermination方法" class="headerlink" title="4.2.4 awaitTermination方法"></a>4.2.4 awaitTermination方法</h3><p>该方法的作用是等待线程池终止，参数是timeout：超时时间和unit：     timeout超时时间的单位，返回结果：true：线程池终止，false：超过timeout指定时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">public boolean awaitTermination(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        long nanos &#x3D; unit.toNanos(timeout);</span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                &#x2F;&#x2F;是否terminated终止</span><br><span class="line">                if (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                    return true;</span><br><span class="line">                 &#x2F;&#x2F;是否已经超过超时时间</span><br><span class="line">                if (nanos &lt;&#x3D; 0)</span><br><span class="line">                    return false;</span><br><span class="line">                 &#x2F;&#x2F;核心逻辑：看注释我们能知道，该方法让调用线程等待一段时间，直到被唤醒（有且仅有之前我们说过的tryTerminate方法中的 termination.signalAll()），或者被异常中断，或者传入了nanos时间参数流逝完。</span><br><span class="line">                nanos &#x3D; termination.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>termination.awaitNanos() 是通过 LockSupport.parkNanos(this, nanosTimeout)实现的阻塞等待</p>
<p>阻塞等待过程中发生以下具体情况会解除阻塞（对上面3种情况的解释）：</p>
<ol>
<li><p>如果发生了 termination.signalAll()（内部实现是 LockSupport.unpark()）会唤醒阻塞等待，且由于ThreadPoolExecutor只有在 tryTerminated()尝试终止线程池成功，将线程池更新为terminated状态后才会signalAll()，故awaitTermination()再次判断状态会return true退出</p>
</li>
<li><p>如果达到了超时时间 termination.awaitNanos() 也会返回，此时nano==0，再次循环判断return false，等待线程池终止失败</p>
</li>
<li><p>如果当前线程被 Thread.interrupt()，termination.awaitNanos()会上抛InterruptException，awaitTermination()继续上抛给调用线程，会以异常的形式解除阻塞</p>
</li>
</ol>
<p>综上，要想优雅的关闭线程池，我们应该：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">executorService.shutdown();</span><br><span class="line">try&#123;</span><br><span class="line">    while(!executorService.awaitTermination(500, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        LOGGER.debug(&quot;Waiting for terminate&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">catch (InterruptedException e) &#123;</span><br><span class="line">    &#x2F;&#x2F;中断处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-hand-o-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">96</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">385.7k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
