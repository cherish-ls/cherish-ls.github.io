<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/29/JAVA%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/29/JAVA%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/" itemprop="url">JAVA中断机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-29T23:21:34+08:00">
                2019-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA线程与并发控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/29/JAVA%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/29/JAVA中断机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-中断的含义"><a href="#1-中断的含义" class="headerlink" title="1 中断的含义"></a>1 中断的含义</h1><p>有人说中断是让某个线程停止运行的意思，那这如何解释中断可以用来唤醒阻塞中的线程呢？有人说中断是唤醒线程的意思，但很多时候我们确实使用它来停止线程。这到底是怎么回事？</p>
<p>其实中断的意思是：用强制的方式来改变线程的状态，一般使用抛出异常的方式，强行获取到CPU执行权，至于改变状态后，线程是唤醒还是停止，则取决于后续的逻辑：</p>
<ul>
<li>如果你在catch块捕获异常并什么都不处理，那么等于线程被唤醒了。</li>
<li>如果你一直向上抛出异常，或者在catch块中优雅退出，那么实现的就是将线程停止的目的。<h1 id="2-中断机制"><a href="#2-中断机制" class="headerlink" title="2 中断机制"></a>2 中断机制</h1>java并未提供任何直接中断某线程的方法，只提供了中断机制。即线程A向线程B发出“请你改变状态”的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，当然也可以忽略中断。</li>
</ul>
<p>也就是说java的中断不能直接控制线程，而是需要被中断的线程自己决定怎么处理，好比是父母叮嘱在外的子女注意身体，但子女是否注意身体，怎么注意身体，则完全取决于他们自己。</p>
<h1 id="3-中断的相关方法"><a href="#3-中断的相关方法" class="headerlink" title="3 中断的相关方法"></a>3 中断的相关方法</h1><h2 id="3-1-interrupt-方法和基本概念"><a href="#3-1-interrupt-方法和基本概念" class="headerlink" title="3.1 interrupt()方法和基本概念"></a>3.1 interrupt()方法和基本概念</h2><p>interrupt status(中断状态)：请记住这个术语，中断机制就是围绕着这个字段来工作的。在Java源码中代表中断状态的字段是Thread类中的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile Interruptible blocker;</span><br></pre></td></tr></table></figure>

<p>对“Interruptible”这个类不需要深入分析，对于“blocker”变量有以下几个操作。</p>
<p>　　1.默认blocker=null;　®1</p>
<p>　　2.调用方法“interrupt0();”将会导致“该线程的中断状态将被设置(JDK文档中术语)”。®2</p>
<p>　　3.再次调用“interrupt0();”将会导致“其中断状态将被清除(同JDK文档中术语)”®3</p>
<p>interrupt()方法并不会中断正在运行的线程，当你的线程正在正常运行时，这个时候调用t.interrupt，除了给该线程置了一个标志位，其他什么反应都没有。当然，如果你在run方法中有判断这个标志位，当其中断为true时有优雅退出的逻辑，或者像很多jdk实现的抛出一个InterruptException异常，利用异常使线程结束，那则另当别论。</p>
<p>“中断“这个词有误区，在语言层面，我们不会真的中断一个运行中的线程，但中断确实可以“中断轻量级阻塞”或者说“唤醒轻量级阻塞”。</p>
<p>“轻量级阻塞”就是调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者线程类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法这几个函数，所造成的线程阻塞。此时线程是处于Waiting状态，会响应t.interrupt，中断阻塞，并直接抛出InterruptException异常。 </p>
<h3 id="3-1-1-为什么调用interrupt-并不能中断线程？"><a href="#3-1-1-为什么调用interrupt-并不能中断线程？" class="headerlink" title="3.1.1 为什么调用interrupt()并不能中断线程？"></a>3.1.1 为什么调用interrupt()并不能中断线程？</h3><p>我们来看interrupt方法源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Interrupts this thread.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; Unless the current thread is interrupting itself, which is</span><br><span class="line">     * always permitted, the &#123;@link #checkAccess() checkAccess&#125; method</span><br><span class="line">     * of this thread is invoked, which may cause a &#123;@link</span><br><span class="line">     * SecurityException&#125; to be thrown.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; If this thread is blocked in an invocation of the &#123;@link</span><br><span class="line">     * Object#wait() wait()&#125;, &#123;@link Object#wait(long) wait(long)&#125;, or &#123;@link</span><br><span class="line">     * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;@link Object&#125;</span><br><span class="line">     * class, or of the &#123;@link #join()&#125;, &#123;@link #join(long)&#125;, &#123;@link</span><br><span class="line">     * #join(long, int)&#125;, &#123;@link #sleep(long)&#125;, or &#123;@link #sleep(long, int)&#125;,</span><br><span class="line">     * methods of this class, then its interrupt status will be cleared and it</span><br><span class="line">     * will receive an &#123;@link InterruptedException&#125;.</span><br><span class="line">     *</span><br><span class="line">     * 如果线程堵塞在object.wait、Thread.join和Thread.sleep，将会抛出InterruptedException,同时清除线程的中断状态;</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; If this thread is blocked in an I&#x2F;O operation upon an &#123;@link</span><br><span class="line">     * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span><br><span class="line">     * then the channel will be closed, the thread&#39;s interrupt</span><br><span class="line">     * status will be set, and the thread will receive a &#123;@link</span><br><span class="line">     * java.nio.channels.ClosedByInterruptException&#125;.</span><br><span class="line">     *</span><br><span class="line"></span><br><span class="line">     *如果该线程被阻塞在InterruptibleChannel 的I&#x2F;O操作上，调用该方法，该channel会被关闭，中断状态会被设置，</span><br><span class="line">     *并且线程会收到ClosedByInterruptException异常</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; If this thread is blocked in a &#123;@link java.nio.channels.Selector&#125;</span><br><span class="line">     * then the thread&#39;s interrupt status will be set and it will return</span><br><span class="line">     * immediately from the selection operation, possibly with a non-zero</span><br><span class="line">     * value, just as if the selector&#39;s &#123;@link</span><br><span class="line">     * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span><br><span class="line">     *</span><br><span class="line">     *如果该线程被阻塞在nio的Selector上，调用该方法，中断状态会被设置，</span><br><span class="line">     *并且线程会携带一个非零值立刻返回（其实就是调用了java.nio.channels.Selector#wakeup方法）</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt</span><br><span class="line">     * status will be set. &lt;&#x2F;p&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span><br><span class="line">     *</span><br><span class="line">     * @throws  SecurityException</span><br><span class="line">     *          if the current thread cannot modify this thread</span><br><span class="line">     *</span><br><span class="line">     * @revised 6.0</span><br><span class="line">     * @spec JSR-51</span><br><span class="line">     *&#x2F;</span><br><span class="line">public void interrupt() &#123;</span><br><span class="line">    if (this !&#x3D; Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    synchronized (blockerLock) &#123;</span><br><span class="line">        Interruptible b &#x3D; blocker;</span><br><span class="line">        if (b !&#x3D; null) &#123;</span><br><span class="line">            interrupt0();           &#x2F;&#x2F; Just to set the interrupt flag，只是设置标记</span><br><span class="line">            &#x2F;&#x2F; Interruptible的interrupt方法在AbstractInterruptibleChannel和AbstractSelector类中有各自的实现</span><br><span class="line">            &#x2F;&#x2F;故而如当前方法的注释说的那样（当前方法注释中中文翻译的部分），interrupt对这两种场景有效</span><br><span class="line">            &#x2F;&#x2F;但对于普通线程，其实绝大多数不是上面的中断场景。</span><br><span class="line">            &#x2F;&#x2F;因为thread默认注入的不是AbstractInterruptibleChannel和AbstractSelector类的实现</span><br><span class="line">            b.interrupt(this);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上是Java源码中的代码，由此我们看出问题的答案。线程的blocker字段(也就是interrupt status)默认是null(®1)。调用interrupt()方法时，只是运行了interrupt0()（设置中断标记），并没有进入if语句，所以没调用真正执行中断的代码b.interrupt().</p>
<h3 id="3-1-2-interrupt-方法使线程提前结束阻塞状态"><a href="#3-1-2-interrupt-方法使线程提前结束阻塞状态" class="headerlink" title="3.1.2 interrupt()方法使线程提前结束阻塞状态"></a>3.1.2 interrupt()方法使线程提前结束阻塞状态</h3><p>interrupt()方法使线程提前结束阻塞状态，为什么呢？我们用sleep方法使线程阻塞</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Causes the currently executing thread to sleep (temporarily cease</span><br><span class="line"> * execution) for the specified number of milliseconds, subject to</span><br><span class="line"> * the precision and accuracy of system timers and schedulers. The thread</span><br><span class="line"> * does not lose ownership of any monitors.</span><br><span class="line"> *</span><br><span class="line"> * @param  millis</span><br><span class="line"> *         the length of time to sleep in milliseconds</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          if the value of &#123;@code millis&#125; is negative</span><br><span class="line"> *</span><br><span class="line"> * @throws  InterruptedException</span><br><span class="line"> *          if any thread has interrupted the current thread. The</span><br><span class="line"> *          &lt;i&gt;interrupted status&lt;&#x2F;i&gt; of the current thread is</span><br><span class="line"> *          cleared when this exception is thrown.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static native void sleep(long millis) throws InterruptedException;</span><br></pre></td></tr></table></figure>
<p>该本地方法会将blocker置为®2，因而此时调用interrupt方法，将执行if中的语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (b !&#x3D; null) &#123;</span><br><span class="line">    interrupt0();           &#x2F;&#x2F; Just to set the interrupt flag</span><br><span class="line">    b.interrupt(this);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，interrupt0();方法将中断标志清除，即置为®3。然后调用核心语句b.interrupt(this)，真正的打断线程，并且抛出InterruptedException。</p>
<p>我们来看下b.interrupt(this)为什么能中断线程。</p>
<p>除了上文说到的Interruptible.interrupt在AbstractInterruptibleChannel和AbstractSelector类中有两种实现外，对于正常Thead类，我们注入的Interruptible b并非AbstractInterruptibleChannel和AbstractSelector类中的Interruptible实现。(这两类只在特定场景实现，可见下文：AbstractInterruptibleChannel类中的中断实现)</p>
<p>来看看Thread.blockedOn方法，Thread本身不会初始化它的blocker字段，blocker的值是注入进来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Set the blocker field; invoked via sun.misc.SharedSecrets from java.nio code</span><br><span class="line">*&#x2F;</span><br><span class="line">void blockedOn(Interruptible b) &#123;</span><br><span class="line">	synchronized (blockerLock) &#123;</span><br><span class="line">		blocker &#x3D; b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释说的很明白，该方法被via sun.misc.SharedSecrets调用，注入的b所执行的interrupt(this)方法，其实是native方法，定义在jvm.cpp中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(&quot;JVM_Interrupt&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Ensure that the C++ Thread and OSThread structures aren&#39;t freed before we operate</span><br><span class="line">  oop java_thread &#x3D; JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  MutexLockerEx ml(thread-&gt;threadObj() &#x3D;&#x3D; java_thread ? NULL : Threads_lock);</span><br><span class="line">  &#x2F;&#x2F; We need to re-resolve the java_thread, since a GC might have happened during the</span><br><span class="line">  &#x2F;&#x2F; acquire of the lock</span><br><span class="line">  JavaThread* thr &#x3D; java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  if (thr !&#x3D; NULL) &#123;</span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>
<p>JVM_Interrupt对参数进行了校验，然后直接调用Thread::interrupt:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Thread::interrupt(Thread* thread) &#123;</span><br><span class="line">  trace(&quot;interrupt&quot;, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Thread::interrupt调用os::interrupt方法实现,os::interrupt方法定义在os_linux.cpp:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void os::interrupt(Thread* thread) &#123;</span><br><span class="line">  assert(Thread::current() &#x3D;&#x3D; thread || Threads_lock-&gt;owned_by_self(),</span><br><span class="line">    &quot;possibility of dangling Thread pointer&quot;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;获取系统native线程对象</span><br><span class="line">  OSThread* osthread &#x3D; thread-&gt;osthread();</span><br><span class="line"></span><br><span class="line">  if (!osthread-&gt;interrupted()) &#123;</span><br><span class="line">    osthread-&gt;set_interrupted(true);</span><br><span class="line">   &#x2F;&#x2F;内存屏障，使osthread的interrupted状态对其它线程立即可见</span><br><span class="line">    OrderAccess::fence();</span><br><span class="line">    &#x2F;&#x2F;前文说过，_SleepEvent用于Thread.sleep,线程调用了sleep方法，则通过unpark唤醒</span><br><span class="line">    ParkEvent * const slp &#x3D; thread-&gt;_SleepEvent ;</span><br><span class="line">    if (slp !&#x3D; NULL) slp-&gt;unpark() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;_parker用于concurrent相关的锁，此处同样通过unpark唤醒</span><br><span class="line">  if (thread-&gt;is_Java_thread())</span><br><span class="line">    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();</span><br><span class="line">  &#x2F;&#x2F;synchronized同步块和Object.wait() 唤醒</span><br><span class="line">  ParkEvent * ev &#x3D; thread-&gt;_ParkEvent ;</span><br><span class="line">  if (ev !&#x3D; NULL) ev-&gt;unpark() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，interrupt其实就是通过ParkEvent的unpark方法唤醒对象；</p>
<h2 id="3-2-isInterrupted-方法和interrupted-方法"><a href="#3-2-isInterrupted-方法和interrupted-方法" class="headerlink" title="3.2 isInterrupted()方法和interrupted()方法"></a>3.2 isInterrupted()方法和interrupted()方法</h2><ul>
<li>isInterrupted()只是判断自己是否已经被置上中断标志</li>
<li>interrupted()方法判断自己是否已经被置上中断标志。并且清除线程的中断状态</li>
</ul>
<p>接下来说一下”interrupted()”和”isInterrupted()”两个方法的相同点和不同点。在这之前看一下源码中两个方法的代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static boolean interrupted() &#123;</span><br><span class="line">    return currentThread().isInterrupted(true);</span><br><span class="line">&#125;</span><br><span class="line">public boolean isInterrupted() &#123;</span><br><span class="line">    return isInterrupted(false);</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;**</span><br><span class="line"> * Tests if some Thread has been interrupted.  The interrupted state</span><br><span class="line"> * is reset or not based on the value of ClearInterrupted that is</span><br><span class="line"> * passed.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private native boolean isInterrupted(boolean ClearInterrupted);</span><br></pre></td></tr></table></figure>


<p>相同点都是判断线程的interrupt status是否被设置，若被设置返回true,否则返回false.区别有两点：</p>
<ul>
<li>一：前者是static方法，调用者是current thread,而后者是普通方法，调用者是this current.</li>
<li>二：它们其实都调用了Java中的一个native方法isInterrupted(boolean ClearInterrupted); 不同的是前者传入了参数true,后者传入了false.</li>
<li>意义就是：前者将清除线程的interrupt state(®3),调用后者线程的interrupt state不受影响。</li>
</ul>
<h1 id="4-AbstractInterruptibleChannel类中的中断实现"><a href="#4-AbstractInterruptibleChannel类中的中断实现" class="headerlink" title="4 AbstractInterruptibleChannel类中的中断实现"></a>4 AbstractInterruptibleChannel类中的中断实现</h1><p>如果一个nio通道实现了InterruptibleChannel接口，就可以响应interrupt()中断，其原理就在InterruptibleChannel接口的抽象实现类AbstractInterruptibleChannel的方法begin()中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">protected final void begin() &#123;</span><br><span class="line">        if (interruptor &#x3D;&#x3D; null) &#123;</span><br><span class="line">            interruptor &#x3D; new Interruptible() &#123;</span><br><span class="line">                    public void interrupt(Thread target) &#123;</span><br><span class="line">                        synchronized (closeLock) &#123;</span><br><span class="line">                            if (!open)</span><br><span class="line">                                return;</span><br><span class="line">                            open &#x3D; false;</span><br><span class="line">                            interrupted &#x3D; target;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                AbstractInterruptibleChannel.this.implCloseChannel();</span><br><span class="line">                            &#125; catch (IOException x) &#123; &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        blockedOn(interruptor);&#x2F;&#x2F;设置当前线程的blocker为interruptor</span><br><span class="line">        Thread me &#x3D; Thread.currentThread();</span><br><span class="line">        if (me.isInterrupted())</span><br><span class="line">            interruptor.interrupt(me);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> protected final void end(boolean completed)</span><br><span class="line">        throws AsynchronousCloseException</span><br><span class="line">    &#123;</span><br><span class="line">        blockedOn(null);&#x2F;&#x2F;设置当前线程的blocker为null</span><br><span class="line">        Thread interrupted &#x3D; this.interrupted;</span><br><span class="line">       &#x2F;&#x2F;如果发生中断，Thread.interrupt方法会调用Interruptible的interrupt方法，</span><br><span class="line">      &#x2F;&#x2F;设置this.interrupted为当前线程</span><br><span class="line">        if (interrupted !&#x3D; null &amp;&amp; interrupted &#x3D;&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            interrupted &#x3D; null;</span><br><span class="line">            throw new ClosedByInterruptException();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!completed &amp;&amp; !open)</span><br><span class="line">            throw new AsynchronousCloseException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上述代码为例，nio通道的ReadableByteChannel每次执行阻塞方法read()前，都会执行begin()，把Interruptible回调接口注册到当前线程上。当线程中断时，Thread.interrupt()触发回调接口Interruptible关闭io通道,导致read方法返回，最后在finally块中执行end()方法检查中断标记，抛出ClosedByInterruptException;</p>
<h1 id="5-AbstractSelector类中的中断实现"><a href="#5-AbstractSelector类中的中断实现" class="headerlink" title="5 AbstractSelector类中的中断实现"></a>5 AbstractSelector类中的中断实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;java.nio.channels.spi.AbstractSelector</span><br><span class="line">	protected final void begin() &#123;</span><br><span class="line">	if (interruptor &#x3D;&#x3D; null) &#123;</span><br><span class="line">		interruptor &#x3D; new Interruptible() &#123;</span><br><span class="line">			public void interrupt(Thread ignore) &#123;</span><br><span class="line">				AbstractSelector.this.wakeup();</span><br><span class="line">		&#125;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	AbstractInterruptibleChannel.blockedOn(interruptor);</span><br><span class="line">	Thread me &#x3D; Thread.currentThread();</span><br><span class="line">	if (me.isInterrupted())</span><br><span class="line">		interruptor.interrupt(me);</span><br><span class="line">&#125;</span><br><span class="line">protected final void end() &#123;</span><br><span class="line">    AbstractInterruptibleChannel.blockedOn(null);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;sun.nio.ch.class EPollSelectorImpl</span><br><span class="line">protected int doSelect(long timeout) throws IOException &#123;</span><br><span class="line">	......</span><br><span class="line">	try &#123;</span><br><span class="line">		begin();</span><br><span class="line">		pollWrapper.poll(timeout);</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		end();</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-对于中断的处理"><a href="#6-对于中断的处理" class="headerlink" title="6 对于中断的处理"></a>6 对于中断的处理</h1><p>既然Java中断机制只是设置被中断线程的中断状态，那么被中断线程该做些什么？</p>
<h2 id="6-1-中断状态的管理"><a href="#6-1-中断状态的管理" class="headerlink" title="6.1 中断状态的管理"></a>6.1 中断状态的管理</h2><ul>
<li><p>一般说来，当可能阻塞的方法声明中有抛出InterruptedException则暗示该方法是可中断的，如BlockingQueue#put、BlockingQueue#take、Object#wait、Thread#sleep等，如果程序捕获到这些可中断的阻塞方法抛出的InterruptedException或检测到中断后，这些中断信息该如何处理？一般有以下两个通用原则：</p>
<ul>
<li>如果遇到的是可中断的阻塞方法抛出InterruptedException，可以继续向方法调用栈的上层抛出该异常</li>
<li>如果是检测到中断，则可清除中断状态并抛出InterruptedException，使当前方法也成为一个可中断的方法。</li>
</ul>
</li>
<li><p>若有时候不太方便在方法上抛出InterruptedException，比如要实现的某个接口中的方法签名上没有throws InterruptedException，这时就可以捕获可中断方法的InterruptedException并通过Thread.currentThread.interrupt()来重新设置中断状态。如果是检测并清除了中断状态，亦是如此。</p>
</li>
</ul>
<blockquote>
<p>一般的代码中，尤其是作为一个基础类库时，绝不应当吞掉中断（即捕获到InterruptedException后在catch里什么也不做，清除中断状态后又不重设中断状态也不抛出InterruptedException等）。因为吞掉中断状态会导致方法调用栈的上层得不到这些信息。    </p>
</blockquote>
<blockquote>
<p>当然，凡事总有例外的时候，当你完全清楚自己的方法会被谁调用，而调用者也不会因为中断被吞掉了而遇到麻烦，就可以这么做。</p>
</blockquote>
<ul>
<li>总得来说，就是要让方法调用栈的上层获知中断的发生。假设你写了一个类库，类库里有个方法amethod，在amethod中检测并清除了中断状态，而没有抛出InterruptedException，作为amethod的用户来说，他并不知道里面的细节，如果用户在调用amethod后也要使用中断来做些事情，那么在调用amethod之后他将永远也检测不到中断了，因为中断信息已经被amethod清除掉了。</li>
</ul>
<h2 id="6-2-中断的响应"><a href="#6-2-中断的响应" class="headerlink" title="6.2 中断的响应"></a>6.2 中断的响应</h2><ul>
<li>程序里发现中断后该怎么响应？这就得视实际情况而定了。有些程序可能一检测到中断就立马将线程终止，有些可能是退出当前执行的任务，继续执行下一个任务……作为一种协作机制，这要与中断方协商好，当调用interrupt会发生些什么都是事先知道的，如做一些事务回滚操作，一些清理工作，一些补偿操作等。若不确定调用某个线程的interrupt后该线程会做出什么样的响应，那就不应当中断该线程。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/dump%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E5%92%8C%E5%88%86%E6%9E%90%E6%9F%A5%E7%9C%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/27/dump%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E5%92%8C%E5%88%86%E6%9E%90%E6%9F%A5%E7%9C%8B/" itemprop="url">dump文件生成和分析查看</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-27T22:00:35+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%9B%91%E6%8E%A7%E5%92%8C%E8%B0%83%E4%BC%98/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA监控和调优</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/27/dump%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E5%92%8C%E5%88%86%E6%9E%90%E6%9F%A5%E7%9C%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/27/dump文件生成和分析查看/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  242
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1，生成dump文件："><a href="#1，生成dump文件：" class="headerlink" title="1，生成dump文件："></a>1，生成dump文件：</h1><h2 id="1-1手动生成dump文件："><a href="#1-1手动生成dump文件：" class="headerlink" title="1.1手动生成dump文件："></a>1.1手动生成dump文件：</h2><p>如图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/d37ad7e6f39429692bcb079452615f94195.jpg" alt=""></p>
<p>命令如下：</p>
<pre><code>ps -ef | grep list-app | grep -v grep

jmap -dump:file=test.hprof,format=b 3307</code></pre><h2 id="1-2自动生成dump文件："><a href="#1-2自动生成dump文件：" class="headerlink" title="1.2自动生成dump文件："></a>1.2自动生成dump文件：</h2><pre><code>1. -XX:+HeapDumpOnOutOfMemoryError 
当OutOfMemoryError发生时自动生成 Heap Dump 文件。

    这是一个非常有用的参数，因为当你需要分析Java内存使用情况时，往往是在OOM(OutOfMemoryError)发生时。

2. -XX:+HeapDumpBeforeFullGC 
当 JVM 执行 FullGC 前执行 dump。

3. -XX:+HeapDumpAfterFullGC 
当 JVM 执行 FullGC 后执行 dump。

4. -XX:+HeapDumpOnCtrlBreak 
交互式获取dump。在控制台按下快捷键Ctrl + Break时，JVM就会转存一下堆快照。

5. -XX:HeapDumpPath=d:\test.hprof 
指定 dump 文件存储路径。</code></pre><p>注意：JVM 生成 Heap Dump 的时候，虚拟机是暂停一切服务的。如果是线上系统执行 Heap Dump 时需要注意。</p>
<h1 id="2，查看dump文件"><a href="#2，查看dump文件" class="headerlink" title="2，查看dump文件"></a>2，查看dump文件</h1><p>推荐使用jdk自带的visualVM，其在JDK_HOME/bin目录下，可搜：jvisualvm。注意：windows系统是jvisualvm.exe文件。然后装入快照即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/23/JAVA%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/23/JAVA%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/" itemprop="url">JAVA并发之AQS详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-23T22:05:35+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA线程与并发控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/23/JAVA%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/23/JAVA并发之AQS详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  16.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  70
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础，许多实现都依赖其所提供的队列式同步器。</p>
<p>AQS的功能可以分为两类：独占锁和共享锁。它的所有子类中，要么实现并使用了它独占锁的API，要么使用了共享锁的API，而不会同时使用两套API，即便是它最有名的子类ReentrantReadWriteLock，也是通过两个内部类：读锁和写锁，分别实现的两套API来实现的，到目前为止，我们只需要明白AQS在功能上有独占锁和共享锁两种功能即可。</p>
<h2 id="1-1-如何使用AQS"><a href="#1-1-如何使用AQS" class="headerlink" title="1.1 如何使用AQS"></a>1.1 如何使用AQS</h2><p>AQS管理一个关于状态信息的单一整数，该整数可以表现任何状态。比如， Semaphore 用它来表现剩余的许可数，ReentrantLock 用它来表现拥有它的线程已经请求了多少次锁；FutureTask 用它来表现任务的状态(尚未开始、运行、完成和取消)。</p>
<p>AQS有众多方法，大致可以分为两类：</p>
<h3 id="1-1-1-需要子类实现的方法（模板方法）"><a href="#1-1-1-需要子类实现的方法（模板方法）" class="headerlink" title="1.1.1 需要子类实现的方法（模板方法）"></a>1.1.1 需要子类实现的方法（模板方法）</h3><ol>
<li><p>tryAcquire(int arg)：独占式的获取锁，返回值是boolean类型的，true代表获取锁，false代表获取失败。</p>
</li>
<li><p>tryRelease(int arg)：释放独占式同步状态，释放操作会唤醒其后继节点获取同步状态。</p>
</li>
<li><p>tryAcquireShared(int arg)：共享式的获取同步状态，返回大于0代表获取成功，否则就是获取失败。</p>
</li>
<li><p>tryReleaseShared(int arg)：共享式的释放同步状态。</p>
</li>
<li><p>isHeldExclusively()：判断当前的线程是否已经获取到了同步状态。</p>
</li>
</ol>
<p>这些方法是子类实现时可能实现的方法，通过上面的这些方法来判断是否获取了锁，然后再通过AQS本身的方法执行获取锁与未获取锁的过程。</p>
<p>以上方法不需要全部实现，根据获取的锁的种类可以选择实现不同的方法，支持独占(排他)获取锁的同步器应该实现tryAcquire、 tryRelease、isHeldExclusively而支持共享获取的同步器应该实现tryAcquireShared、tryReleaseShared。</p>
<h3 id="1-1-2-AQS本身的实现的方法"><a href="#1-1-2-AQS本身的实现的方法" class="headerlink" title="1.1.2 AQS本身的实现的方法"></a>1.1.2 AQS本身的实现的方法</h3><ol>
<li><p>acquire(int arg)/acquireInterruptibly(int arg)：独占式的获取锁操作，独占式获取同步状态都调用这个方法，通过子类实现的tryAcquire方法判断是否获取了锁。Interruptibly后缀的方法带有中断异常的签名，表示可以响应中断异常，无此后缀的acquire方法则通过重新标记中断状态的方式响应中断。</p>
</li>
<li><p>acquireShared(int arg)/acquireSharedInterruptibly：共享式的获取锁操作，在读写锁中用到，通过tryAcquireShared方法判断是否获取到了同步状态。Interruptibly后缀的方法带有中断异常的签名，表示可以响应中断异常，无此后缀的acquire方法则通过重新标记中断状态的方式响应中断。</p>
</li>
<li><p>release(int arg)：独占式的释放同步状态，通过tryRelease方法判断是否释放了独占式同步状态。</p>
</li>
<li><p>releaseShared(int arg)：共享式的释放同步状态，通过tryReleaseShared方法判断是否已经释放了共享同步状态。</p>
</li>
</ol>
<p>从这两类方法可以看出，AQS为子类定义了一套获取锁和释放锁以后的操作，而具体的如何判断是否获取锁和释放锁都是交由不同的子类自己去实现其中的逻辑，这也是Java设计模式之一：模板模式的实现。有了AQS我们就可以实现一个属于自己的Lock。</p>
<h1 id="2-源码分析（基于jdk1-8）"><a href="#2-源码分析（基于jdk1-8）" class="headerlink" title="2.源码分析（基于jdk1.8）"></a>2.源码分析（基于jdk1.8）</h1><h2 id="2-1-AQS类"><a href="#2-1-AQS类" class="headerlink" title="2.1 AQS类"></a>2.1 AQS类</h2><p>首先是类图↓</p>
<p><img src="https://oscimg.oschina.net/oscnet/a637d282fecd36584c7c7bfc6587911543e.jpg" alt=""></p>
<p>从图中可以看出来，AbstractQueuedSynchronizer内部维护了一个Node节点类和一个ConditionObject内部类。Node内部类是一个双向的FIFO队列，用来保存阻塞中的线程以及获取同步状态的线程，而ConditionObject对应的是后面要讲的Lock中的等待和通知机制。↓</p>
<p><img src="https://oscimg.oschina.net/oscnet/7e44fbc800913348d7e9c169e9c597b2fbc.jpg" alt=""></p>
<p>我们可以看到，AQS类是JUC框架的基石。为什么这么说？我们以ReentrantLock为例，ReentrantLock把所有Lock接口的操作都委派到一个自定义的内部类Sync类上，该类继承自AbstractQueuedSynchronizer。同时该类又有两个子类，NonfairSync 和 FairSync，实现非公平锁和公平锁。↓</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">公平锁：线程获取锁的顺序和调用lock的顺序一样，FIFO，先到先得；  </span><br><span class="line">非公平锁：线程获取锁的顺序和调用lock的顺序无关，全凭运气。</span><br></pre></td></tr></table></figure>

<p><img src="https://oscimg.oschina.net/oscnet/b0a383ed47e17b63787953d80e48673cee3.jpg" alt=""></p>
<p>同样的，CountDownLatch、Semaphore等其他类，也自定义了自己的Sync类和NonfairSync 和 FairSync，以达到功能的差异化。</p>
<h2 id="2-2-AQS的属性"><a href="#2-2-AQS的属性" class="headerlink" title="2.2 AQS的属性"></a>2.2 AQS的属性</h2><h3 id="2-2-1-状态位state"><a href="#2-2-1-状态位state" class="headerlink" title="2.2.1 状态位state"></a>2.2.1 状态位state</h3><p>AQS用的是一个32位的整型来表示同步状态的，它是用volatile修饰的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> * 在互斥锁中它表示着线程是否已经获取了锁，0未获取，1已经获取了，大于1表示重入数。</span></span><br><span class="line"><span class="comment"> * 同时AQS提供了getState()、setState()、compareAndSetState()方法来获取和修改该值：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-当前持有独占锁的线程"><a href="#2-2-2-当前持有独占锁的线程" class="headerlink" title="2.2.2 当前持有独占锁的线程"></a>2.2.2 当前持有独占锁的线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-获取锁的阻塞队列——CLH同步队列"><a href="#2-2-3-获取锁的阻塞队列——CLH同步队列" class="headerlink" title="2.2.3 获取锁的阻塞队列——CLH同步队列"></a>2.2.3 获取锁的阻塞队列——CLH同步队列</h3><h4 id="2-2-3-1-head和tail属性"><a href="#2-2-3-1-head和tail属性" class="headerlink" title="2.2.3.1 head和tail属性"></a>2.2.3.1 head和tail属性</h4><p>AQS内部维护着一个FIFO的CLH队列，用来保存阻塞中的线程以及获取同步状态的线程，每个node都封装着一个独立的线程，<strong>head指向的node可以简单理解为当前持有锁的线程</strong>，tail指向了等待队列的链尾。正因为head指向当前持有锁的线程，<strong>所以，真正的等待队列，不包括head</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">     * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">     * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">     * CANCELLED.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">     * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail</span><br></pre></td></tr></table></figure>

<p>因为是CLH队列，所以AQS并不支持基于优先级的同步策略。至于为何要选择CLH队列，主要在于CLH锁相对于MSC锁，他更加容易处理cancel和timeout，同时他进出队列快、检查是否有线程在等待也非常容易（head != tail,头尾指针不同）。<strong>当然相对于原始的CLH队列锁，ASQ采用的是一种变种的CLH队列锁</strong>：</p>
<ol>
<li><p>原始CLH使用的locked自旋，而AQS的CLH则是在每个node里面使用一个状态字段来控制阻塞，而不是自旋。</p>
</li>
<li><p>为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段。</p>
</li>
<li><p>head结点使用的是傀儡结点。虽然node对象（封装了线程）在获取到锁的时候，逻辑会将这个node置为head，看起来head表示的是当前正在拥有锁的node节点的意思。但看setHead方法就能知道，node赋值为head后，node封装的thread对象被清空，node成为一个空对象。</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/7215e10a01926df7cf7fb31927ab4388c52.jpg" alt=""></p>
<p>我们来看看这个队列结点的实现：</p>
<h4 id="2-2-3-2-node实现"><a href="#2-2-3-2-node实现" class="headerlink" title="2.2.3.2 node实现"></a>2.2.3.2 node实现</h4><p>我们来看看node的源码 ↓</p>
<p><img src="https://oscimg.oschina.net/oscnet/9ee0ef0255f8bf5d74e23cdb3f1134ad17b.jpg" alt=""></p>
<p>众多字段，我们一个一个来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**共享模式是允许多个线程可以获取同一个锁，而独占模式则一个锁只能被一个线程持有，其他线程必须要等待。**/</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>下面的几个int常量是给waitStatus字段使用的，表示节点现在的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**代表此线程取消了争抢这个锁</span></span><br><span class="line"><span class="comment">*场景：当该线程等待超时或者被中断，需要从同步队列中取消等待，则该线程被置1，即被取消（这里该线程在取消之前是等待状态）</span></span><br><span class="line"><span class="comment">*被取消状态的结点不应该去竞争锁，只能保持取消状态不变，不能转换为其他状态。处于这种状态的结点会被踢出队列</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate successor's thread needs unparking </span></span><br><span class="line"><span class="comment"> *  场景：后继的节点处于等待状态，当前节点的线程如果释放了同步状态或者被取消（当前节点状态置为-1），</span></span><br><span class="line"><span class="comment"> *  将会唤醒后继节点，使后继节点的线程得以运行；</span></span><br><span class="line"><span class="comment"> *  当一个节点的状态为SIGNAL时就意味着在等待获取同步状态</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition</span></span><br><span class="line"><span class="comment"> * 场景：节点处于等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，</span></span><br><span class="line"><span class="comment"> * 与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上</span></span><br><span class="line"><span class="comment"> * 当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> * 场景：表示下一次共享式同步状态获取将会被无条件的被传播下去（读写锁中存在的状态，代表后续还有资源，可以多个线程同时拥有同步状态）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>然后就是状态字段的主角了，上面的这些常量，都是给该字段赋值用的 ↓</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure>

<p>前面说过，在AQS中，我们维护了一个链表，故而node节点中，也定义了前后驱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment"> * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment"> * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment"> * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment"> * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment"> * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment"> * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment"> * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment"> * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment"> * 前驱节点，当节点加入同步队列的时候被设置（尾部添加）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment"> * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment"> * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment"> * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment"> * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment"> * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment"> * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment"> * to be null, we can scan prev's from the tail to</span></span><br><span class="line"><span class="comment"> * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment"> * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment"> * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment"> * 后继节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br></pre></td></tr></table></figure>

<p>当然，还有node节点的最重要主角：被封装的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment"> * construction and nulled out after use.</span></span><br><span class="line"><span class="comment"> * 节点封装的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br></pre></td></tr></table></figure>
<p>还有一个很特殊的后驱节点，这个后驱，负责维护node节点参与的第二个链表（第一个就是AQS的同步等待链表）——condition等待链表，至于什么是condition，我们最后再来讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment"> * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment"> * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment"> * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment"> * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment"> * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment"> * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment"> * mode.</span></span><br><span class="line"><span class="comment"> * 指向condition等待队列中的下一个节点，或特殊值SHARED。 </span></span><br><span class="line"><span class="comment"> * 因为condition等待队列只有在保持独占模式时才被访问，</span></span><br><span class="line"><span class="comment"> * 所以我们只需要一个简单的链表来在节点等待condition时保存节点。 </span></span><br><span class="line"><span class="comment"> * 然后将它们转移到队列中以重新获取。 并且因为条件只能是独占的，所以我们通过使用特殊值来指示共享模式来保存字段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// nextWaiter还有一个作用，是区别当前CLH队列是 ‘独占锁’队列 还是 ‘共享锁’队列 的标记</span></span><br><span class="line"> <span class="comment">// 若nextWaiter=SHARED，则CLH队列是“独占锁”队列；</span></span><br><span class="line"> <span class="comment">// 若nextWaiter=EXCLUSIVE，(即nextWaiter=null)，则CLH队列是“共享锁”队列。</span></span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>你可以把node节点简单看作 thread + waitStatus + pre + next 四个属性的封装，从本质上来说，这是没错的，node几乎所有的api也都服务于这四个属性。</p>
<h2 id="2-3-AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）"><a href="#2-3-AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）" class="headerlink" title="2.3 AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）"></a>2.3 AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）</h2><p><img src="https://oscimg.oschina.net/oscnet/6d8cc66f9760007e7cf8213087cf517d768.jpg" alt=""></p>
<p>从上图可以看到，AQS的<strong>实现有许多种</strong>，我们以最典型的在ReentrantLock类内部定义的公平锁FairSync和非公平锁NonFairSync为例，来探讨一下AQS<strong>独占模式</strong>的同步原理。（ReentrantLock是典型的独占锁，真正管理锁的也是其内部实现类FairSync或者NonFairSync）</p>
<p>独占锁是独占的，排他的，因此在独占锁中有一个exclusiveOwnerThread属性，用来记录当前持有锁的线程。</p>
<p>我们一般怎么使用ReentrantLock呢？很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">needLockFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 比如我们对下面这段逻辑加锁</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="comment">// 通常，lock 之后紧跟着 try 语句</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span></span><br><span class="line">            <span class="comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们可以从lock方法看起</p>
<h3 id="2-3-1-公平锁的加锁逻辑"><a href="#2-3-1-公平锁的加锁逻辑" class="headerlink" title="2.3.1 公平锁的加锁逻辑"></a>2.3.1 公平锁的加锁逻辑</h3><p>reentrantLock的lock方法调用的是reentrantLock内部的sync字段的lock方法，sync字段在reentrantLock的构造方法中就开始初始化默认是非公平锁：</p>
<blockquote>
<p>ReentrantLock默认使用非公平锁是基于性能考虑，公平锁为了保证线程规规矩矩地排队，需要增加阻塞和唤醒的时间开销。如果直接插队获取非公平锁，跳过了对队列的处理，速度会更快</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-1-FairSync-lock"><a href="#2-3-1-1-FairSync-lock" class="headerlink" title="2.3.1.1 FairSync.lock()"></a>2.3.1.1 FairSync.lock()</h4><p>我们来看看FairSync的lock()，很简单直接调用了acquire(); ↓</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-2-AQS-acquire"><a href="#2-3-1-2-AQS-acquire" class="headerlink" title="2.3.1.2 AQS.acquire()"></a>2.3.1.2 AQS.acquire()</h4><p>所以lock()的重点都在acquire()，FairSync调用了AQS类中实现的acquire();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span><br><span class="line"> * by invoking at least once &#123;@link #tryAcquire&#125;,</span><br><span class="line"> * returning on success.  Otherwise the thread is queued, possibly</span><br><span class="line"> * repeatedly blocking and unblocking, invoking &#123;@link</span><br><span class="line"> * #tryAcquire&#125; until success.  This method can be used</span><br><span class="line"> * to implement method &#123;@link Lock#lock&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param arg the acquire argument.  This value is conveyed to</span><br><span class="line"> *        &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and</span><br><span class="line"> *        can represent anything you like.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final void acquire(int arg) &#123;&#x2F;&#x2F;记住此时arg&#x3D;1</span><br><span class="line">    &#x2F;&#x2F;我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。方法return，逻辑继续执行。</span><br><span class="line">    &#x2F;&#x2F; 否则，acquireQueued方法会将当前线程压到队列中，阻塞在里面</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;首先执行tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br><span class="line">    &#x2F;&#x2F; 因为有可能直接就成功了呢，也就不需要进队列排队了。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        &#x2F;&#x2F; tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        &#x2F;&#x2F;该方法就是调用：Thread.currentThread().interrupt();中断当前线程</span><br><span class="line">        &#x2F;&#x2F;之所以有这个逻辑，是因为acquire方法没有中断异常的签名，</span><br><span class="line">        &#x2F;&#x2F;所以为了外层能继续响应中断，需要感应到acquireQueued内的中断，并在这里重新设置中断状态</span><br><span class="line">        &#x2F;&#x2F;可抛出中断异常的acquire方法为acquireInterruptibly(),除了中断处理不同以外，其他实现与acquire大同小异。</span><br><span class="line">        &#x2F;&#x2F;同理，其他带有Interruptibly后缀的方法，都是原方法的中断模式实现。</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一句话总结，AbstractQueuedSynchronizer.acquire()方法的作用是：先尝试获取锁，若成功则不用进队列阻塞，逻辑往下走（其实就是返回了）。否则封装当前线程为node，塞进队列，然后在acquireQueued方法中一直尝试，先期会自旋，如果在自旋期间内获得锁了，那么返回，返回结果是false，表示不需要调用selfInterrupt()做自我中断。如果是阻塞后才获取锁，返回，返回结果是true，表示要设置自我中断。（只是设置中断状态，至于到底何时中断，由线程本身决定）</p>
</blockquote>
<hr>
<h4 id="2-3-1-3-FairSync-tryAcquire"><a href="#2-3-1-3-FairSync-tryAcquire" class="headerlink" title="2.3.1.3 FairSync.tryAcquire()"></a>2.3.1.3 FairSync.tryAcquire()</h4><p>AQS类中实现的acquire()又调用了FairSync中实现的tryAcquire(1)，我们来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">        * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line">       <span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="comment">//获取AQS的状态，我们之前说过，0未加锁，1已经加锁了，大于1表示重入数。</span></span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="comment">//如果AQS未加锁</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">               <span class="comment">// 看看有没有别人在队列中等了半天了，没有才改变状态</span></span><br><span class="line">               <span class="comment">//hasQueuedPredecessors()根据 当前线程是否是等待队列的第一个 来判断是否有等待更久的节点。</span></span><br><span class="line">               <span class="comment">//记住，我们说过，等待队列不包括头结点head</span></span><br><span class="line">               <span class="comment">//所以hasQueuedPredecessors判断的是当前线程是否为head的后驱next</span></span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   <span class="comment">//执行到这里，意味着队列中没有更老的节点，那么CAS置换状态为1或者大于1（重入时大于1）</span></span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   <span class="comment">//设置拥有独占锁的线程是当前线程</span></span><br><span class="line">	    <span class="comment">//代码就一行，exclusiveOwnerThread = thread;</span></span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">				<span class="comment">//获取到锁</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//否则，说明AQS是被持有锁的状态，先判断持有锁的是不是自己</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">	<span class="comment">//如果是自己，那么说明自己重入了，status+1</span></span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="comment">//nextc只有在重入次数超过int值上限，导致溢出为负时才会达到，报错超过最大锁计数</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">			<span class="comment">//获取到锁</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//上述逻辑都不满足，未获取到锁</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一句话总结，FairSync.tryAcquire()方法的作用是：如果未加锁，那么判断自己是不是队列的头名，若是，设置独占锁线程，获得锁。否则，判断加锁的人是不是自己，如果是，那么重入，status+1，设置独占锁线程，获得锁。再否则，返回false，占锁失败。</p>
</blockquote>
<hr>
<h4 id="2-3-1-2-AQS-addWaiter"><a href="#2-3-1-2-AQS-addWaiter" class="headerlink" title="2.3.1.2 AQS.addWaiter()"></a>2.3.1.2 AQS.addWaiter()</h4><p>看完了tryAcquire方法，我们知道在acquire方法中，如果tryAcquire方法返回false，即没有获取到锁，那么将会执行addWaiter，将当前线程封装为node，addWaiter()是AbstractQueuedSynchronizer的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Creates and enqueues node for current thread and given mode.</span><br><span class="line"> *</span><br><span class="line"> * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="line"> * @return the new node</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;mode值有Node.EXCLUSIVE 和Node.SHARED，表示封装为独占模式还是分享模式</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    &#x2F;&#x2F;先使用快速入列法来尝试一下,如果失败,则进行更加完备的入列算法.</span><br><span class="line">    &#x2F;&#x2F;只有在必要的情况下才会使用更加复杂耗时的算法，也就是乐观的态度</span><br><span class="line">    Node pred &#x3D; tail;&#x2F;&#x2F;tail为队尾指针</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;进行入列操作</span><br><span class="line">        node.prev &#x3D; pred;&#x2F;&#x2F;该节点的前趋指针指向tail</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;&#x2F;&#x2F;cas将尾指针指向该节点</span><br><span class="line">            pred.next &#x3D; node;&#x2F;&#x2F;如果成果,让旧列尾节点的next指针指向该节点</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;cas失败,或在pred &#x3D;&#x3D; null时调用enq</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123; &#x2F;&#x2F;cas无锁算法的标准for循环,不停的尝试，直到成功入队</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;t &#x3D;&#x3D; null为真的话，说明队列为空，要初始化一个空队列，即只存在一个哨兵node的队列</span><br><span class="line">            &#x2F;&#x2F;还是那句话，head是一个哨兵的作用，并不代表某个要获取锁的线程节点，所以并没有将node赋给head</span><br><span class="line">            &#x2F;&#x2F;而是new了一个无关紧要的新node</span><br><span class="line">            &#x2F;&#x2F;compareAndSetHead方法，用cas，期望head为null时将其更新为new Node()</span><br><span class="line">            if (compareAndSetHead(new Node())) </span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">           &#x2F;&#x2F;注意，这里没有return，执行完后，还是要继续for循环，下一次，必定走else逻辑。</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;和addWaiter中一致，不过有了外侧的无限循环，不停的尝试，相当于自旋锁</span><br><span class="line">            &#x2F;&#x2F;将node的前驱改为原来的队尾node</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            &#x2F;&#x2F;新创建的节点指向队列尾节点，毫无疑问并发情况下这里会有多个新创建的节点指向队列尾节点</span><br><span class="line">            &#x2F;&#x2F;基于这一步的CAS，不管前一步有多少新节点都指向了尾节点，这一步只有一个能真正入队成功</span><br><span class="line">            &#x2F;&#x2F;其他的都必须重新执行循环体</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;&#x2F;&#x2F;改变队尾指针的值</span><br><span class="line">                t.next &#x3D; node;&#x2F;&#x2F;原本的队尾的后驱设为node</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，AbstractQueuedSynchronizer.addWaiter()方法的作用是将当前线程封装为node，并将node节点塞入等待队列，塞入逻辑包括节点前后驱，head和tail指针的维护，以及必要时对空列表的初始化。然后返回封装好的node。</p>
</blockquote>
<hr>
<h4 id="2-3-1-3-AQS-acquireQueued"><a href="#2-3-1-3-AQS-acquireQueued" class="headerlink" title="2.3.1.3 AQS.acquireQueued()"></a>2.3.1.3 AQS.acquireQueued()</h4><p>回到acquire方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           &#x2F;&#x2F; tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           &#x2F;&#x2F;该方法就是调用：Thread.currentThread().interrupt();中断当前线程</span><br><span class="line">           selfInterrupt();</span><br></pre></td></tr></table></figure>
<p>addWaiter()将当前线程封装为node，紧接着，执行的是AbstractQueuedSynchronizer.acquireQueued()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Acquires in exclusive uninterruptible mode for thread already in</span><br><span class="line">  * queue. Used by condition wait methods as well as acquire.</span><br><span class="line">  *</span><br><span class="line">  * @param node the node</span><br><span class="line">  * @param arg the acquire argument</span><br><span class="line">  * @return &#123;@code true&#125; if interrupted while waiting</span><br><span class="line">  *&#x2F;</span><br><span class="line"> final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">     boolean failed &#x3D; true;</span><br><span class="line">     try &#123;</span><br><span class="line">         boolean interrupted &#x3D; false;</span><br><span class="line">         &#x2F;&#x2F;不会一直自旋，如果判断还没轮到自己，那么线程会阻塞在这个for循环中的parkAndCheckInterrupt里面</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">             final Node p &#x3D; node.predecessor();</span><br><span class="line">             &#x2F;&#x2F;node的前驱p是head，就说明，node是将要获取锁的下一个节点.</span><br><span class="line">             if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;&#x2F;&#x2F;所以再次尝试获取锁</span><br><span class="line">                 setHead(node);&#x2F;&#x2F;如果成功，那么就将自己设置为head，前文说过，node会被置为傀儡，然后赋给head</span><br><span class="line">                 p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                 failed &#x3D; false;</span><br><span class="line">                 return interrupted;</span><br><span class="line">             &#x2F;&#x2F;此时，还没有进入阻塞状态，所以直接返回false，表示不需要中断调用后面的selfInterrupt函数</span><br><span class="line">             &#x2F;&#x2F;此时方法返回后，在acquire方法内也走完了所有逻辑，acquire方法返回，执行lock操作后的业务逻辑。</span><br><span class="line">             &#125;</span><br><span class="line">             &#x2F;&#x2F;判断是否要进入阻塞状态。</span><br><span class="line">             &#x2F;&#x2F;如果shouldParkAfterFailedAcquire返回true，表示需要进入阻塞，则调用parkAndCheckInterrupt，进行阻塞；</span><br><span class="line">             &#x2F;&#x2F;否则表示还可以再次尝试获取锁，继续进行for循环</span><br><span class="line">             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                 parkAndCheckInterrupt())</span><br><span class="line">                 interrupted &#x3D; true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         if (failed)</span><br><span class="line">             cancelAcquire(node);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL) &#x2F;&#x2F;前一个节点在等待锁释放的通知，所以还没那么快轮到自己，当前节点可以阻塞</span><br><span class="line">        return true;</span><br><span class="line">    &#x2F;&#x2F;static final int CANCELLED &#x3D;  1;节点状态中，只有CANCELLED大于0</span><br><span class="line">    &#x2F;&#x2F;前一个节点处于取消获取锁的状态，所以，可以跳过去</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;前驱的前驱变为自己的前驱，即前驱在链表中被剔除了。</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">          &#x2F;&#x2F;如果前驱都是取消，那么一直剔除。</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;将上一个节点的状态设置为signal，返回false。</span><br><span class="line">        &#x2F;&#x2F;但因为前驱被置为SIGNAL，外面的for循环下一次获取还失败后，该node也会返回true了。</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this); &#x2F;&#x2F;将AQS对象自己传入</span><br><span class="line">    &#x2F;&#x2F;LockSupport.park()也能响应中断信号，但是跟Thread.sleep()之类不同的是它不会抛出InterruptedException</span><br><span class="line">    &#x2F;&#x2F;那怎么知道线程是被unpark还是被中断的呢，根据线程的interrupted status。</span><br><span class="line">    &#x2F;&#x2F;如果线程是被中断退出阻塞的那么该值被设置为true，通过Thread的interrupted和isInterrupted方法都能获取该值，不再赘述。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;线程waiting在park方法中，这个返回，肯定是线程被唤醒后才会执行</span><br><span class="line">    &#x2F;&#x2F;此时它表示的意思为：在waiting中时，是否是被中断唤醒了。如果是unpark，那么Thread.interrupted()为false。中断唤醒才为true；</span><br><span class="line">    &#x2F;&#x2F;我们知道处理中断时最好不要将其吃掉，要么抛出新的中断异常，要么重新设置interrupted status</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;结合上文，我们知道这里如果返回true，那么外面acquireQueued方法在获取到锁的时候也会返回interrupted &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;表示是中断唤醒的，届时acquireQueued方法会调用selfInterrupt();</span><br><span class="line">    &#x2F;&#x2F;selfInterrupt()方法其实就是调用：Thread.currentThread().interrupt();中断当前线程</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);&#x2F;&#x2F;设置阻塞对象，用来记录线程被谁阻塞的，用于线程监控和分析工具来定位</span><br><span class="line">    UNSAFE.park(false, 0L);&#x2F;&#x2F;让当前线程不再被线程调度，就是当前线程不再执行.</span><br><span class="line">    setBlocker(t, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们回到acquireQueued方法的最后一步，finally模块。这里是针对锁资源获取失败以后做的一些善后工作，翻看上面的代码，其实能进入这里的就是tryAcquire()方法抛出异常，也就是说AQS框架针对开发人员自己实现的获取锁操作如果抛出异常，也做了妥善的处理，一起来看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传入的方法参数是当前获取锁资源失败的节点</span><br><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果节点不存在则直接忽略</span><br><span class="line">        if (node &#x3D;&#x3D; null)</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        node.thread &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 跳过所有已经取消的前置节点，跟上面的那段跳转逻辑类似</span><br><span class="line">        Node pred &#x3D; node.prev;</span><br><span class="line">        while (pred.waitStatus &gt; 0)</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#x2F;&#x2F;这个是前置节点的后继节点，由于上面可能的跳节点的操作，所以这里可不一定就是当前节点</span><br><span class="line">        Node predNext &#x3D; pred.next;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;把当前节点waitStatus置为取消，这样别的节点在处理时就会跳过该节点</span><br><span class="line">        node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">        &#x2F;&#x2F;如果当前是尾节点，则直接删除，即出队</span><br><span class="line">        &#x2F;&#x2F;注：这里不用关心CAS失败，因为即使并发导致失败，该节点也已经被成功删除</span><br><span class="line">        if (node &#x3D;&#x3D; tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">            compareAndSetNext(pred, predNext, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int ws;</span><br><span class="line">            if (pred !&#x3D; head &amp;&amp;</span><br><span class="line">                ((ws &#x3D; pred.waitStatus) &#x3D;&#x3D; Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;&#x3D; 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread !&#x3D; null) &#123;</span><br><span class="line">                Node next &#x3D; node.next;</span><br><span class="line">                if (next !&#x3D; null &amp;&amp; next.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                    &#x2F;&#x2F;这里的判断逻辑很绕，具体就是如果当前节点的前置节点不是头节点且它后面的节点等待它唤醒（waitStatus小于0）</span><br><span class="line">                    &#x2F;&#x2F;再加上如果当前节点的后继节点没有被取消就把前置节点跟后置节点进行连接，相当于删除了当前节点</span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;进入这里，要么当前节点的前置节点是头结点，要么前置节点的waitStatus是PROPAGATE，直接唤醒当前节点的后继节点</span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next &#x3D; node; &#x2F;&#x2F; help GC</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，AbstractQueuedSynchronizer.acquireQueued()方法会一直循环来尝试获取锁，当并非一直自旋，而是会在每一次循环判断是否要进入阻塞，如果通过判断前置节点状态得知无法很快得到锁（这其中会将cancel状态的node踢出队列），那么该node会进入阻塞。<br>阻塞被唤醒后，如果是中断唤醒的，那么会将这个中断唤醒的标记往外层传，并在次尝试获取锁，如果还是失败，继续进入上述判断阻塞逻辑。直到获取到锁。<br>同时，如果tryAcquire()方法抛出异常，也会有体面的退出逻辑。</p>
</blockquote>
<h3 id="2-3-2-非公平锁的加锁逻辑"><a href="#2-3-2-非公平锁的加锁逻辑" class="headerlink" title="2.3.2 非公平锁的加锁逻辑"></a>2.3.2 非公平锁的加锁逻辑</h3><h4 id="2-3-2-1-NonFairSync-lock"><a href="#2-3-2-1-NonFairSync-lock" class="headerlink" title="2.3.2.1 NonFairSync.lock()"></a>2.3.2.1 NonFairSync.lock()</h4><p>再来看看NonFairSync的lock(); </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line"> * acquire on failure.</span><br><span class="line"> *&#x2F;</span><br><span class="line">final void lock() &#123;&#x2F;&#x2F;不管三七二十一，先尝试获取一次锁</span><br><span class="line">    &#x2F;&#x2F;CAS,成功了就设置拥有独占锁的线程是当前线程</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-2-AQS-acquire"><a href="#2-3-2-2-AQS-acquire" class="headerlink" title="2.3.2.2 AQS.acquire()"></a>2.3.2.2 AQS.acquire()</h4><p>调用AQS.acquire()方法，前文已说过，不再赘述。可通过侧边导航快速回看。</p>
<h4 id="2-3-2-3-NonFairSync-nonfairTryAcquire"><a href="#2-3-2-3-NonFairSync-nonfairTryAcquire" class="headerlink" title="2.3.2.3 NonFairSync.nonfairTryAcquire()"></a>2.3.2.3 NonFairSync.nonfairTryAcquire()</h4><p>AQS.acquire()中重要的tryAcquire方法，非公平锁定义了自己的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">	return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line"> * subclasses, but both need nonfair try for trylock method.</span><br><span class="line"> *&#x2F;</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    &#x2F;&#x2F;和公平锁一样，获取AQS的状态，我们之前说过，0未加锁，1已经加锁了，大于1表示重入数。</span><br><span class="line">    &#x2F;&#x2F;如果AQS未加锁</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;注意，这里和公平锁的区别来了，还记得公平锁中这里的实现么？</span><br><span class="line">        &#x2F;&#x2F;公平锁中，如果AQS未加锁，逻辑即便到了这里，也会调用hasQueuedPredecessors()来判断等待线程是否有等了更久的node</span><br><span class="line">        &#x2F;&#x2F;但是非公平锁不管，我到了这里是我本事，本身不讲究公平，直接CAS设置锁状态，抢锁</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;否则，说明AQS是被持有锁的状态，先判断持有锁的是不是自己</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是自己，那么说明自己重入了，status+1，同样的，如果int值溢出，抛异常</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;上述逻辑都不满足，未获取到锁</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，NonFairSync.nonfairTryAcquire方法的作用是：如果未加锁，那么直接抢锁，而不是像公平锁一样去检查是否轮到自己。若AQS已经上锁，判断加锁的人是不是自己，如果是，那么重入，status+1，设置独占锁线程，获得锁。再否则，返回false，占锁失败。</p>
</blockquote>
<p><strong>剩下的加锁逻辑，则完全和公平锁没有区别了，因为实际都是调用的AQS的addWaiter()和acquireQueued()方法，不再赘述。</strong></p>
<h3 id="2-3-3-释放锁逻辑"><a href="#2-3-3-释放锁逻辑" class="headerlink" title="2.3.3 释放锁逻辑"></a>2.3.3 释放锁逻辑</h3><p>释放锁的逻辑，公平锁和非公平锁没有区别，本质都是调用的AQS.release()方法和Sync.tryRelease()方法</p>
<h4 id="2-3-3-1-ReentrantLock-unlock"><a href="#2-3-3-1-ReentrantLock-unlock" class="headerlink" title="2.3.3.1 ReentrantLock.unlock()"></a>2.3.3.1 ReentrantLock.unlock()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-2-AQS-release"><a href="#2-3-3-2-AQS-release" class="headerlink" title="2.3.3.2 AQS.release()"></a>2.3.3.2 AQS.release()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;&#x2F;&#x2F;release就是先调用tryRelease来释放独占性变量。</span><br><span class="line">        &#x2F;&#x2F;释放独占性变量,起始就是将status的值减1,因为acquire时是加1</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)&#x2F;&#x2F;是否有等待锁的阻塞线程，0为waitStatus的初始值，表示未赋值任何状态</span><br><span class="line">            unparkSuccessor(h);&#x2F;&#x2F;唤醒head的后继节点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-3-AQS-tryRelease"><a href="#2-3-3-3-AQS-tryRelease" class="headerlink" title="2.3.3.3 AQS.tryRelease()"></a>2.3.3.3 AQS.tryRelease()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F;由于只有一个线程可以获得独占先变量，也只有这个线程才能有效调用unlock，所以所有操作不需要考虑多线程</span><br><span class="line">    int c &#x3D; getState() - releases;&#x2F;&#x2F;对于重入场景，重入数-1，非重入场景，解锁。</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        &#x2F;&#x2F;如果不是持有独占锁的线程执行unlock，抛出异常。</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;如果等于0,那么说明锁应该被释放了，否则表示当前线程有重入操作，该次解锁只是一次重入的释放</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-4-AQS-unparkSuccessor"><a href="#2-3-3-4-AQS-unparkSuccessor" class="headerlink" title="2.3.3.4 AQS.unparkSuccessor()"></a>2.3.3.4 AQS.unparkSuccessor()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">	&#x2F;&#x2F;注意这里的node是AQS.release()中塞进来的head节点</span><br><span class="line">	int ws &#x3D; node.waitStatus;</span><br><span class="line">	if (ws &lt; 0)&#x2F;&#x2F;head的状态为非取消</span><br><span class="line">		compareAndSetWaitStatus(node, ws, 0);&#x2F;&#x2F;将head的waitStatus置为0，即没有任何有实质意思的状态</span><br><span class="line">		</span><br><span class="line">	 &#x2F;&#x2F;一般来说,需要唤醒的线程就是head的下一个节点，但是如果它获取锁的操作被取消,或在节点为null时</span><br><span class="line">	 &#x2F;&#x2F;就直接继续往后遍历，找到第一个未取消的后继节点.</span><br><span class="line">	Node s &#x3D; node.next;</span><br><span class="line">	if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">		s &#x3D; null;</span><br><span class="line">		for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">			if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">				s &#x3D; t;</span><br><span class="line">	&#125;</span><br><span class="line">	if (s !&#x3D; null)</span><br><span class="line">		LockSupport.unpark(s.thread);&#x2F;&#x2F;将对应节点唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了unpark方法后，进行lock操作被阻塞的线程就恢复到运行状态,就会再次执行acquireQueued中的无限for循环中的操作，再次尝试获取锁。</p>
<h2 id="2-4-AQS的共享锁实现（以Semaphore为例）"><a href="#2-4-AQS的共享锁实现（以Semaphore为例）" class="headerlink" title="2.4 AQS的共享锁实现（以Semaphore为例）"></a>2.4 AQS的共享锁实现（以Semaphore为例）</h2><p>前面我们学习了AQS独占锁的逻辑，对于独占锁而言，锁只能被一个线程独占持有，而对于共享锁而言，由于锁是可以被共享的，因此它可以被多个线程同时持有。</p>
<p>AQS的共享锁应用于Semaphore、ReentrantReadWriteLock等实现中，本次我们以Semaphore为例来剖析一下AQS的共享锁</p>
<p>共享锁的实现和独占锁是对应的，我们可以从下面这张表中看出</p>
<table>
<thead>
<tr>
<th align="left">独占锁</th>
<th align="left">共享锁</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tryAcquire(int arg)</td>
<td align="left">tryAcquireShared(int arg)</td>
</tr>
<tr>
<td align="left">tryAcquireNanos(int arg, long nanosTimeout)</td>
<td align="left">tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
</tr>
<tr>
<td align="left">acquire(int arg)</td>
<td align="left">acquireShared(int arg)</td>
</tr>
<tr>
<td align="left">acquireQueued(final Node node, int arg)</td>
<td align="left">doAcquireShared(int arg)</td>
</tr>
<tr>
<td align="left">acquireInterruptibly(int arg)</td>
<td align="left">acquireSharedInterruptibly(int arg)</td>
</tr>
<tr>
<td align="left">doAcquireInterruptibly(int arg)</td>
<td align="left">doAcquireSharedInterruptibly(int arg)</td>
</tr>
<tr>
<td align="left">doAcquireNanos(int arg, long nanosTimeout)</td>
<td align="left">doAcquireSharedNanos(int arg, long nanosTimeout)</td>
</tr>
<tr>
<td align="left">release(int arg)</td>
<td align="left">releaseShared(int arg)</td>
</tr>
<tr>
<td align="left">tryRelease(int arg)</td>
<td align="left">tryReleaseShared(int arg)</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">doReleaseShared()</td>
</tr>
<tr>
<td align="left">除了最后一个属于共享锁的doReleaseShared()方法没有对应外，其他的方法，独占锁和共享锁都是一一对应的。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="2-4-1-Semaphore"><a href="#2-4-1-Semaphore" class="headerlink" title="2.4.1 Semaphore"></a>2.4.1 Semaphore</h3><p>在解析之前，我们先来了解一下Semaphore是什么。</p>
<blockquote>
<p>Semaphore也叫信号量，在JDK1.5被引入，用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。</p>
</blockquote>
<p>打个比喻，Semaphore就像一道阀门，可以控制同时进入某一逻辑的线程数量（构造方法中指定），我们使用acquire方法来争取通行票，使用release方法来归还通行票。通行票只是一个比喻，一般我们称之为许可。</p>
<ul>
<li>Semaphore内部维护了一组虚拟的许可，许可的数量可以通过构造函数的参数指定。<ul>
<li><code>public Semaphore(int permits) {
  sync = new NonfairSync(permits);
}</code></li>
</ul>
</li>
<li>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。</li>
<li>访问资源后，使用release释放许可。</li>
<li>Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。<ul>
<li><code>public Semaphore(int permits, boolean fair) {
  sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}</code></li>
</ul>
</li>
<li>当初始值为1时，可以用作互斥锁，并具备不可重入的加锁语义。</li>
<li>Semaphore将AQS的同步状态（status字段）用于保存当前可用许可的数量。</li>
</ul>
<p>我们调用Semaphore方法时，其实是在间接调用其内部类或AQS方法执行的。Semaphore类结构与ReetrantLock类相似，内部类Sync继承自AQS，然后其子类FairSync和NoFairSync分别实现公平锁和非公平锁的获取锁方法tryAcquireShared(int arg)，而释放锁的tryReleaseShared(int arg)方法则有Sync类实现，因为非公平或公平锁的释放过程都是相同的。</p>
<h3 id="2-4-2-Semaphore公平锁争锁逻辑"><a href="#2-4-2-Semaphore公平锁争锁逻辑" class="headerlink" title="2.4.2 Semaphore公平锁争锁逻辑"></a>2.4.2 Semaphore公平锁争锁逻辑</h3><p>不论是公平锁还是非公平锁，Semaphore使用acquire()方法来争锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquireSharedInterruptibly方法，<strong>是定义在AQS中的</strong>，它可以响应中断异常，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())&#x2F;&#x2F;如果当前线程被中断，抛出中断异常。</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;尝试获取共享锁，返回值小于0表示获取失败</span><br><span class="line">        doAcquireSharedInterruptibly(arg);&#x2F;&#x2F;未获取成功则加入同步队列等待</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-4-2-1-Semaphore-FairSync-tryAcquireShared"><a href="#2-4-2-1-Semaphore-FairSync-tryAcquireShared" class="headerlink" title="2.4.2.1 Semaphore.FairSync.tryAcquireShared"></a>2.4.2.1 Semaphore.FairSync.tryAcquireShared</h4><p>我们知道AQS中，try开头的几个方法都是模板方法，需要各个实现自己重写，Semaphore的公平锁实现类FairSync同样实现了自己的tryAcquireShared</p>
<p>tryAcquire的返回值是个boolean类型，表示是否成功获取到了锁，而tryAcquireShared的返回值是一个int类型，这表示tryAcquireShared的返回含义绝不止是或者否这么简单，它的返回有三种情况：</p>
<ul>
<li>小于0 ： 表示获取锁失败，需要进入等待队列。</li>
<li>等于0 ： 表示当前线程获取共享锁成功，但它后续的线程是无法继续获取的。</li>
<li>大于0 ： 表示当前线程获取共享锁成功且它后续等待的节点也有可能继续获取共享锁成功。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;&#x2F;&#x2F;一直执行，直到要么失败，要么成功</span><br><span class="line">        &#x2F;&#x2F;hasQueuedPredecessors我们在上文见过了，它实现在AQS中</span><br><span class="line">        &#x2F;&#x2F;根据 当前线程是否是等待队列的第一个 来判断是否有等待更久的节点。</span><br><span class="line">        &#x2F;&#x2F;因为是公平锁，所以要先判断先来后到</span><br><span class="line">        if (hasQueuedPredecessors())</span><br><span class="line">            return -1;&#x2F;&#x2F;还没轮到你，所以获取锁失败，需要进入等待队列</span><br><span class="line">        int available &#x3D; getState();&#x2F;&#x2F;Semaphore的status表示许可总数量</span><br><span class="line">        int remaining &#x3D; available - acquires;&#x2F;&#x2F;总数量-索取量</span><br><span class="line">        &#x2F;&#x2F;如果索取量超过剩余量，返回的是小于0，表示获取许可失败。</span><br><span class="line">        &#x2F;&#x2F;如果CAS成功，表示获取许可成功，那么返回剩余量。</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，FairSync.tryAcquireShared方法的作用是：重复判断是否轮到自己来获取许可了，如果不是，返回获取失败。否则检查剩余量，若许可的剩余量满足索取量，那么CAS获取许可，返回索取后的剩余量。</p>
</blockquote>
<h4 id="2-4-2-2-AQS-doAcquireSharedInterruptibly"><a href="#2-4-2-2-AQS-doAcquireSharedInterruptibly" class="headerlink" title="2.4.2.2 AQS.doAcquireSharedInterruptibly()"></a>2.4.2.2 AQS.doAcquireSharedInterruptibly()</h4><p>acquireSharedInterruptibly中，如果tryAcquireShared获取许可失败，那么逻辑就进入了doAcquireSharedInterruptibly方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Acquires in shared interruptible mode.</span><br><span class="line"> * @param arg the acquire argument</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F;以共享模式调用addWaiter封装一个node，</span><br><span class="line">    &#x2F;&#x2F;addWaiter前文已分析，具体可见右侧导航栏跳转2.3.1.2 AQS.addWaiter()</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;&#x2F;&#x2F;重复执行</span><br><span class="line">            &#x2F;&#x2F;获取node的前驱</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;&#x2F;&#x2F;前驱如果是head，表示自己已经在队首</span><br><span class="line">            &#x2F;&#x2F;tryAcquireShared再尝试一次</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F;这里是重点，获取到锁以后的唤醒操作，后面详细说</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;&#x2F;&#x2F;获取许可成功</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;自己不在队首，或者取锁失败，调用AQS.shouldParkAfterFailedAcquire判断是否需要阻塞，</span><br><span class="line">            &#x2F;&#x2F;若需要则调用parkAndCheckInterrupt，进行阻塞；</span><br><span class="line">            &#x2F;&#x2F;否则表示还可以再次尝试获取锁，继续进行for循环</span><br><span class="line">            &#x2F;&#x2F;这两个方法前文都已分析，具体可见右侧导航栏跳转2.3.1.3 AQS.acquireQueued()</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                &#x2F;&#x2F;注意，非Interruptibly后缀的方法，在进入这里的时候是将它们定义的interrupted设为true;</span><br><span class="line">                &#x2F;&#x2F;而Interruptibly后缀的方法则不需要向外传递中断状态，直接抛出中断异常即可</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            &#x2F;&#x2F;cancelAcquire方法前文也已分析，体面的退出获取。只有报异常才会来到这里。</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一句话总结，AQS.doAcquireSharedInterruptibly方法的作用是：调用addWaiter封装当前线程，然后重复执行取锁逻辑，直到渠道锁为止，如果取到锁，设置各个状态并唤醒后继线程，如果没有获取到锁，改变前驱节点状态，然后阻塞，等待唤醒</p>
</blockquote>
<h4 id="2-4-2-3-AQS-setHeadAndPropagate"><a href="#2-4-2-3-AQS-setHeadAndPropagate" class="headerlink" title="2.4.2.3 AQS.setHeadAndPropagate()"></a>2.4.2.3 AQS.setHeadAndPropagate()</h4><p>获取到许可时，逻辑调用了AQS.setHeadAndPropagate()，从方法名就可以看出除了设置新的头结点以外还有一个传递动作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    &#x2F;&#x2F;两个入参，一个是当前成功获取共享锁的节点，一个就是tryAcquireShared方法的返回值</span><br><span class="line">    &#x2F;&#x2F;注意上面说的，它可能大于0也可能等于0</span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F;将老的头结点记录下来，用来下面if的check</span><br><span class="line">    &#x2F;&#x2F;设置新的头节点，即把当前获取到锁的节点设置为头节点</span><br><span class="line">    setHead(node);&#x2F;&#x2F;此时head&#x3D;&#x3D;node了</span><br><span class="line">    &#x2F;&#x2F;这里意思是：有两种情况是需要执行唤醒操作</span><br><span class="line">    &#x2F;&#x2F;1.propagate &gt; 0 表示调用方指明了后继节点还可以被唤醒，因为许可还有</span><br><span class="line">    &#x2F;&#x2F;2.头节点后面的节点需要被唤醒（waitStatus&lt;0），不论是老的头结点（h &#x3D; head）还是新的头结点（node）</span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s &#x3D; node.next;&#x2F;&#x2F;此时node已经是head了，node的next就是在等待队列的队首</span><br><span class="line">        &#x2F;&#x2F;如果当前节点的后继节点是共享类型或者没有后继节点，则进行唤醒</span><br><span class="line">        &#x2F;&#x2F;这里可以理解为除非明确指明不需要唤醒（后继等待节点是独占类型），否则都要唤醒</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">            &#x2F;&#x2F;doReleaseShared不会释放锁，别被名字误导，它会唤醒后续节点，讲到释放锁时重点说</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final boolean isShared() &#123;</span><br><span class="line">    return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，在条件队列中，nextWaiter是指向条件队列中的下一个节点的，它将条件队列中的节点串起来，构成了单链表。但是在sync queue队列中，我们只用prev/next属性来串联节点，形成双向链表，nextWaiter属性在这里只起到一个标记作用，不会串联节点，这里不要被Node SHARED = new Node()所指向的空节点迷惑，这个空节点并不属于sync queue，不代表任何线程，它只起到标记作用，仅仅用作判断节点是否处于共享模式的依据。</p>
<blockquote>
<p>一句话总结，AQS.setHeadAndPropagate方法的作用是：设置head节点，并在许可还有剩余或者后继新旧head节点的后驱都应该被唤醒时（waitStatus &lt; 0），唤醒head的后继，让其参与争锁。</p>
</blockquote>
<h3 id="2-4-3-Semaphore非公平锁争锁逻辑"><a href="#2-4-3-Semaphore非公平锁争锁逻辑" class="headerlink" title="2.4.3 Semaphore非公平锁争锁逻辑"></a>2.4.3 Semaphore非公平锁争锁逻辑</h3><p>前文说过，不论是公平锁还是非公平锁，Semaphore都使用acquire()方法来争锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquireSharedInterruptibly方法，<strong>是定义在AQS中的</strong>，它可以响应中断异常，这个前文介绍过了，不再多说，拷贝过来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())&#x2F;&#x2F;如果当前线程被中断，抛出中断异常。</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;尝试获取共享锁，返回值小于0表示获取失败</span><br><span class="line">        doAcquireSharedInterruptibly(arg);&#x2F;&#x2F;未获取成功则加入同步队列等待</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-1-Semaphore-nonfairTryAcquireShared"><a href="#2-4-3-1-Semaphore-nonfairTryAcquireShared" class="headerlink" title="2.4.3.1 Semaphore.nonfairTryAcquireShared()"></a>2.4.3.1 Semaphore.nonfairTryAcquireShared()</h4><p>acquireSharedInterruptibly方法中的tryAcquireShared是模板方法，在Semaphore的两个内部类NonfairSync和FairSync中有各自的实现，FairSync.tryAcquireShared我们讲过了，我们来看下NonfairSync.tryAcquireShared</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用了nonfairTryAcquireShared方法，该方法定义在Semaphore类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;&#x2F;&#x2F;一直执行，直到要么失败，要么成功</span><br><span class="line">        &#x2F;&#x2F;在FairSync.tryAcquireShared中，此时会判断if (hasQueuedPredecessors())</span><br><span class="line">        &#x2F;&#x2F;如果为true，则返回抢锁失败</span><br><span class="line">        &#x2F;&#x2F;但非公平锁不讲究先来后到，直接争锁</span><br><span class="line">        int available &#x3D; getState();&#x2F;&#x2F;Semaphore的status表示许可总数量</span><br><span class="line">        int remaining &#x3D; available - acquires;&#x2F;&#x2F;总数量-索取量</span><br><span class="line">        &#x2F;&#x2F;如果索取量超过剩余量，返回的是小于0，表示获取许可失败。</span><br><span class="line">        &#x2F;&#x2F;如果CAS成功，表示获取许可成功，那么返回剩余量。</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，Semaphore.nonfairTryAcquireShared方法的作用是：重复检查剩余量，若许可的剩余量满足索取量，那么CAS获取许可，返回索取后的剩余量。</p>
</blockquote>
<h3 id="2-4-4-Semaphore释放锁逻辑"><a href="#2-4-4-Semaphore释放锁逻辑" class="headerlink" title="2.4.4 Semaphore释放锁逻辑"></a>2.4.4 Semaphore释放锁逻辑</h3><h4 id="2-4-4-1-AQS-releaseShared"><a href="#2-4-4-1-AQS-releaseShared" class="headerlink" title="2.4.4.1 AQS.releaseShared()"></a>2.4.4.1 AQS.releaseShared()</h4><p>我们使用releaseShared(int arg)方法来释放共享锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在独占锁模式下，由于头节点就是持有独占锁的节点，在它释放独占锁后，如果发现自己的waitStatus不为0，则它将负责唤醒它的后继节点。</p>
<p>在共享锁模式下，头节点就是持有共享锁的节点，在它释放共享锁后，它也应该唤醒它的后继节点，但是值得注意的是，我们在之前的setHeadAndPropagate方法中可能已经调用过该方法了，也就是说它可能会被同一个头节点调用两次，也有可能在我们从releaseShared方法中调用它时，当前的头节点已经易主了。</p>
<h4 id="2-4-4-2-Semaphore-tryReleaseShared"><a href="#2-4-4-2-Semaphore-tryReleaseShared" class="headerlink" title="2.4.4.2 Semaphore.tryReleaseShared()"></a>2.4.4.2 Semaphore.tryReleaseShared()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current &#x3D; getState();&#x2F;&#x2F;当前剩余的许可数</span><br><span class="line">        int next &#x3D; current + releases;&#x2F;&#x2F;剩余许可数+这次释放的许可数</span><br><span class="line">        if (next &lt; current) &#x2F;&#x2F; overflow &#x2F;&#x2F;int型溢出才会有这种情况</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))&#x2F;&#x2F;成功释放锁，重置剩余许可数</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一句话总结，Semaphore.tryReleaseShared方法的作用是：一直尝试将锁释放，CAS控制并发，将state值加回来</p>
</blockquote>
<h4 id="2-4-4-3-AQS-doReleaseShared"><a href="#2-4-4-3-AQS-doReleaseShared" class="headerlink" title="2.4.4.3 AQS.doReleaseShared()"></a>2.4.4.3 AQS.doReleaseShared()</h4><p>doReleaseShared是共享锁中最难理解的部分，我们来看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;&#x2F;&#x2F;循环check</span><br><span class="line">        Node h &#x3D; head;&#x2F;&#x2F;当前的head节点，执行到这里时，head可能是当前线程之前绑定的节点，也可能节点已经易主了</span><br><span class="line">        &#x2F;&#x2F;如果当前线程获取到锁后没有其他线程再获取到共享锁，那么这个head就是之前自己绑定的节点，否则，就不是了。</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;&#x2F;&#x2F;等待队列不为空</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            &#x2F;&#x2F;表示后继节点需要被唤醒</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                &#x2F;&#x2F;将head节点状态置为0，0为默认值，无特殊含义。</span><br><span class="line">                &#x2F;&#x2F;CAS不成功，重新执行for循环判断。</span><br><span class="line">                &#x2F;&#x2F;正是因为这个CAS的存在，保证即便doReleaseShared入口有setHeadAndPropagate跟release两个</span><br><span class="line">                &#x2F;&#x2F;但同一时间也只会唤醒一个后继节点。</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);&#x2F;&#x2F;CAS成功，执行唤醒操作，唤醒h.next</span><br><span class="line">                &#x2F;&#x2F;注意，这里唤醒h.next后，逻辑就到了if (h &#x3D;&#x3D; head)这里</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去</span><br><span class="line">            &#x2F;&#x2F;head的ws什么情况下会等于0？</span><br><span class="line">            &#x2F;&#x2F;1.上面的if会将ws从Node.SIGNAL置为0</span><br><span class="line">                 &#x2F;&#x2F;但执行了if，在本次迭代中不会执行else，得等到下次循环，如果期间head节点没有易主，那就没有下次循环。</span><br><span class="line">                 &#x2F;&#x2F;如果易主了，这里的h和ws就指向的是新head节点和其waitStatus。</span><br><span class="line">                 &#x2F;&#x2F;所以情况1不成立。</span><br><span class="line">            &#x2F;&#x2F;2.当前队列的最后一个节点成为了头节点</span><br><span class="line">                 &#x2F;&#x2F;因为只要有新节点入列，都会在shouldParkAfterFailedAcquire把前置节点的waitStatus置为Node.SIGNAL</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;当队列里唯一的节点成为了头节点，那什么情况下compareAndSetWaitStatus(h, 0, Node.PROPAGATE)会失败呢？</span><br><span class="line">            &#x2F;&#x2F;答案是：并发时，ws &#x3D;&#x3D; 0判断刚过，就有新节点将ws改为Node.SIGNAL。</span><br><span class="line">            &#x2F;&#x2F;但别忘了，for循环的第一个if，也是最外层的if是if (h !&#x3D; null &amp;&amp; h !&#x3D; tail)</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果这个方法期间head没有易主，说明没有其他线程在这个期间获取到共享锁，它就可以break了。</span><br><span class="line">        &#x2F;&#x2F;如果head易主，说明方法执行过程中其他线程获取到了锁，</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法最难理解的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">	!compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">	continue;</span><br></pre></td></tr></table></figure>
<p>为什么要有这个continue呢？？</p>
<p>根据上述的注解，我们知道要进入continue，得满足如下条件：</p>
<ul>
<li>队列中的最后一个节点成为了head，不然head的ws不会为0；</li>
<li>判断<code>if (h != null &amp;&amp; h != tail)</code>时，队列中不能只有head一个节点，否则不会进入if语句。</li>
<li>判断<code>else if (ws == 0</code>时，ws还要为0，但紧接着<code>compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</code>时却不能成功，说明此时ws不为0；</li>
</ul>
<p>所以总结下来，只有一个极其短暂的瞬间，逻辑有可能走到这里：</p>
<ul>
<li>队列中的最后一个节点成为了head</li>
<li>在当前线程中（我们称线程A）判断<code>if (h != null &amp;&amp; h != tail)</code>之前，等待队列中新加入一个节点（执行入列逻辑的线程我们称为线程B），该节点即head的后驱（等待队列不包括head），使得<code>if (h != null &amp;&amp; h != tail)</code>通过。</li>
<li>此时线程B中，head的后驱尝试获取锁失败，于是准备入列，刚刚执行addWaiter加入队列，还没有将head的ws改写，ws还是为0</li>
<li>然后线程A中我们判断<code>if (ws == Node.SIGNAL)</code> 不成立，进而判断<code>else if (ws == 0</code> ，逻辑通过</li>
<li>紧接着线程A判断<code>compareAndSetWaitStatus(h, 0, Node.PROPAGATE)</code>之前的一瞬间，ws在线程B中被head后驱通过调用<code>shouldParkAfterFailedAcquire</code>改写</li>
<li>改写后，线程B中，head后驱在下个循环就会进入阻塞了，而此时线程A执行<code>compareAndSetWaitStatus(h, 0, Node.PROPAGATE)</code>失败，触发了这个continue，而不是去进行<code>if (h == head)</code>判断。<ul>
<li>为什么要有这个continue？因为此时如果没有continue，那么进行<code>if (h == head)</code>判断，可能（其实是大概率）会通过，逻辑直接break了（break后就不会再唤醒后继了），逻辑A将唤醒后驱的逻辑break，而head的后驱却要阻塞，这使得head的后驱短时间内可能无人唤醒。</li>
<li>有了这个continue，那么下次循环，<code>if (ws == Node.SIGNAL)</code>通过，会对head的后继进行一次unpark，如果此时线程B已经park，那么唤醒正好。如果线程B慢悠悠的还没执行到park，那么我们知道，当我们unpark一个并没有被park的线程时，该线程在下一次调用park方法时就不会被阻塞，这时候如果线程B再执行park，也不会被阻塞了。</li>
</ul>
</li>
</ul>
<p>(上述只是个人猜想总结，如有缺漏或错误，还请指正)</p>
<blockquote>
<p>一句话总结，AQS.doReleaseShared方法的作用是：运用精细的逻辑控制，重复尝试唤醒head节点的后继。</p>
</blockquote>
<h2 id="2-5-AQS-condition实现"><a href="#2-5-AQS-condition实现" class="headerlink" title="2.5 AQS condition实现"></a>2.5 AQS condition实现</h2><h3 id="2-5-1-condition是什么"><a href="#2-5-1-condition是什么" class="headerlink" title="2.5.1 condition是什么"></a>2.5.1 condition是什么</h3><h4 id="2-5-1-1-简介"><a href="#2-5-1-1-简介" class="headerlink" title="2.5.1.1 简介"></a>2.5.1.1 简介</h4><p>condition又叫做条件队列，是AQS的一个内部实现，它能实现线程之间的通信，condition对象维护了一个FIFO的单向node链表，我们称之为等待队列（单向体现在只有后驱）（上文中争锁的队列我们叫做同步队列，以示区分，但其实他们的元素都是AQS.Node对象）。</p>
<p>我们在利用condition可以特定的场景下使线程休眠或被唤醒，和wait、notify实现的功能是一样的，但condition将休眠的对象放入等待队列，使其变得更为灵活。比如我们知道notify无法唤醒特定的一个线程，而是随机唤醒一个线程，但condition基于等待队列就能做到唤醒特定的一个线程（队首的线程），甚至我们还可以定义多个condition，使其能够互不干扰的休眠或唤醒。</p>
<p>condition是AQS的一个内部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">    extends AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">	private static final long serialVersionUID &#x3D; 7373984972572414691L;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">			private static final long serialVersionUID &#x3D; 1173984872572414699L;</span><br><span class="line">			&#x2F;** First node of condition queue. *&#x2F;</span><br><span class="line">			private transient Node firstWaiter;</span><br><span class="line">			&#x2F;** Last node of condition queue. *&#x2F;</span><br><span class="line">			private transient Node lastWaiter;</span><br><span class="line"></span><br><span class="line">			&#x2F;**</span><br><span class="line">			 * Creates a new &#123;@code ConditionObject&#125; instance.</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			public ConditionObject() &#123; &#125;</span><br><span class="line">			...</span><br><span class="line">			...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-2-语义"><a href="#2-5-1-2-语义" class="headerlink" title="2.5.1.2 语义"></a>2.5.1.2 语义</h4><p>从语义上来看，AQS实现的锁机制对应的是对象内置锁（synchronized语义对应的同步机制）的语义，这很好理解，在AQS这种显性锁出现前，我们使用java内置的对象的monitor来当做锁（对象锁或者类锁，即synchronized关键字和 (lock)等 ），AQS使用精妙的逻辑，重新显性的实现了锁机制。</p>
<p><strong>同理的，AQS.condition也是相对于内置锁的条件队列的一种显性存在。</strong></p>
<ul>
<li><p>用对象锁时，我们有Object.wait()、Object.notify()和Object.notifyAll()这三个api来操作对象的内部条件队列：</p>
<ul>
<li>用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）。</li>
<li>用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程；</li>
<li>用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程；</li>
</ul>
</li>
<li><p>用AQS实现的锁时，我们有condition.await(),condition.signal(),condition.ignalAll（）这三个api来操作AQS实现的锁的内部条件队列：</p>
<ul>
<li>Condition提供了await()方法将当前线程阻塞，线程调用await()方法前必须获取锁，调用await()方法时，将线程构造成节点加入等待队列，同时释放锁，并挂起当前线程</li>
<li>Condition提供了signal()方法支持另外一个线程将已经阻塞的线程唤醒。其他线程调用signal()方法前也必须获取锁，当执行signal()方法时将等待队列的节点移入到同步队列，当线程退出临界区释放锁的时候，唤醒同步队列的首个节点</li>
</ul>
</li>
</ul>
<h4 id="2-5-1-3-condition的使用"><a href="#2-5-1-3-condition的使用" class="headerlink" title="2.5.1.3 condition的使用"></a>2.5.1.3 condition的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">public void doSomething()&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(String.format(&quot;%s线程，获取到锁了&quot;,Thread.currentThread().getName()));</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(String.format(&quot;%s线程，await&quot;,Thread.currentThread().getName()));</span><br><span class="line">        TimeUnit.SECONDS.sleep(2L); &#x2F;&#x2F;模拟耗时业务逻辑执行</span><br><span class="line">        condition.await();  &#x2F;&#x2F;await</span><br><span class="line">        System.out.println(String.format(&quot;%s线程，await被唤醒&quot;,Thread.currentThread().getName()));</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(String.format(&quot;%s线程，业务执行完毕&quot;,Thread.currentThread().getName()));</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    ReentrantLockTest test &#x3D; new ReentrantLockTest();</span><br><span class="line">    int total &#x3D; 1;</span><br><span class="line">    while (total&gt;0)&#123;</span><br><span class="line">        Thread t &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            test.doSomething();</span><br><span class="line">        &#125;,&quot;T-&quot;+total);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(200L);  &#x2F;&#x2F;让子线程T-1率先获取到锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(String.format(&quot;%s线程，获取到锁了&quot;,Thread.currentThread().getName()));</span><br><span class="line">        test.condition.signal();</span><br><span class="line">        System.out.println(String.format(&quot;%s线程，signal&quot;,Thread.currentThread().getName()));</span><br><span class="line">        lock.unlock();</span><br><span class="line">        total--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T-1线程，获取到锁了</span><br><span class="line">T-1线程，await</span><br><span class="line">main线程，获取到锁了</span><br><span class="line">main线程，signal</span><br><span class="line">T-1线程，await被唤醒</span><br><span class="line">T-1线程，业务执行完毕</span><br></pre></td></tr></table></figure>

<h3 id="2-5-2-condition源码解析"><a href="#2-5-2-condition源码解析" class="headerlink" title="2.5.2 condition源码解析"></a>2.5.2 condition源码解析</h3><p>看完demo，我们来看源码，以ReentrantLock实现的condition为例，看看ReentrantLock是如何在AQS的condition上继承和实现的。</p>
<h4 id="2-5-2-1-ReentrantLock-newCondition"><a href="#2-5-2-1-ReentrantLock-newCondition" class="headerlink" title="2.5.2.1 ReentrantLock.newCondition"></a>2.5.2.1 ReentrantLock.newCondition</h4><p>如之前的demo所示，我们使用如下方式来获得condition对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br></pre></td></tr></table></figure>
<p>来看下newCondition（）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final ConditionObject newCondition() &#123;</span><br><span class="line">	return new ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-2-AQS-ConditionObject"><a href="#2-5-2-2-AQS-ConditionObject" class="headerlink" title="2.5.2.2 AQS.ConditionObject"></a>2.5.2.2 AQS.ConditionObject</h4><p>newCondition()返回的就是一个ConditionObject对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 1173984872572414699L;</span><br><span class="line">        &#x2F;** First node of condition queue. *&#x2F;</span><br><span class="line">        private transient Node firstWaiter;</span><br><span class="line">        &#x2F;** Last node of condition queue. *&#x2F;</span><br><span class="line">        private transient Node lastWaiter;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Creates a new &#123;@code ConditionObject&#125; instance.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public ConditionObject() &#123; &#125;</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>condition通过firstWaiter字段和lastWaiter字段组成了一个单向队列，即等待队列，并且和AQS的同步队列相比，他们虽然都是FIFO的，但等待队列的首节点并不具备同步队列首节点的传播通知的功能。而且首节点是第一个阻塞的线程节点。</p>
<ul>
<li>firstWaiter字段<ul>
<li>首个等待节点</li>
</ul>
</li>
<li>lastWaiter字段<ul>
<li>最后一个等待节点</li>
</ul>
</li>
</ul>
<h4 id="2-5-2-3-AQS-await"><a href="#2-5-2-3-AQS-await" class="headerlink" title="2.5.2.3 AQS.await()"></a>2.5.2.3 AQS.await()</h4><p>我们先来看一下condition将当前线程挂起的方法：await()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())&#x2F;&#x2F;当前线程加入等待队列前先判断是否被中断，若是，得响应中断</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    Node node &#x3D; addConditionWaiter();&#x2F;&#x2F;将同步队列中的当前线程构造成一个新的节点添加到等待队列尾部，后面详讲</span><br><span class="line">    &#x2F;&#x2F;释放node的同步状态（即释放锁）并返回释放之前的同步状态，后面详讲</span><br><span class="line">    &#x2F;&#x2F;因为condition的使用基于当前线程已经获取到锁了，所以release不会报错IllegalMonitorStateException</span><br><span class="line">    &#x2F;&#x2F;IllegalMonitorStateException：未持有锁的线程去释放锁时报该异常</span><br><span class="line">    int savedState &#x3D; fullyRelease(node);</span><br><span class="line">    int interruptMode &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;第一次进入while，判断被唤醒的node是否已经转移到AQS的同步队列中，不再则挂起线程，转移成功才退出循环</span><br><span class="line">    &#x2F;&#x2F;后面被唤醒后的线程，将从await()方法中的while循环中退出</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;&#x2F;&#x2F;（isOnSyncQueue(Node node)方法返回true，表示节点状态不为condition，且已经在同步队列中）</span><br><span class="line">        &#x2F;&#x2F;挂起线程，之后如果被被unpark或者发生中断时，也从此方法返回</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        &#x2F;&#x2F;被唤醒后来到这里，</span><br><span class="line">				</span><br><span class="line">        &#x2F;&#x2F;checkInterruptWhileWaiting方法有点绕，但其实不重要</span><br><span class="line">        &#x2F;&#x2F;只需知道是为了发生中断的时候能够让node跳出while循环</span><br><span class="line">        if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;&#x2F;如果开到这里，说明被唤醒了，但不是因为发生中断</span><br><span class="line">        &#x2F;&#x2F;这时还需要继续判断是否进入同步队列，如果没有则继续挂起。</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;跳出循环了，调用AQS的acquireQueued()方法加入到获取同步状态的竞争中。State还是之前释放锁时保存的status</span><br><span class="line">    &#x2F;&#x2F;interruptMode !&#x3D; THROW_IE:如果不是因为中断异常而退出循环的话；</span><br><span class="line">    &#x2F;&#x2F;AQS的acquireQueued()前文已分析，具体可见右侧导航栏跳转2.3.1.3 AQS.acquireQueued()</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)</span><br><span class="line">        &#x2F;&#x2F;处理中断要么抛出中断异常，要么重设置中断态。</span><br><span class="line">        &#x2F;&#x2F;这里排除了抛出异常，那么标记一下后面如果要处理中断，应该采用重置中断态的方式</span><br><span class="line">        interruptMode &#x3D; REINTERRUPT;</span><br><span class="line">    if (node.nextWaiter !&#x3D; null) &#x2F;&#x2F; clean up if cancelled</span><br><span class="line">        &#x2F;&#x2F; 从队首开始往后溯，清空条件等待队列中节点状态不为 CONDITION 的节点</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode !&#x3D; 0)</span><br><span class="line">        &#x2F;&#x2F; 如果线程已经被中断，则根据之前获取的interruptMode的值来判断是继续中断还是抛出异常</span><br><span class="line">        &#x2F;&#x2F;reportInterruptAfterWait方法作用：</span><br><span class="line">        &#x2F;&#x2F;如果之前是抛出中断异常，那么这里要再次抛出</span><br><span class="line">        &#x2F;&#x2F;如果之前是给自己设置中断状态，那么这里也要设置</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Adds a new waiter to wait queue.</span><br><span class="line"> * @return its new wait node</span><br><span class="line"> *&#x2F;</span><br><span class="line">private Node addConditionWaiter() &#123;&#x2F;&#x2F;该方法比较简单，构造node，并加入condition等待队列</span><br><span class="line">    Node t &#x3D; lastWaiter;&#x2F;&#x2F;获取等待队列队尾</span><br><span class="line">    &#x2F;&#x2F; If lastWaiter is cancelled, clean out.</span><br><span class="line">    if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; Node.CONDITION) &#123;&#x2F;&#x2F;如果队尾被取消了，将其清理</span><br><span class="line">        unlinkCancelledWaiters();&#x2F;&#x2F;该方法从队首开始往后清理被取消的节点</span><br><span class="line">        t &#x3D; lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), Node.CONDITION);&#x2F;&#x2F;构造node</span><br><span class="line">    if (t &#x3D;&#x3D; null)&#x2F;&#x2F;如果等待队列为空，加入队首</span><br><span class="line">        firstWaiter &#x3D; node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter &#x3D; node;&#x2F;&#x2F;否则加入队尾</span><br><span class="line">    lastWaiter &#x3D; node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Invokes release with current state value; returns saved state.</span><br><span class="line"> * Cancels node and throws exception on failure.</span><br><span class="line"> * @param node the condition node for this wait</span><br><span class="line"> * @return previous sync state</span><br><span class="line"> *&#x2F;</span><br><span class="line">final int fullyRelease(Node node) &#123;&#x2F;&#x2F;fully的意思是将持有的锁完全释放：即即便有n次重入或许可，也要全部释放。</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        int savedState &#x3D; getState();&#x2F;&#x2F;因为要释放所有重入次数或者许可，所以要获取总量</span><br><span class="line">        if (release(savedState)) &#123;&#x2F;&#x2F;调用AQS的release一次释放总量，详见上文2.3.3.3 AQS.tryRelease()</span><br><span class="line">            failed &#x3D; false;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;IllegalMonitorStateException：未持有锁的线程去释放锁时报该异常</span><br><span class="line">            &#x2F;&#x2F;这里如果</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            &#x2F;&#x2F;释放锁失败的场景，只有IllegalMonitorStateException异常。这时可以认为该节点已经被取消。</span><br><span class="line">            node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-4-AQS-signal"><a href="#2-5-2-4-AQS-signal" class="headerlink" title="2.5.2.4 AQS.signal()"></a>2.5.2.4 AQS.signal()</h4><p>看完了挂起线程的方法，我们来看下唤醒线程的方法，signal方法会唤醒condition等待队列中队首的那个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Moves the longest-waiting thread, if one exists, from the</span><br><span class="line"> * wait queue for this condition to the wait queue for the</span><br><span class="line"> * owning lock.</span><br><span class="line"> *</span><br><span class="line"> * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125;</span><br><span class="line"> *         returns &#123;@code false&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final void signal() &#123;</span><br><span class="line">    if (!isHeldExclusively())&#x2F;&#x2F;该方法AQS未实现，ReentrantLock的实现是判断当前线程是不是持有锁的线程，是，则true</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first &#x3D; firstWaiter;&#x2F;&#x2F;获取等待队列的队首</span><br><span class="line">    if (first !&#x3D; null)</span><br><span class="line">        doSignal(first);&#x2F;&#x2F;下面我们来看看这个方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="line"> * null. Split out from signal in part to encourage compilers</span><br><span class="line"> * to inline the case of no waiters.</span><br><span class="line"> * @param first (non-null) the first node on condition queue</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)</span><br><span class="line">            lastWaiter &#x3D; null;</span><br><span class="line">        first.nextWaiter &#x3D; null;</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first &#x3D; firstWaiter) !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doSignal进来就是一个do-while，我们先看transferForSignal，回头再看doSignal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 将一个node从等待队列转移至同步队列，</span><br><span class="line"> * 如果成功，返回true</span><br><span class="line"> * @param node the node</span><br><span class="line"> * @return true if successfully transferred (else the node was</span><br><span class="line"> * cancelled before signal)</span><br><span class="line"> *&#x2F;</span><br><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;尝试将node的状态置为无意义的0，如果失败，说明该节点已经被取消。</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">     * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">     * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">     * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Node p &#x3D; enq(node);&#x2F;&#x2F;node进入同步队列的入列操作，在前文2.3.1.2 AQS.addWaiter()有过介绍</span><br><span class="line">    &#x2F;&#x2F;enq会返回入队前同步队列的队尾指针，即刚入队的node的前驱。</span><br><span class="line">    int ws &#x3D; p.waitStatus;</span><br><span class="line">    &#x2F;&#x2F;只有取消ws才会 大于0</span><br><span class="line">    &#x2F;&#x2F;我们知道同步队列中的节点都是依靠前驱节点来唤醒</span><br><span class="line">    &#x2F;&#x2F;如果入队后node的前驱已经被取消或者设置SIGNAL状态不成功，那么尝试唤醒当前node</span><br><span class="line">    &#x2F;&#x2F;虽然唤醒了可能还是争不到锁，但该操作至少是无害的。</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：传进transferForSignal的node节点被取消，会返回false，成功入同步队列了，会返回true。这时我们再看doSignal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="line"> * null. Split out from signal in part to encourage compilers</span><br><span class="line"> * to inline the case of no waiters.</span><br><span class="line"> * @param first (non-null) the first node on condition queue</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;第一次进来，先把firstWaiter设置为first.nextWaiter，这相当于first已经脱离等待队列了。</span><br><span class="line">        &#x2F;&#x2F;为什么这么果断呢，因为transferForSignal如果返回true，while循环结束</span><br><span class="line">        &#x2F;&#x2F;那么说明first已经进入同步队列，确实应该取消</span><br><span class="line">				</span><br><span class="line">        &#x2F;&#x2F;如果transferForSignal返回false，那么说明first节点已经被canceled了，也应该脱离等待队列。</span><br><span class="line">        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)&#x2F;&#x2F;如果条件满足，说明等待队列已经为空了</span><br><span class="line">            lastWaiter &#x3D; null;&#x2F;&#x2F;则将lastWaiter指针也置空</span><br><span class="line">        first.nextWaiter &#x3D; null;&#x2F;&#x2F;first此时已经脱队，将其单向链表的后继也置空，first彻底脱离等待队列</span><br><span class="line">				</span><br><span class="line">    &#x2F;&#x2F;如果transferForSignal返回true，说明first入同步队列成功，while条件不满足，退出循环</span><br><span class="line">    &#x2F;&#x2F;如果transferForSignal返回false，说明first被取消，如果此时等待队列已经空了，那么也退出循环，</span><br><span class="line">    &#x2F;&#x2F;否则，将新的等待队列队首设置为first，执行重复逻辑。</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first &#x3D; firstWaiter) !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-5-AQS-signalAll"><a href="#2-5-2-5-AQS-signalAll" class="headerlink" title="2.5.2.5 AQS.signalAll()"></a>2.5.2.5 AQS.signalAll()</h4><p>signalAll可唤醒等待队列中的全部线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Moves all threads from the wait queue for this condition to</span><br><span class="line"> * the wait queue for the owning lock.</span><br><span class="line"> *</span><br><span class="line"> * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125;</span><br><span class="line"> *         returns &#123;@code false&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final void signalAll() &#123;</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first &#x3D; firstWaiter;</span><br><span class="line">    if (first !&#x3D; null)&#x2F;&#x2F;等待队列不为空，执行doSignalAll</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不赘述，直接看doSignalAll</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Removes and transfers all nodes.</span><br><span class="line"> * @param first (non-null) the first node on condition queue</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doSignalAll(Node first) &#123;</span><br><span class="line">    lastWaiter &#x3D; firstWaiter &#x3D; null;&#x2F;&#x2F;先把标示性的指针lastWaiter和firstWaiter清空，因为等待队列即将要空了。</span><br><span class="line">    do &#123;</span><br><span class="line">        Node next &#x3D; first.nextWaiter;</span><br><span class="line">        first.nextWaiter &#x3D; null;</span><br><span class="line">        transferForSignal(first);&#x2F;&#x2F;现将first转移至同步队列，不管成功或者失败，都要继续执行。</span><br><span class="line">        first &#x3D; next;&#x2F;&#x2F;将first改为原来first的后继</span><br><span class="line">    &#125; while (first !&#x3D; null);&#x2F;&#x2F;只要等待队列不空，就一直将队首移入同步队列。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，将等待队列从队首无脑移入同步队列。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper%E7%AE%80%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper%E7%AE%80%E8%AE%BA/" itemprop="url">分布式协调服务zookeeper简论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-20T21:49:46+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/" itemprop="url" rel="index">
                    <span itemprop="name">ZooKeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper%E7%AE%80%E8%AE%BA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/20/分布式协调服务zookeeper简论/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  5.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps.本文为《从Paxos到Zookeeper  分布式一致性原理与实践》笔记之一</p>
<h1 id="1-ZooKeeper"><a href="#1-ZooKeeper" class="headerlink" title="1 ZooKeeper"></a>1 ZooKeeper</h1><ul>
<li><p>ZooKeeper曾是Apache Hadoop的一个子项目，是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、master选举、分布式锁和分布式队列等。</p>
</li>
<li><p>ZooKeeper是Google的Chubby一个开源的实现，由雅虎创建，是Hadoop和Hbase的重要组件。</p>
</li>
<li><p>ZooKeeper没有直接采用paxos算法，而是采用了一种被称为ZAB（Zookeeper Atomic Broadcast）的一致性协议</p>
</li>
<li><p>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
</li>
</ul>
<h2 id="1-1-ZooKeeper可以保证如下分布式一致性特性"><a href="#1-1-ZooKeeper可以保证如下分布式一致性特性" class="headerlink" title="1.1 ZooKeeper可以保证如下分布式一致性特性"></a>1.1 ZooKeeper可以保证如下分布式一致性特性</h2><ol>
<li><p>顺序一致性：从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中；</p>
</li>
<li><p>原子性：所有事务的请求结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么在整个集群中所有机器上都成功应用了某一个事务，要么都没有应用，没有中间状态；</p>
</li>
<li><p>单一视图：无论客户端连接的是哪个Zookeeper服务器，其看到的服务端数据模型都是一致的。</p>
</li>
<li><p>可靠性：一旦服务端成功应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p>
</li>
<li><p>实时性：Zookeeper仅仅保证在一定的时间内，客户端最终一定能够从服务端上读到最终的数据状态。</p>
</li>
</ol>
<h2 id="1-2-ZooKeeper的四个设计目标"><a href="#1-2-ZooKeeper的四个设计目标" class="headerlink" title="1.2 ZooKeeper的四个设计目标"></a>1.2 ZooKeeper的四个设计目标</h2><p>zk致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力（主要是写操作）的分布式协议，最后者能使得zk能实现一些复杂的同步语义。</p>
<ol>
<li><p>简单的数据模型：能够通过一个共享的、树型结构的名字空间来进行相互协调。这里是树形结构的名字空间是指zk服务器内存中的一个数据结构，由其一系列的ZNode数据节点组成，他们的层级关系就像文件系统的目录结构，不过zk将其全量数据存储在内存中，以达到高吞吐。</p>
</li>
<li><p>可以构建集群：zk集群通常由一组机器组成，集群中的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都保持着通信。集群中只要超过一半的机器可以正常工作，zk就可以对外提供服务。zk客户端会选择和集群中任意一台机器共同来创建一个tcp链接，如果连接断开，客户端会自动连接到服务机器的其他机器。</p>
</li>
<li><p>顺序访问：对于来自客户端的每个更新请求，Zookeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序。</p>
</li>
<li><p>高性能：Zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的应用场景。</p>
</li>
</ol>
<h1 id="2-ZooKeeper的基本概念"><a href="#2-ZooKeeper的基本概念" class="headerlink" title="2 ZooKeeper的基本概念"></a>2 ZooKeeper的基本概念</h1><h2 id="2-1-集群角色"><a href="#2-1-集群角色" class="headerlink" title="2.1 集群角色"></a>2.1 集群角色</h2><ul>
<li>最典型的集群就是Master/Slave模式（主备模式），此情况下把所有能够处理写操作的机器称为Master机器，把所有通过异步复制方式获取最新数据，并提供读服务的机器为Slave机器。  </li>
<li>Zookeeper不采用主备模式，它引入了Leader、Follower、Observer三种角色，Zookeeper集群中的所有机器通过Leaser选举过程来选定一台被称为Leader的机器，Leader服务器为客户端提供读和写服务，Follower和Observer提供读服务，但是Observer不参与Leader选举过程，不参与写操作的”过半写成功”策略，Observer可以在不影响写性能的情况下提升集群的性能。</li>
</ul>
<p>leader：  是整个集群工作机制中的核心，其主要工作有：</p>
<ol>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性。</li>
<li>集群内部各服务器的调度者。</li>
</ol>
<p>follower：是zookeeper集群状态的跟随者，其主要工作是：</p>
<ol>
<li>处理客户端的非事务请求，转发事务请求给leader服务器。</li>
<li>参与事务请求proposal的投票</li>
<li>参与leader选举投票</li>
</ol>
<p>observer：和follower唯一的区别在于，observer服务器只提供非事务服务，不参与任何形式的投票，包括事务请求proposal的投票和leader选举投票。</p>
<ol>
<li>通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</li>
</ol>
<h2 id="2-2-会话"><a href="#2-2-会话" class="headerlink" title="2.2 会话"></a>2.2 会话</h2><ul>
<li>指客户端会话，一个客户端连接是指客户端和服务端之间的一个TCP长连接，Zookeeper对外的服务端口默认为2181，客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接受来自服务器的Watch事件通知。</li>
</ul>
<h2 id="2-3-数据节点"><a href="#2-3-数据节点" class="headerlink" title="2.3 数据节点"></a>2.3 数据节点</h2><ul>
<li>我们常说的节点指的是集群中的机器节点，zk中节点有两类，第一类指构成集群的机器，称为机器节点，第二类是指数据模型中的数据单元，称为数据节点-Znode，Zookeeper将所有数据存储在内存中，数据模型是一棵树，由斜杠/进行分割的路径，就是一个ZNode，如/foo/path1，每个ZNode都会保存自己的数据内存，同时还会保存一些列属性信息。</li>
<li>ZNode分为持久节点和临时节点两类，持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上，而临时节点的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</li>
<li>另外，Zookeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点后面追加一个整形数字，其是由父节点维护的自增数字。</li>
<li>临时，持久和顺序，如此，数据节点一共有四种类型：<ol>
<li>持久节点（PERSISTENT）<ul>
<li>zk中最常见的一种节点类型。除非主动删除，否则一直保留</li>
</ul>
</li>
<li>持久顺序节点（PERSISTENT_SEQUENTIAL）<ul>
<li>基本和持久节点一致，额外的特性表现在顺序性上。持久顺序节点在创建节点的时候，zk会自动给它的名字加上数字后缀，表示在该父节点下的创建顺序，后缀上线是整型最大值。</li>
</ul>
</li>
<li>临时节点（EPHEMERAL）<ul>
<li>临时节点的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</li>
</ul>
</li>
<li>临时顺序节点（EPHEMERAL_SEQUENTIAL）<ul>
<li>同临时节点，再加上顺序特性。<h2 id="2-4-stat"><a href="#2-4-stat" class="headerlink" title="2.4 stat"></a>2.4 stat</h2></li>
</ul>
</li>
</ol>
</li>
<li>数据节点中除了有数据内容外，还有一个stat对象来记录节点的状态信息：<br>  <img src="https://oscimg.oschina.net/oscnet/d18c5024bebdf96b7546ea05d385eb5ec6e.jpg" alt=""><br>  <img src="https://oscimg.oschina.net/oscnet/40cc46a32f2828bd4c8d995e4015c780691.jpg" alt=""><h2 id="2-5-版本"><a href="#2-5-版本" class="headerlink" title="2.5 版本"></a>2.5 版本</h2></li>
<li>对于每个ZNode，Zookeeper都会为其维护一个叫作Stat的数据结构，Stat记录了这个ZNode的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）、aversion（当前ZNode的ACL版本）。</li>
<li>类似于乐观锁和cas，保证原子性操作<h2 id="2-6-事务操作"><a href="#2-6-事务操作" class="headerlink" title="2.6 事务操作"></a>2.6 事务操作</h2></li>
<li>在ZooKeeper中，能改变ZooKeeper服务器状态的操作称为事务操作。一般包括数据节点创建与删除、数据内容更新和客户端会话创建与失效等操作。对应每一个事务请求，ZooKeeper都会为其分配一个全局唯一的事务ID，用ZXID表示，通常是一个64位的数字。每一个ZXID对应一次更新操作，从这些ZXID中可以间接地识别出ZooKeeper处理这些事务操作请求的全局顺序。<h2 id="2-7-watcher"><a href="#2-7-watcher" class="headerlink" title="2.7 watcher"></a>2.7 watcher</h2></li>
<li>watcher是事件监听器，Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，Zookeeper服务端会将事件通知到感兴趣的客户端。该机制是zk实现分布式协调服务的重要特性。</li>
<li>其逻辑如下图：<br>  <img src="https://oscimg.oschina.net/oscnet/a30aeb692c39f7d5b0824afe7befd31a31b.jpg" alt=""></li>
<li>当客户端向服务端注册watcher时，也会将watcher对象存储在客户端的watcherManager中，当服务端出发watcher时间后，向客户端发送通知，客户端从watcherManager中去处watcher对象来执行回调逻辑。<h2 id="2-8-ACL"><a href="#2-8-ACL" class="headerlink" title="2.8 ACL"></a>2.8 ACL</h2>Zookeeper采用ACL（Access Control Lists）策略来进行权限控制，类似于unix文件系统的权限控制，</li>
<li>权限模式<ul>
<li>ip模式<ul>
<li>通过ip地址粒度来进行权限控制。</li>
</ul>
</li>
<li>digest<ul>
<li>类似于username:password形式配置权限标识来控制，</li>
</ul>
</li>
<li>world<ul>
<li>即任何人都可以访问</li>
</ul>
</li>
<li>super<ul>
<li>一种特殊的digest模式，只不过权限是超级用户。</li>
</ul>
</li>
</ul>
</li>
<li>权限：<ul>
<li>CREATE：创建子节点的权限。</li>
<li>READ：获取节点数据和子节点列表的权限。</li>
<li>WRITE：更新节点数据的权限。</li>
<li>DELETE：删除子节点的权限。</li>
<li>ADMIN：设置节点ACL的权限。</li>
</ul>
</li>
<li>值得注意的是，CREATE和READ都是针对子节点的权限控制。</li>
</ul>
<h1 id="3-ZAB协议"><a href="#3-ZAB协议" class="headerlink" title="3 ZAB协议"></a>3 ZAB协议</h1><p>见文章《ZAB协议分析》一文</p>
<h1 id="4-Zookeeper应用场景"><a href="#4-Zookeeper应用场景" class="headerlink" title="4 Zookeeper应用场景"></a>4 Zookeeper应用场景</h1><h2 id="4-1-数据发布-订阅"><a href="#4-1-数据发布-订阅" class="headerlink" title="4.1 数据发布/订阅"></a>4.1 数据发布/订阅</h2><ul>
<li><p>发布订阅系统，即所谓的配置中心，发布者将数据发布到zk的一个或者一系列节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的。</p>
</li>
<li><p>常规的发布订阅系统有push和pull两种模式，在push模式中，服务端主动将数据更新发送给所有订阅的客户端。pull模式中，客户端通常采用盯视轮询拉取的方式发送请求来服务端获取。</p>
</li>
<li><p>zk的发布订阅系统采用推拉结合的模式，客户端向服务端祖册自己需要关注的数据节点，一旦该节点的数据（也就是配置信息）发生变更，服务端会发送watcher时间通知客户端来获取数据。</p>
</li>
</ul>
<h2 id="4-2-负载均衡"><a href="#4-2-负载均衡" class="headerlink" title="4.2 负载均衡"></a>4.2 负载均衡</h2><ul>
<li>这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。</li>
<li>消息中间件中发布者和订阅者的负载均衡，linkedin开源的KafkaMQ和阿里开源的metaq都是通过zookeeper来做到生产者、消费者的负载均衡。我们以kafka为例子。<h3 id="4-2-1-kafka概念："><a href="#4-2-1-kafka概念：" class="headerlink" title="4.2.1 kafka概念："></a>4.2.1 kafka概念：</h3></li>
<li>消息生产者：producer</li>
<li>消息消费者：consumer</li>
<li>主题：即Topic，由用户定义并配置在Kafka服务端，用于建立生产者和消费者之间的订阅关系：生产者发送消息到指定Topic下，消费者从这个Topic下消费消息。</li>
<li>Broker：即Kafka服务器，用于存储消息，在消息中间件中通常被称为Broker<br>消费者分组：Group</li>
<li>Offset：消息存储在Kafka的Broker上，消费者拉取消息数据的过程中需要知道消息在文件中的偏移量，这个偏移量就是所谓的Offset</li>
<li>ZooKeeper负责管理所有Broker服务器列表，并且建立了对应路径来对其进行管理/brokers/ids<br>每个Broker服务器在启动时，都会到ZooKeeper上进行注册，其节点路径为/broker/ids/[0…N]</li>
<li>Topic注册：Kafka当中，会将同一个Topic的消息分成多个区，分布到多个Broker上，这些分区信息和Broker的对应关系由ZooKeeper来维护<h3 id="4-2-2-ZooKeeper负载均衡实现"><a href="#4-2-2-ZooKeeper负载均衡实现" class="headerlink" title="4.2.2 ZooKeeper负载均衡实现"></a>4.2.2 ZooKeeper负载均衡实现</h3></li>
<li>每当一个Broker启动时，会首先完成Broker注册过程，在ZooKeeper的节点列表里保存Broker。</li>
<li>Kafka的生产者会对ZooKeeper上的“Broker的新增与减少”、“Topic的新增和减少”和“Broker和Topic关联关系的变化”等事件注册Watcher监听</li>
<li>通过ZooKeeper的Watcher通知能够让生产者动态的获取Broker和Topic的变化情况</li>
<li>Kafka有消费者分组的概念，每个消费者分组包含了若干个消费者，每一条消息只会发送给分组内的一个消费者，不同消费者分组消费自己特定的Topic下面的消息，互不干扰</li>
<li>Kafka会为每个消费者分配全局唯一的Consumer ID，采用“Hostname：UUID”形式来表示</li>
<li>每个消费者一旦确定了对一个消息分区的消费权利，ZooKeeper会将其Consumer ID写入到对应消息分区的<strong>临时节点</strong>上</li>
<li>消费进度管理：Kafka需要定时地将分区消息的消费进度，即Offset记录到ZooKeeper上去</li>
</ul>
<h2 id="4-3-命名服务"><a href="#4-3-命名服务" class="headerlink" title="4.3 命名服务"></a>4.3 命名服务</h2><ul>
<li>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li>
<li>其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</li>
<li>阿里巴巴集团开源的分布式服务框架Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表，在Dubbo实现中<ul>
<li>服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。</li>
<li>服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址， 并向/dubbo/${serviceName} /consumers目录下写入自己的URL地址。</li>
<li>注意，所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。</li>
<li>另外，Dubbo还有针对服务粒度的监控，方法是订阅/dubbo/${serviceName}目录下所有提供者和消费者的信息。<h2 id="4-4-分布式通知-协调"><a href="#4-4-分布式通知-协调" class="headerlink" title="4.4 分布式通知/协调"></a>4.4 分布式通知/协调</h2></li>
</ul>
</li>
<li>ZooKeeper中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对ZK上同一个znode进行注册，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理。<ul>
<li>心跳检测式通知/协调：检测系统和被检测系统之间并不直接关联起来，而是通过zk上某个节点关联，比如两个客户端都在一个节点下创建各自的临时节点，并定时心跳去检测对方节点的存在，达到心跳检测的目的。</li>
<li>系统调度式通知/协调：有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了ZK上某些节点的状态，而ZK就把这些变化通知给他们注册Watcher的客户端，即推送系统，于是，作出相应的推送任务。</li>
<li>工作汇报式通知/协调：一些类似于任务分发系统，子任务启动后，到zk来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点），这样任务管理者就能够实时知道任务进度。</li>
</ul>
</li>
<li>总之，使用zookeeper来进行分布式通知和协调能够大大降低系统之间的耦合</li>
</ul>
<h2 id="4-5-集群管理"><a href="#4-5-集群管理" class="headerlink" title="4.5 集群管理"></a>4.5 集群管理</h2><ul>
<li>通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题：<ul>
<li>集群中机器有变动的时候，牵连修改的东西比较多。</li>
<li>有一定的延时。</li>
</ul>
</li>
<li>利用ZooKeeper有两个特性，就可以实时另一种集群机器存活性监控系统：<ul>
<li>客户端在节点x上注册一个Watcher，那么如果 x的子节点变化了，会通知该客户端。</li>
<li>创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。</li>
</ul>
</li>
<li>例如，监控系统在 /clusterServers 节点上注册一个Watcher，以后每动态加机器，那么就往 /clusterServers 下创建一个 EPHEMERAL类型的节点：/clusterServers/{hostname}. 这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控系统的业务了。<h2 id="4-6-Master选举"><a href="#4-6-Master选举" class="headerlink" title="4.6 Master选举"></a>4.6 Master选举</h2></li>
<li>在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。</li>
<li>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建同名的如名字为 /currentMaster的节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。<h3 id="4-6-1-动态master选举"><a href="#4-6-1-动态master选举" class="headerlink" title="4.6.1 动态master选举"></a>4.6.1 动态master选举</h3></li>
<li>上述场景演化一下，就是动态Master选举。这就要用到EPHEMERAL_SEQUENTIAL类型节点的特性了。上文中提到，所有客户端创建请求，最终只有一个能够创建成功。在这里稍微变化下，创建EPHEMERAL_SEQUENTIAL节点，于是所有的请求最终在ZK上创建结果的一种可能情况是这样<ul>
<li>/currentMaster/{sessionId}-1 ,/currentMaster/{sessionId}-2 ,/currentMaster/{sessionId}-3</li>
</ul>
</li>
<li>每次选取序列号最小的那个机器作为Master，如果这个机器挂了，由于他创建的节点会马上消失，那么之后最小的那个机器就是Master了。</li>
</ul>
<h2 id="4-7-分布式锁"><a href="#4-7-分布式锁" class="headerlink" title="4.7 分布式锁"></a>4.7 分布式锁</h2><ul>
<li>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。<ul>
<li>所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。</li>
<li>控制时序，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。<h2 id="4-8-分布式队列"><a href="#4-8-分布式队列" class="headerlink" title="4.8 分布式队列"></a>4.8 分布式队列</h2></li>
</ul>
</li>
<li>队列方面，简单地讲有两种，一种是常规的先进先出队列，另一种是要等到队列成员聚齐之后的才统一按序执行。对于第一种先进先出队列，和分布式锁服务中的控制时序场景基本原理一致，这里不再赘述。</li>
<li>第二种队列其实是在FIFO队列的基础上作了一个增强。通常可以在 /queue 这个znode下预先建立一个/queue/num 节点，并且赋值为n（或者直接给/queue赋值n），表示队列大小，之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行了。</li>
<li>这种用法的典型场景是，分布式环境中，一个大任务Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/paxos%E7%AE%97%E6%B3%95%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%8E%A8%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/paxos%E7%AE%97%E6%B3%95%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%8E%A8%E5%AF%BC/" itemprop="url">paxos算法论述和推导</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-12T00:34:38+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分布式算法&理论</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务和数据一致性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/12/paxos%E7%AE%97%E6%B3%95%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%8E%A8%E5%AF%BC/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/12/paxos算法论述和推导/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><ul>
<li><p>在HA集群系统中，假设有同一个整体、动作协调的节点A 和节点B，节点A和B之间通过heartBeat来检查对方的存活状态,负责协调保证整个集群服务的可用性。正常情况下，如果节点A通过心跳检测不到B的存在的时候，就会接管B的资源，同理节点B检查不到B的存活状态的时候也会接管A的资源。</p>
</li>
<li><p>如果出现网络故障，就会导致A和B同时检查不到对方的存活状态认为对方出现异常，这个时候就会导致A接管B的资源，B也会接管A的资源。原来被一个节点访问的资源就会出现被多个节点同时访问的情况，这种情况就是脑裂现象。</p>
</li>
<li><p>嗯，这是比较官方的解释，说人话的话，其实就是在一个集群中，有多个“大脑”，即多个master</p>
<h2 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h2></li>
<li><p>在传统的单机系统中，我们调用一个函数，这个函数要么返回成功，要么返回失败，其结果是确定的。可以概括为传统的单机系统调用只存在两态（2-state system）：成功和失败。</p>
</li>
<li><p>然而在分布式系统中，由于系统是分布在不同的机器上，系统之间的请求就相对于单机模式来说复杂度较高了。具体的，节点 A 上的系统通过 RPC (Remote Procedure Call) 方式与节点 B 上的系统进行通信，在这个请求结果存在三态(3-state system)：也就是成功、失败和超时，不要小瞧超时这个状态，因为它几乎是所有分布式系统复杂性的根源。</p>
</li>
</ul>
<h1 id="1-paxos算法"><a href="#1-paxos算法" class="headerlink" title="1 paxos算法"></a>1 paxos算法</h1><ul>
<li>Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。- - Paxos算法及变种算法在分布式系统中应用广泛。基于Paxos算法的变种有：ZAB、Raft。 Zookeeper 中的ZAB协议也是Paxos算法的变种。</li>
<li>Paxos是一个解决共识问题consensus problem的算法，现实中Paxos的实现以及成为一些世界级软件的心脏，如Cassandra, Google的Spanner数据库, 分布式锁服务Chubby。一个被Paxos管理的系统实际上谈论的是值状态和跟踪等问题，其目标是建造更高可用性和强一致性的分布式系统。</li>
<li>Paxos算法解决的问题是在一个可能发生消息可能会延迟、丢失、重复的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。这 个“值”可能是一个数据的某，也可能是一条log日志等；根据不同的应用环境这个“值”也不同。<h2 id="1-1-角色"><a href="#1-1-角色" class="headerlink" title="1.1 角色"></a>1.1 角色</h2></li>
<li>Paxos中有三类角色Proposer、Acceptor及Learner，主要交互过程在Proposer和Acceptor之间。网络中的任意节点，都可能既是Proposer，又是Acceptor。</li>
<li>当某个节点想将分布式系统中进行写操作的，它就是Proposer。除Proposer外，所有接收到请求，被要求对某个值进行更改的其他节点，就是Acceptor。</li>
</ul>
<h2 id="1-2-比喻推导前提"><a href="#1-2-比喻推导前提" class="headerlink" title="1.2 比喻推导前提"></a>1.2 比喻推导前提</h2><ul>
<li><p>举个例子，一个城市为了确定城市未来的发展方针，市长皮皮虾决定集思广益，向全体市民寻求建议。每个人都有建议权，也都有投票权（一个市民在发展方针的时候，他就是proposer，其他人是acceptor，此时，发展方针即表示节点希望推动的值变更或者说值状态，他希望所有节点都接受自己提出的值变更）</p>
</li>
<li><p>在现实环境中我们可以在一个大会堂召集全体市民共同讨论或在微信群中讨论（基于内存共享方式）；但在基于消息传递的分布式环境中每个人只能通过手机短信与其它人沟通。我们要寻求一种机制以解决如何在这种会延迟、丢失的环境中确定一个城市的发展方针。</p>
</li>
<li><p>在讨论之前，我们得制定一些投票规则，以便能够胜利选出呼声最高的发展方针。</p>
<ol>
<li>最终只能确定一个建议</li>
<li>少数服从多数。只要建议被多数人同意即可确定该建议。</li>
</ol>
</li>
<li><p>为了保证投票环节让所有人信服，我们得保证如下几点：</p>
<ol>
<li>只有被提出来的建议才能被大家投票同意。<ul>
<li>也就是大家只能投票给被建议出来的选项。</li>
</ul>
</li>
<li>最终一定要能够得到一个被大多数人同意的建议。</li>
<li>不同人的提议可以重复。</li>
<li>如果某个人认为大家同意了某个建议，那么这个建议必须真的是被大家同意的。<ul>
<li>也就是要让所有市民心服口服，人们认为的众望所归的建议，必须真的是大家众望所归的建议。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="1-3-比喻推导过程"><a href="#1-3-比喻推导过程" class="headerlink" title="1.3 比喻推导过程"></a>1.3 比喻推导过程</h2><p>为了制定行之有效的机制，市长皮皮虾召集了一大批专家团队来规划整个决策机制，在讨论当中，专家们提出了许多未来可能遇到的问题，并尝试完善规则：</p>
<h3 id="1-3-1-情况一"><a href="#1-3-1-情况一" class="headerlink" title="1.3.1 情况一"></a>1.3.1 情况一</h3><p>如果因为宣传不充分，很多人准备也不到位，结果只有一位市民提出了自己的建议，它希望这个小城大力发展纸尿裤行业，希望大家在即将到来的投票中选择自己的提议。这个明显是帮宝适董事长提的傻逼建议，在初步征询阶段就得不到市民的认可，于是情况陷入了僵局，在没有新的建议出来的情况下，大家都不同意，导致决策机制彻底失灵。</p>
<p><strong>解决办法</strong>：为了使得这个表决机制不会陷入这个局面，一根筋的市长皮皮虾决定增加一条硬性规定，<strong>我们称他为P1：不许不投票，每一个人必须同意他收到的第一个建议</strong>。这样即使只有一个建议被提出，也能够被采纳。</p>
<h3 id="1-3-2-情况二"><a href="#1-3-2-情况二" class="headerlink" title="1.3.2 情况二"></a>1.3.2 情况二</h3><p>此时一位专家说：基于情况一，我们要求每一个人必须同意他收到的第一个提议，但因为我们又需要一个提议必须被大多数人同意才能生效，所以一个人必须可以同时同意多个人的建议，即一个人必须可以拥有多次投票权可以投给不同的人，不然发生A同意B，B同意C，C同意D，D同意A的情况，永远也得不出一个超过半数同意的提议。</p>
<p>市长皮皮虾表示这位专家说的很有道理。</p>
<p>但这时又有一位专家提醒，就算我们允许一个人可以投给不同的人，也会遇到类似的僵局，比如A同意B和C的提议，B同意C和D的提议，C同意D和A的提议，D同意A和B的提议，这样每个人的提议都有两票，也会陷入僵局。</p>
<p>要避免出现这种问题，就要求被某个人投票的这些建议者们，他们的提议内容都是一样的。</p>
<p>于是皮皮虾市长规定，<strong>我们称他为P2：市民只能有一个立场，抱定这个立场后，可以投票给不同的但都是提议该立场的建议者，以便选出最后得票最高的建议</strong>。</p>
<h3 id="1-3-3-情况三"><a href="#1-3-3-情况三" class="headerlink" title="1.3.3 情况三"></a>1.3.3 情况三</h3><p>此时一位专家说：如果有五个人甲乙丙丁戊，甲乙丙三个人同意了方案A，方案A成为了主流意见。丁，戊 2人由于之前手机没电，没收到通知，所以他们下线了。当他们2人开机后（注意此时甲乙丙之间的投票已经结束，方案A成为了主流意见），丁和戊以为主流意见尚未选出，刚好丁也有提议没发出去，所以丁给戊发短信提议了方案B，这个提议是戊开机后第一次收到的提议，根据P1原则，他必须同意他接收到的第一个提议，并将其作为自己的立场，所以戊同意方案B。但这样就会导致戊与甲乙丙他们意见不一致。</p>
<p>一个人意见不一致还好，但因为有这样的漏洞，所以可能最后和主流意见不一致的人会非常多，这不利于我们构建和谐且令人心服的讨论。</p>
<p>于是市长皮皮虾对P2进行了补充，<strong>我们称为P2a:一旦一个提议成为了主流的意见，那么之后的人再次投票的提议内容，必须和主流意见内容一致</strong>。</p>
<p>也就是说，戊在开机后同意的第一个提议必须是方案A才不会出现信息不一致的现象。但戊开机后必须得接受第一个提议（P1原则），并且无法干涉提议中的内容（方案A还是方案B）。所以最好的办法通过某种方式让丁的提议中的内容与甲乙丙的提议相同。这样戊同意的第一个提议就是方案A</p>
<p>于是皮皮虾再次对P2a进行补充，<strong>我们称为P2b:一旦一个提议成为主流意见，那么之后的人再次提议，提议中的内容必须跟主流意见一致。</strong></p>
<p>如何让刚开机的戊提议的内容必须与甲乙丙同意的一致呢？要想达到这一点，只要达到另一个条件即可：</p>
<p><strong>我们称为P2c:存在一个提议A，对于大多数市民来说，要么他们中所有人在同意A前没有同意其他提议，要么他们已经同意的所有提议，内容都和A一模一样。</strong></p>
<p>如果能做到P2c这一点，那么P2b自然就达到了，P2c是P2b的充分条件。也是P2的充分条件。</p>
<h2 id="1-4-paxos流程比喻"><a href="#1-4-paxos流程比喻" class="headerlink" title="1.4 paxos流程比喻"></a>1.4 paxos流程比喻</h2><p>也就是说，要想这个表决机制表决出的结果是真的所有人都认同的，那么必须同时满足P1,P2c(P2的充分条件),那如何设计表决的程序，才能使表决满足P1和P2c呢？</p>
<p>而且P2c条件中，有提议的时间先后概念，在一个只能依靠短信沟通的环境中，如何确定一个提议早于另外一个提议被提出呢？毕竟就算某个提议A比提议B早提出，它也不可能永远比B早到达每一个节点。众人觉得应该引入一个全局的编号，每个提议对应一个编号，用这个编号来表示时间维度的早和晚。但具体如何实施呢？</p>
<p>在众人一筹莫展的时候，一个天才专家站了出来，它设计了一个流程，能够使P1和P2c成立。</p>
<p>专家建议，谁的提议最后被选为了最终提议，可以奖励一个巨量的奖金，这样，每一个提议者都会竭尽所能的让自己的提议成为最终提议（模拟真实paxos实现中proposer始终试图让acceptor接受自己提议的场景）</p>
<p>专家还建议，可以引入贿选机制，每个提议者都可以为自己的提议选定一个贿选金额（模拟实际情况中的全局编号），承诺如果自己的提议成为最终提议，每个接受自己的提议的投票人可以得到该金额。贿选金额维护在一个地方，每个提议者在提议之前都知道目前最高的贿选金额是多少了。</p>
<p>为了得到最后的奖金，每个提议者都会一直提高这个贿选金额（这就模拟了实际中一直自增的全局编号，也合理了为什么accept会投票给后来的提议，因为后来的提议给的钱多啊）。</p>
<p>基于上面两个前提，专家提出了最后的流程，这个表决要分两步：</p>
<ul>
<li>准备阶段，大家先内部讨论一下，不急着投票<ol>
<li>proposer选择一个贿选金额，并将信息以<br> <code>[贿选金额，提议内容]</code><br> 的kv形式广播（prepare请求）。</li>
<li>如果收信人收到 [贿选金额，提议内容] 后。<ul>
<li>如果该提议的金额大于它已经回复的所有提议的金额。那么acceptor将会为了钱出卖自己的上家，将自己上次接受的提议内容以及上家给了他多少钱回复给proposer，即<code>[之前最高的贿选金额，我之前同意的提案内容]</code>，并承诺不再接受小于这个金额的提议。</li>
<li>如果该提议的金额不大于它已经接受的那个提议的金额。那么直接无视。（贿选金额没有吸引力，无视）</li>
</ul>
</li>
</ol>
</li>
<li>同意阶段，经过阶段一，proposer们已经通过acceptor们的反馈知道了每个acceptor的投票承诺。（因为prepare是广播形式，所以会受到全部acceptor的返回，即要么得到接受提议的回馈，表示我接受你的提案了，并且将我上家的提案告诉你。要么我就无视你，无视也是一种表态），<ol>
<li>当proposer<strong>收到多数人接受提议的反馈信息后</strong>，就进入同意阶段（<strong>重点，收到大多数的承诺后才会进入同意阶段</strong>）。它要向反馈给它信息的人再次发送一个请同意该提议的请求（accept请求）,内容为<br><code>[第一步的那个贿选金额，收到的反馈中价码最高的那个提议内容]</code><br>（如果proposer接收到的<strong>所有</strong>回复中都没有acceptor已经接受过的提议内容，则proposer可以自由决定提议内容）  </li>
</ol>
  <strong>注意</strong>，对于某些proposer来说，这里再次发出的提议内容，可能已经和自己之前在第一步的提议不一样了。因为如果他通过acceptor们的反馈（里面包含acceptor们接受的提议），知道了自己之前的提议没有成为主流意见，大伙大多数都同意了另一个给钱最壕的proposer的提议，那么为了彰显自己的正确，它也默默的把提议内容改成了大家都同意的提议内容。<ol start="2">
<li>acceptor接收到请求：<ul>
<li>在不违背向其它人承诺的前提下，收到该提议请求后会立即同意该请求，并回馈一个接受的消息。（即一个acceptor只要尚未响应过任何编号大于N的prepare请求，那么它就可以接受这个编号为N的accept请求）</li>
<li>而如果此时acceptor又叛变了，它接受了一个金额更高（编号更高）的提议，那么，他会无视这个accept请求。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>如果一个proposer发出的accept请求没有得到大多数的回应，那么他就会知道大多数acceptor已经叛变了，无奈之下，他只能重新进入准备阶段，重新选择一个更大的金额（编号n），再去冲击一波。（此时他的提案，就是之前他默默改成的大家都同意的提议）</strong></p>
<p>否则，如果一个proposer发出的accept请求得到了大多数的回应，那么流程结束，该proposer的提案胜出，至于算法如何将胜出的提案通知给 Learner，有如下三种方案，各有优劣</p>
<h2 id="1-5-Learner学习被选定的value"><a href="#1-5-Learner学习被选定的value" class="headerlink" title="1.5 Learner学习被选定的value"></a>1.5 Learner学习被选定的value</h2><p>Learner学习（获取）被选定的value有如下三种方案：<br><img src="https://oscimg.oschina.net/oscnet/f9856c18ffd5c2077b95209a2d0cf256e57.jpg" alt=""></p>
<h2 id="1-6-后述"><a href="#1-6-后述" class="headerlink" title="1.6 后述"></a>1.6 后述</h2><p>Leslie Lamport没有用数学描述Paxos，但是他用英文阐述得很清晰。至于Paxos中一直提到的一个全局唯一且递增的proposer number，其如何实现，引用如下</p>
<blockquote>
<p>如何产生唯一的编号呢？在《Paxos made simple》中提到的是让所有的Proposer都从不相交的数据集合中进行选择，例如系统有5个Proposer，则可为每一个Proposer分配一个标识j(0~4)，则每一个proposer每次提出决议的编号可以为5*i + j(i可以用来表示提出议案的次数)</p>
</blockquote>
<p>除此之外，如何保证paxos的活性<br><img src="https://oscimg.oschina.net/oscnet/153639395f419d81e803cf5bbcdec3c0d1a.jpg" alt=""><br>通过选取主Proposer，就可以保证Paxos算法的活性。至此，我们得到一个既能保证安全性，又能保证活性的分布式一致性算法——Paxos算法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/" itemprop="url">常用shell命令导航</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-21T23:46:16+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/Linux%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">Linux相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/07/21/常用shell命令导航/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  25.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  102
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>导航栏位于右侧，只收录常用命令，按字母表排序</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="alias-设置指令的别名"><a href="#alias-设置指令的别名" class="headerlink" title="alias-设置指令的别名"></a>alias-设置指令的别名</h2><ul>
<li><p>简介：</p>
</li>
<li><p>别名就是一种便捷方式，可以为用户省去输入一长串命令序列的麻烦。Linux alias命令用于设置指令的别名。用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.bashrc中设定指令的别名。</p>
</li>
<li><p>语法：</p>
</li>
<li><p><code>alias[别名]=[指令名称]</code></p>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为apt-get install创建别名。</span><br><span class="line">$ alias install&#x3D;&#39;sudo apt-get install&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;alias命令的效果只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。</span><br><span class="line">&#x2F;&#x2F;为了使别名在所有的shell中都可用，可以将其定义放入~&#x2F;.bashrc文件中。</span><br><span class="line">&#x2F;&#x2F;每当一个新的交互式shell进程生成时，都会执行 ~&#x2F;.bashrc中的命令。</span><br><span class="line">$ echo &#39;alias cmd&#x3D;&quot;command seq&quot;&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们可以创建一个别名rm，它能够删除原始文件，同时在backup目录中保留副本。</span><br><span class="line">$ alias rm&#x3D;&#39;cp $@ ~&#x2F;backup &amp;&amp; rm $@&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>alias命令若不加任何参数，则列出目前所有的别名设置。</p>
</blockquote>
<blockquote>
<p> 如果需要删除别名，只需将其对应的定义（如果有的话）从~/.bashrc中删除，或者使用unalias命令。也可以使用alias example=，这会取消别名example。</p>
</blockquote>
<blockquote>
<p>创建别名时，如果已经有同名的别名存在，那么原有的别名设置将被新的<br>设置取代。</p>
</blockquote>
<blockquote>
<p>如果我们遇到别名和原生命令同名的情况，我们可以转义要使用的命令，忽略当前定义的别名：<br>$ \command<br>字符\可以转义命令，从而执行原本的命令。</p>
</blockquote>
<blockquote>
<p>在不可信环境下执行特权命令时，在命令前加上\来忽略可能存在的别名总是一种良好的安全实践。这是因为攻击者可能已经将一些别有用心的命令利用别名伪装成了特权命令，借此来盗取用户输入的重要信息。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="awk——把文件逐行的读入，以分隔符将其切片，再进行处理。"><a href="#awk——把文件逐行的读入，以分隔符将其切片，再进行处理。" class="headerlink" title="awk——把文件逐行的读入，以分隔符将其切片，再进行处理。"></a>awk——把文件逐行的读入，以分隔符将其切片，再进行处理。</h2><ul>
<li><p>简介：</p>
<ul>
<li>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</li>
<li>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</li>
<li>之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>awk [选项参数] &#39;{pattern + action}&#39; {filenames}</code></li>
<li>尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</li>
<li>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</li>
<li>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-F fs or –field-separator fs</strong></p>
<ul>
<li>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式。在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</li>
</ul>
</li>
<li><p><strong>-v var=value or –asign var=value</strong></p>
<ul>
<li>赋值一个用户定义变量。</li>
</ul>
</li>
<li><p><strong>-f scripfile or –file scriptfile</strong></p>
<ul>
<li>从脚本文件中读取awk命令。</li>
</ul>
</li>
<li><p><strong>-mf nnn and -mr nnn</strong></p>
<ul>
<li>对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li>
</ul>
</li>
<li><p><strong>-W compact or –compat, -W traditional or –traditional</strong></p>
<ul>
<li>在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</li>
</ul>
</li>
<li><p><strong>-W copyleft or –copyleft, -W copyright or –copyright</strong></p>
<ul>
<li>打印简短的版权信息。</li>
</ul>
</li>
<li><p><strong>-W help or –help, -W usage or –usage</strong></p>
<ul>
<li>打印全部awk选项和每个选项的简短说明。</li>
</ul>
</li>
<li><p><strong>-W lint or –lint</strong></p>
<ul>
<li>打印不能向传统unix平台移植的结构的警告。</li>
</ul>
</li>
<li><p><strong>-W lint-old or –lint-old</strong></p>
<ul>
<li>打印关于不能向传统unix平台移植的结构的警告。</li>
</ul>
</li>
</ul>
</li>
<li><p>内建变量</p>
<p>  如下变量在awk中具有特定含义。</p>
<ul>
<li>$n    当前记录的第n个字段，字段间由FS分隔</li>
<li>$0    完整的输入记录</li>
<li>ARGC    命令行参数的数目</li>
<li>ARGIND    命令行中当前文件的位置(从0开始算)</li>
<li>ARGV    包含命令行参数的数组</li>
<li>CONVFMT    数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</li>
<li>ERRNO    最后一个系统错误的描述</li>
<li>FIELDWIDTHS    字段宽度列表(用空格键分隔)</li>
<li>FILENAME    当前文件名</li>
<li>FNR    各文件分别计数的行号</li>
<li>IGNORECASE    如果为真，则进行忽略大小写的匹配</li>
<li>NF    一条记录的字段的数目</li>
<li>NR    已经读出的记录数，就是行号，从1开始</li>
<li>OFMT    数字的输出格式(默认值是%.6g)</li>
<li>OFS    输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</li>
<li>ORS    输出记录分隔符(默认值是一个换行符)</li>
<li>RLENGTH    由match函数所匹配的字符串的长度</li>
<li>RS    记录分隔符(默认是一个换行符)</li>
<li>RSTART    由match函数所匹配的字符串的第一个位置</li>
<li>SUBSEP    数组下标分隔符(默认值是/034)</li>
</ul>
</li>
<li><p>代码示例</p>
<blockquote>
<p>awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。</p>
</blockquote>
<ul>
<li><p>action的使用示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假设last -n 5的输出如下</span><br><span class="line">$ last -n 5 &lt;&#x3D;&#x3D;仅取出前五行</span><br><span class="line">&gt; root     pts&#x2F;1   192.168.1.100  Tue Feb 10 11:21   still logged in</span><br><span class="line">&gt; root     pts&#x2F;1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)</span><br><span class="line">&gt; root     pts&#x2F;1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)</span><br><span class="line">&gt; dmtsai   pts&#x2F;1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)</span><br><span class="line">&gt; root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用awk显示最近登录的5个帐号</span><br><span class="line">$ last -n 5 | awk  &#39;&#123;print $1&#125;&#39;</span><br><span class="line">&gt; root</span><br><span class="line">&gt; root</span><br><span class="line">&gt; root</span><br><span class="line">&gt; dmtsai</span><br><span class="line">&gt; root</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果只是显示&#x2F;etc&#x2F;passwd文件中的账户信息</span><br><span class="line">$ awk  -F &#39;:&#39;  &#39;&#123;print $1&#125;&#39;  &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root</span><br><span class="line">&gt; daemon</span><br><span class="line">&gt; bin</span><br><span class="line">&gt; sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示&#x2F;etc&#x2F;passwd文件中的账户和账户对应的shell信息,而账户与shell之间以tab键分割</span><br><span class="line">$ awk  -F &#39;:&#39;  &#39;&#123;print $1&quot;\t&quot;$7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root    &#x2F;bin&#x2F;bash</span><br><span class="line">&gt; daemon  &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; bin     &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; sys     &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;格式化输出</span><br><span class="line">$ awk &#39;&#123;printf &quot;%-8s %-10s\n&quot;,$1,$7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root       &#x2F;bin&#x2F;bash</span><br><span class="line">&gt; daemon     &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; bin        &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; sys        &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示&#x2F;etc&#x2F;passwd的账户和账户对应的shell,而账户与shell之间以逗号分割</span><br><span class="line">&#x2F;&#x2F;而且在所有行添加列名name,shell,在最后一行添加&quot;blue,&#x2F;bin&#x2F;nosh&quot;。</span><br><span class="line">&#x2F;&#x2F; 遇到BEGIN和END关键字，则二者分别在 读取文件之前 和 所有记录读完之后 执行</span><br><span class="line">$ awk  -F &#39;:&#39;  &#39;BEGIN &#123;print &quot;name,shell&quot;&#125;  &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,&#x2F;bin&#x2F;nosh&quot;&#125;&#39; &#x2F;etc&#x2F;passwd </span><br><span class="line">&gt; name,shell</span><br><span class="line">&gt; root,&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; daemon,&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; bin,&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; sys,&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; blue,&#x2F;bin&#x2F;nosh</span><br></pre></td></tr></table></figure></li>
<li><p>pattern使用示例 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 搜索&#x2F;etc&#x2F;passwd有root关键字的所有行,</span><br><span class="line">$ awk -F: &#39;&#x2F;root&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;&#x2F; 匹配了pattern(这里是root)的行才会执行action(本例未指定action，默认输出每行的内容，即$0，下例指定action)。</span><br><span class="line">&#x2F;&#x2F; 搜索支持正则，例如找root开头的: awk -F: &#39;&#x2F;^root&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定action&#123;print $7&#125;。搜索&#x2F;etc&#x2F;passwd有root关键字的所有行，并显示对应的shell</span><br><span class="line">$ awk -F: &#39;&#x2F;root&#x2F;&#123;print $7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列大于2的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1&gt;2&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列等于2的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1&#x3D;2&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列大于2并且第二列等于&#39;Are&#39;的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1&gt;2 &amp;&amp; $2&#x3D;&#x3D;&quot;Are&quot;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列包含 &quot;th&quot;的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1 ~ &#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列包含 &quot;th&quot;的行,忽略大小写(action就不指定了)</span><br><span class="line">$ awk &#39;BEGIN&#123;IGNORECASE&#x3D;1&#125; $1 ~ &#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列不包含 &quot;th&quot;的行,忽略大小写(action就不指定了)</span><br><span class="line">$ awk &#39;BEGIN&#123;IGNORECASE&#x3D;1&#125; $1 !~ &#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤整行不包含 &quot;th&quot;的行,忽略大小写(action就不指定了)</span><br><span class="line">$ awk &#39;BEGIN&#123;IGNORECASE&#x3D;1&#125; !&#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure></li>
<li><p>变量赋值和使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 内建变量赋值。使用BEGIN替代-F,其中FS是awk内建变量</span><br><span class="line">$ awk  &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125; &#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root</span><br><span class="line">&gt; daemon</span><br><span class="line">&gt; bin</span><br><span class="line">&gt; sys</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内建变量使用。使用BEGIN替代-F,其中FS是awk内建变量，并且打印文件名，使用FILENAME内建变量</span><br><span class="line">$ awk  &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125; &#123;print FILENAME,$1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd root</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd daemon</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd bin</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd sys</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-v变量赋值用法</span><br><span class="line">$ awk -F: -va&#x3D;1 -vb&#x3D;s &#39;&#x2F;root&#x2F;&#123;print $7,$7+a,$7b&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;bash 1 &#x2F;bin&#x2F;bashs</span><br><span class="line">&gt; &#x2F;bin&#x2F;false 1 &#x2F;bin&#x2F;falses</span><br><span class="line">&#x2F;&#x2F;BEGIN同理</span><br><span class="line">$ awk -F: &#39;BEGIN &#123;a&#x3D;1;b&#x3D;s&#125; &#x2F;root&#x2F;&#123;print $7,$7+a,$7b&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;bash 1 &#x2F;bin&#x2F;bashs</span><br><span class="line">&gt; &#x2F;bin&#x2F;false 1 &#x2F;bin&#x2F;falses</span><br></pre></td></tr></table></figure></li>
<li><p>其他一些实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;计算文件大小</span><br><span class="line">$ ls -l *.txt | awk &#39;&#123;sum+&#x3D;$6&#125; END &#123;print sum&#125;&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从文件中找出长度大于80的行</span><br><span class="line">$ awk &#39;length&gt;80&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>awk还支持条件语句和循环，使用较少，本文不再展开。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="cat-连接文件或标准输入至标准输出"><a href="#cat-连接文件或标准输入至标准输出" class="headerlink" title="cat-连接文件或标准输入至标准输出"></a>cat-连接文件或标准输入至标准输出</h2><ul>
<li><p>简介：</p>
</li>
<li><p>cat命令是linux下的一个文本输出命令，其功能是连接文件或标准输入至标准输出，常用于显示文件内容 。cat是concatenate(串联)的缩写。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>cat [选项参数] [--help] [--version] fileName</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-n 或 –number</strong></p>
<ul>
<li>由 1 开始对所有输出的行数编号。</li>
</ul>
</li>
<li><p><strong>-b 或 –number-nonblank</strong></p>
<ul>
<li>和 -n 相似，只不过对于空白行不编号。</li>
</ul>
</li>
<li><p><strong>-s 或 –squeeze-blank</strong></p>
<ul>
<li>当遇到有连续两行以上的空白行，就代换为一行的空白行。</li>
</ul>
</li>
<li><p><strong>-v 或 –show-nonprinting</strong></p>
<ul>
<li>以^和M-显示不可打印字符，除LFD与TAB </li>
</ul>
</li>
<li><p><strong>-E 或 –show-ends</strong></p>
<ul>
<li>在每行结束处显示 $。</li>
</ul>
</li>
<li><p><strong>-T 或 –show-tabs</strong></p>
<ul>
<li>将 TAB 字符显示为 ^I。这有助于排查缩进错误。</li>
</ul>
</li>
<li><p><strong>-A, –show-all</strong></p>
<ul>
<li>等价于-vET显示所有，以$结尾。</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
<ul>
<li>在每行行尾添加$,用以标记</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>等价于”-vT”选项；</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//打印多个文件的内容</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat one.txt two.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> This line is from one.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> This line is from two.txt</span></span><br><span class="line"></span><br><span class="line">//将stdin和另一个文件中的数据组合在一起，其中-被作为stdin文本的文件名。</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'Text through stdin'</span> | cat - file.txt</span></span><br><span class="line"></span><br><span class="line">//把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat -n textfile1 &gt; textfile2</span></span><br><span class="line"></span><br><span class="line">//把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat -b textfile1 textfile2 &gt;&gt; textfile3</span></span><br><span class="line"></span><br><span class="line">//有时候，我们只希望抓取文件中感兴趣的关键字</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat fileName | grep keyword</span></span><br><span class="line"></span><br><span class="line">//清空某个文件内容</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /dev/null &gt; /test.txt</span></span><br><span class="line"></span><br><span class="line">//创建文件，并把标准输入输出到filename文件中</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat&gt;filename，</span></span><br><span class="line"></span><br><span class="line">//以EOF作为输入结束，将输入流重定向覆盖filename文件，可用于创建文件，追加使用&gt;&gt;</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat&gt;filename&lt;&lt;EOF</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>现在我们知道cat &lt;&lt; EOF语句表示 打印以EOF输入字符为标准输入结束的流内容，EOF是“end of file”，        表示文本结束符。用在这里起到什么作用？首先必须要说明的是EOF在这里没有特殊的含义，你可以使用FOE或        OOO等（当然也不限制在三个字符或大写字符）可以把EOF替换成其他东西。cat &lt;&lt; OOF的含义即为打印以OOF输入字符为标准输入结束的流内容，代码如下图<br><img src="https://oscimg.oschina.net/oscnet/69fc8c9ccaff98a782091232365f03a9898.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>cat&gt;filename，创建文件，并把标准输入输出到filename文件中，以ctrl+d作为输入结束。</p>
</blockquote>
<blockquote>
<p>cat&gt;filename&lt;&lt;EOF等价于cat&lt;<EOF>filename,执行顺序固定是输入早于输出<br><img src="https://oscimg.oschina.net/oscnet/8cf56f84669c53afd935f5ee1def0b64841.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="cd——切换当前工作目录"><a href="#cd——切换当前工作目录" class="headerlink" title="cd——切换当前工作目录"></a>cd——切换当前工作目录</h2><ul>
<li><p>简介：</p>
<ul>
<li>Linux cd命令用于切换当前工作目录至 dirName(目录参数)。</li>
<li>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</li>
<li>另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录；”-“表示上次所在目录</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>cd [dirName]</code></li>
<li>dirName：要切换的目标目录。</li>
</ul>
</li>
<li><p>选项值：</p>
</li>
</ul>
<ul>
<li>代码示例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;跳到 &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">$ cd &#x2F;usr&#x2F;bin</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳到自己的 home 目录</span><br><span class="line">$ cd ~</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳到目前目录的上层</span><br><span class="line">$ cd ..</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳到目前目录的上上两层</span><br><span class="line">$ cd ..&#x2F;..</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回之前的目录</span><br><span class="line">$ cd -</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="chmod-设置文件权限"><a href="#chmod-设置文件权限" class="headerlink" title="chmod-设置文件权限"></a>chmod-设置文件权限</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux/Unix 的文件调用权限分为三级：用户，用户组，其他用户。利用 chmod 可以藉以控制文件如何被他人所调用。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>chmod [选项参数]  mode filename</code></li>
<li>其中mode为权限设定字串，格式如下<code>[ugoa...][[+-=][rwxX]...][,...]</code><ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个用户组(group)者，o 表示其他用户，a 表示这三者皆是。</li>
<li>+表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
<li>x 权限的位置上还可能出现t表示文件有执行权限并设置了粘滞位权限、T表示文件没有执行权限并设置了粘滞位权限、S表示setuid（S）的特殊权限，setuid权限允许可执行文件以其拥有者的权限来执行，即使这个可执行文件是由其他用户运行的。</li>
<li>同时，mode也可以使用3位八进制数来表示，每一位按顺序分别对应用户、用户组和其他用户。其中r=4，w=2，x=1。所以：<ul>
<li>rwx属性：4+2+1=7；</li>
<li>rw-属性：4+2=6；</li>
<li>r-x属性：4+1=5；</li>
<li>以此类推…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-c</strong></p>
<ul>
<li>若该文件权限确实已经更改，才显示其更改动作</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>若该文件权限无法被更改也不要显示错误讯息</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>显示权限变更的详细资料</li>
</ul>
</li>
<li><p><strong>-R</strong></p>
<ul>
<li>对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助说明</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将文件 file1.txt 设为所有人皆可读取</span><br><span class="line">$ chmod ugo+r file1.txt</span><br><span class="line">或</span><br><span class="line">$ chmod a+r file1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 file1.txt 设定为只有该文件拥有者可以执行 :</span><br><span class="line">$ chmod u+x file1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一用户组的用户可写入，但其他以外的人则不可写入 </span><br><span class="line">$ chmod ug+w,o-w file1.txt file2.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将目前目录下的所有文件与子目录皆设为任何人可读取 :</span><br><span class="line">$ chmod -R a&#x3D;rwx *</span><br><span class="line">或</span><br><span class="line">$ chmod 777 . -R</span><br><span class="line">或</span><br><span class="line">$  chmod 777 &quot;$(pwd)&quot; -R</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给所有用户赋值读写执行权限</span><br><span class="line">$ chmod a&#x3D;rwx file</span><br><span class="line">或</span><br><span class="line">$ chmod 777 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给文件拥有用户和其相同用户组用户读写执行权限，其他用户可执行权限。</span><br><span class="line">$ chmod ug&#x3D;rwx,o&#x3D;x file</span><br><span class="line">或</span><br><span class="line">$ chmod 771 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给特定目录加粘滞位权限（设置粘滞位后，只有目录的所有者才能够删除目录中的文件，即使其他人有该目录的写权限也无法执行删除操作。）</span><br><span class="line">$ chmod a+t directoryName</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>chmod 4755 filename 使此程序具有root的权限</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="chown-更改文件或目录的所有权"><a href="#chown-更改文件或目录的所有权" class="headerlink" title="chown-更改文件或目录的所有权"></a>chown-更改文件或目录的所有权</h2><ul>
<li>简介：<ul>
<li>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</li>
</ul>
</li>
</ul>
<pre><code>- 一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</code></pre><ul>
<li><p>语法：</p>
<ul>
<li><code>chown [选项参数] [--help] [--version] user[:group] file...</code></li>
<li>其中user表示新的文件拥有者的使用者 ID。group表示新的文件拥有者的使用者组(group)</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-c</strong></p>
<ul>
<li>显示更改的部分的信息</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>忽略错误信息</li>
</ul>
</li>
<li><p><strong>-h</strong></p>
<ul>
<li>修复符号链接</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>显示详细的处理信息</li>
</ul>
</li>
<li><p><strong>-R</strong></p>
<ul>
<li>处理指定目录以及其子目录下的所有文件</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助说明</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</span><br><span class="line">$ chown runoob:runoobgroup file1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将目前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</span><br><span class="line">$ chown -R runoob:runoobgroup *</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="cp-于复制文件或目录"><a href="#cp-于复制文件或目录" class="headerlink" title="cp-于复制文件或目录"></a>cp-于复制文件或目录</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux cp命令主要用于复制文件或目录。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>cp [options] source dest 或 cp [options] source... directory</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li>
</ul>
</li>
<li><p><strong>-d</strong></p>
<ul>
<li>复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>覆盖已经存在的目标文件而不给出提示。</li>
</ul>
</li>
<li><p><strong>-i</strong></p>
<ul>
<li>与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>不复制文件，只是生成链接文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用指令&quot;cp&quot;将当前目录&quot;test&#x2F;&quot;下的所有文件复制到新目录&quot;newtest&quot;下</span><br><span class="line">$ cp –r test&#x2F; newtest</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>用户使用该指令复制目录时，必须使用参数”-r”或者”-R”。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="curl——发送各种HTTP请求"><a href="#curl——发送各种HTTP请求" class="headerlink" title="curl——发送各种HTTP请求"></a>curl——发送各种HTTP请求</h2><ul>
<li><p>简介：</p>
<ul>
<li>curl命令的用途广泛，其功能包括下载、发送各种HTTP请求以及指定HTTP头部。</li>
<li>cURL默认会将下载文件输出到stdout，将进度信息输出到stderr。如果不想显示进度信息，可以使用–silent选项</li>
<li>cURL可以使用HTTP、HTTPS、FTP协议在客户端与服务器之间传递数据。它支持POST、cookie、认证、从指定偏移处下载部分文件、参照页（referer）、用户代理字符串、扩展头部、限速、文件大小限制、进度条等特性。cURL可用于网站维护、数据检索以及服务器配置核对。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>curl [选项] url</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>–silent</strong></p>
<ul>
<li>不显示进度信息</li>
</ul>
</li>
<li><p><strong>-O</strong></p>
<ul>
<li>指明将下载数据写入文件，采用从URL中解析出的文件名。注意，其中的URL必须是完整的，不能仅是站点的域名</li>
<li><code>$ curl www.knopper.net/index.htm -O</code></li>
</ul>
</li>
<li><p><strong>-o</strong></p>
<ul>
<li>指明将下载数据写入文件，可以指定输出文件名。如果使用了该选项，只需要写明站点的域名就可以下载其主页了</li>
<li><code>$ curl www.knopper.net -o knoppix_index.html</code></li>
</ul>
</li>
<li><p><strong>–progress</strong></p>
<ul>
<li>在下载过程中显示形如#的进度条</li>
<li><code>$ curl http://knopper.net -o index.html --progress</code><br>################################## 100.0%</li>
</ul>
</li>
<li><p><strong>-C</strong></p>
<ul>
<li>够从特定的文件偏移处继续下载，偏移量是以字节为单位的整数。</li>
<li><code>$ curl URL/file -C offset</code></li>
<li>如果只是想断点续传，那么cURL不需要指定准确的字节偏移。要是你希望cURL推断出正确的续传位置，请使用选项-C -。cURL会自动计算出应该从哪里开始续传</li>
<li><code>$ curl -C - www.xxx.com</code></li>
</ul>
</li>
<li><p><strong>–referer</strong></p>
<ul>
<li>指定参照页字符串。参照页（referer）①是位于HTTP头部中的一个字符串，用来标识用户是从哪个页面到达当前页面的。如果用户通过点击页面A中的某个链接跳转到了页面B，那么页面B头部的参照页字符串就会包含页面A的URL。</li>
<li>一些动态页面会在返回HTML数据前检测参照页字符串。例如，如果用户是通过Google搜索来到了当前页面，那么页面上就可以显示一个Google的logo；</li>
<li><code>$ curl --referer Referer_URL target_URL 如 $ curl --referer http://google.com http://knopper.org</code></li>
</ul>
</li>
<li><p><strong>–cookie</strong></p>
<ul>
<li>指定储HTTP操作过程中使用到的cookie，cookies需要以name=value的形式来给出。多个cookie之间使用分号分隔</li>
<li><code>$ curl http://example.com --cookie &quot;user=username;pass=hack&quot;</code></li>
</ul>
</li>
<li><p><strong>–cookie-jar</strong></p>
<ul>
<li>可以将cookie另存为文件</li>
<li><code>$ curl URL --cookie-jar cookie_file</code></li>
</ul>
</li>
<li><p><strong>-b <filename></strong></p>
<ul>
<li>指定以一个存储了Cookie值的本地文件内容作为cookie</li>
<li><code>$ curl -b stored_cookies_in_file www.baidu.com</code></li>
</ul>
</li>
<li><p><strong>–user-agent或-A</strong></p>
<ul>
<li>设置用户代理字符串,如果不指定用户代理（user agent），一些需要检验用户代理的页面就无法显示。例如，有些旧网站只能在Internet Explorer（IE）下正常工作。如果使用其他浏览器，则会提示只能用IE访问。这是因为这些网站检查了用户代理。</li>
<li><code>$ curl URL --user-agent &quot;Mozilla/5.0&quot;</code></li>
</ul>
</li>
<li><p><strong>-H</strong></p>
<ul>
<li>发送HTTP头部信息</li>
<li><code>$ curl -H &quot;Host: www.knopper.net&quot; -H &quot;Accept-language: en&quot; URL</code></li>
</ul>
</li>
<li><p><strong>–limit-rate</strong></p>
<ul>
<li>如果多个用户共享带宽有限，我们可以用–limit-rate限制cURL的下载速度。在命令中用k（千字节）和m（兆字节）指定下载速度限制</li>
<li><code>$ curl URL --limit-rate 20k</code></li>
</ul>
</li>
<li><p><strong>–max-filesize</strong></p>
<ul>
<li>指定可下载的最大文件大小。如果文件大小超出限制，命令返回一个非0的退出码。如果文件下载成功，则返回0。</li>
<li><code>$ curl URL --max-filesize bytes</code></li>
</ul>
</li>
<li><p><strong>-u</strong></p>
<ul>
<li>指定用户名和密码完成HTTP或FTP认证</li>
<li><code>$ curl -u user:pass http://test_auth.com</code></li>
<li>如果你喜欢经提示后输入密码，只需要使用用户名即可</li>
<li><code>$ curl -u user http://test_auth.com</code></li>
</ul>
</li>
<li><p><strong>-I 或–head</strong></p>
<ul>
<li>只打印HTTP头部信息，无须下载远程文件。只检查头部信息就足以完成很多检查或统计。例如，如果要检查某个页面是否能够打开，并不需要下载整个页面内容。只读取HTTP响应头部就足够了。</li>
<li><code>$ curl -I http://knopper.net</code></li>
</ul>
</li>
<li><p><strong>-E或–cert</strong></p>
<ul>
<li>指定本地证书</li>
<li><code>$ curl -E mycert.pem https:/itbilu.com</code></li>
</ul>
</li>
<li><p><strong>-T 或–upload-file</strong></p>
<ul>
<li>上传文件</li>
<li><code>$ curl -T ./index.html www.uploadhttp.com/receive.cgi</code></li>
</ul>
</li>
<li><p><strong>-d 或–data</strong></p>
<ul>
<li>POST提交表单数据</li>
<li><code>$ curl -X POST --data &#39;keyword=linux&#39; itbilu.com</code></li>
</ul>
</li>
<li><p><strong>-X</strong></p>
<ul>
<li>拓展http请求方法，使curl支持put，delete等</li>
<li><code>$ curl -X DELETE itbilu.com/examlple.html</code></li>
<li><code>$ curl -X PUT --data &#39;keyword=linux&#39; itbilu.com</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;访问一个网页时，可以使用curl命令后加上要访问的网址</span><br><span class="line">$ curl www.baidu.com</span><br><span class="line">&gt; &lt;!DOCTYPE html&gt;</span><br><span class="line">&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv&#x3D;content-type content&#x3D;text&#x2F;html;...</span><br><span class="line">&#x2F;&#x2F;我们就看到所访问网址的页面源码。</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="cut——按列切分文件"><a href="#cut——按列切分文件" class="headerlink" title="cut——按列切分文件"></a>cut——按列切分文件</h2><ul>
<li><p>简介：</p>
<ul>
<li>cut命令能够提取指定位置或列之间的字符。你可以指定每列的分隔符。在cut的术语中，每列被称为一个字段。</li>
<li>cut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、CSV文件或是由空格分隔的文件（例如标准日志文件）。</li>
<li>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>cut  [选项参数] [file]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-b <range></strong></p>
<ul>
<li>以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</li>
<li>range可以为如下格式，如cut -b 2-5 file<ul>
<li>N-：从第N个字节、字符、字段到结尾；</li>
<li>N-M：从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段；</li>
<li>-M：从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>-c <range></strong></p>
<ul>
<li>以字符为单位进行分割。</li>
<li>range可以为如下格式，如cut -c 2-5 file<ul>
<li>N-：从第N个字节、字符、字段到结尾；</li>
<li>N-M：从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段；</li>
<li>-M：从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>-d</strong></p>
<ul>
<li>自定义分隔符，默认为制表符。</li>
</ul>
</li>
<li><p><strong>-f <FIELD_LIST></strong></p>
<ul>
<li>指定要提取的列。FIELD_LIST是需要显示的列。它由列号组成，彼此之间用逗号分隔。</li>
</ul>
</li>
<li><p><strong>-n</strong></p>
<ul>
<li>取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除</li>
</ul>
</li>
<li><p><strong>–complement</strong></p>
<ul>
<li>显示出没有被-f指定的那些字段。</li>
</ul>
</li>
<li><p><strong>–output-delimiter</strong></p>
<ul>
<li>指定输出分隔符。在显示多组数据时，该选项尤为有用</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从使用制表符作为分隔符的文件中提取列</span><br><span class="line">$ cat student_data.txt </span><br><span class="line">&gt; No Name Mark Percent </span><br><span class="line">&gt; 1 Sarath 45 90 </span><br><span class="line">&gt; 2 Alex 49 98 </span><br><span class="line">&gt; 3 Anu 45 90</span><br><span class="line">$ cut -f 1 student_data.txt</span><br><span class="line">&gt; No </span><br><span class="line">&gt; 1 </span><br><span class="line">&gt; 2 </span><br><span class="line">&gt; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;要想提取多个字段，就得给出由逗号分隔的多个字段编号</span><br><span class="line">$ cut -f 2,4 student_data.txt </span><br><span class="line">&gt; Name Percent </span><br><span class="line">&gt; Sarath 90 </span><br><span class="line">&gt; Alex 98 </span><br><span class="line">&gt; Anu 90</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用cut处理由分号分隔的字段</span><br><span class="line">$ cat delimited_data.txt</span><br><span class="line">&gt; No;Name;Mark;Percent </span><br><span class="line">&gt; 1;Sarath;45;90 </span><br><span class="line">&gt; 2;Alex;49;98 </span><br><span class="line">&gt; 3;Anu;45;90</span><br><span class="line">$ cut -f2 -d&quot;;&quot; delimited_data.txt</span><br><span class="line">&gt; Name </span><br><span class="line">&gt; Sarath </span><br><span class="line">&gt; Alex </span><br><span class="line">&gt; Anu</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印第2个到第5个字符</span><br><span class="line">$ cat range_fields.txt</span><br><span class="line">&gt; abcdefghijklmnopqrstuvwxyz </span><br><span class="line">&gt; abcdefghijklmnopqrstuvwxyz </span><br><span class="line">&gt; abcdefghijklmnopqrstuvwxyz</span><br><span class="line">&#x2F;&#x2F;打印第2个到第5个字符</span><br><span class="line">$ cut -c2-5 range_fields.txt</span><br><span class="line">&gt; ab </span><br><span class="line">&gt; ab </span><br><span class="line">&gt; ab </span><br><span class="line">&#x2F;&#x2F;--output-delimiter指定输出分隔符</span><br><span class="line">$ cut range_fields.txt -c1-3,6-9 --output-delimiter &quot;,&quot;</span><br><span class="line">&gt; abc,fghi </span><br><span class="line">&gt; abc,fghi </span><br><span class="line">&gt; abc,fghi</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="date-显示或设定系统的日期与时间"><a href="#date-显示或设定系统的日期与时间" class="headerlink" title="date-显示或设定系统的日期与时间"></a>date-显示或设定系统的日期与时间</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>date [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help] [--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-d datestr</strong></p>
<ul>
<li>显示 datestr 中所设定的时间 (非系统时间)</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助讯息</li>
</ul>
</li>
<li><p><strong>-s datestr 或 –set</strong></p>
<ul>
<li>将系统时间设为 datestr 中所设定的时间</li>
</ul>
</li>
<li><p><strong>-u 或 –utc</strong></p>
<ul>
<li>显示目前的格林威治时间</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本编号</li>
</ul>
</li>
<li><p><strong>–date</strong></p>
<ul>
<li>显示该选项指定的输入日期所设定的时间</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>格式字段datestr必须以+号开头</p>
</blockquote>
<blockquote>
<p>当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。</p>
</blockquote>
<blockquote>
<p>date命令的最小精度是秒</p>
</blockquote>
<blockquote>
<p>只有取得权限者(比如说 root)才能设定系统时间。当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。</p>
</blockquote>
<blockquote>
<p>datestr的值有如下这些可选：</p>
</blockquote>
<ul>
<li><p><strong>%</strong></p>
<ul>
<li>印出 %</li>
</ul>
</li>
<li><p><strong>%n</strong></p>
<ul>
<li>下一行</li>
</ul>
</li>
<li><p><strong>%t</strong></p>
<ul>
<li>跳格，一个tab</li>
</ul>
</li>
<li><p><strong>%H</strong></p>
<ul>
<li>小时(00-23)</li>
</ul>
</li>
<li><p><strong>%I</strong></p>
<ul>
<li>小时(01-12)</li>
</ul>
</li>
<li><p><strong>%k</strong></p>
<ul>
<li>小时(0-23)</li>
</ul>
</li>
<li><p><strong>%l</strong></p>
<ul>
<li>小时(1-12)</li>
</ul>
</li>
<li><p><strong>%M</strong></p>
<ul>
<li>分钟(00-59)</li>
</ul>
</li>
<li><p><strong>%p</strong></p>
<ul>
<li>显示本地 AM 或 PM</li>
</ul>
</li>
<li><p><strong>%S</strong></p>
<ul>
<li>秒(00-61)</li>
</ul>
</li>
<li><p><strong>%T</strong></p>
<ul>
<li>直接显示时间 (24 小时制)</li>
</ul>
</li>
<li><p><strong>%Z</strong></p>
<ul>
<li>显示时区</li>
</ul>
</li>
<li><p><strong>%a</strong></p>
<ul>
<li>星期几 (Sun-Sat)</li>
</ul>
</li>
<li><p><strong>%A</strong></p>
<ul>
<li>星期几 (Sunday-Saturday)</li>
</ul>
</li>
<li><p><strong>%b</strong></p>
<ul>
<li>月份 (Jan-Dec)</li>
</ul>
</li>
<li><p><strong>%B</strong></p>
<ul>
<li>月份 (January-December)</li>
</ul>
</li>
<li><p><strong>%c</strong></p>
<ul>
<li>直接显示日期与时间</li>
</ul>
</li>
<li><p><strong>%d</strong></p>
<ul>
<li>日 (01-31)</li>
</ul>
</li>
<li><p><strong>%D</strong></p>
<ul>
<li>直接显示日期 (mm/dd/yy)</li>
</ul>
</li>
<li><p><strong>%h</strong></p>
<ul>
<li>同 %b</li>
</ul>
</li>
<li><p><strong>%j</strong></p>
<ul>
<li>一年中的第几天 (001-366)</li>
</ul>
</li>
<li><p><strong>%m</strong></p>
<ul>
<li>月份 (01-12)</li>
</ul>
</li>
<li><p><strong>%U</strong></p>
<ul>
<li>一年中的第几周 (00-53) (以 Sunday 为一周的第一天的情形)</li>
</ul>
</li>
<li><p><strong>%w</strong></p>
<ul>
<li>一周中的第几天 (0-6)</li>
</ul>
</li>
<li><p><strong>%W</strong></p>
<ul>
<li>一年中的第几周 (00-53) (以 Monday 为一周的第一天的情形)</li>
</ul>
</li>
<li><p><strong>%x</strong></p>
<ul>
<li>直接显示日期 (mm/dd/yy)</li>
</ul>
</li>
<li><p><strong>%y</strong></p>
<ul>
<li>年份的最后两位数字 (00-99)</li>
</ul>
</li>
<li><p><strong>%Y</strong></p>
<ul>
<li>完整年份 (0000-9999)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>代码示例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;读取当前时间</span><br><span class="line">$ date</span><br><span class="line">&gt; Thu May 20 23:09:04 IST 2010</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印unix时间</span><br><span class="line">$ date +%s</span><br><span class="line">&gt; 1290047248</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将输入的时间转换成unix时间</span><br><span class="line">$ date --date &quot;Wed mar 15 08:09:16 EDT 2017&quot; +%s</span><br><span class="line">&gt; 1489579718</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取当前时间</span><br><span class="line">$ date &quot;+%d %B %Y&quot;</span><br><span class="line">&gt; 20 May 2010</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置日期和时间</span><br><span class="line">$ date -s &quot;21 June 2009 11:01:22&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示时间后换行，再显示目前日期</span><br><span class="line">$ date &#39;+%T%n%D&#39;</span><br><span class="line">&gt;23:09:00</span><br><span class="line">&gt;07&#x2F;09&#x2F;19</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按自己的格式输出</span><br><span class="line">$ date &#39;+usr_time: $1:%M %P -hey&#39;</span><br><span class="line">&gt; usr_time: $1:16 下午 -hey</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="echo-打印内容"><a href="#echo-打印内容" class="headerlink" title="echo-打印内容"></a>echo-打印内容</h2><ul>
<li><p>简介：</p>
</li>
<li><p>echo命令是linux中最基础的命令,也是很常用的命令,功能说明用以显示文字。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>echo [-ne][字符串]或 echo [--help][--version]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-n</strong></p>
<ul>
<li>echo会在输出文本的尾部追加一个换行符。可以使用选项-n来禁止这种行为。</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">激活转义字符。使用-e选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：</span><br><span class="line">\a 发出警告声；</span><br><span class="line">\b 删除前一个字符；</span><br><span class="line">\c 最后不加上换行符号；</span><br><span class="line">\f 换行但光标仍旧停留在原来的位置；</span><br><span class="line">\n 换行且光标移至行首；</span><br><span class="line">\r 光标移至行首，但不换行；</span><br><span class="line">\t 插入tab；</span><br><span class="line">\v 与\f相同；</span><br><span class="line">\\ 插入\字符；</span><br><span class="line">\e 打印彩色文本 </span><br><span class="line">	文本颜色是由对应的色彩码来描述的。其中包括：重置&#x3D;0，黑色&#x3D;30，红色&#x3D;31，绿色&#x3D;32，黄色&#x3D;33，蓝色&#x3D;34，洋红&#x3D;35，青色&#x3D;36，白色&#x3D;37。</span><br><span class="line">	对于彩色背景，经常使用的颜色码是：重置&#x3D;0，黑色&#x3D;40，红色&#x3D;41，绿色&#x3D;42，黄色&#x3D;43，蓝色&#x3D;44，洋红&#x3D;45，青色&#x3D;46，白色&#x3D;47。</span><br><span class="line">	用法：echo -e &quot;\e[1;31m This is red text \e[0m&quot; </span><br><span class="line">	其中\e[1;31m是一个转义字符串，可以将颜色设为红色，\e[0m将颜色重新置回。</span><br><span class="line">\nnn 插入nnn（八进制）所代表的ASCII字符；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>echo的单引号不会解释文本中的特殊字符，双引号会。</p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ a&#x3D;1;</span><br><span class="line">- echo &#39;$a+1&#39;</span><br><span class="line">&gt; a+1</span><br><span class="line">$ echo &quot;$a+1&quot;</span><br><span class="line">&gt; 1+1</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="find-查找文件"><a href="#find-查找文件" class="headerlink" title="find-查找文件"></a>find-查找文件</h2><ul>
<li><p>简介：</p>
<ul>
<li>find命令的工作方式如下：沿着文件层次结构向下遍历，匹配符合条件的文件，执行相应<br>的操作。默认的操作是打印出文件和目录，这也可以使用-print选项来指定。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-mount或 -xdev</strong></p>
<ul>
<li>只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</li>
</ul>
</li>
<li><p><strong>-newer file</strong></p>
<ul>
<li>找出比file文件更新的（更近的修改时间）所有文件。</li>
</ul>
</li>
<li><p><strong>-anewer file</strong></p>
<ul>
<li>查找比文件 file 更晚被读取过的文件</li>
</ul>
</li>
<li><p><strong>-cnewer file</strong></p>
<ul>
<li>查找比文件 file 更新的文件</li>
</ul>
</li>
<li><p><strong>-amin n</strong></p>
<ul>
<li>根据用户最近一次访问文件的时间查找，查找在过去 n 分钟内被读取过的文件,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-atime n</strong></p>
<ul>
<li>根据用户最近一次访问文件的时间查找，查找在过去 n 天内被读取过的文件,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-cmin n</strong></p>
<ul>
<li>根据文件元数据（例如权限或所有权）最后一次改变的时间查找，查找在过去 n 分钟内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-ctime n</strong></p>
<ul>
<li>根据文件元数据（例如权限或所有权）最后一次改变的时间查找，查找在过去 n 天内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-mtime n</strong></p>
<ul>
<li>根据文件内容最后一次被修改的时间查找，查找在过去 n 分钟内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-mmin n</strong></p>
<ul>
<li>根据文件内容最后一次被修改的时间查找，查找在过去 n 天内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-ipath p, -path p</strong></p>
<ul>
<li>查找路径名称符合 p 的文件，ipath 会忽略大小写。p一般可以为通配符如’<em>/slynux/</em>‘</li>
</ul>
</li>
<li><p><strong>-regex r,-iregex r</strong></p>
<ul>
<li>查找路径名称符合 r 的文件。r 一般可以为正则表达式</li>
</ul>
</li>
<li><p><strong>-name name, -iname name</strong></p>
<ul>
<li>查找文件名称符合 name 的文件。iname 会忽略大小写。这个模式可以是通配符，也可以是正则表达式。如’*.txt’能够匹配所有名字以.txt结尾的文件或目录</li>
</ul>
</li>
<li><p><strong>-size n</strong></p>
<ul>
<li>可以根据文件的大小展开搜索，n可以为+2k，数字前面可以加上-或+。-表示小于，+表示大于。单位取值可以为<ul>
<li>b：块（512字节）。</li>
<li>c：字节。</li>
<li>w：字（2字节）。</li>
<li>k：千字节（1024字节）。</li>
<li>M：兆字节（1024K字节）。</li>
<li>G：吉字节（1024M字节）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>-maxdepth n,–mindepth n</strong></p>
<ul>
<li>-maxdepth和–mindepth选项可以限制find命令遍历的目录深度。这可以避免find命令没完没了地查找。</li>
</ul>
</li>
<li><p><strong>–user USER</strong></p>
<ul>
<li>找出由某个特定用户权限下所拥有的文件。参数USER可以是用户名或UID。</li>
</ul>
</li>
<li><p><strong>-prune n</strong></p>
<ul>
<li>在搜索时排除某些文件或目录,一般与其他选项一起使用，如.git目录应该被排除在外：<br><code>$ find devel/source_path -name &#39;.git&#39; -prune -o -type f -print</code></li>
</ul>
</li>
<li><p><strong>-perm n</strong></p>
<ul>
<li>指明find应该只匹配具有特定权限值的文件。n为文件权限<br><code>$ find devel/source_path -name &#39;.git&#39; -prune -o -type f -print</code></li>
</ul>
</li>
<li><p><strong>pid n</strong></p>
<ul>
<li>process id 是 n 的文件</li>
</ul>
</li>
<li><p><strong>-type t</strong></p>
<ul>
<li><p>类Unix系统将一切都视为文件。文件具有不同的类型，例如普通文件、目录、字符设备、块<br>设备、符号链接、硬链接、套接字以及FIFO等。可以使用-type选项对文件搜索进行过滤。借助这个选项，我们可以告诉find命令只匹配指定类型的文件。t的取值可以是</p>
<ul>
<li><p>d：目录</p>
</li>
<li><p>c: 字符设备</p>
</li>
<li><p>b: 块设备</p>
</li>
<li><p>p: FIFO具名贮列</p>
</li>
<li><p>f: 一般文件</p>
</li>
<li><p>l: 符号链接</p>
</li>
<li><p>s: socket套接字</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;列出给定目录下所有的文件和子目录 find base_path</span><br><span class="line">$ find . -print</span><br><span class="line">&gt; .history </span><br><span class="line">&gt; Downloads</span><br><span class="line">&gt; Downloads&#x2F;tcl.fossil </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;够匹配所有名字以.txt结尾的文件或目录。</span><br><span class="line">$ find &#x2F;home&#x2F;slynux -name &#39;*.txt&#39; -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;find命令支持逻辑操作符。-a和-and选项可以执行逻辑与（AND）操作，-o和-or选项可以执行逻辑或（OR）操作。</span><br><span class="line">$ find . \( -name &#39;*.txt&#39; -o -name &#39;*.pdf&#39; \) -print </span><br><span class="line">&gt; .&#x2F;text.pdf </span><br><span class="line">&gt; .&#x2F;new.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用-and操作符选择名字以s开头且其中包含e的文件</span><br><span class="line">$ find . \( -name &#39;*e*&#39; -and -name &#39;s*&#39; \)</span><br><span class="line">&gt; .&#x2F;some.jpg</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匹配.py或.sh文件</span><br><span class="line">$ find . -regex &#39;.*\.(py\|sh\)$&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;find也可以用!排除匹配到的模式,匹配所有不以.txt结尾的文件</span><br><span class="line">$ find . ! -name &quot;*.txt&quot; -print</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印出在最近7天内被访问过的所有文件</span><br><span class="line">$ find . -type f -atime -7 -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印出访问时间超过7天的所有文件。</span><br><span class="line">$ find . -type f -atime +7 -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找出比file.txt修改时间更近的所有文件</span><br><span class="line">$ find . -type f -newer file.txt -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印出用户slynux拥有的所有文件</span><br><span class="line">$ find . -type f -user slynux -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;利用find执行相应操作</span><br><span class="line">&#x2F;&#x2F;删除匹配的文件</span><br><span class="line">&#x2F;&#x2F;find命令的-delete选项可以删除所匹配到的文件。下面的命令能够从当前目录中删除.swp文件：</span><br><span class="line">$ find . -type f -name &quot;*.swp&quot; -delete</span><br><span class="line"></span><br><span class="line">&#x2F;利用find执行相应操作</span><br><span class="line">&#x2F;&#x2F;执行命令,利用-exec选项，find命令可以结合其他命令使用。</span><br><span class="line">&#x2F;&#x2F;将某位用户（比如root）所拥有的全部文件的所有权更改成另一位用户（比如用户www-data）</span><br><span class="line">&#x2F;&#x2F;那么可以用-user找出root拥有的所有文件，然后用-exec更改所有权。</span><br><span class="line">&#x2F;&#x2F;在下面的例子中，对于每一个匹配的文件，find命令会将&#123;&#125;替换成相应的文件名并更改该文件的所有权。</span><br><span class="line">$ find . -type f -user root -exec chown slynux &#123;&#125; \;</span><br><span class="line">&#x2F;&#x2F;find命令使用一对花括号&#123;&#125;代表文件名。</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>注意 find . -type f -user root -exec chown slynux {} ; 该命令结尾的;。必须对分号进行转义，否则shell会将其视为find命令的结束，而非chown命令的结束。</p>
</blockquote>
<blockquote>
<p>为每个匹配到的文件调用命令可是个不小的开销。如果指定的命令接受多个参数（如chown），你可以换用加号（+）作为命令的结尾。这样find会生成一份包含所有搜索结果的列表，然后将其作为指定命令的参数，一次性执行。</p>
</blockquote>
<blockquote>
<p>我们无法在-exec选项中直接使用多个命令。该选项只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个 shell脚本中（例如command.sh），然后在-exec中使用这个脚本：<br>-exec ./commands.sh {} ;</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="ftp-lftp——使用ftp协议共享文件"><a href="#ftp-lftp——使用ftp协议共享文件" class="headerlink" title="ftp/lftp——使用ftp协议共享文件"></a>ftp/lftp——使用ftp协议共享文件</h2><ul>
<li><p>简介：</p>
<ul>
<li>文件传输协议（File Transfer Protocol，FTP）是一个古老的协议，在很多公共站点上用于文件共享。</li>
<li>FTP服务器通常运行在端口21上。远程主机上必须安装并运行FTP服务器才能使用FTP。</li>
<li>我们可以使用传统的ftp命令或更新的lftp命令访问FTP服务器。两者都支持下面要讲到的命令。很多公共网站都是用FTP共享文件</li>
</ul>
</li>
<li><p>使用步骤</p>
<ol>
<li>要连接FTP服务器传输文件，可以使用<ul>
<li><code>$ lftp username@ftphost</code></li>
<li>它会提示你输入密码，然后显示一个像下面这样的登录提示符<br><code>lftp username@ftphost:~&gt;</code></li>
</ul>
</li>
<li>你可以在提示符后输入各种命令，如下所示<ul>
<li>cd directory：更改远程主机目录。</li>
<li>lcd：更改本地主机目录。</li>
<li>mkdir：在远程主机上创建目录。</li>
<li>ls：列出远程主机当前目录下的文件。</li>
<li>get FILENAME：将文件下载到本地主机的当前目录中。<ul>
<li><code>lftp username@ftphost:~&gt; get filename</code></li>
</ul>
</li>
<li>put filename：将文件从当前目录上传到远程主机。<ul>
<li><code>lftp username@ftphost:~&gt; put filename</code></li>
</ul>
</li>
<li>quit命令可以退出lftp会话</li>
</ul>
</li>
</ol>
</li>
<li><p>注意事项</p>
<blockquote>
<p>lftp提示符支持命令自动补全。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="grep——在文件中搜索文本"><a href="#grep——在文件中搜索文本" class="headerlink" title="grep——在文件中搜索文本"></a>grep——在文件中搜索文本</h2><ul>
<li><p>简介：</p>
<ul>
<li><p>Linux grep命令用于查找文件里符合条件的字符串。</p>
</li>
<li><p>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一行显示出来。</p>
</li>
<li><p>若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。</p>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>grep [选项参数][范本样式][文件或目录...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a 或 –text</strong></p>
<ul>
<li>不要忽略二进制的数据。</li>
</ul>
</li>
<li><p><strong>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt;</strong></p>
<ul>
<li>除了显示符合范本样式的那一行之外，并显示该行之后的内容。</li>
</ul>
</li>
<li><p><strong>-b 或 –byte-offset</strong></p>
<ul>
<li>可以打印出匹配出现在行中的偏移。字符在行中的偏移是从0开始计数，不是1。</li>
</ul>
</li>
<li><p><strong>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt;</strong></p>
<ul>
<li>除了显示符合样式的那一行之外，并显示该行之前的内容。</li>
</ul>
</li>
<li><p><strong>-c 或 –count</strong></p>
<ul>
<li>计算符合样式的行数。需要注意的是-c只是统计匹配行的数量，并不是匹配的次数</li>
</ul>
</li>
<li><p><strong>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong></p>
<ul>
<li>除了显示符合样式的那一行之外，并显示该行之前和之后的内容。</li>
</ul>
</li>
<li><p><strong>-d &lt;动作&gt; 或 –directories=&lt;动作&gt;</strong></p>
<ul>
<li>当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li>
</ul>
</li>
<li><p><strong>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt;</strong></p>
<ul>
<li>指定字符串做为查找文件内容的样式。可以指定多个匹配模式。</li>
</ul>
</li>
<li><p><strong>-E 或 –extended-regexp</strong></p>
<ul>
<li>将样式为延伸的普通表示法来使用。grep命令默认使用基础正则表达式。这是先前描述的正则表达式的一个子集。选项-E可以使grep使用扩展正则表达式。也可以使用默认启用扩展正则表达式的egrep命令。</li>
</ul>
</li>
<li><p><strong>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt;</strong></p>
<ul>
<li>指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li>
</ul>
</li>
<li><p><strong>-F 或 –fixed-regexp</strong></p>
<ul>
<li>将样式视为固定字符串的列表。</li>
</ul>
</li>
<li><p><strong>-G 或 –basic-regexp</strong></p>
<ul>
<li>将样式视为普通的表示法来使用。</li>
</ul>
</li>
<li><p><strong>-h 或 –no-filename</strong></p>
<ul>
<li>在显示符合样式的那一行之前，不标示该行所属的文件名称。</li>
</ul>
</li>
<li><p><strong>-H 或 –with-filename</strong></p>
<ul>
<li>在显示符合样式的那一行之前，表示该行所属的文件名称。</li>
</ul>
</li>
<li><p><strong>-i 或 –ignore-case</strong></p>
<ul>
<li>忽略字符大小写的差别。</li>
</ul>
</li>
<li><p><strong>-l 或 –file-with-matches</strong></p>
<ul>
<li>列出文件内容符合指定的样式的文件名称。</li>
</ul>
</li>
<li><p><strong>-L 或 –files-without-match</strong></p>
<ul>
<li>列出文件内容不符合指定的样式的文件名称。</li>
</ul>
</li>
<li><p><strong>-n 或 –line-number</strong></p>
<ul>
<li>在显示符合样式的那一行之前，标示出该行的列数编号。</li>
</ul>
</li>
<li><p><strong>-o 或 –only-matching</strong></p>
<ul>
<li>只显示匹配PATTERN 部分。</li>
</ul>
</li>
<li><p><strong>-q 或 –quiet或–silent</strong></p>
<ul>
<li>不显示任何信息。</li>
</ul>
</li>
<li><p><strong>-r 或 –recursive</strong></p>
<ul>
<li>此参数的效果和指定”-d recurse”参数相同。</li>
</ul>
</li>
<li><p><strong>-s 或 –no-messages</strong></p>
<ul>
<li>不显示错误信息。</li>
</ul>
</li>
<li><p><strong>-v 或 –revert-match</strong></p>
<ul>
<li>显示不包含匹配文本的所有行。</li>
</ul>
</li>
<li><p><strong>-V 或 –version</strong></p>
<ul>
<li>显示版本信息。</li>
</ul>
</li>
<li><p><strong>-w 或 –word-regexp</strong></p>
<ul>
<li>只显示全字符合的列。</li>
</ul>
</li>
<li><p><strong>-x –line-regexp</strong></p>
<ul>
<li>只显示全列符合的列。</li>
</ul>
</li>
<li><p><strong>-y</strong></p>
<ul>
<li>此参数的效果和指定”-i”参数相同。</li>
</ul>
</li>
<li><p><strong>–color</strong></p>
<ul>
<li>在输出行中着重标记出匹配到的模式，一般为–color=auto。</li>
</ul>
</li>
<li><p><strong>–include</strong></p>
<ul>
<li>在搜索过程中使用通配符指定（include）某些文件</li>
</ul>
</li>
<li><p><strong>–exclude</strong></p>
<ul>
<li>在搜索过程中使用通配符排除（exclude）某些文件</li>
</ul>
</li>
<li><p><strong>–exclude-dir</strong></p>
<ul>
<li>在搜索过程中使用通配符以排除目录</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在当前目录中，查找有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。</span><br><span class="line">$ grep test *file* </span><br><span class="line">&gt; file1:This a Linux testfile! #列出file1 文件中包含test字符的行  </span><br><span class="line">&gt; file_2:This is a linux testfile! #列出file_2 文件中包含test字符的行  </span><br><span class="line">&gt; file_2:Linux test #列出file_2 文件中包含test字符的行 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以递归的方式查找符合条件的文件。</span><br><span class="line">&#x2F;&#x2F;例如，查找指定目录&#x2F;etc&#x2F;acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串&quot;update&quot;的文件</span><br><span class="line">&#x2F;&#x2F;并打印出该字符串所在行的内容</span><br><span class="line">$ grep -r update &#x2F;etc&#x2F;acpi </span><br><span class="line">&gt; &#x2F;etc&#x2F;acpi&#x2F;ac.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  Rather than  </span><br><span class="line">&gt; &#x2F;etc&#x2F;acpi&#x2F;resume.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.) Rather than  </span><br><span class="line">&gt; &#x2F;etc&#x2F;acpi&#x2F;events&#x2F;thinkpad-cmos: action&#x3D;&#x2F;usr&#x2F;sbin&#x2F;thinkpad-keys--update </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;反向查找。前面各个例子是查找并打印出符合条件的行，通过&quot;-v&quot;参数可以打印出不符合条件行的内容。</span><br><span class="line">&#x2F;&#x2F;查找文件名中包含 file 的文件中不包含test 的行，</span><br><span class="line">$ grep -v test *file*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在stdin中搜索匹配特定模式的文本行</span><br><span class="line">$ $ echo -e &quot;this is a word \n next line&quot; | grep word</span><br><span class="line">&gt; this is a word</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用扩展正则，只输出匹配到的文本，</span><br><span class="line">$ echo this is a line. | grep -o -E &quot;[a-z]+\.&quot;</span><br><span class="line">&gt; line</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计出匹配模式的文本行数，-c只是统计匹配行的数量，并不是匹配的次数</span><br><span class="line">$ grep -c &quot;text&quot; filename</span><br><span class="line">&gt; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计文件中匹配项的数量，可以使用下面的技巧</span><br><span class="line">$ echo -e &quot;1 2 3 4\nhello\n5 6&quot; | egrep -o &quot;[0-9]&quot; | wc -l</span><br><span class="line">&gt; 6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印多个文件包含Linux的行，输出行号</span><br><span class="line">$ grep linux -n sample1.txt sample2.txt</span><br><span class="line">&gt; sample1.txt:2:linux is fun </span><br><span class="line">&gt; sample2.txt:2:planetlinux</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选项-b可以打印出匹配出现在行中的偏移。配合选项-o可以打印出匹配所在的字符或字节偏移</span><br><span class="line">$ echo gnu is not unix | grep -b -o &quot;not&quot;</span><br><span class="line">&gt; 7:not</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出匹配模式所在的文件</span><br><span class="line">$ grep -l linux sample1.txt sample2.txt</span><br><span class="line">&gt; sample1.txt </span><br><span class="line">&gt; sample2.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对当前目录中对文本进行递归搜索</span><br><span class="line">$  grep &quot;text&quot; . -R -n</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在匹配模式时不考虑字符的大小写</span><br><span class="line">$ echo hello world | grep -i &quot;HELLO&quot;</span><br><span class="line">&gt; hello</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用-e指定多个匹配模式，打印出匹配任意一种模式的行，每个匹配对应一行输出。</span><br><span class="line">$  echo this is a line of text | grep -o -e &quot;this&quot; -e &quot;line&quot;</span><br><span class="line">&gt; this </span><br><span class="line">&gt; line</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以将多个模式定义在文件中。选项-f可以读取文件并使用其中的模式（一个模式一行）</span><br><span class="line">$ cat pat_file </span><br><span class="line">&gt; hello </span><br><span class="line">&gt; cool</span><br><span class="line">$ echo hello this is cool | grep -f pat_file</span><br><span class="line">&gt; hello this is cool</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用--include选项在目录中递归搜索所有的 .c和 .cpp文件。</span><br><span class="line">&#x2F;&#x2F;注意，some&#123;string1,string2,string3&#125;会被扩展成somestring1 somestring2 somestring3。</span><br><span class="line">$ grep &quot;main()&quot; . -r --include *.&#123;c,cpp&#125;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用选项--exclude在搜索过程中排除所有的README文件</span><br><span class="line">$ grep &quot;main()&quot; . -r --exclude &quot;README&quot;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选项--exclude-dir可以排除目录：</span><br><span class="line">$ grep main . -r -exclude-dir CVS</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;grep的静默输出。可以通过设置grep的静默选项（-q）来实现。</span><br><span class="line">&#x2F;&#x2F;在静默模式中，grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。</span><br><span class="line">&#x2F;&#x2F;0表示匹配成功，非0表示匹配失败。</span><br><span class="line">$ grep -q word file</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h2 id="head-打印文件的前n行"><a href="#head-打印文件的前n行" class="headerlink" title="head-打印文件的前n行"></a>head-打印文件的前n行</h2><ul>
<li><p>简介：</p>
</li>
<li><p>head命令用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>head [选项] fileName</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-n&lt;数字&gt;</strong></p>
<ul>
<li>指定显示头部内容的行数,负数时表示倒数n行</li>
</ul>
</li>
<li><p><strong>-c&lt;字符数&gt;</strong></p>
<ul>
<li>指定显示头部内容的字符数；</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>总是显示文件名的头信息；</li>
</ul>
</li>
<li><p><strong>-q</strong></p>
<ul>
<li>不显示文件名的头信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示 test.log 文件中前 20 行</span><br><span class="line">$ head -n 20 test.log</span><br><span class="line">&#x2F;&#x2F;显示 test.log 文件中前 20 字节</span><br><span class="line">$ head -c 20 test.log</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示 test.log 文件中除了最后20行之外的所有行</span><br><span class="line">$ head -n -20 test.log</span><br></pre></td></tr></table></figure>
<p>  <img src="https://oscimg.oschina.net/oscnet/15e07e85dcfeca736889def8b923fd05a0f.jpg" alt=""></p>
</li>
</ul>
<hr>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><h2 id="ifconfig——配置和展示网络信息"><a href="#ifconfig——配置和展示网络信息" class="headerlink" title="ifconfig——配置和展示网络信息"></a>ifconfig——配置和展示网络信息</h2><ul>
<li><p>简介：</p>
</li>
<li><p>ifconfig可设置网络设备的状态，或是显示目前的设置。注意和Windows的命令ipconfig区分。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>ifconfig [选项参数]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>add&lt;地址&gt;</strong></p>
<ul>
<li>设置网络设备IPv6的IP地址。</li>
</ul>
</li>
<li><p><strong>del&lt;地址&gt;</strong></p>
<ul>
<li>删除网络设备IPv6的IP地址。</li>
</ul>
</li>
<li><p><strong>down</strong></p>
<ul>
<li>关闭指定的网络设备。</li>
</ul>
</li>
<li><p><strong>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;</strong></p>
<ul>
<li>设置网络设备的类型与硬件地址。</li>
</ul>
</li>
<li><p><strong>io_addr&lt;I/O地址&gt;</strong></p>
<ul>
<li>设置网络设备的I/O地址。</li>
</ul>
</li>
<li><p><strong>irq&lt;IRQ地址&gt;</strong></p>
<ul>
<li>设置网络设备的IRQ。</li>
</ul>
</li>
<li><p><strong>media&lt;网络媒介类型&gt;</strong></p>
<ul>
<li>设置网络设备的媒介类型。</li>
</ul>
</li>
<li><p><strong>mem_start&lt;内存地址&gt;</strong></p>
<ul>
<li>设置网络设备在主内存所占用的起始地址。</li>
</ul>
</li>
<li><p><strong>metric&lt;数目&gt;</strong></p>
<ul>
<li>指定在计算数据包的转送次数时，所要加上的数目。</li>
</ul>
</li>
<li><p><strong>mtu&lt;字节&gt;</strong></p>
<ul>
<li>设置网络设备的MTU。</li>
</ul>
</li>
<li><p><strong>netmask&lt;子网掩码&gt;</strong></p>
<ul>
<li>设置网络设备的子网掩码。</li>
</ul>
</li>
<li><p><strong>tunnel&lt;地址&gt;</strong></p>
<ul>
<li>建立IPv4与IPv6之间的隧道通信地址。</li>
</ul>
</li>
<li><p><strong>up</strong></p>
<ul>
<li>启动指定的网络设备。</li>
</ul>
</li>
<li><p><strong>-broadcast&lt;地址&gt;</strong></p>
<ul>
<li>将要送往指定地址的数据包当成广播数据包来处理。</li>
</ul>
</li>
<li><p><strong>-pointopoint&lt;地址&gt;</strong></p>
<ul>
<li>与指定地址的网络设备建立直接连线，此模式具有保密功能。</li>
</ul>
</li>
<li><p><strong>-promisc</strong></p>
<ul>
<li>关闭或启动指定网络设备的promiscuous模式。</li>
</ul>
</li>
<li><p><strong>[IP地址]</strong></p>
<ul>
<li>指定网络设备的IP地址。</li>
</ul>
</li>
<li><p><strong>[网络设备]</strong></p>
<ul>
<li>指定网络设备的名称。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示网络设备信息，ifconfig输出的最左边一列是网络接口名，右边的若干列显示对应的网络接口的详细信息。</span><br><span class="line">$ ifconfig</span><br><span class="line">&gt; eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C </span><br><span class="line">&gt; .....以下省略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ifconfig会显示系统中所有活动网络接口的详细信息。不过，我们可以限制它只显示某个特定接口的信息</span><br><span class="line">$ ifconfig  wlan0</span><br><span class="line">&gt; wlan0 Link encap:EthernetHWaddr 00:1c:bf:87:25:d2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置网络接口的IP地址</span><br><span class="line">$ ifconfig wlan0 192.168.0.80</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置此IP地址的子网掩码</span><br><span class="line">$ ifconfig wlan0 192.168.0.80 netmask 255.255.252.0</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><h2 id="less——对文件或其它输出进行分页显示"><a href="#less——对文件或其它输出进行分页显示" class="headerlink" title="less——对文件或其它输出进行分页显示"></a>less——对文件或其它输出进行分页显示</h2><ul>
<li><p>简介：</p>
<ul>
<li>对文件或其它输出进行分页显示。缓冲加载。</li>
<li>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>less [参数] 文件</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-e</strong></p>
<ul>
<li>当文件显示结束后，自动离开</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>强迫打开特殊文件，例如外围设备代号、目录和二进制文件</li>
</ul>
</li>
<li><p><strong>-g</strong></p>
<ul>
<li>只标志最后搜索的关键词</li>
</ul>
</li>
<li><p><strong>-i</strong></p>
<ul>
<li>忽略搜索时的大小写</li>
</ul>
</li>
<li><p><strong>-m</strong></p>
<ul>
<li>显示类似more命令的百分比</li>
</ul>
</li>
<li><p><strong>-N</strong></p>
<ul>
<li>显示每行的行号</li>
</ul>
</li>
<li><p><strong>-Q</strong></p>
<ul>
<li>不使用警告音</li>
</ul>
</li>
<li><p><strong>-s</strong></p>
<ul>
<li>显示连续空行为一行</li>
</ul>
</li>
<li><p><strong>-S</strong></p>
<ul>
<li>行过长时间将超出部分舍弃</li>
</ul>
</li>
</ul>
</li>
<li><p>快捷键</p>
<ul>
<li><p><strong>/&lt;字符串&gt;</strong></p>
<ul>
<li>向下搜索”字符串”的功能</li>
</ul>
</li>
<li><p><strong>?&lt;字符串&gt;</strong></p>
<ul>
<li>向上搜索”字符串”的功能</li>
</ul>
</li>
<li><p><strong>n</strong></p>
<ul>
<li>针对 / 或 ?的结果，重复前一个搜索</li>
</ul>
</li>
<li><p><strong>N</strong></p>
<ul>
<li>针对 / 或 ?的结果，反向重复前一个搜索</li>
</ul>
</li>
<li><p><strong>b</strong></p>
<ul>
<li>向后翻一页</li>
</ul>
</li>
<li><p><strong>d</strong></p>
<ul>
<li>向后翻半页</li>
</ul>
</li>
<li><p><strong>h</strong></p>
<ul>
<li>显示帮助界面</li>
</ul>
</li>
<li><p><strong>u</strong></p>
<ul>
<li>向前滚动半页</li>
</ul>
</li>
<li><p><strong>y</strong></p>
<ul>
<li>向前滚动一行</li>
</ul>
</li>
<li><p><strong>空格键</strong></p>
<ul>
<li>滚动一页</li>
</ul>
</li>
<li><p><strong>回车键</strong></p>
<ul>
<li>滚动一行</li>
</ul>
</li>
<li><p><strong>q / ZZ</strong></p>
<ul>
<li>退出 less 命令</li>
</ul>
</li>
<li><p><strong>v</strong></p>
<ul>
<li>使用配置的编辑器编辑当前文件</li>
<li>对于提示的^X等操作，^X即为CTRL+X。</li>
</ul>
</li>
<li><p><strong>h</strong></p>
<ul>
<li>显示 less 的帮助文档</li>
</ul>
</li>
<li><p><strong>F</strong></p>
<ul>
<li>类似 tail -f 的效果，读取写入文件的最新内容， 按 ctrl+C 停止。</li>
</ul>
</li>
<li><p><strong>&amp;</strong></p>
<ul>
<li>开启模式匹配模式，可继续键入正则匹配，使得less仅显示匹配模式的行，而不是整个文件</li>
</ul>
</li>
<li><p><strong>m</strong></p>
<ul>
<li>mark的意思，开启mark模式,让你键入一个字符，比如我们键入了a，那么less会使用 a 标记文本的当前位置。当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置</li>
</ul>
</li>
<li><p><strong>‘</strong></p>
<ul>
<li>单引号，开启goto mark模式，让你键入一个字符，到达你键入字符标记的位置，比如你键入啊，那么导航到你标记的 a 处</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看文件</span><br><span class="line">$ less log.log</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ps查看进程信息并通过less分页显示</span><br><span class="line">$ ps -ef |less</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看命令历史使用记录并通过less分页显示</span><br><span class="line">$ history | less</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;浏览多个文件，输入 &quot;:n&quot; (n&#x3D;next) 后，切换到 log2.log;输入&quot;:p&quot; (p&#x3D;preview)后，切换到log1.log</span><br><span class="line">$ less log1.log log2.log</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="ls———显示指定工作目录下之内容"><a href="#ls———显示指定工作目录下之内容" class="headerlink" title="ls———显示指定工作目录下之内容"></a>ls———显示指定工作目录下之内容</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。它是list的简写。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>ls [选项参数] [name...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>显示所有文件及目录(ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>将文件以相反次序显示(原定依英文字母次序)</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>将文件依建立时间之先后次序列出</li>
</ul>
</li>
<li><p><strong>-A</strong></p>
<ul>
<li>同-a，但不列出”.”(目前目录)及”..”(父目录)</li>
</ul>
</li>
<li><p><strong>-R</strong></p>
<ul>
<li>若目录下有文件，则以下之文件亦皆依序列出</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;列出目前工作目录下所有名称是 s 开头的文件，越新的排越后面 </span><br><span class="line">$ ls -ltr s*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;bin 目录以下所有目录及文件详细资料列出 </span><br><span class="line">$ ls -lR &#x2F;bin</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出目前工作目录下所有文件及目录；目录于名称后加 &quot;&#x2F;&quot;, 可执行档于名称后加 &quot;*&quot; </span><br><span class="line">$ ls -AF</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><h1 id="N"><a href="#N" class="headerlink" title="N"></a>N</h1><h1 id="O"><a href="#O" class="headerlink" title="O"></a>O</h1><h1 id="P"><a href="#P" class="headerlink" title="P"></a>P</h1><h2 id="paste——合并文件的列"><a href="#paste——合并文件的列" class="headerlink" title="paste——合并文件的列"></a>paste——合并文件的列</h2><ul>
<li><p>简介：</p>
</li>
<li><p>paste指令会把每个文件以列对列的方式，一列列地加以合并。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>paste [选项参数][文件...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-d&lt;间隔字符&gt;或–delimiters=&lt;间隔字符&gt;</strong></p>
<ul>
<li>用指定的间隔字符取代跳格字符。</li>
</ul>
</li>
<li><p><strong>-s或–serial</strong></p>
<ul>
<li>串列进行而非平行处理。</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>在线帮助。</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示帮助信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;合并file1.txt 和file2.txt，先看看这两个文件的内容</span><br><span class="line">$ cat file1.txt </span><br><span class="line">&gt; 1 </span><br><span class="line">&gt; 2 </span><br><span class="line">&gt; 3 </span><br><span class="line">&gt; 4 </span><br><span class="line">&gt; 5 </span><br><span class="line">$ cat file2.txt </span><br><span class="line">&gt; slynux </span><br><span class="line">&gt; gnu </span><br><span class="line">&gt; bash </span><br><span class="line">&gt; hack</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用paste合并</span><br><span class="line">$ paste file1.txt file2.txt </span><br><span class="line">&gt; 1 slynux </span><br><span class="line">&gt; 2 gnu </span><br><span class="line">&gt; 3 bash </span><br><span class="line">&gt; 4 hack </span><br><span class="line">&gt; 5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认的分隔符是制表符，也可以用-d指定分隔符</span><br><span class="line">$ paste file1.txt file2.txt -d &quot;,&quot; </span><br><span class="line">&gt; 1,slynux </span><br><span class="line">&gt; 2,gnu </span><br><span class="line">&gt; 3,bash </span><br><span class="line">&gt; 4,hack </span><br><span class="line">&gt; 5,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若使用paste指令的参数&quot;-s&quot;，则可以将一个文件中的多行数据合并为一行进行显示。</span><br><span class="line">&#x2F;&#x2F;例如，将文件&quot;file&quot;中的3行数据合并为一行数据进行显示，输入如下命令</span><br><span class="line">$ paste -s file </span><br><span class="line">&gt; xiongdan 200 lihaihui 233 lymlrl 231</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>参数”-s”只是将testfile文件的内容调整显示方式，并不会改变原文件的内容格式。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="printf-打印内容"><a href="#printf-打印内容" class="headerlink" title="printf-打印内容"></a>printf-打印内容</h2><ul>
<li><p>简介：</p>
<ul>
<li>printf命令接受<strong>引用文本或由空格分隔的参数</strong>。我们可以在printf中使用格式化字符串来指定字符串的宽度、左右对齐方式等。</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4s\n"</span> No Name Mark ;</span></span><br><span class="line">- printf "%-5s %-10s %-4.2f\n" 1 Sarath 80.3456 11 ;</span><br><span class="line">- printf "%-5s %-10s %-4.2f\n" 2 James 90.9989 ;</span><br><span class="line">- printf "%-5s %-10s %-4.2f\n" 3 Jeff 77.564</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> No Name Mark </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1 Sarath 80.35 </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2 James 91.00 14 </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 3 Jeff 77.56</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<ul>
<li><p>%s、%c、%d和%f都是格式替换符（format substitution character），它们定义了该如何打印后续参数。%-5s指明了一个格式为左对齐且宽度为5的字符串替换（-表示左对齐）。如果不指明-，字符串就采用右对齐形式。</p>
</li>
<li><p>宽度指定了保留给某个字符串的字符数量。对Name而言，其保留宽度是10。因此，任何Name字段的内容都会被显示在10字符宽的保留区域内，如果内容不足10个字符，余下的则以空格填充。</p>
</li>
<li><p>对于浮点数，可以使用其他参数对小数部分进行舍入（round off）。 对于Mark字段，我们将其格式化为%-4.2f，其中.2指定保留两位小数。注意，在每行的格式字符串后都有一个换行符（\n）。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><h2 id="read-从键盘或标准输入中读取文本"><a href="#read-从键盘或标准输入中读取文本" class="headerlink" title="read-从键盘或标准输入中读取文本"></a>read-从键盘或标准输入中读取文本</h2><ul>
<li><p>简介：</p>
<ul>
<li><p>我们可以使用read以交互的形式读取用户输入，不过read能做的可远不止这些。编程语言的大多数输入库都是从键盘读取输入，当回车键按下的时候，标志着输入完毕。</p>
</li>
<li><p>但有时候是没法按回车键的，输入结束与否是由读取到的字符数或某个特定字符来决定的。例如在交互式游戏中，当按下 + 键时，小球就会向上移动。那么若每次都要按下 + 键，然后再按回车键来确认已经按过 + 键，这就显然太低效了。</p>
</li>
<li><p>read命令提供了一种不需要按回车键就能够搞定这个任务的方法。</p>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><strong>-a</strong></li>
</ul>
</li>
<li><p>后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。</p>
<ul>
<li><p><strong>-d</strong></p>
<ul>
<li>用特定的定界符delim_char作为输入行的结束,结果存入var变量（不包括边界符）：<code>read -d delim_char var</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	$ read -d &quot;:&quot; var</span><br><span class="line">$ hello:</span><br><span class="line">	</span><br><span class="line">	$ echo $var</span><br><span class="line">	&gt; hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>后面跟提示信息，即在输入前打印提示信息。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -p &quot;输入网站名:&quot; website</span><br><span class="line">echo &quot;你输入的网站名是 $website&quot; </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 输入网站名:www.cherish.com</span><br><span class="line">&gt; 你输入的网站名是 www.cherish.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
<ul>
<li>在输入的时候可以使用命令补全功能。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下实例输入字符 a 后按下 Tab 键就会输出相关的文件名(该目录存在的)：</span><br><span class="line">$ read -e -p &quot;输入文件名:&quot; str</span><br><span class="line">$ 输入文件名:a</span><br><span class="line">a.out    a.py     a.pyc    abc.txt  </span><br><span class="line">&gt; 输入文件名:a</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-n</strong></p>
<ul>
<li>后跟一个数字，定义输入文本的长度，很实用。<br>例如：下面的语句从输入中读取n个字符并存入变量variable_name：<br><code>read -n number_of_chars variable_name</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -n 2 -p &quot;请随便输入两个字符: &quot; any</span><br><span class="line">echo &quot;\n您输入的两个字符是:$any&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 请随便输入两个字符: 12</span><br><span class="line">&gt; 您输入的两个字符是:12</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-s</strong></p>
</li>
<li><p>安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</p>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li><p>后面跟秒数，定义输入字符的等待时间。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">if read -t 5 -p &quot;输入网站名:&quot; website</span><br><span class="line">then</span><br><span class="line">	echo &quot;你输入的网站名是 $website&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;\n抱歉，你输入超时了。&quot;</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;执行程序不输入，等待 5 秒后：</span><br><span class="line">$ 输入网站名:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>抱歉，你输入超时了</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-u</strong></p>
<ul>
<li>后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#这里默认会换行  </span><br><span class="line">echo &quot;输入网站名: &quot;  </span><br><span class="line">#读取从键盘的输入  </span><br><span class="line">read website  </span><br><span class="line">echo &quot;你输入的网站名是 $website&quot;  </span><br><span class="line">exit 0  #退出</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;常规用法</span><br><span class="line">$ .&#x2F;testcat.sh</span><br><span class="line">&gt; 输入网站名:</span><br><span class="line">$ www.baidu.com</span><br><span class="line">&gt; 你输入的网站名是 www.baidu.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="rm-删除一个文件或者目录"><a href="#rm-删除一个文件或者目录" class="headerlink" title="rm-删除一个文件或者目录"></a>rm-删除一个文件或者目录</h2><ul>
<li><p>简介：</p>
</li>
<li><p>rm [options] filename…</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>Linux rm命令用于删除一个文件或者目录。</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-i</strong></p>
<ul>
<li>删除前逐一询问确认。</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>即使原档案属性设为只读，亦直接删除，无需逐一确认。</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>将目录及以下之档案逐一删除。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除文件可以直接使用rm命令，若删除目录则必须配合选项&quot;-r&quot;</span><br><span class="line">$ rm  test.txt </span><br><span class="line">&#x2F;&#x2F;删除当前目录下的所有文件及目录</span><br><span class="line">$ rm  -r  *</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="rsync——数据远程同步工具"><a href="#rsync——数据远程同步工具" class="headerlink" title="rsync——数据远程同步工具"></a>rsync——数据远程同步工具</h2><ul>
<li><p>简介：</p>
<ul>
<li>rsync命令广泛用于网络文件复制以及备份。</li>
<li>rsync可以在最小化数据传输量同时，同步不同位置上的文件和目录。</li>
<li>相较于cp命令，rsync的优势在于比较文件修改日期，仅复制较新的文件。另外，它还支持远程数据传输以及压缩和加密。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>rsync [选项参数] [源文件路径] [目标文件路径]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>进行归档操作</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>表示在stdout上打印出细节信息或进度</li>
</ul>
</li>
<li><p><strong>-z</strong></p>
<ul>
<li>指定在传输时压缩数据</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>强制rsync以递归方式复制目录中所有的内容</li>
</ul>
</li>
<li><p><strong>–exclude</strong></p>
<ul>
<li>指定不需要传输的文件，可以使用通配符指定需要排除的文件</li>
<li><code>$ rsync -avz /home/code/app /mnt/disk/backup/code --exclude &quot;*.o&quot;</code></li>
</ul>
</li>
<li><p><strong>–exclude-from</strong></p>
<ul>
<li>我们也可以通过一个列表文件指定需要排除的文件</li>
<li><code>$ rsync -avz /home/code/app /mnt/disk/backup/code --exclude-from FILEPATH</code></li>
</ul>
</li>
<li><p><strong>–delete</strong></p>
<ul>
<li>在更新rsync备份时，删除不存在的文件。默认情况下，rsync并不会在目的端删除那些在源端已不存在的文件。如果要删除这类文件，可以使用rsync的–delete选项：</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将源目录（本地路径）复制到目的路径(远程路径)</span><br><span class="line">$ rsync -av &#x2F;home&#x2F;slynux&#x2F;data  slynux@192.168.0.6:&#x2F;home&#x2F;backups&#x2F;data</span><br><span class="line">&#x2F;&#x2F; 上面的命令会以递归的方式将所有的文件从源路径复制到目的路径。源路径和目的路径既可以是远程路径，也可以是本地路径。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以将远程主机上的数据恢复到本地</span><br><span class="line">$ rsync -av slynux@192.168.0.6:&#x2F;home&#x2F;backups&#x2F;data &#x2F;home&#x2F;slynux&#x2F;data</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将一个目录中的内容同步到另一个目录，这条命令将源目录（&#x2F;home&#x2F;test）中的内容（不包括目录本身）复制到现有的backups目录中。</span><br><span class="line">$  rsync -av &#x2F;home&#x2F;test&#x2F; &#x2F;home&#x2F;backups</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将包括目录本身在内的内容复制到另一个目录中，将包括源目录本身（&#x2F;home&#x2F;test）在内的内容复制到新的backups目录中</span><br><span class="line">$ rsync -av &#x2F;home&#x2F;test &#x2F;home&#x2F;backups</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>rsync命令用SSH连接远程主机，因此必须使用username<a href="https://my.oschina.net/u/116016" target="_blank" rel="noopener">@host</a>:PATH 这种形式设定远程主机的地址，其中user代表用户名，host代表远程主机的IP地址或主机名。而PATH指定了远程主机中待复制数据所在的路径。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1><h2 id="scp——安全复制工具"><a href="#scp——安全复制工具" class="headerlink" title="scp——安全复制工具"></a>scp——安全复制工具</h2><ul>
<li><p>简介：</p>
<ul>
<li>SCP是一个安全的文件复制命令，和旧式的、不安全的远程复制命令rcp类似。文件均通过SSH加密通道进行传输。</li>
<li>因为是基于ssh，远程地址格式同样为<code>username@host:/path</code></li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>scp [选项参数] [源文件路径] [目标文件路径]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-oPort=PORTNO</strong></p>
<ul>
<li>SSH服务器有时候并不在默认的端口22上运行。如果它在其他端口运行，我们可以在scp中用选项-oPort=PORTNO来指定端口号。</li>
</ul>
</li>
<li><p><strong>-1</strong></p>
<ul>
<li>强制scp命令使用协议ssh1</li>
</ul>
</li>
<li><p><strong>-2</strong></p>
<ul>
<li>强制scp命令使用协议ssh2</li>
</ul>
</li>
<li><p><strong>-4</strong></p>
<ul>
<li>强制scp命令只使用IPv4寻址</li>
</ul>
</li>
<li><p><strong>-6</strong></p>
<ul>
<li>强制scp命令只使用IPv6寻址</li>
</ul>
</li>
<li><p><strong>-B</strong></p>
<ul>
<li>使用批处理模式（传输过程中不询问传输口令或短语）</li>
</ul>
</li>
<li><p><strong>-C</strong></p>
<ul>
<li>允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>保留原文件的修改时间，访问时间和访问权限。</li>
</ul>
</li>
<li><p><strong>-q</strong></p>
<ul>
<li>不显示传输进度条。</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>递归复制整个目录。</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
</ul>
</li>
<li><p><strong>-c cipher</strong></p>
<ul>
<li>以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
</ul>
</li>
<li><p><strong>-F ssh_config</strong></p>
<ul>
<li>指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
</ul>
</li>
<li><p><strong>-i identity_file</strong></p>
<ul>
<li>从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
</ul>
</li>
<li><p><strong>-l limit</strong></p>
<ul>
<li>限定用户所能使用的带宽，以Kbit/s为单位。</li>
</ul>
</li>
<li><p><strong>-o ssh_option</strong></p>
<ul>
<li>如果习惯于使用ssh_config(5)中的参数传递方式，</li>
</ul>
</li>
<li><p><strong>-P port</strong></p>
<ul>
<li>注意是大写的P, port是指定数据传输用到的端口号</li>
</ul>
</li>
<li><p><strong>-S program</strong></p>
<ul>
<li>指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将远程主机中的文件复制到当前目录并使用给定的文件名</span><br><span class="line">$ scp user@remotehost:&#x2F;home&#x2F;path&#x2F;filename filename</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="sed——对文本进行编辑"><a href="#sed——对文本进行编辑" class="headerlink" title="sed——对文本进行编辑"></a>sed——对文本进行编辑</h2><ul>
<li><p>简介：</p>
</li>
<li><p>sed是stream editor（流编辑器）的缩写。sed 可依照脚本的指令来处理、编辑文本文件。主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>sed [选项参数][文本文件]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-e<action>或–expression=<action></strong></p>
<ul>
<li><p>以选项中指定的action动作来处理输入的文本文件。-e可省略，sed默认为该模式</p>
</li>
<li><p>action动作包括：</p>
<ul>
<li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li>
<li>c ：取代行， c 的后面可以接字串，这些字串可以取代指定的行！</li>
<li>d ：删除，因为是删除啊，所以 d 后面通常不接任何字符</li>
<li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li>
<li>s ：取代部分数据，可以直接进行取代的工作！通常s的动作可以搭配正规表示法！例如 1,20s/old/new/g</li>
</ul>
<blockquote>
<p>注意动作符号后面，需要使用\符号分隔开动作与字符</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>-f&lt;script文件&gt;或–file=&lt;script文件&gt;</strong></p>
</li>
<li><p>以选项中指定的script文件(文件内容为action)来处理输入的文本文件。</p>
</li>
</ul>
</li>
<li><p><strong>-h或–help</strong></p>
<ul>
<li><p>显示帮助。</p>
</li>
<li><p><strong>-n或–quiet或–silent</strong></p>
</li>
<li><p>仅显示script处理后的结果。</p>
</li>
<li><p><strong>-V或–version</strong></p>
<ul>
<li>显示版本信息。</li>
</ul>
</li>
<li><p><strong>-i</strong></p>
<ul>
<li>in place的意思，在参数为文件时，选项-i会使得sed用修改后的数据替换原始文件，相当于直接修改文件<br><code>$ sed -i &#39;s/text/replace/&#39; file</code><br>直接修改文件十分危险，我们可以使用如下命令，这时的sed不仅替换文件内容，还会创建一个名为file.bak的文件，其中包含着原始文件内容的副本。<br><code>sed -i.bak &#39;s/text/replace/&#39; file</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
<ul>
<li><p>a 添加</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在testfile文件的第一行后添加一行，并将结果输出到标准输出</span><br><span class="line">$ cat testfile #查看testfile 中的内容  </span><br><span class="line">&gt; HELLO LINUX!  </span><br><span class="line">&gt; Linux is a free unix-type opterating system.</span><br><span class="line"></span><br><span class="line">$ sed -e 1a\newLine testfile </span><br><span class="line">或</span><br><span class="line">$ sed -e &#39;1a newLine&#39; testfile </span><br><span class="line">&gt; HELLO LINUX! #testfile文件原有的内容  </span><br><span class="line">&gt; newline </span><br><span class="line">&gt; Linux is a free unix-type opterating system.</span><br></pre></td></tr></table></figure>
</li>
<li><p>d 添加</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出，同时，请将第 2~5 行删除！(nl命令，给文本内容添加行号)</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;2,5d&#39;</span><br><span class="line">&gt; 1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; 6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">&gt; 7 shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown</span><br><span class="line">&gt; .....(后面省略).....</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出，同时，请将第 2 行删除！</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;2d&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出，同时，要删除第 3 到最后一行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;3,$d&#39; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出,要在第二行前加上drink tea</span><br><span class="line">$ cat &#x2F;etc&#x2F;passwd | sed &#39;2i drink tea&#39; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除&#x2F;etc&#x2F;passwd所有包含root的行，其他行输出</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed  &#39;&#x2F;root&#x2F;d&#39;</span><br><span class="line">&gt; 2  daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; 3  bin:x:2:2:bin:&#x2F;bin:&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; ....下面忽略,第一行的匹配root已经删除了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除空行</span><br><span class="line">$ sed &#39;&#x2F;^$&#x2F;d&#39; file</span><br></pre></td></tr></table></figure>
</li>
<li><p>c 替换</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将第2-5行的内容取代成为No 2-5 number</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;2,5c No 2-5 number&#39;</span><br><span class="line">&gt; 1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; No 2-5 number</span><br><span class="line">&gt; 6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">&gt; .....(后面省略).....</span><br></pre></td></tr></table></figure></li>
<li><p>p 打印</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;仅列出 &#x2F;etc&#x2F;passwd 文件内的第 5-7 行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed -n &#39;5,7p&#39;</span><br><span class="line">&gt; 5 lp:x:4:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;sbin&#x2F;nologin</span><br><span class="line">&gt; 6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">&gt; 7 shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;搜索 &#x2F;etc&#x2F;passwd有root关键字的行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed -n &#39;&#x2F;root&#x2F;p&#39;</span><br><span class="line">&gt; 1  root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li>
<li><p>s 取代（语法：<code>sed &#39;s/正则表达式/新的字串/&#39;</code>）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;替换第一个出现的this</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;&#39;</span><br><span class="line">&gt; THISthisthisthis</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;g标记可以使sed执行全局替换。</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;g&#39;</span><br><span class="line">&gt; THISTHISTHISTHIS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;#g标记可以使sed替换第N次起出现的匹配</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;2g&#39;</span><br><span class="line">&gt; thisTHISTHISTHIS</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;3g&#39;</span><br><span class="line">&gt; thisthisTHISTHIS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;g标记可以使sed执行全局替换。</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;g&#39;</span><br><span class="line">&gt; THISTHISTHISTHIS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;搜索&#x2F;etc&#x2F;passwd,找到root对应的行，执行后面花括号中的一组命令。</span><br><span class="line">&#x2F;&#x2F;每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed -n &#39;&#x2F;root&#x2F;&#123;s&#x2F;bash&#x2F;blueshell&#x2F;;p;q&#125;&#39; #s为替换，p为打印，最后的q是退出。</span><br><span class="line">&gt; 1  root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;blueshell</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sed命令会将s之后的字符视为命令分隔符。这允许我们更改默认的分隔符&#x2F;：</span><br><span class="line">$ sed &#39;s:text:replace:g&#39; #此时分隔符是：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果作为分隔符的字符出现在模式中，必须使用\对其进行转义。\|是出现在模式中被转义的分隔符</span><br><span class="line">$ sed &#39;s|te\|xt|replace|g&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在sed中，我们可以用&amp;指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹配的内容</span><br><span class="line">&#x2F;&#x2F;在这个例子中，正则表达式\w\+匹配每一个单词，然后我们用[&amp;]替换它。&amp;对应于之前所匹配到的单词。</span><br><span class="line">$ echo this is an example | sed &#39;s&#x2F;\w\+&#x2F;[&amp;]&#x2F;g&#39;</span><br><span class="line">&gt; [this] [is] [an] [example]</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>注意事项</p>
<blockquote>
<p>可以利用管道组合多个sed命令，多个模式之间可以用分号分隔，或是使用选项-e PATTERN ;如下命令都是等价的：<br><code>sed &#39;expression&#39; | sed &#39;expression&#39;</code><br><code>sed &#39;expression; expression&#39;</code><br><code>sed -e &#39;expression&#39; -e &#39;expression&#39;</code></p>
</blockquote>
<blockquote>
<p>如果想在sed表达式中使用变量，双引号就能派上用场了。<br>$ text=hello<br>$ echo hello world | sed “s/$text/HELLO/“<br>HELLO world</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="set-调试执行命令"><a href="#set-调试执行命令" class="headerlink" title="set-调试执行命令"></a>set-调试执行命令</h2><ul>
<li><p>简介：</p>
</li>
<li><p>set命令能设置所使用shell的执行方式，可依照不同的需求来做设置。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>set [+-abCdefhHklmnpPtuvx]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>　标示已修改的变量，以供输出至环境变量。</li>
</ul>
</li>
<li><p><strong>-b</strong></p>
<ul>
<li>　使被中止的后台程序立刻回报执行状态。</li>
</ul>
</li>
<li><p><strong>-C</strong></p>
<ul>
<li>　转向所产生的文件无法覆盖已存在的文件。</li>
</ul>
</li>
<li><p><strong>-d</strong></p>
<ul>
<li>　Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
<ul>
<li>　若指令传回值不等于0，则立即退出shell。</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>　取消使用通配符。</li>
</ul>
</li>
<li><p><strong>-h</strong></p>
<ul>
<li>　自动记录函数的所在位置。</li>
</ul>
</li>
<li><p><strong>-k</strong></p>
<ul>
<li>　指令所给的参数都会被视为此指令的环境变量。</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>　记录for循环的变量名称。</li>
</ul>
</li>
<li><p><strong>-m</strong></p>
<ul>
<li>　使用监视模式。</li>
</ul>
</li>
<li><p><strong>-n</strong></p>
<ul>
<li>　只读取指令，而不实际执行。</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>　启动优先顺序模式。</li>
</ul>
</li>
<li><p><strong>-P</strong></p>
<ul>
<li>　启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>　执行完随后的指令，即退出shell。</li>
</ul>
</li>
<li><p><strong>-u</strong></p>
<ul>
<li>　当执行时使用到未定义过的变量，则显示错误信息。</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>　显示shell所读取的输入值。</li>
</ul>
</li>
<li><p><strong>-x</strong></p>
<ul>
<li>　执行指令后，会先显示该指令及参数。</li>
</ul>
</li>
<li><p><strong>+&lt;参数&gt;</strong></p>
<ul>
<li>　取消某个set曾启动的参数。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>+&lt;参数&gt;:取消某个set曾启动的参数。</p>
</blockquote>
<blockquote>
<p>set命令不带任何参数时，为打印所有环境变量</p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;执行指令后，会先显示该指令及参数。</span><br><span class="line">$ #!&#x2F;bin&#x2F;bash </span><br><span class="line">- #文件名: debug.sh </span><br><span class="line">- for i in &#123;1..2&#125;; </span><br><span class="line">- do</span><br></pre></td></tr></table></figure>
<ul>
<li><p>set -x </p>
</li>
<li><p>echo $i </p>
<ul>
<li>set +x </li>
<li>done </li>
</ul>
<blockquote>
<ul>
<li>echo 1<br>1</li>
<li>set +x</li>
<li>echo 2<br>2</li>
<li>set +x</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统"><a href="#sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统" class="headerlink" title="sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统"></a>sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统</h2><ul>
<li><p>简介：</p>
<ul>
<li>它不需要远端运行FTP服务器来进行文件传输，但必须要有SSH服务器。sftp是一个交互式命令，提供了命令提示符。</li>
<li>sftp支持与ftp和lftp相同的命令。不赘述。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>xxxxxxxxxxxxxxxxx</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><strong>-oPort=PORTNO</strong><ul>
<li>SSH服务器有时候并不在默认的端口22上运行。如果它在其他端口运行，我们可以在sftp中用选项-oPort=PORTNO来指定端口号。  </li>
<li><code>$ sftp -oPort=422 user@slynux.org</code></li>
<li>-oPort应该作为sftp命令的第一个参数。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动sftp会话</span><br><span class="line">$ sftp user@domainname</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="sleep-命令延迟一段时间执行。"><a href="#sleep-命令延迟一段时间执行。" class="headerlink" title="sleep-命令延迟一段时间执行。"></a>sleep-命令延迟一段时间执行。</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux sleep命令可以用来将目前动作延迟一段时间。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>sleep [--help] [--version] number[smhd]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助讯息</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本编号</li>
</ul>
</li>
<li><p><strong>number</strong></p>
<ul>
<li>时间长度，后面可接 s、m、h 或 d。其中 s 为秒，m 为 分钟，h 为小时，d 为日数</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示目前时间后延迟 1 分钟，之后再次显示时间</span><br><span class="line">$ date;sleep 1m;date</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="ssh——远程连接工具"><a href="#ssh——远程连接工具" class="headerlink" title="ssh——远程连接工具"></a>ssh——远程连接工具</h2><ul>
<li><p>简介：</p>
<ul>
<li>SSH代表的是Secure Shell（安全shell）。它使用加密隧道连接两台计算机。</li>
<li>SSH能够让你访问远程计算机上的shell，从而在其上执行交互命令并接收结果，或是启动交互会话。</li>
<li>GNU/Linux发布版中默认并不包含SSH，需要使用软件包管理器安装openssh-server和openssh-client。SSH服务默认运行在端口22之上。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>ssh [选项参数] [user@]hostname] [command]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-p  &lt;端口号&gt;</strong></p>
<ul>
<li>SSH服务器默认在端口22上运行。但有些SSH服务器并没有使用这个端口。针对这种情况，可以用ssh命令的-p &lt;端口号&gt;来指定端口</li>
<li><code>ssh user@locahost -p 422</code></li>
</ul>
</li>
<li><p><strong>- -C</strong></p>
<ul>
<li>SSH协议也支持对数据进行压缩传输。当带宽有限时，这一功能很方便。</li>
<li><code>ssh -C user@hostname COMMANDS</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;连接运行了SSH服务器的远程主机</span><br><span class="line">$  ssh mec@192.168.0.1</span><br><span class="line">&#x2F;&#x2F;mec是远程主机上的用户,192.168.0.1是IP地址,这里也可以是域名</span><br><span class="line">&#x2F;&#x2F;SSH会询问用户密码，一旦认证成功，就会连接到远程主机上的登录shell</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在远程执行命令whoami</span><br><span class="line">$ ssh mec@192.168.0.1 &#39;whoami&#39;</span><br><span class="line">&gt; mec</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以输入多条命令，命令之间用分号分隔</span><br><span class="line">$ ssh mec@192.168.0.1 &quot;echo user: $(whoami);echo OS: $(uname)&quot;</span><br><span class="line">&gt; user: mec </span><br><span class="line">&gt; OS: Linux</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将数据重定向至远程shell命令的stdin</span><br><span class="line">$  echo &#39;text&#39; | ssh user@remote_host &#39;echo&#39;</span><br><span class="line">&gt; text</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将本地主机上的tar存档文件传给远程主机</span><br><span class="line">$ &gt; tar -czf - LOCALFOLDER | ssh &#39;tar -xzvf-&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h1 id="T"><a href="#T" class="headerlink" title="T"></a>T</h1><h2 id="tar——归档或者压缩，解压文件"><a href="#tar——归档或者压缩，解压文件" class="headerlink" title="tar——归档或者压缩，解压文件"></a>tar——归档或者压缩，解压文件</h2><ul>
<li><p>简介：</p>
</li>
<li><p>tar命令可以归档文件。它最初是设计用来将数据存储在磁带上，因此其名字也来源于TapeARchive。tar可以将多个文件和文件夹打包为单个文件，同时还能保留所有的文件属性，如所有者、权限等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>tar [选项参数]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-A或–catenate</strong></p>
<ul>
<li>新增文件到已存在的备份文件。</li>
</ul>
</li>
<li><p><strong>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt;</strong></p>
<ul>
<li>设置每笔记录的区块数目，每个区块大小为12Bytes。</li>
</ul>
</li>
<li><p><strong>-B或–read-full-records</strong></p>
<ul>
<li>读取数据时重设区块大小。</li>
</ul>
</li>
<li><p><strong>-c或–create</strong></p>
<ul>
<li>建立新的备份文件。</li>
</ul>
</li>
<li><p><strong>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt;</strong></p>
<ul>
<li>切换到指定的目录。</li>
</ul>
</li>
<li><p><strong>-d或–diff或–compare</strong></p>
<ul>
<li>对比备份文件内和文件系统上的文件的差异。</li>
</ul>
</li>
<li><p><strong>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt;</strong></p>
<ul>
<li>指定备份文件。</li>
</ul>
</li>
<li><p><strong>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt;</strong></p>
<ul>
<li>每次更换磁带时，就执行指定的Script文件。</li>
</ul>
</li>
<li><p><strong>-g或–listed-incremental</strong></p>
<ul>
<li>处理GNU格式的大量备份。</li>
</ul>
</li>
<li><p><strong>-G或–incremental</strong></p>
<ul>
<li>处理旧的GNU格式的大量备份。</li>
</ul>
</li>
<li><p><strong>-h或–dereference</strong></p>
<ul>
<li>不建立符号连接，直接复制该连接所指向的原始文件。</li>
</ul>
</li>
<li><p><strong>-i或–ignore-zeros</strong></p>
<ul>
<li>忽略备份文件中的0 Byte区块，也就是EOF。</li>
</ul>
</li>
<li><p><strong>-k或–keep-old-files</strong></p>
<ul>
<li>解开备份文件时，不覆盖已有的文件。</li>
</ul>
</li>
<li><p><strong>-K&lt;文件&gt;或–starting-file=&lt;文件&gt;</strong></p>
<ul>
<li>从指定的文件开始还原。</li>
</ul>
</li>
<li><p><strong>-l或–one-file-system</strong></p>
<ul>
<li>复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li>
</ul>
</li>
<li><p><strong>-m或–modification-time</strong></p>
<ul>
<li>还原文件时，不变更文件的更改时间。</li>
</ul>
</li>
<li><p><strong>-M或–multi-volume</strong></p>
<ul>
<li>在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
</ul>
</li>
<li><p><strong>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt;</strong></p>
<ul>
<li>只将较指定日期更新的文件保存到备份文件里。</li>
</ul>
</li>
<li><p><strong>-o或–old-archive或–portability</strong></p>
<ul>
<li>将资料写入备份文件时使用V7格式。</li>
</ul>
</li>
<li><p><strong>-O或–stdout</strong></p>
<ul>
<li>把从备份文件里还原的文件输出到标准输出设备。</li>
</ul>
</li>
<li><p><strong>-p或–same-permissions</strong></p>
<ul>
<li>用原来的文件权限还原文件。</li>
</ul>
</li>
<li><p><strong>-P或–absolute-names</strong></p>
<ul>
<li>文件名使用绝对名称，不移除文件名称前的”/“号。</li>
</ul>
</li>
<li><p><strong>-r或–append</strong></p>
<ul>
<li>新增文件到已存在的备份文件的结尾部分。</li>
</ul>
</li>
<li><p><strong>-R或–block-number</strong></p>
<ul>
<li>列出每个信息在备份文件中的区块编号。</li>
</ul>
</li>
<li><p><strong>-s或–same-order</strong></p>
<ul>
<li>还原文件的顺序和备份文件内的存放顺序相同。</li>
</ul>
</li>
<li><p><strong>-S或–sparse</strong></p>
<ul>
<li>倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
</ul>
</li>
<li><p><strong>-t或–list</strong></p>
<ul>
<li>列出备份文件的内容。</li>
</ul>
</li>
<li><p><strong>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt;</strong></p>
<ul>
<li>指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
</ul>
</li>
<li><p><strong>-u或–update</strong></p>
<ul>
<li><p>仅置换较备份文件内的文件更新的文件。追加选项（-r）可以将指定的任意文件加入到归档文件中。如果同名文件已经存在，那么归档文件中就会包含两个名字一样的文件。我们可以用更新选项-u指明：只添加比归档文件中的同<br>名文件更新（newer）的文件。</p>
</li>
<li><p><code>$ tar -uf archive.tar filea</code>  #如果两个filea的时间戳相同，则什么都不会发生。</p>
</li>
</ul>
</li>
<li><p><strong>-U或–unlink-first</strong></p>
<ul>
<li>解开压缩文件还原文件之前，先解除文件的连接。</li>
</ul>
</li>
<li><p><strong>-v或–verbose</strong></p>
<ul>
<li>显示指令执行过程。</li>
</ul>
</li>
<li><p><strong>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt;</strong></p>
<ul>
<li>建立使用指定的卷册名称的备份文件。</li>
</ul>
</li>
<li><p><strong>-w或–interactive</strong></p>
<ul>
<li>遭遇问题时先询问用户。</li>
</ul>
</li>
<li><p><strong>-W或–verify</strong></p>
<ul>
<li>写入备份文件后，确认文件正确无误。</li>
</ul>
</li>
<li><p><strong>-x或–extract或–get</strong></p>
<ul>
<li>从备份文件中还原文件。</li>
</ul>
</li>
<li><p><strong>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt;</strong></p>
<ul>
<li>指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li>
</ul>
</li>
<li><p><strong>-z或–gzip或–ungzip</strong></p>
<ul>
<li>通过gzip指令处理备份文件。</li>
</ul>
</li>
<li><p><strong>-Z或–compress或–uncompress</strong></p>
<ul>
<li>通过compress指令处理备份文件。</li>
</ul>
</li>
<li><p><strong>-&lt;设备编号&gt;&lt;存储密度&gt;</strong></p>
<ul>
<li>设置备份用的外围设备编号及存放数据的密度。</li>
</ul>
</li>
<li><p><strong>–after-date=&lt;日期时间&gt;</strong></p>
<ul>
<li>此参数的效果和指定”-N”参数相同。</li>
</ul>
</li>
<li><p><strong>–atime-preserve</strong></p>
<ul>
<li>不变更文件的存取时间。</li>
</ul>
</li>
<li><p><strong>–backup=&lt;备份方式&gt;或–backup</strong></p>
<ul>
<li>移除文件前先进行备份。</li>
</ul>
</li>
<li><p><strong>–checkpoint</strong></p>
<ul>
<li>读取备份文件时列出目录名称。</li>
</ul>
</li>
<li><p><strong>–concatenate</strong></p>
<ul>
<li>此参数的效果和指定”-A”参数相同。</li>
</ul>
</li>
<li><p><strong>–confirmation</strong></p>
<ul>
<li>此参数的效果和指定”-w”参数相同。</li>
</ul>
</li>
<li><p><strong>–delete</strong></p>
<ul>
<li>从备份文件中删除指定的文件。</li>
</ul>
</li>
<li><p><strong>–exclude=&lt;范本样式&gt;</strong></p>
<ul>
<li>排除符合范本样式的文件。</li>
</ul>
</li>
<li><p><strong>–group=&lt;群组名称&gt;</strong></p>
<ul>
<li>把加入设备文件中的文件的所属群组设成指定的群组。</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>在线帮助。</li>
</ul>
</li>
<li><p><strong>–ignore-failed-read</strong></p>
<ul>
<li>忽略数据读取错误，不中断程序的执行。</li>
</ul>
</li>
<li><p><strong>–new-volume-script=&lt;Script文件&gt;</strong></p>
<ul>
<li>此参数的效果和指定”-F”参数相同。</li>
</ul>
</li>
<li><p><strong>–newer-mtime</strong></p>
<ul>
<li>只保存更改过的文件。</li>
</ul>
</li>
<li><p><strong>–no-recursion</strong></p>
<ul>
<li>不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
</ul>
</li>
<li><p><strong>–null</strong></p>
<ul>
<li>从null设备读取文件名称。</li>
</ul>
</li>
<li><p><strong>–numeric-owner</strong></p>
<ul>
<li>以用户识别码及群组识别码取代用户名称和群组名称。</li>
</ul>
</li>
<li><p><strong>–owner=&lt;用户名称&gt;</strong></p>
<ul>
<li>把加入备份文件中的文件的拥有者设成指定的用户。</li>
</ul>
</li>
<li><p><strong>–posix</strong></p>
<ul>
<li>将数据写入备份文件时使用POSIX格式。</li>
</ul>
</li>
<li><p><strong>–preserve</strong></p>
<ul>
<li>此参数的效果和指定”-ps”参数相同。</li>
</ul>
</li>
<li><p><strong>–preserve-order</strong></p>
<ul>
<li>此参数的效果和指定”-A”参数相同。</li>
</ul>
</li>
<li><p><strong>–preserve-permissions</strong></p>
<ul>
<li>此参数的效果和指定”-p”参数相同。</li>
</ul>
</li>
<li><p><strong>–record-size=&lt;区块数目&gt;</strong></p>
<ul>
<li>此参数的效果和指定”-b”参数相同。</li>
</ul>
</li>
<li><p><strong>–recursive-unlink</strong></p>
<ul>
<li>解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
</ul>
</li>
<li><p><strong>–remove-files</strong></p>
<ul>
<li>文件加入备份文件后，就将其删除。</li>
</ul>
</li>
<li><p><strong>–rsh-command=&lt;执行指令&gt;</strong></p>
<ul>
<li>设置要在远端主机上执行的指令，以取代rsh指令。</li>
</ul>
</li>
<li><p><strong>–same-owner</strong></p>
<ul>
<li>尝试以相同的文件拥有者还原文件。</li>
</ul>
</li>
<li><p><strong>–suffix=&lt;备份字尾字符串&gt;</strong></p>
<ul>
<li>移除文件前先行备份。</li>
</ul>
</li>
<li><p><strong>–totals</strong></p>
<ul>
<li>备份文件建立后，列出文件大小。</li>
</ul>
</li>
<li><p><strong>–use-compress-program=&lt;执行指令&gt;</strong></p>
<ul>
<li>通过指定的指令处理备份文件。</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本信息。</li>
</ul>
</li>
<li><p><strong>–volno-file=&lt;编号文件&gt;</strong></p>
<ul>
<li>使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>tar命令默认只归档文件，并不对其进行压缩。不过tar支持用于压缩的相关选项。我们日常理解的tar能压缩，其实都并非其命令的本意。压缩能够显著减少文件的体积。<br>归档文件通常被压缩成下列格式之一。<br>gzip格式：file.tar.gz或file.tgz。<br>bzip2格式：file.tar.bz2。<br>Lempel-Ziv-Markov格式：file.tar.lzma。  </p>
</blockquote>
<blockquote>
<p>不同的tar选项可以用来指定不同的压缩格式<br> -j 指定bunzip2格式；<br> -z 指定gzip格式；<br> –lzma 指定lzma格式。  </p>
</blockquote>
<blockquote>
<p>不明确指定上面那些特定的选项也可以使用压缩功能。tar能够基于输出或输入文件的扩展名来进行压缩。为了让tar支持根据扩展名自动选择压缩算法，使用-a或–auto-compress选项<br> <code>$ tar -acvf archive.tar.gz filea fileb filec</code></p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;归档文件，选项-c表示创建新的归档文件。选项-f表示归档文件名，该选项后面必须跟一个或多个文件</span><br><span class="line">$ tar -cf output.tar file</span><br><span class="line">$ $ tar -cf archive.tar file1 file2 file3 folder1 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出归档文件内容</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">&gt; file1 </span><br><span class="line">&gt; file2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出压缩文件内容,而且还要展示更多的细节，使用v选项表示冗长模式，vv为非常冗长模式；</span><br><span class="line">$ tar -tvf archive.tar</span><br><span class="line">&gt; -rw-rw-r-- shaan&#x2F;shaan 0 2013-04-08 21:34 file1 </span><br><span class="line">&gt; -rw-rw-r-- shaan&#x2F;shaan 0 2013-04-08 21:34 file2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向归档文件中追加文件,选项-r可以将新文件追加到已有的归档文件末尾</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">&gt; hello.txt </span><br><span class="line">$ tar -rf archive.tar world.txt </span><br><span class="line">$ tar -tf archive.tar </span><br><span class="line">&gt; hello.txt </span><br><span class="line">&gt; world.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提取文件，-x可以将归档文件的内容提取到当前目录</span><br><span class="line">$ tar -xf archive.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解压文件</span><br><span class="line">$ tar -xzf archive.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们也可以用选项-C来指定将文件提取到哪个目录：</span><br><span class="line">$ tar -xf archive.tar -C &#x2F;path&#x2F;to&#x2F;extraction_directory</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;上述命令将归档文件的内容提取到指定目录中。它提取的是归档文件中的全部内容。</span><br><span class="line">&#x2F;&#x2F;我们可以通过将文件名作为命令行参数来提取特定的文件，下述命令只提取file1和file4，忽略其他文件</span><br><span class="line">$ tar -xvf file.tar file1 file4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在归档时，我们可以将stdout指定为输出文件，这样另一个命令就可以通过管道来读取（作为stdin）并进行其他处理。</span><br><span class="line">&#x2F;&#x2F;当通过安全shell（Secure Shell，SSH）传输数据时，这招很管用。</span><br><span class="line">$ tar cvf - files&#x2F; | ssh user@example.com &quot;tar xv -C Documents&#x2F;&quot;</span><br><span class="line">&#x2F;&#x2F;在上面的例子中，对files目录中的内容进行了归档并将其输出到stdout（由-指明），然后提取到远程系统中的Documents目录中。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们可以用选项-A合并多个tar文件。</span><br><span class="line">&#x2F;&#x2F;假设我们现在有两个tar文件：file1.tar和file2.tar。下面的命令可以将file2.tar的内容合并到file1.tar中</span><br><span class="line">$ tar -Af file1.tar file2.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从归档中删除文件</span><br><span class="line">$ tar -f archive.tar --delete file1 file2</span><br><span class="line">或</span><br><span class="line">$ tar --delete --file archive.tar [FILE LIST]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在归档过程中排除部分文件</span><br><span class="line">&#x2F;&#x2F;选项--exclude [PATTERN]可以将匹配通配符模式的文件排除在归档过程之外。例如，排除所有的.txt文件</span><br><span class="line">&#x2F;&#x2F;注意，模式应该使用双引号来引用，避免shell对其进行扩展。</span><br><span class="line">$ tar -cf arch.tar * --exclude &quot;*.txt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以配合选项-X将需要排除的文件列表放入文件中</span><br><span class="line">$ cat list </span><br><span class="line">&gt; filea </span><br><span class="line">&gt; fileb</span><br><span class="line">$ tar -cf arch.tar * -X list</span><br><span class="line">&#x2F;&#x2F;这样就把filea和fileb排除了。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="tail–打印文件尾部内容"><a href="#tail–打印文件尾部内容" class="headerlink" title="tail–打印文件尾部内容"></a>tail–打印文件尾部内容</h2><ul>
<li><p>简介：</p>
</li>
<li><p>tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。<strong>如果没有指定文件或者文件名为“-”，则读取标准输入。</strong></p>
</li>
<li><p>语法：</p>
<ul>
<li><code>tail [选项][参数]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>–retry</strong></p>
<ul>
<li>即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；</li>
</ul>
</li>
<li><p><strong>-c <N>或–bytes=N</strong></p>
<ul>
<li>输出文件尾部的N（N为整数）个字节内容；N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。N值后面可以有后缀：b表示512，k表示1024，m表示1 048576(1M)。</li>
</ul>
</li>
<li><p><strong>-f &lt;name/descriptor&gt;或；–follow &lt;name/descript&gt;</strong></p>
<ul>
<li>显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；</li>
</ul>
</li>
<li><p><strong>-F</strong></p>
<ul>
<li>与选项“-follow=name”和“–retry”连用时功能相同；</li>
</ul>
</li>
<li><p><strong>-n<N>或–line=N</strong></p>
<ul>
<li>输出文件的尾部N（N位数字）行内容。N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。</li>
</ul>
</li>
<li><p><strong>–pid=&lt;进程号&gt;</strong></p>
<ul>
<li>与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；</li>
</ul>
</li>
<li><p><strong>-q或–quiet或–silent</strong></p>
<ul>
<li>当有多个文件参数时，不输出各个文件名；</li>
</ul>
</li>
<li><p><strong>-s&lt;秒数&gt;或–sleep-interal=&lt;秒数&gt;</strong></p>
<ul>
<li>与“-f”选项连用，指定监视文件变化时间隔的秒数；</li>
</ul>
</li>
<li><p><strong>-v或–verbose</strong></p>
<ul>
<li>当有多个文件参数时，总是输出各个文件名；</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示指令的帮助信息；</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示指令的版本信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示文件file的最后10行</span><br><span class="line">$ tail file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示文件file的内容，从第20行至文件末尾</span><br><span class="line">$ tail +20 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示文件file的最后10个字符</span><br><span class="line">$ tail -c 10 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实时查看file追加的内容</span><br><span class="line">$ tail -f file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;间隔五秒刷新file追加的内容</span><br><span class="line">$ tail -f -s 5 file</span><br></pre></td></tr></table></figure>
<p>  <img src="https://oscimg.oschina.net/oscnet/4d13470cc8c44cb148b7e75722332757ea9.jpg" alt=""></p>
</li>
</ul>
<hr>
<h2 id="time-量测命令执行消耗的时间"><a href="#time-量测命令执行消耗的时间" class="headerlink" title="time-量测命令执行消耗的时间"></a>time-量测命令执行消耗的时间</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux time命令的用途，在于量测特定指令执行时所需消耗的时间及系统资源等资讯。例如 CPU 时间、记忆体、输入输出等等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>time [options] COMMAND [arguments]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-o 或 –output=FILE</strong></p>
<ul>
<li>设定结果输出档。这个选项会将 time 的输出写入 所指定的档案中。如果档案已经存在，系统将覆写其内容。</li>
</ul>
</li>
<li><p><strong>-a 或 –append</strong></p>
<ul>
<li>配合 -o 使用，会将结果写到档案的末端，而不会覆盖掉原来的内容。</li>
</ul>
</li>
<li><p><strong>-f <FORMAT> 或 –format=FORMAT</strong></p>
<ul>
<li>以 FORMAT 字串设定显示方式。当这个选项没有被设定的时候，会用系统预设的格式。不过你可以用环境变数 time 来设定这个格式，如此一来就不必每次登入系统都要设定一次。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;检测date命令运行时间和资源</span><br><span class="line">$ time date</span><br><span class="line">&gt; real    0m0.136s</span><br><span class="line">&gt; user    0m0.010s</span><br><span class="line">&gt; sys     0m0.070s</span><br><span class="line">&#x2F;&#x2F;在以上实例中，执行命令&quot;time date&quot;。系统先执行命令&quot;date&quot;，第2行为命令&quot;date&quot;的执行结果。</span><br><span class="line">&#x2F;&#x2F;第3-6行为执行命令&quot;date&quot;的时间统计结果，其中第4行&quot;real&quot;为实际时间，</span><br><span class="line">&#x2F;&#x2F;第5行&quot;user&quot;为用户CPU时间，第6行&quot;sys&quot;为系统CPU时间。以上三种时间的显示格式均为MMmNN[.FFF]s。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="tr-转换或删除文件中的字符。"><a href="#tr-转换或删除文件中的字符。" class="headerlink" title="tr-转换或删除文件中的字符。"></a>tr-转换或删除文件中的字符。</h2><ul>
<li><p>简介：</p>
</li>
<li><p>tr 可以对来自标准输入的内容进行字符替换、字符删除以及重复字符压缩，将结果输出到标准输出设备。tr是translate（转换）的简写，因为它可以将一组字符转换成另一组字符。</p>
</li>
<li><p>语法：</p>
<ul>
<li><p><code>tr [选项参数][--help][--version][第一字符集][第二字符集]   或 tr [OPTION] SET1[SET2]</code></p>
<blockquote>
<p>来自stdin的输入字符会按照位置从set1映射到set2（set1中的第一个字符映射到set2中的第一个字符，以此类推），然后将输出写入stdout（标准输出）。</p>
</blockquote>
<blockquote>
<p>set1和set2是字符类或字符组。如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-c, –complement</strong></p>
<ul>
<li>反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换</li>
</ul>
</li>
<li><p><strong>-d, –delete</strong></p>
<ul>
<li>删除指令字符</li>
</ul>
</li>
<li><p><strong>-s, –squeeze-repeats</strong></p>
<ul>
<li>缩减连续重复的字符成指定的单个字符</li>
</ul>
</li>
<li><p><strong>-t, –truncate-set1</strong></p>
<ul>
<li>削减 SET1 指定范围，使之与 SET2 设定长度相等</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示程序用法信息</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示程序本身的版本信息</li>
</ul>
</li>
</ul>
</li>
<li><p>字符集合的范围</p>
<ul>
<li><p><strong>\NNN</strong></p>
<ul>
<li>八进制值的字符 NNN (1 to 3 为八进制值的字符)</li>
</ul>
</li>
<li><p><strong>\a Ctrl-G</strong></p>
<ul>
<li>铃声</li>
</ul>
</li>
<li><p><strong>\b Ctrl-H</strong></p>
<ul>
<li>退格符</li>
</ul>
</li>
<li><p><strong>\f Ctrl-L</strong></p>
<ul>
<li>走行换页</li>
</ul>
</li>
<li><p><strong>\n Ctrl-J</strong></p>
<ul>
<li>新行</li>
</ul>
</li>
<li><p><strong>\r Ctrl-M</strong></p>
<ul>
<li>回车</li>
</ul>
</li>
<li><p><strong>\t Ctrl-I</strong></p>
<ul>
<li>tab键</li>
</ul>
</li>
<li><p><strong>\v Ctrl-X</strong></p>
<ul>
<li>水平制表符</li>
</ul>
</li>
<li><p><strong>CHAR1-CHAR2</strong></p>
<ul>
<li>字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。<br>‘ABD-}’、’aA.,’、’a-ce-x’以及’a-c0-9’等均是合法的集合。<br>定义集合也很简单，不需要书写一长串连续的字符序列，只需要使用“起始字符-终止字符”这种格式就行了。</li>
</ul>
</li>
<li><p><strong>[CHAR*]</strong></p>
<ul>
<li>这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止</li>
</ul>
</li>
<li><p><strong>[CHAR*REPEAT]</strong></p>
<ul>
<li>这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)</li>
</ul>
</li>
<li><p><strong>[:alnum:]</strong></p>
<ul>
<li>所有字母字符与数字</li>
</ul>
</li>
<li><p><strong>[:alpha:]</strong></p>
<ul>
<li>所有字母字符</li>
</ul>
</li>
<li><p><strong>[:blank:]</strong></p>
<ul>
<li>所有水平空格</li>
</ul>
</li>
<li><p><strong>[:cntrl:]</strong></p>
<ul>
<li>所有控制（非打印）字符</li>
</ul>
</li>
<li><p><strong>[:digit:]</strong></p>
<ul>
<li>所有数字</li>
</ul>
</li>
<li><p><strong>[:graph:]</strong></p>
<ul>
<li>所有可打印的字符(不包含空格符)</li>
</ul>
</li>
<li><p><strong>[:lower:]</strong></p>
<ul>
<li>所有小写字母</li>
</ul>
</li>
<li><p><strong>[:print:]</strong></p>
<ul>
<li>所有可打印的字符(包含空格符)</li>
</ul>
</li>
<li><p><strong>[:punct:]</strong></p>
<ul>
<li>所有标点字符</li>
</ul>
</li>
<li><p><strong>[:space:]</strong></p>
<ul>
<li>所有水平与垂直空格符</li>
</ul>
</li>
<li><p><strong>[:upper:]</strong></p>
<ul>
<li>所有大写字母</li>
</ul>
</li>
<li><p><strong>[:xdigit:]</strong></p>
<ul>
<li>所有 16 进位制的数字</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;文件testfile中的小写字母全部转换成大写字母，然后输出</span><br><span class="line">$ cat testfile |tr a-z A-Z</span><br><span class="line">或反过来</span><br><span class="line">$ echo &quot;HELLO WHO IS THIS&quot; |tr [:upper:] [:lower:]</span><br><span class="line">&gt; hello who is this</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用tr进行数字加密和解密</span><br><span class="line">&#x2F;&#x2F;加密</span><br><span class="line">$ echo 12345 | tr &#39;0-9&#39; &#39;9876543210&#39;</span><br><span class="line">&gt; 87654 # 已加密</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解密</span><br><span class="line">$  echo 87654 | tr &#39;9876543210&#39; &#39;0-9&#39;</span><br><span class="line">&gt; 12345 # 已解密</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将制表符转换成单个空格</span><br><span class="line">$ tr &#39;\t&#39; &#39; &#39; &lt; file.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用tr删除字符，语法上只使用set1，不使用set2</span><br><span class="line">&#x2F;&#x2F;将stdin中的数字删除并打印删除后的结果</span><br><span class="line">$ echo &quot;Hello 123 world 456&quot; | tr -d &#39;0-9&#39;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从输入文本中删除不在补集中的所有字符</span><br><span class="line">$ echo hello 1 char 2 next 4 | tr -d -c &#39;0-9 \n&#39;</span><br><span class="line">&gt; 124</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将不在set1中的字符替换成空格</span><br><span class="line">$ echo hello 1 char 2 next 4 | tr -c &#39;0-9&#39; &#39; &#39;</span><br><span class="line">&gt;  1 2 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果你习惯在点号后面放置两个空格，你需要在不删除重复字母的情况下去掉多余的空格（-s 缩减连续重复的字符成指定的单个字符）</span><br><span class="line">$  echo &quot;GNU is not UNIX. Recursive right ?&quot; | tr -s &#39; &#39;</span><br><span class="line">&gt; GNU is not UNIX. Recursive right ?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件中的数字进行相加,先删除字母，再将&#39; &#39;替换成+号，得到 $[ 1+2+3+4+5 ]，$[ operation ]执行算术运算，得出结果</span><br><span class="line">$ cat test.txt | tr -d [a-z] | echo &quot;total: $[$(tr &#39; &#39; &#39;+&#39;)]&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>tr只能通过stdin（标准输入）接收输入（无法通过命令行参数接收）</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="U"><a href="#U" class="headerlink" title="U"></a>U</h1><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><h1 id="W"><a href="#W" class="headerlink" title="W"></a>W</h1><h2 id="which-查找并显示给定命令的绝对路径"><a href="#which-查找并显示给定命令的绝对路径" class="headerlink" title="which-查找并显示给定命令的绝对路径"></a>which-查找并显示给定命令的绝对路径</h2><ul>
<li><p>简介：</p>
</li>
<li><p>环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>which cmdName</code></li>
</ul>
</li>
<li><p>选项值：</p>
</li>
<li><p>注意事项</p>
<blockquote>
<p>which是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p>
</blockquote>
<blockquote>
<p>cd 这种常用的命令找不到,因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以找不到的！</p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查找文件、显示命令路径</span><br><span class="line">$ which pwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;pwd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><h2 id="xargs-参数传递过滤器"><a href="#xargs-参数传递过滤器" class="headerlink" title="xargs-参数传递过滤器"></a>xargs-参数传递过滤器</h2><ul>
<li><p>简介：</p>
<ul>
<li>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</li>
<li>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</li>
<li>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</li>
<li>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</li>
<li>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</li>
<li>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;sbin -perm +700 |ls -l       #这个命令是错误的</span><br><span class="line">find &#x2F;sbin -perm +700 |xargs ls -l   #这样才是正确的</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>somecommand |xargs -item  command</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a file</strong></p>
<ul>
<li>从文件中读入作为sdtin</li>
</ul>
</li>
<li><p><strong>-e flag 或 -E flag</strong></p>
<ul>
<li>flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>当每次执行一个argument的时候询问一次用户。</li>
</ul>
</li>
<li><p><strong>-n num</strong></p>
<ul>
<li>后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。如果用在输出场景，那就是一行有n个</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>表示先打印命令，然后再执行。</li>
</ul>
</li>
<li><p><strong>-i 或-I</strong></p>
<ul>
<li>可以用于指定替换字符串，这个字符串会在xargs解析输入时被参数替换掉。如 复制所有图片文件到/data/images 目录下：-I 指定替换符号是{}，那么xargs每个输出，都会替换cp后面的{}<br><code>ls *.jpg | xargs -n1 -I {} cp {} /data/images</code></li>
</ul>
</li>
<li><p><strong>-r no-run-if-empty</strong></p>
<ul>
<li>当xargs的输入为空的时候则停止xargs，不用再去执行了。</li>
</ul>
</li>
<li><p><strong>-s num</strong></p>
<ul>
<li>命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li>
</ul>
</li>
<li><p><strong>-L num</strong></p>
<ul>
<li>从标准输入一次读取 num 行送给 command 命令。</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>同 -L。</li>
</ul>
</li>
<li><p><strong>-d delim</strong></p>
<ul>
<li>xargs对于输入的默认分隔符是空格，-d选项可以为输入数据指定自定义的分隔符</li>
</ul>
</li>
<li><p><strong>-x</strong></p>
<ul>
<li>exit的意思，主要是配合-s使用。。</li>
</ul>
</li>
<li><p><strong>-P</strong></p>
<ul>
<li>修改最大的进程数，默认是1，为0时候为as many as it can</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;多行输入单行输出</span><br><span class="line">$ cat test.txt</span><br><span class="line">&gt; a b c d e f g</span><br><span class="line">&gt; h i j k l m n</span><br><span class="line"></span><br><span class="line">$ cat test.txt | xargs</span><br><span class="line">&gt; a b c d e f g h i j k l m n</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-n 选项多行输出,每行三个元素</span><br><span class="line">$ cat test.txt | xargs -n 3</span><br><span class="line">&gt; a b c</span><br><span class="line">&gt; d e f</span><br><span class="line">&gt; g h i</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;stdin中是一个包含了多个X字符的字符串。我们可以用–d选项将X定义为输入分隔符。</span><br><span class="line">$ echo &quot;splitXsplit2Xsplit3Xsplit4&quot; | xargs -d X </span><br><span class="line">&gt; Split1 split2 split3 split4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在系统中搜索.docx文件，这些文件名中通常会包含大写字母和空格。其中使用了grep找出内容中不包含image的文件</span><br><span class="line">$ find &#x2F;smbMount -iname &#39;*.docx&#39; -print0 | xargs -0 grep -L image</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>xargs 一般是和管道一起使用。</p>
</blockquote>
<blockquote>
<p>xargs命令可以同find命令很好地结合在一起。find的输出可以通过管道传给xargs，由后者执行-exec选项所无法处理的复杂操作。如果文件系统的有些文件名中包含空格，find命令的-print0选项可以使用0（NULL）来分隔查找到的元素，然后再用xargs对应的-0选项进行解析。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h1><h1 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h1><h2 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h2><ul>
<li><p>简介：</p>
<ul>
<li>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>xxxxxxxxxxxxxxxxx</code></li>
</ul>
</li>
<li><p>选项值：</p>
</li>
</ul>
<ul>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">$ </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/17/shell-notes-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/17/shell-notes-tips/" itemprop="url">shell notes&tips</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-17T18:56:32+08:00">
                2019-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/Linux%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">Linux相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/17/shell-notes-tips/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/07/17/shell-notes-tips/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  8.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  31
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><blockquote>
<p>ps：下文中，我们使用$ 表示终端提示符表示输入命令的符号，- 表示多行命令的换行（多行命令不挤在一行以便美观），&gt; 表示终端的输出。</p>
</blockquote>
<blockquote>
<p>右侧边有导航栏，可进行跳转</p>
</blockquote>
<hr>
<ul>
<li>shell脚本通常以shebang起始，/bin/bash是Bash的解释器命令路径 <code>#!/bin/bash</code></li>
</ul>
<h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><h3 id="fork模式"><a href="#fork模式" class="headerlink" title="fork模式"></a>fork模式</h3><p>我们所执行的任何程序，都是由父进程(parent process)所产生出来的一个子进程(child process)，子进程在结束后，将返回到父进程去。此一现像在Linux系统中被称为 fork。当子进程被产生的时候，将会从父进程那里获得一定的资源分配、及(更重要的是)继承父进程的环境。</p>
<ul>
<li><p>fork模式，脚本的执行方式有两种。</p>
<ul>
<li><p>将脚本名作为命令行参数（无须设置权限）</p>
<p>  <code>$ bash myScript.sh</code></p>
</li>
<li><p>授予脚本执行权限，将其变为可执行文件：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 755 myScript.sh</span><br><span class="line">$ .&#x2F;myScript.sh.</span><br></pre></td></tr></table></figure>
<h3 id="source模式"><a href="#source模式" class="headerlink" title="source模式"></a>source模式</h3><p>source方式的特点是，在不另外创建子进程，而是在当前的的Shell环境中执行。</p>
</li>
</ul>
</li>
<li><p>source模式，脚本的执行方式有两种。</p>
<ul>
<li><p>source命令+文件路径</p>
<p>  <code>$ source myScript.sh 或 source ./myScript.sh</code></p>
</li>
<li><p>. 命令</p>
<p>  <code>$ . myScript.sh 或 . ./myScript.sh</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="exec模式"><a href="#exec模式" class="headerlink" title="exec模式"></a>exec模式</h3><p>exec模式和source方式一样，不另外创建子进程，而是在当前的的Shell环境中执行脚本，但是执行完后会终止当前的shell进程，如果使用终端，可以看见执行exec后终端退出。</p>
<ul>
<li><p>exec命令</p>
<p>  <code>exec ./mytest.sh 或 exec myScript.sh</code></p>
</li>
</ul>
<hr>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>你在命令行中输入的绝大部分命令都可以放置在一个特殊的文件中，留待登录或启动新的bash会话时执行。将函数定义、别名以及环境变量设置放置在这种特殊文件中，是一种定制shell的常用方法。</p>
<ul>
<li>当用户登录shell时，会执行下列文件：<ul>
<li>/etc/profile</li>
<li>$HOME/.profile</li>
<li>$HOME/.bash_login</li>
<li>$HOME/.bash_profile<blockquote>
<p>注意，如果你是通过图形化登录管理器登入的话，是不会执行/etc/profile、$HOME/.profile和$HOME/.bash_profile这3个文件的。这是因为图形化窗口管理器并不会启动shell。当你打开终端窗口时才会创建shell，但这个shell也不是登录shell。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果.bash_profile或.bash_login文件存在，则不会去读取.profile文件。</p>
</blockquote>
<ul>
<li>交互式shell（如X11终端会话）或ssh执行单条命令（如ssh 192.168.1.1 ls /tmp）时，<br>会读取并执行以下文件：<ul>
<li>/etc/bash.bashrc</li>
<li>$HOME/.bashrc</li>
</ul>
</li>
<li>调用ssh登录会话<br>  <code>ssh 192.168.1.100</code><br>  这会创建一个新的登录bash shell，该shell会读取并执行以下文件：<ul>
<li>/etc/profile</li>
<li>/etc/bash.bashrc</li>
<li>$HOME/.profile</li>
<li>.bashrc_profile</li>
</ul>
</li>
<li>运行脚本  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果运行如下脚本：</span><br><span class="line">$&gt; cat myscript.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;Running&quot;</span><br></pre></td></tr></table></figure>
  不会执行任何配置文件，除非定义了环境变量BASH_ENV：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; export BASH_ENV&#x3D;~&#x2F;.bashrc </span><br><span class="line">$&gt; .&#x2F;myscript.sh</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li>
</ul>
<p>Shell变量大致可以分为3种类型： </p>
<ul>
<li><p>内部变量：系统提供，不用定义，不能修改，比如$#，$?，$*，$0等 </p>
</li>
<li><p>环境变量：系统提供，不用定义，可以修改，当前进程及其子进程中使用，比如PATH，PWD，SHELL等 </p>
</li>
<li><p>用户变量（本地变量）：用户定义，可以修改，在当前进程使用，比如var=123等</p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量有如下几种形式</p>
<ul>
<li>不加符号的等号操作符赋值</li>
</ul>
<p><code>varName=value</code>  </p>
<blockquote>
<p>如果value不包含任何空白字符（例如空格），那么就不需要将其放入引号中，否则必须使用单引号或双引号。</p>
</blockquote>
<ul>
<li>单引号的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;单引号不扩展或解释任何变量和符号</span><br><span class="line">$ test&#x3D;&#39;ps$?&#39;</span><br><span class="line">$ echo $test</span><br><span class="line">&gt; ps$?</span><br></pre></td></tr></table></figure></li>
<li>双引号的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;双引号会扩展解释变量和符号，其中$?为上条命令执行的结果</span><br><span class="line">$ test&#x3D;&quot;ps$?&quot;</span><br><span class="line">$ echo $test</span><br><span class="line">&gt; ps0</span><br></pre></td></tr></table></figure></li>
<li>反引号的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;反引号（键盘上的~键），将内容命令的输出存入变量，该例中将ps命令的输出存入test</span><br><span class="line">$ test&#x3D;&#96;ps&#96;</span><br><span class="line">$ echo $test</span><br><span class="line">PID TTY TIME CMD 2856 pts&#x2F;0 00:00:00 bash 3234 pts&#x2F;0 00:00:00 ps</span><br></pre></td></tr></table></figure></li>
<li>子shell的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用$()，将开启子shell，或者说子进程执行内容命令，并将内容命令的输出存入变量，该例中将ps命令的输出存入test</span><br><span class="line">$ test&#x3D;$(ps)</span><br><span class="line">$ echo $test</span><br><span class="line">PID TTY TIME CMD 2856 pts&#x2F;0 00:00:00 bash 3234 pts&#x2F;0 00:00:00 ps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，var = value不同于var=value。两边没有空格的等号是赋值操作符，加上空格的等号表示的是等量关系测试。</p>
</blockquote>
</li>
<li>export命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> HTTP_PROXY=192.168.1.23:3128</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HTTP_PROXY</span></span><br><span class="line">//export命令声明了将由子进程所继承的一个或多个变量。</span><br><span class="line">//这些变量被导出后，当前shell脚本所执行的任何应用程序都会获得这个变量。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要append变量，例如对PATH中添加一条新路径，可以使用如下命令：</p>
<figure class="highlight plain"><figcaption><span>export PATH</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 常见的环境变量</span><br><span class="line">- SHELL：环境变量SHELL获知当前使用的是哪种shell </span><br></pre></td></tr></table></figure>
<p>$ echo $SHELL<br>$ echo $0<br>/bin/bash</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- UID：环境变量UID中保存的是用户ID。root用户的UID是0。</span><br><span class="line">- PS1：当我们打开终端或是运行shell时，会看到类似于user@hostname:&#x2F;home&#x2F;$ 的提示字符串。不同的GNU&#x2F;Linux发布版中的提示字符串及颜色各不相同。我们可以利用PS1环境变量来定义主提示字符串。</span><br><span class="line">- PATH：PATH环境变量通常保存了可用于搜索可执行文件的路径列表。&#96;PATH&#x3D;&#x2F;usr&#x2F;bin; &#x2F;bin&#96;这意味着只要shell执行应用程序（二进制文件或脚本）时，它就会首先查找&#x2F;usr&#x2F;bin，然后查找&#x2F;bin。</span><br><span class="line">- LD_LIBRARY_PATH：LD_LIBRARY_PATH环境变量通常保存了可用于搜索库文件的路径列表。&#96;LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;lib; &#x2F;lib&#96;这意味着只要shell执行库文件时，它就会首先查找&#x2F;usr&#x2F;lib，然后查找&#x2F;lib。</span><br><span class="line">- IFS:内部字段分隔符（internal field separator）。IFS环境变量保存了用于分隔的字符。它是当前shell环境使用的默认定界字符串。IFS的默认值为空白字符（换行符、制表符或者空格）。</span><br></pre></td></tr></table></figure>
$ oldIFS=$IFS </li>
<li>IFS=, #IFS现在被设置为, </li>
<li>for item in $data; </li>
<li>do </li>
<li>echo Item: $item </li>
<li>done </li>
<li>IFS=$oldIFS</li>
</ul>
<blockquote>
<p>Item: name<br>Item: gender<br>Item: rollno<br>Item: location</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SHLVL：保存当前shell的层级</span><br><span class="line">### 访问变量</span><br><span class="line">- 和编译型语言不同，大多数脚本语言不要求在创建变量之前声明其类型。用到什么类型就是什么类型。在变量名前面加上一个美元符号就可以访问到变量的值。也可以使用$&#123;var&#125;。其分别如下：</span><br></pre></td></tr></table></figure>
<p>$ fruit=apple<br>$ count=5<br>$ echo “We have $count ${fruit}s”</p>
<blockquote>
<p>We have 5 apples<br>//因为shell使用空白字符来分隔单词，<br>//所以我们需要加上一对花括号来告诉shell这里的变量名是fruit，<br>//而不是fruits。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 获得字符串的长度</span><br><span class="line">- 可以用下面的方法获得变量值的长度：</span><br></pre></td></tr></table></figure>
<p>$ var=12345678901234567890<br>$ echo $操作符</p>
</li>
</ul>
<p>% %% # ## 操作符可以得到变量var删除特定的值后的结果：</p>
<p>假设我们定义file=/dir1/dir2/dir3/my.file.txt</p>
<p>可以用${ }分别替换得到不同的值：</p>
<ul>
<li>${file#*/}：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt</li>
<li>${file##*/}：删掉最后一个 /  及其左边的字符串：my.file.txt</li>
<li>${file#*.}：删掉第一个 .  及其左边的字符串：file.txt</li>
<li>${file##*.}：删掉最后一个 .  及其左边的字符串：txt</li>
<li>${file%/*}：删掉最后一个  /  及其右边的字符串：/dir1/dir2/dir3</li>
<li>${file%%/*}：删掉第一个 /  及其右边的字符串：(空值)</li>
<li>${file%.*}：删掉最后一个  .  及其右边的字符串：/dir1/dir2/dir3/my.file</li>
<li>${file%%.*}：删掉第一个  .   及其右边的字符串：/dir1/dir2/dir3/my</li>
</ul>
<blockquote>
<p>记忆方法：  </p>
<h1 id="是去掉左边（键盘上-在-的左边）去掉左边的时候，通配符-就要在指定的符号左边"><a href="#是去掉左边（键盘上-在-的左边）去掉左边的时候，通配符-就要在指定的符号左边" class="headerlink" title="是去掉左边（键盘上#在 $ 的左边）去掉左边的时候，通配符*就要在指定的符号左边"></a>是去掉左边（键盘上#在 $ 的左边）去掉左边的时候，通配符*就要在指定的符号左边</h1><p>% 是去掉右边（键盘上% 在$ 的右边）去掉右边的时候，通配符*就要在指定的符号右边<br>单一符号是最小匹配；吝啬匹配<br>两个符号是最大匹配；贪婪匹配</p>
</blockquote>
<hr>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="${::}操作符"></a>${::}操作符</h4><ul>
<li>${file:0:5} ：提取从第0个开始的连续5个字节：/dir1</li>
<li>${file:5:5} ：提取第5个开始的连续5个字节：/dir2<h4 id=""><a href="#" class="headerlink" title="${//}"></a>${//}</h4></li>
<li>${file/dir/path}：将第一个dir替换为path：/path1/dir2/dir3/my.file.txt</li>
<li>${file//dir/path}：将全部dir 替换为 path：/path1/path2/path3/my.file.txt<blockquote>
<p>同样的：单一符号是最小匹配；吝啬匹配<br>两个符号是最大匹配；贪婪匹配</p>
</blockquote>
<h3 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp;和||"></a>&amp;&amp;和||</h3></li>
<li>shell 在执行某个命令的时候，会返回一个返回值，该返回值保存在 shell 变量 $? 中。当 $? == 0 时，表示执行成功；当 $? == 1 时（我认为是非0的数，返回值在0-255间），表示执行失败。</li>
<li>有时候，下一条命令依赖前一条命令是否执行成功。如：在成功地执行一条命令之后再执行另一条命令，或者在一条命令执行失败后再执行另一条命令等。shell 提供了 &amp;&amp; 和 || 来实现命令执行控制的功能，shell 将根据 &amp;&amp; 或 || 前面命令的返回值来控制其后面命令的执行。</li>
<li>无论是&amp;&amp;还是||，联合命令行都会尽量执行至成功为止。（这才有了短路的意义）  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2 [&amp;&amp; command3 ...]</span><br><span class="line">&#x2F;&#x2F;命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。</span><br><span class="line">&#x2F;&#x2F;只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? &#x3D;&#x3D; 0），&amp;&amp; 右边的命令才会被执行。</span><br><span class="line">&#x2F;&#x2F;只要有一个命令返回假（命令返回值 $? &#x3D;&#x3D; 1），后面的命令就不会被执行。</span><br><span class="line"></span><br><span class="line">command1 || command2 [|| command3 ...]</span><br><span class="line">&#x2F;&#x2F;命令之间使用 || 连接，实现逻辑或的功能。</span><br><span class="line">&#x2F;&#x2F;只有在 || 左边的命令返回假（命令返回值 $? &#x3D;&#x3D; 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。</span><br><span class="line">&#x2F;&#x2F;只要有一个命令返回真（命令返回值 $? &#x3D;&#x3D; 0），后面的命令就不会被执行。 –直到返回真的地方停止执行。</span><br></pre></td></tr></table></figure>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h3></li>
</ul>
<p>Unix shell脚本最棒的特性之一就是可以轻松地将多个命令组合起来生成输出。一个命令的输出可以作为另一个命令的输入，而这个命令的输出又会传递至下一个命令，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这里我们组合了3个命令。cmd1的输出传递给cmd2，cmd2的输出传递给cmd3，最终的输出 12（来自cmd3）会出现在显示器中或被导入某个文件。</span><br><span class="line">$ cmd1 | cmd2 | cmd3</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="shell代码执行顺序"><a href="#shell代码执行顺序" class="headerlink" title="shell代码执行顺序"></a>shell代码执行顺序</h2><h3 id="重定向执行顺序"><a href="#重定向执行顺序" class="headerlink" title="重定向执行顺序"></a>重定向执行顺序</h3><ul>
<li><p>先读取输入重定向符&lt;后的内容做为输入，如果一条命令有多个&lt;，会读取最后一个&lt;后的内容<br>输入重定向符&lt;放在命令前后都可以，例如【&lt; /etc/hosts cat】相当于【cat /etc/hosts】</p>
</li>
<li><p>执行命令</p>
</li>
<li><p>如果有&gt;或&gt;&gt;会将结果进行重定向，如果输出重定向多个文件，只会将内容重定向到最后一个文件<br>例如 cat /etc/hosts &gt; test1.txt &gt;test2.txt，只有test2.txt会出现内容，test1.txt内容是空的<br>输出重定向&gt;和&gt;&gt;的位置放在哪里都可以，例如【&gt; test.txt  cat /etc/hosts】，表示将/etc/hosts的内容输入到test.txt中</p>
</li>
</ul>
<h3 id="管道符执行顺序"><a href="#管道符执行顺序" class="headerlink" title="管道符执行顺序"></a>管道符执行顺序</h3><p><code>command1 | command2</code><br>命令1必须要有输出，且是正确的。命令2才会执行。命令1的输出作为命令2的输入</p>
<hr>
<h2 id="数学运算-let、-和"><a href="#数学运算-let、-和" class="headerlink" title="数学运算-let、(( ))和[]"></a>数学运算-let、(( ))和[]</h2><p>Bash shell使用let、(( ))和[]执行基本的算术操作。工具expr和bc可以用来执行高级操作。</p>
<ul>
<li>let命令<ul>
<li>let命令可以直接执行基本的算术操作。当使用let时，变量名之前不需要再添加$，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ no1&#x3D;4; </span><br><span class="line">$ no2&#x3D;5;</span><br><span class="line">$ let result&#x3D;no1</span><br><span class="line">$ echo $result</span><br><span class="line">&gt; 9</span><br></pre></td></tr></table></figure></li>
<li>let自操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ let no1++</span><br><span class="line">$ let no1--</span><br><span class="line">$ let no+&#x3D;6</span><br><span class="line">$ let no-&#x3D;6</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>操作符$[]和$(())<ul>
<li>操作符[]的使用方法和let命令一样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ result&#x3D;$[ no1 + no2 ]</span><br><span class="line">&#x2F;&#x2F;在[]中也可以使用$前缀，例如：</span><br><span class="line">$ result&#x3D;$[ $no1 + 5 ]</span><br><span class="line">&#x2F;&#x2F;也可以使用操作符(())</span><br><span class="line">$ result&#x3D;$(( no1 + 50 ))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>expr<ul>
<li>expr同样可以用于基本算术操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ result&#x3D;&#96;expr 3 + 4&#96;</span><br><span class="line">$ result&#x3D;$(expr $no1 + 5)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>bc<ul>
<li>上述命令不支持浮点数计算，浮点数计算需要使用bc命令，bc是一个用于数学运算的高级实用工具，这个精密的计算器包含了大量的选项。我们可以借助它执行浮点数运算并使用一些高级函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;4 * 0.56&quot; | bc</span><br><span class="line">&gt; 2.24</span><br><span class="line">$ no&#x3D;54; </span><br><span class="line">$ result&#x3D;&#96;echo &quot;$no * 1.5&quot; | bc&#96;</span><br><span class="line">$ echo $result</span><br><span class="line">&gt; 81.0</span><br></pre></td></tr></table></figure></li>
<li>设定小数精度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在下面的例子中，参数scale&#x3D;2将小数位个数设置为2。因此，bc将会输出包含两个小数位的数值：</span><br><span class="line">$ echo &quot;scale&#x3D;2;22&#x2F;7&quot; | bc</span><br><span class="line">&gt; 3.14</span><br></pre></td></tr></table></figure></li>
<li>进制转换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用bc可以将一种进制系统转换为另一种。来看看下面的代码是如何在十进制与二进制之间相互转换的：</span><br><span class="line">$ no&#x3D;100 </span><br><span class="line">$ echo &quot;obase&#x3D;2;$no&quot; | bc</span><br><span class="line">&gt; 1100100</span><br><span class="line">$ no&#x3D;1100100 </span><br><span class="line">$ echo &quot;obase&#x3D;10;ibase&#x3D;2;$no&quot; | bc</span><br><span class="line">&gt; 100</span><br></pre></td></tr></table></figure></li>
<li>计算平方以及平方根。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;sqrt(100)&quot; | bc #Square root </span><br><span class="line">$ echo &quot;10^10&quot; | bc #Square</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="文件描述符与重定向"><a href="#文件描述符与重定向" class="headerlink" title="文件描述符与重定向"></a>文件描述符与重定向</h2><p>文件描述符是与输入和输出流相关联的整数。最广为人知的文件描述符是stdin、stdout和stderr。文件描述符0、1以及2是系统预留的。</p>
<ul>
<li><p>文件描述符</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 —— stdin （标准输入）。</span><br><span class="line">1 —— stdout（标准输出）。</span><br><span class="line">2 —— stderr（标准错误）。</span><br></pre></td></tr></table></figure></li>
<li><p>重定向符号</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt; file</td>
<td align="center">输入重定向，将&lt;后的file文件内容作为command执行前的输入</td>
</tr>
<tr>
<td align="center">&gt; file 或1&gt;file</td>
<td align="center">输出重定向，将标准正确输出覆盖到后面的file文件内</td>
</tr>
<tr>
<td align="center">&gt;&gt; file或1&gt;&gt;file</td>
<td align="center">输出重定向，将标准正确输出追加到后面的file文件内</td>
</tr>
<tr>
<td align="center">2&gt;file</td>
<td align="center">输出重定向，将标准错误输出覆盖到后面的file文件内</td>
</tr>
<tr>
<td align="center">2&gt;&gt;file</td>
<td align="center">输出重定向，将标准错误输出追加到后面的file文件内</td>
</tr>
<tr>
<td align="center">&amp;&gt;file 或 &gt;file 2&gt;&amp;1</td>
<td align="center">输出重定向，将标准正确输出和标准错误输出覆盖到后面的file文件内</td>
</tr>
<tr>
<td align="center">&amp;&gt;&gt;file 或 &gt;&gt;file 2&gt;&amp;1</td>
<td align="center">输出重定向，将标准正确输出和标准错误输出追加到后面的file文件内</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>如果你不想看到或保存错误信息，那么可以将stderr的输出重定向到/dev/null，保证一切都<br>会被清除得干干净净。</p>
</blockquote>
<blockquote>
<p>cat&lt;<EOF>log.txt，注意，&lt;&lt;EOF是固定用法，&lt;&lt;不是指输入重定向两次，命令&lt;&lt;EOF会将键入的、以EOF输入字符为标准输入结束的流内容作为输入。然后按照重定向执行顺序，第二步骤执行cat命令，输出&lt;&lt;EOF键入的内容，最后将其重定向进log.txt</p>
</blockquote>
<hr>
<h2 id="数组与关联数组"><a href="#数组与关联数组" class="headerlink" title="数组与关联数组"></a>数组与关联数组</h2><p>数组允许脚本利用索引将数据集合保存为独立的条目。Bash支持普通数组和关联数组，前者使用整数作为数组索引，后者使用字符串作为数组索引。当数据以数字顺序组织的时候，应该使用普通数组，例如一组连续的迭代。当数据以字符串组织的时候，关联数组就派上用场了，例如主机名称。</p>
<h3 id="值序列"><a href="#值序列" class="headerlink" title="值序列"></a>值序列</h3><p>值序列在循环中经常使用，我们可以使用{1..5}来得到1-5的数字序列,也可以使用{1,2,3,4,5}得到同样的序列，也可以用{a..z}得到a-z的集合。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;1..5&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1,2,3,4,5,6&#125;;</span></span><br><span class="line">- do</span><br><span class="line">-  echo $i </span><br><span class="line">- done</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><ul>
<li><p>定义数组</p>
<ul>
<li>可以在单行中使用数值列表来定义一个数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这些值将会存储在以0为起始索引的连续位置上</span><br><span class="line">$ array_var&#x3D;(test1 test2 test3 test4)</span><br></pre></td></tr></table></figure></li>
<li>定义特定索引数组值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ array_var[2]&#x3D;&quot;test3&quot;</span><br></pre></td></tr></table></figure></li>
<li>定义空数组并加值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ array_var&#x3D;();</span><br><span class="line">&#x2F;&#x2F;加入someVar变量值 </span><br><span class="line">$ array_var+&#x3D;(&quot;$someVar&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>访问数组</p>
<ul>
<li>访问特定索引的数组元素内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;array_var[0]&#125; </span><br><span class="line">&gt; test1 </span><br><span class="line">$ index&#x3D;5 </span><br><span class="line">$ echo $&#123;array_var[$index]&#125; </span><br><span class="line">&gt; test6</span><br></pre></td></tr></table></figure></li>
<li>以列表形式打印出数组中的所有值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;array_var[*]&#125; </span><br><span class="line">&gt; test1 test2 test3 test4 test5 test6</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">$ echo $&#123;array_var[@]&#125; </span><br><span class="line">&gt; test1 test2 test3 test4 test5 test6</span><br></pre></td></tr></table></figure></li>
<li>打印数组长度（即数组中元素的个数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;#array_var[*]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3>关联数组从Bash 4.0版本开始被引入。当使用字符串（站点名、用户名、非顺序数字等）作为索引时，关联数组要比数字索引数组更容易使用。</li>
</ul>
</li>
<li><p>定义关联数组</p>
<p>  在关联数组中，我们可以用任意的文本作为数组索引。首先，需要使用声明语句将一个变量定义为关联数组</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ declare -A fruits_value</span><br><span class="line">$ fruits_value&#x3D;([apple]&#x3D;&#39;100 dollars&#39; [orange]&#x3D;&#39;150 dollars&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>访问数组</p>
<ul>
<li>用下面的方法显示数组内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;Apple costs $&#123;fruits_value[apple]&#125;&quot;</span><br><span class="line">&gt; Apple costs 100 dollars</span><br></pre></td></tr></table></figure></li>
<li>列出数组索引(对于普通数组，这个方法同样可行。)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;!fruits_value[*]&#125;</span><br><span class="line">&gt; orange apple</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">$ echo $&#123;!fruits_value[@]&#125;</span><br><span class="line">&gt; orange apple</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数和别名乍一看很相似，不过两者在行为上还是略有不同。alias是使用纯文本代替命令名，它在命令解析阶段就会把内容进行替换，由于替换过程完全是基于文本的，因而别名可以改变shell的语法；</p>
<p>函数的函数体是复合命令(bash)，函数名在命令解析阶段并不会被替换，只是在命令执行阶段调用相应的函数处理对应的复合命令。</p>
<p>函数参数可以在函数体中任意位置上使用，而别名只能将参数放在命令尾部。</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>函数的定义包括function命令、函数名、开/闭括号以及包含在一对花括号中的函数体。</p>
<ul>
<li>function 关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fname()</span><br><span class="line">&#123;</span><br><span class="line"> statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>无 function 关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fname()</span><br><span class="line">&#123;</span><br><span class="line"> statements;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">fname() &#123; statement; &#125;</span><br></pre></td></tr></table></figure></li>
<li>返回值<br>在定义函数时，可以在函数体中使用return来定义返回值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fname() </span><br><span class="line">&#123; </span><br><span class="line"> if [ $1 -eq 0 ];</span><br><span class="line"> then</span><br><span class="line"> 	return 0; #返回值</span><br><span class="line"> else</span><br><span class="line"> 	return 1; #返回值</span><br><span class="line"> fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们知道，在使用&amp;&amp;和||连接符时，判断依据即为符号前后命令的成功与否，返回值等于0为成功，大于0为失败。</p>
</blockquote>
</li>
</ul>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ fname ; &#x2F;&#x2F;执行函数</span><br><span class="line">或者</span><br><span class="line">$ fname arg1 arg2 ; &#x2F;&#x2F;函数参数可以按位置访问，$1是第一个参数，$2是第二个参数，</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数体中，要活用$1,$2,$*,$@等符号</p>
</blockquote>
<ul>
<li><p>递归调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fname() &#123;</span><br><span class="line">	echo $1; fname hello;</span><br><span class="line">	sleep 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义函数示例"><a href="#自定义函数示例" class="headerlink" title="自定义函数示例"></a>自定义函数示例</h3><blockquote>
<p>自定义函数需要定义在rc或者profile文件中，此文件的作用可详见<a href="https://wido.me/sunteya/understand-bashrc-and-profile/" target="_blank" rel="noopener" title="理解 bashrc 和 profile">理解 bashrc 和 profile</a></p>
</blockquote>
</li>
<li><p>对于<code>export PATH=/opt/myapp/bin:$PATH</code>，我们可以在.bashrc文件中定义一个新的函数，来简化这一追加路径的功能，使得<code>export PATH=/opt/myapp/bin:$PATH</code>等价于<code>prepend PATH /opt/myapp/bin</code>，其中$1=PATH,$2=/opt/myapp/bin：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prepend() &#123; [ -d &quot;$2&quot; ] &amp;&amp; eval $1&#x3D;\&quot;$2\$\&#123;$1:+&#39;:&#39;\$$1\&#125;\&quot; &amp;&amp; export $1 ; &#125;</span><br><span class="line">&#x2F;&#x2F; [ -d &quot;$2&quot; ]含义为先确认该函数第二个参数所指定的目录是否存在。</span><br><span class="line">&#x2F;&#x2F;如果存在，eval表达式将第一个参数所指定的变量值设置成第二个参数的值加上$\&#123;$1:+&#39;:&#39;\$$1\&#125;表达式的值</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;\&quot;$2\$\&#123;$1:+&#39;:&#39;\$$1\&#125;\&quot;</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;&quot;$2$&#123;PATH:+&#39;:&#39;$PATH&#125;&quot;   &#x2F;&#x2F;$1&#x3D;PATH有值</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;&quot;$2&#39;:&#39;$PATH&quot;</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;&quot;&#x2F;opt&#x2F;myapp&#x2F;bin:$PATH&quot;</span><br><span class="line">&#x2F;&#x2F;如果第二步执行成功，第三步，export，完成</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="逻辑关键字"><a href="#逻辑关键字" class="headerlink" title="逻辑关键字"></a>逻辑关键字</h2><h3 id="循环-for、while、until"><a href="#循环-for、while、until" class="headerlink" title="循环-for、while、until"></a>循环-for、while、until</h3><ul>
<li><p>面向列表的for循环</p>
<pre><code>list可以是一个字符串，也可以是一个值序列。</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in &#123;1..50&#125;;</span><br><span class="line">do</span><br><span class="line">	commands;#使用变量$var</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>迭代指定范围的数字</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for((i&#x3D;0;i&lt;10;i++))</span><br><span class="line">&#123;</span><br><span class="line">	commands; #使用变量$i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>循环到条件满足为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当条件为真时，while循环继续执行；当条件不为真时，until循环继续执行。</span><br><span class="line">&#x2F;&#x2F;用true或者:作为循环条件能够产生无限循环。</span><br><span class="line">while condition</span><br><span class="line">do</span><br><span class="line"> commands;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>until循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在Bash中还可以使用一个特殊的循环until。它会一直循环，直到给定的条件为真。例如：</span><br><span class="line">x&#x3D;0; </span><br><span class="line">until [ $x -eq 9 ]; #条件是[$x -eq 9 ] </span><br><span class="line">do</span><br><span class="line"> let x++; echo $x; </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="判断-if-else"><a href="#判断-if-else" class="headerlink" title="判断-if else"></a>判断-if else</h3></li>
<li><p>if条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if condition; </span><br><span class="line">then </span><br><span class="line">   commands; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
</li>
<li><p>else if和else</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if condition; </span><br><span class="line">then </span><br><span class="line">  commands; </span><br><span class="line">else if condition; then </span><br><span class="line">  commands; </span><br><span class="line">else </span><br><span class="line">  commands; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>if和else语句能够嵌套使用。if的条件判断部分可能会变得很长，但可以用<br>逻辑运算符将它变得简洁一些：<br>[ condition ] &amp;&amp; action; # 如果condition为真，则执行action<br>[ condition ] || action; # 如果condition为假，则执行action</p>
</blockquote>
</li>
</ul>
<h2 id="判断条件-和"><a href="#判断条件-和" class="headerlink" title="判断条件- [] 和 [[]]"></a>判断条件- [] 和 [[]]</h2><p>判断条件通常被放置在封闭的中括号内。一定要注意在 [ 和 ] 与操作数<strong>之间有一个空格</strong>。如果忘记了这个空格，脚本就会报错。<code>[$var -eq 0 ] or [ $var -eq 0]会报错</code></p>
<blockquote>
<p>在[]和[[ ]]中，其实任何一个符号两边都要有空格，所以在判断的时候，不要吝啬空格。</p>
</blockquote>
<ul>
<li><p>对数字变量或值进行算术条件比较</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ $var -eq 0 ] #当$var等于0时，返回真</span><br><span class="line">[ $var -ne 0 ] #当$var不为0时，返回真</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其他重要的操作符如下</p>
<ul>
<li><p>-gt：大于。</p>
</li>
<li><p>-lt：小于。</p>
</li>
<li><p>-ge：大于或等于。 </p>
</li>
<li><p>-le：小于或等于。</p>
<blockquote>
<p>这些操作符只适用于数值。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- 文件系统相关判断</span><br><span class="line"></span><br><span class="line">	我们可以使用不同的条件标志测试各种文件系统相关的属性。</span><br><span class="line">	- [ -f $file_var ]：如果给定的变量包含正常的文件路径或文件名，则返回真。</span><br><span class="line">	- [ -x $var ]：如果给定的变量包含的文件可执行，则返回真。</span><br><span class="line">	- [ -d $var ]：如果给定的变量包含的是目录，则返回真。</span><br><span class="line">	- [ -e $var ]：如果给定的变量包含的文件存在，则返回真。</span><br><span class="line">	- [ -c $var ]：如果给定的变量包含的是一个字符设备文件的路径，则返回真。</span><br><span class="line">	- [ -b $var ]：如果给定的变量包含的是一个块设备文件的路径，则返回真。</span><br><span class="line">	- [ -w $var ]：如果给定的变量包含的文件可写，则返回真。</span><br><span class="line">	- [ -r $var ]：如果给定的变量包含的文件可读，则返回真。</span><br><span class="line">	- [ -L $var ]：如果给定的变量包含的是一个符号链接，则返回真</span><br><span class="line">	- [ -s $var ]：如果给定的变量包含的文件大小大于0字节，则返回真</span><br><span class="line">	- [ $var1 -nt $var2 ]：new than操作，如果给定的变量包含的文件1比文件2新，则返回真</span><br><span class="line">	- [ $var1 -ot $var2 ]：old than操作，如果给定的变量包含的文件1比文件2旧，则返回真</span><br><span class="line">	- [ $var1 -ef $var2 ]：equal file操作，如果给定的变量包含的文件1和文件2为同一文件，则返回真</span><br><span class="line">- 字符串比较</span><br><span class="line"></span><br><span class="line">	**进行字符串比较时，最好用双中括号**，因为有时候采用单个中括号会产生错误。</span><br><span class="line">	- 测试两个字符串是否相同</span><br></pre></td></tr></table></figure>
//当str1等于str2时，返回真。也就是说，str1和str2包含的文本是一模一样的。
[[ $str1 = $str2 ]]

//这是检查字符串是否相同的另一种写法。
[[ $str1 == $str2 ]]

//如果str1和str2不相同，则返回真。
[[ $str1 != $str2 ]]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		&gt; 注意在&#x3D;前后各有一个空格。如果忘记加空格，那就不是比较关系了，而是变成了赋值语句。</span><br><span class="line">	- 字符串比较</span><br><span class="line">	</span><br><span class="line">		字符串是依据字符的ASCII值进行比较的。例如，A的值是0x41，a的值是0x61。因此，A</span><br><span class="line">小于a，AAa小于Aaa。</span><br></pre></td></tr></table></figure>
//如果str1的字母序比str2大，则返回真。
 [[ $str1 &gt; $str2 ]]
//如果str1的字母序比str2小，则返回真。
 [[ $str1 &lt; $str2 ]]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 判断空串</span><br></pre></td></tr></table></figure>
 [[ -z $str1 ]]    //如果str1为空串，则返回真。
 [[ ! -z $str1 ]]   //如果str1为空串，则返回假。与-n 等价
 [[ -n $str1 ]     //如果str1不为空串，则返回真。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 逻辑与和逻辑或</span><br><span class="line"></span><br><span class="line">	- -a是逻辑与操作符，-o是逻辑或操作符。可以按照下面的方法结合多个条件进行</span><br></pre></td></tr></table></figure>
[ $var1 -ne 0 -a $var2 -gt 2 ] #使用逻辑与-a
[ $var1 -ne 0 -o $var2 -gt 2 ] #逻辑或-o
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- [] 和 [[ ]]的区别</span><br><span class="line"></span><br><span class="line">二者基本相等，除了下述几点</span><br><span class="line"></span><br><span class="line">- 逻辑运算符不同</span><br><span class="line">	- []使用 -a 和 -o 来表达 与 和 或，不识别&amp;&amp; 和 ||</span><br><span class="line">	- [[ ]]使用 &amp;&amp; 和 || 来表达 与 和 或，不识别-a 和 -o</span><br><span class="line"></span><br><span class="line">- &#x3D;&#x3D;含义不同</span><br><span class="line"></span><br><span class="line">	- 在[[ ]]中，表达式&quot;&#x3D;&#x3D;&quot;和&quot;!&#x3D;&quot;的右边其实会被当做pattern匹配，只不过不是正则匹配，是通配符匹配（即？表示匹配单个字符，*表示匹配零个一个或多个字符）。</span><br><span class="line"></span><br><span class="line">- [[ ]]支持正则匹配</span><br><span class="line"></span><br><span class="line">	- 在[[ ]]中，表达式&quot;&#x3D;~&quot;的右边会被当做正则匹配</span><br><span class="line">		- 不过要注意，使用&quot;&#x3D;~&quot;时，右边表达式不需要引号，如：[[ &#39;$var&#39; &#x3D;~ a* ]]</span><br><span class="line"></span><br><span class="line">&gt; 使用建议，无论是[]还是[[ ]]，都建议对其变量使用双引号包围，换句话说，能做字符比较的时候，不要做数值比较。例如&#96;var&#x3D;&#39;shell script&#39; [ $var &#x3D; &quot;shell script&quot; ]&#96; 会报错，因为变量不加双引号，相当于[ shell script &#x3D; &quot;shell script&quot; ],这显然是错误的，所以应该加上引号&#96;[ &quot;$var&quot; &#x3D; &quot;shell script&quot; ]&#96;</span><br><span class="line"></span><br><span class="line">&gt; 使用建议，使用-eq数值比较的时候，可以在操作符两边同时+0，避免变量为空报错，当日，一边为常数的话可以不用+0：&#96; [ $((a+0)) -le 1]&#96;</span><br><span class="line"></span><br><span class="line">&gt; test命令可以用来测试条件。用test可以避免使用过多的括号，增强代码的可读性。[]中的测试条件同样可以用于test命令。&#96;if [ $var -eq 0 ]; then echo &quot;True&quot;; fi&#96; 等价于 &#96;if test $var -eq 0 ; then echo &quot;True&quot;; fi&#96;</span><br><span class="line">---</span><br><span class="line">## Linux&#x2F;unix文件系统</span><br><span class="line">### 文件权限</span><br><span class="line"></span><br><span class="line">文件权限和所有权是Unix&#x2F;Linux文件系统的显著特性之一。这些特性能够在多用户环境中保护你的个人信息。每一个文件都拥有多种类型的权限。在这些权限中，我们通常要和三组权限打交道：用户、用户组以及其他用户。</span><br><span class="line"></span><br><span class="line">用户（user）是文件的所有者，通常拥有所有的访问权。用户组（group）是多个用户的集合（由系统管理员指定），可能拥有文件的部分访问权。其他用户（others）是除文件所有者或用户组成员之外的任何人。</span><br><span class="line"></span><br><span class="line">ls命令的-l选项可以显示出包括文件类型、权限、所有者以及组在内的多方面信息：</span><br></pre></td></tr></table></figure></code></pre><p>$ ls -l </p>
<blockquote>
<p>-rw-r–r– 1 slynux users 2497 2010-02-28 11:22 bot.py<br>drwxr-xr-x 2 slynux users 4096 2010-05-27 14:31 a.py<br>-rw-r–r– 1 slynux users 539 2010-02-10 09:11 cl.pl</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">上述代码中，第1列表明了文件类型。字符串slynux users分别对应用户和用户组。在这里，slynux是文件所有者，也是组成员之一。</span><br><span class="line"></span><br><span class="line">其中文件类型有如下几种：</span><br><span class="line">- -：普通文件。</span><br><span class="line">- d：目录。</span><br><span class="line">- c：字符设备。</span><br><span class="line">- b：块设备。</span><br><span class="line">- l：符号链接。</span><br><span class="line">- s：套接字。</span><br><span class="line">- p：管道</span><br><span class="line"></span><br><span class="line">接下来的9个字符可以划分成三组，每组3个字符（--- --- ---）第一组的3个字符对应用户权限（所有者），第二组对应用户组权限，第三组对应其他用户权限。这9个字符（即9个权限）中的每一个字符指明是否其设置了某种权限。如果已设置，对应位置上会出现一个字符，否则出现一个-，表明没有设置对应的权限。</span><br><span class="line"></span><br><span class="line">有3种常见的字符。</span><br><span class="line"></span><br><span class="line">- r（read）：如果设置，表明该文件、设备或目录可读。</span><br><span class="line">- w（write）：如果设置，表明该文件、设备或目录可以被修改。对于目录而言，此权限指定了是否可以在目录下创建或删除文件。</span><br><span class="line">- x（execute）：如果设置，表明该文件可执行。对于目录而言，此权限指定了能否访问目录下的文件。</span><br><span class="line"></span><br><span class="line">同时这三组权限含义如下：</span><br><span class="line"></span><br><span class="line">- 用户（权限序列：rwx------）：定义了用户权限。通常来说，对于数据文件，用户权限是rw-；对于脚本或可执行文件，用户权限是rwx。用户还有一个称为setuid（S）的特殊权限，它出现在执行权限（x）的位置。setuid权限允许可执行文件以其拥有者的权限来执行，即使这个可执行文件是由其他用户运行的。具有setuid权限文件的权限序列可以是这样的：-rwS------。</span><br><span class="line">- 用户组（权限序列：---rwx---）：第二组字符指定了组权限。组权限中并没有setuid，但是有一个setgid（S）位。它允许使用与可执行文件所属组权限相同的有效组来运行该文件。但是这个组和实际发起命令的用户组未必相同。例如，组权限的权限序列可以是这样的：----rwS---。</span><br><span class="line">- 其他用户（权限序列：------rwx）：最后3个字符是其他用户权限。如果设置了相应的权限，其他用户也可以访问特定的文件或目录。作为一种规则，通常将这组权限设置为---。</span><br><span class="line"></span><br><span class="line">&gt; 目录有一个叫作粘滞位（sticky bit）的特殊权限。如果目录设置了粘滞位，只有创建该目录的用户才能删除目录中的文件，就算用户组和其他用户也有写权限，仍无能无力。粘滞位出现在其他用户权限组中的执行权限（x）位置。它使用t或T来表示。如果没有设置执行权限，但设置了粘滞位，就使用T；如果同时设置了执行权限和粘滞位，就使用t。例如：  </span><br><span class="line">&gt; &#96;------rwt , ------rwT&#96;  </span><br><span class="line">&gt; 设置目录粘滞位的一个典型例子就是&#x2F;tmp，也就是说任何人都可以在该目录中创建文件，</span><br><span class="line">&gt; 但只有文件的所有者才能删除其所创建的文件。</span><br><span class="line"></span><br><span class="line">&gt; 可使用chmod命令设置文件权限。具体参见博文 [常用shell命令导航（Linux shell脚本攻略笔记）](https:&#x2F;&#x2F;my.oschina.net&#x2F;u&#x2F;4133922&#x2F;blog&#x2F;3077074 &quot;常用shell命令导航（Linux shell脚本攻略笔记）&quot;)</span><br><span class="line"></span><br><span class="line">## 有用的函数或者脚本</span><br><span class="line"></span><br><span class="line">### 持续运行命令直至执行成功</span><br><span class="line">有时候命令只有在满足某些条件时才能够成功执行。例如，在下载文件之前必须先创建该文件。这种情况下，你可能希望重复执行命令，直到成功为止。</span><br></pre></td></tr></table></figure>
<p>//定义如下函数：<br>repeat()<br>{<br> while true<br> do<br> $@ &amp;&amp; return<br> done<br>}<br>//函数repeat()中包含了一个无限while循环，该循环执行以函数参数形式（通过$@访问）传入的命令。如果命令执行成功，则返回，进而退出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在大多数现代系统中，true是作为&#x2F;bin中的一个二进制文件来实现的。</span><br><span class="line">这就意味着每执行一次之前提到的while循环，shell就不得不生成一个进程。为了避免这种情况，可以使用shell的内建命令:，该命令的退出状态总是为0：</span><br></pre></td></tr></table></figure>
<p>repeat() { while :; do $@ &amp;&amp; return; done }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加入延时</span><br></pre></td></tr></table></figure>
<p>//每30秒才会运行一次<br>repeat() { while :; do $@ &amp;&amp; return; sleep 30; done }</p>
<pre><code>---</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/git%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%EF%BC%88Linux-Ubuntu%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/git%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%EF%BC%88Linux-Ubuntu%EF%BC%89/" itemprop="url">git安装集成（Linux Ubuntu）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-17T21:41:16+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">工具&软件安装集成相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/17/git%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%EF%BC%88Linux-Ubuntu%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/17/git安装集成（Linux-Ubuntu）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  41
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>git 拥有官方的安装指导页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;git-scm.com&#x2F;download&#x2F;linux</span><br></pre></td></tr></table></figure>

<p>ubuntu中我们使用<br><code>apt install git</code><br><img src="https://oscimg.oschina.net/oscnet/5b073f890c52cf1086a47b7649f9d9c035c.jpg" alt=""></p>
<p>安装完成后执行</p>
<p><code>git --version</code></p>
<p>得到</p>
<p><img src="https://oscimg.oschina.net/oscnet/66a3e034fecab46135045cb751a71d6977a.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/gradle%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/gradle%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90/" itemprop="url">Gradle安装集成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-16T21:34:57+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">工具&软件安装集成相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/16/gradle%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/16/gradle安装集成/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网寻找资源 <a href="https://gradle.org/releases/" target="_blank" rel="noopener">https://gradle.org/releases/</a> 红框部分得到下载链接<br><img src="https://oscimg.oschina.net/oscnet/8ffdfd582da547044513263a75684c10a73.jpg" alt=""></p>
<p>在Ubuntu环境下，使用<br><code>wget https://downloads.gradle.org/distributions/gradle-3.4.1-bin.zip</code><br>下载gradle</p>
<p>根据Gradle官方推荐，我们将安装包的内容解压至想要的路径（千万不要放在高权限路径）。<br><code>sudo unzip -d /home/lisheng/tools/gradle gradle-3.4.1-bin.zip</code></p>
<p>修改环境变量</p>
<p><code>sudo vim /etc/profile</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;$PATH:&#x2F;home&#x2F;lisheng&#x2F;tools&#x2F;gradle&#x2F;gradle-3.4.1&#x2F;bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>配置生效</p>
<p><code>source /etc/profile</code></p>
<p>输入gradle -v检查gradle是否安全完成，以及查看其版本号。<br><img src="https://oscimg.oschina.net/oscnet/97541a0ea7ae241c549c8ff65460c020209.jpg" alt=""></p>
<p>使用，直接创建gradle项目即可<br><img src="https://oscimg.oschina.net/oscnet/781840e501ad6e329cd99badf00692733cf.jpg" alt=""></p>
<h1 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a>wrapper</h1><p>当我们平时使用gradle来构建项目的时候，可以现在电脑上安装gradle，在配置环境变量之后就能正常使用了</p>
<p>不过当我们把项目分享给一个电脑上没安装gradle的人时，整体的项目构建还需要配置，显得麻烦。</p>
<p>由此就有了今天的主角：gradle wrapper 一个gradle的封装体，即使电脑上没有安装gradle也能构建。</p>
<p>初衷是因为gradle处于快速迭代阶段，经常发布新版本，如果我们的项目直接去引用，那么更改版本等会变得无比麻烦。而且每个项目又有可能用不一样的gradle版本，这样去手动配置每一个项目对应的gradle版本就会变得麻烦，gradle的引入本来就是想让大家构建项目变得轻松，如果这样的话，岂不是又增加了新的麻烦？所以android想到了包装，引入gradle-wrapper，通过读取配置文件中gradle的版本，为每个项目自动的下载和配置gradle，就是这么简单。</p>
<p>gradle建议开发者为每一个项目创建wrapper，以便其他人在没有gradle环境的机器上运行该项目。</p>
<p>如何创建wrapper呢？使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle wrapper</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/19e49b805f3219d5d183af9b616af9e6acf.jpg" alt=""></p>
<p>目录下会生成以下目录结构<br>Project-name/<br>  gradlew<br>  gradlew.bat<br>  gradle/wrapper/<br>    gradle-wrapper.jar<br>    gradle-wrapper.properties</p>
<p>因为就像wrapper本身的意义，gradle命令行也是善变的，所以wrapper对命令行也进行了一层封装，使用同一的gradlew命令，wrapper会自动去执行具体版本对应的gradle命令。需要使用gradle wrapper的时候，我们就直接在项目根目录下直接执行gradlew(gradle wrapper的简写), 使用gradlew的方式和gradle一模一样, 例如通过gradlew tasks来查看所有的任务。事实上，执行gradlew命令的时候，gradlew会委托gradle命令来做相应的事情，所以gradlew真的只是一个壳而已。</p>
<p>当执行gradlew的时候，wrapper会检查当前机器是否已经安装了对应版本的gradle，如果安装了那么gradlew就会委托gradle执行用户输入的命令。如果还未安装的话，那么首先会自动帮我们从gradle repository下载安装。当然你也可以在配置文件中指定想要下载的server来替代默认的gradle repo。</p>
<p>那么我们如何去修改要下载的gradle版本呢？通过修改gradle-wrapper.properties文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Fri May 17 00:24:36 CST 2019</span><br><span class="line">distributionBase&#x3D;GRADLE_USER_HOME</span><br><span class="line">distributionPath&#x3D;wrapper&#x2F;dists</span><br><span class="line">zipStoreBase&#x3D;GRADLE_USER_HOME</span><br><span class="line">zipStorePath&#x3D;wrapper&#x2F;dists</span><br><span class="line">distributionUrl&#x3D;https\:&#x2F;&#x2F;services.gradle.org&#x2F;distributions&#x2F;gradle-0.9-preview-1-bin.zip</span><br></pre></td></tr></table></figure>

<p>distributionUrl:要下载的gradle地址以及版本，gradle-wrapper会去wrapper/list目录下查找，如果没有对应版本的gradle就调用url资源采取下载</p>
<p>gradle的3种版本：</p>
<ul>
<li><p>gradle-xx-all.zip是完整版，包含了各种二进制文件，源代码文件，和离线的文档。例如，<a href="https://services.gradle.org/distributions/gradle-3.1-all.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-all.zip</a></p>
</li>
<li><p>gradle-xx-bin.zip是二进制版，只包含了二进制文件（可执行文件），没有文档和源代码。例如，<a href="https://services.gradle.org/distributions/gradle-3.1-bin.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-bin.zip</a></p>
</li>
<li><p>gradle-xx-src.zip是源码版，只包含了Gradle源代码，不能用来编译你的工程。例如，<a href="https://services.gradle.org/distributions/gradle-3.1-src.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-src.zip</a></p>
</li>
</ul>
<p>gradle-wrapper.properties各项属性的整体含义，如下：</p>
<ol>
<li><p>去 <a href="https://services.gradle.org/distributions/gradle-3.1-bin.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-bin.zip</a> 下载gradle的3.1版本，只包含binary的版本。</p>
</li>
<li><p>下载的gradle-3.1-bin.zip存放到C:\Users&lt;user_name&gt;.gradle\wrapper\dists目录中。（注：具体还有2级目录，即全路径为C:\Users&lt;user_name&gt;.gradle\wrapper\dists\gradle-3.1-bin&lt;url-hash&gt;\，gradle-3.1-bin目录是根据下载的gradle的文件名来定的，<url-hash>目录是根据distribution url路径字符串计算md5值得来的</p>
</li>
<li><p>解压gradle-3.1-bin.zip，将解压后的文件存放到C:\Users&lt;user_name&gt;.gradle\wrapper\dists中。（注：具体还有2级目录，同上）</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/" itemprop="url">ElasticSearch升级记录 ver.1.4.5→ver.5.2.0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-02T22:03:06+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">ElasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/02/ElasticSearch升级记录-ver-1-4-5→ver-5-2-0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目中的es由ver.1.4.5升级至ver.5.2.0。</p>
<h1 id="安装elasticSearch"><a href="#安装elasticSearch" class="headerlink" title="安装elasticSearch"></a>安装elasticSearch</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#下载</span><br><span class="line">wget https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;elasticsearch&#x2F;elasticsearch-5.2.0.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar zxvf elasticsearch-5.5.0.tar.gz</span><br></pre></td></tr></table></figure>
<h1 id="修改elasticsearch-yml"><a href="#修改elasticsearch-yml" class="headerlink" title="修改elasticsearch.yml"></a>修改elasticsearch.yml</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ES_HOME&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure>
<p>在这里不详细展开elasticsearch.yml的各个配置项，附上链接。<br><a href="https://www.cnblogs.com/zlslch/p/6419948.html" target="_blank" rel="noopener">配置es外部链接</a></p>
<h1 id="安装elasticsearch-head"><a href="#安装elasticsearch-head" class="headerlink" title="安装elasticsearch-head"></a>安装elasticsearch-head</h1><p>lasticsearch-head是一个很好的可视化前端框架，方便用可视化界面对es进行调用。elasticsearch-head在Github的地址如下：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a><br>安装也不复杂，由于它是一个前端的工具，因此需要我们预先安装了node和npm，之后执行下面的步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>安装完成后，运行命令npm run start就行。</p>
<h1 id="调整弃用api的兼容问题"><a href="#调整弃用api的兼容问题" class="headerlink" title="调整弃用api的兼容问题"></a>调整弃用api的兼容问题</h1><h2 id="1-setting"><a href="#1-setting" class="headerlink" title="1.setting"></a>1.setting</h2><p>1.4.5的org.elasticsearch.common.settings.ImmutableSettings已经弃用，生成配置对象setting的方式改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings settings &#x3D; Settings.builder().put(&quot;cluster.name&quot;, clusterName).put(&quot;client.transport.sniff&quot;, true).build();</span><br></pre></td></tr></table></figure>

<h2 id="2-InetSocketTransportAddress"><a href="#2-InetSocketTransportAddress" class="headerlink" title="2.InetSocketTransportAddress"></a>2.InetSocketTransportAddress</h2><p>org.elasticsearch.common.transport.InetSocketTransportAddress#InetSocketTransportAddress(java.lang.String, int)方法已经弃用，注入集群地址的方式改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clusterNodeAddressList.add(new InetSocketTransportAddress(InetAddress.getByName(host), 9300));</span><br></pre></td></tr></table></figure>
<h2 id="3-TransportClient"><a href="#3-TransportClient" class="headerlink" title="3.TransportClient"></a>3.TransportClient</h2><p>org.elasticsearch.client.transport.TransportClient#TransportClient(org.elasticsearch.common.settings.Settings)，该构造方法已经弃用，生成TransportClient实例的方式改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transportClient &#x3D; new PreBuiltTransportClient(settings);</span><br></pre></td></tr></table></figure>
<h2 id="4-ClusterHealthStatus"><a href="#4-ClusterHealthStatus" class="headerlink" title="4.ClusterHealthStatus"></a>4.ClusterHealthStatus</h2><p>org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus类已经弃用，相同功能由org.elasticsearch.cluster.health.ClusterHealthStatus继承</p>
<h2 id="5-ScriptSortBuilder调整"><a href="#5-ScriptSortBuilder调整" class="headerlink" title="5.ScriptSortBuilder调整"></a>5.ScriptSortBuilder调整</h2><p>原版写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Integer&gt; optionalSortMap &#x3D; manualSortMapBuilder.put(&quot;other&quot;, sortIndex + 1).build();</span><br><span class="line"></span><br><span class="line">String script &#x3D; &quot;paramsMap.containsKey(doc[\&quot;%s\&quot;].value) ? paramsMap.get(doc[\&quot;%s\&quot;].value) : paramsMap.get(&#39;other&#39;)&quot;;</span><br><span class="line"></span><br><span class="line">script &#x3D; String.format(script, sort.getFieldName(), sort.getFieldName());</span><br><span class="line"></span><br><span class="line">sortBuilder &#x3D; SortBuilders.scriptSort(script, &quot;number&quot;).param(&quot;paramsMap&quot;, optionalSortMap).order(SortOrder.ASC).missing(optionalSortMap.get(&quot;other&quot;));</span><br></pre></td></tr></table></figure>

<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Integer&gt; optionalSortMap &#x3D; manualSortMapBuilder.put(&quot;other&quot;, sortIndex + 1).build();</span><br><span class="line"></span><br><span class="line">String script &#x3D; &quot;paramsMap.containsKey(doc[\&quot;%s\&quot;].value) ? paramsMap.get(doc[\&quot;%s\&quot;].value) : paramsMap.get(&#39;other&#39;)&quot;;</span><br><span class="line"></span><br><span class="line">script &#x3D; String.format(script, sort.getFieldName(), sort.getFieldName());</span><br><span class="line">Map&lt;String, Object&gt; params &#x3D; Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">params.put(&quot;paramsMap&quot;, optionalSortMap);</span><br><span class="line"></span><br><span class="line">Script scriptObject &#x3D; new Script(Script.DEFAULT_SCRIPT_TYPE, Script.DEFAULT_SCRIPT_LANG, script, params);</span><br><span class="line"></span><br><span class="line">sortBuilder &#x3D; SortBuilders.scriptSort(scriptObject, ScriptSortBuilder.ScriptSortType.fromString(&quot;number&quot;)).order(SortOrder.ASC);</span><br></pre></td></tr></table></figure>
<h2 id="6-FilterBuilder调整"><a href="#6-FilterBuilder调整" class="headerlink" title="6.FilterBuilder调整"></a>6.FilterBuilder调整</h2><p>org.elasticsearch.index.query.FilterBuilder类已经弃用，基本上从2.x版本开始，Filter就已经弃用了（不包括bool查询内的filter），所有FilterBuilder全都要用QueryBuilder的各种子类来调整：</p>
<h3 id="1-org-elasticsearch-index-query-BoolFilterBuilder"><a href="#1-org-elasticsearch-index-query-BoolFilterBuilder" class="headerlink" title="1.org.elasticsearch.index.query.BoolFilterBuilder"></a>1.org.elasticsearch.index.query.BoolFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoolFilterBuilder boolFilterBuilder &#x3D; FilterBuilders.boolFilter();</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoolQueryBuilder boolFilterBuilder &#x3D; new BoolQueryBuilder();</span><br></pre></td></tr></table></figure>

<h3 id="2-org-elasticsearch-index-query-NestedFilterBuilder"><a href="#2-org-elasticsearch-index-query-NestedFilterBuilder" class="headerlink" title="2.org.elasticsearch.index.query.NestedFilterBuilder"></a>2.org.elasticsearch.index.query.NestedFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; FilterBuilders.nestedFilter(param.getPath(), boolFilterBuilder);</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; new NestedQueryBuilder(param.getPath(), boolFilterBuilder, ScoreMode.None);</span><br></pre></td></tr></table></figure>

<h3 id="3-org-elasticsearch-index-query-MissingFilterBuilder"><a href="#3-org-elasticsearch-index-query-MissingFilterBuilder" class="headerlink" title="3.org.elasticsearch.index.query.MissingFilterBuilder"></a>3.org.elasticsearch.index.query.MissingFilterBuilder</h3><p>5.x版本中，missing关键字已经弃用，其功能由其逆运算exist继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MissingFilterBuilder missingFilterBuilder &#x3D; FilterBuilders.missingFilter(paramName);</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.EXISTS) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.boolFilter().mustNot(missingFilterBuilder);</span><br><span class="line">&#125;</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.MISSING) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.boolFilter().must(missingFilterBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExistsQueryBuilder existsQueryBuilder &#x3D; new ExistsQueryBuilder(paramName);</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.EXISTS) &#123;</span><br><span class="line">    filterBuilder &#x3D; new BoolQueryBuilder().must(existsQueryBuilder);</span><br><span class="line">&#125;</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.MISSING) &#123;</span><br><span class="line">    filterBuilder &#x3D; new BoolQueryBuilder().mustNot(existsQueryBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-org-elasticsearch-index-query-TermFilterBuilder"><a href="#4-org-elasticsearch-index-query-TermFilterBuilder" class="headerlink" title="4.org.elasticsearch.index.query.TermFilterBuilder"></a>4.org.elasticsearch.index.query.TermFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; FilterBuilders.termFilter(paramName, param.getEqValue());</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; new TermQueryBuilder(paramName, param.getEqValue());</span><br></pre></td></tr></table></figure>

<h3 id="5-org-elasticsearch-index-query-TermsFilterBuilder"><a href="#5-org-elasticsearch-index-query-TermsFilterBuilder" class="headerlink" title="5.org.elasticsearch.index.query.TermsFilterBuilder"></a>5.org.elasticsearch.index.query.TermsFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; FilterBuilders.inFilter(paramName, param.getInValues());</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; new TermsQueryBuilder(paramName, param.getInValues());</span><br></pre></td></tr></table></figure>

<h3 id="6-org-elasticsearch-index-query-RangeFilterBuilder"><a href="#6-org-elasticsearch-index-query-RangeFilterBuilder" class="headerlink" title="6.org.elasticsearch.index.query.RangeFilterBuilder"></a>6.org.elasticsearch.index.query.RangeFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;gte</span><br><span class="line">if (null !&#x3D; param.getGteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).gte(param.getGteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;gt</span><br><span class="line">if (null !&#x3D; param.getGtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).gt(param.getGtValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lte</span><br><span class="line">if (null !&#x3D; param.getLteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).lte(param.getLteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lt</span><br><span class="line">if (null !&#x3D; param.getLtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).lt(param.getLtValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;gte</span><br><span class="line">if (null !&#x3D; param.getGteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).gte(param.getGteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;gt</span><br><span class="line">if (null !&#x3D; param.getGtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).gt(param.getGtValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lte</span><br><span class="line">if (null !&#x3D; param.getLteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).lte(param.getLteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lt</span><br><span class="line">if (null !&#x3D; param.getLtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).lt(param.getLtValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-search-type-count"><a href="#7-search-type-count" class="headerlink" title="7.search_type=count"></a>7.search_type=count</h2><p>原来我们想要计算文档的需要用到search_type=count，现在5.0已经将该API移除，取而代之你只需将size置于0即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;my_index&#x2F;_search?search_type&#x3D;count</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;my_terms&quot;: &#123;</span><br><span class="line">       &quot;terms&quot;: &#123;</span><br><span class="line">         &quot;field&quot;: &quot;foo&quot;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#5.0以后</span><br><span class="line">GET &#x2F;my_index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;my_terms&quot;: &#123;</span><br><span class="line">       &quot;terms&quot;: &#123;</span><br><span class="line">         &quot;field&quot;: &quot;foo&quot;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-RangeBuilder"><a href="#8-RangeBuilder" class="headerlink" title="8.RangeBuilder"></a>8.RangeBuilder</h2><p>org.elasticsearch.search.aggregations.bucket.range.RangeBuilder已经弃用，相应功能由org.elasticsearch.search.aggregations.bucket.range.RangeAggregationBuilder实现，直接替换即可。</p>
<h2 id="9-TopHitsAggregationBuilder"><a href="#9-TopHitsAggregationBuilder" class="headerlink" title="9.TopHitsAggregationBuilder"></a>9.TopHitsAggregationBuilder</h2><p>org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder已经弃用，相应功能由org.elasticsearch.search.aggregations.metrics.tophits.TopHitsAggregationBuilder实现，直接替换即可。</p>
<h2 id="10-FiltersAggregationBuilder"><a href="#10-FiltersAggregationBuilder" class="headerlink" title="10.FiltersAggregationBuilder"></a>10.FiltersAggregationBuilder</h2><p>org.elasticsearch.search.aggregations.bucket.filters.FiltersAggregationBuilder构造报文调整</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FiltersAggregationBuilder filtersAggregationBuilder &#x3D; AggregationBuilders.filters(aggregationField.getAggName());</span><br><span class="line">LufaxSearchConditionBuilder tmpConditionBuilder &#x3D; new LufaxSearchConditionBuilder();</span><br><span class="line">for (String key : aggregationField.getFiltersMap().keySet()) &#123;</span><br><span class="line">    LufaxFilterCondition tmpLufaxFilterCondition &#x3D; aggregationField.getFiltersMap().get(key);</span><br><span class="line">    FilterBuilder tmpFilterBuilder &#x3D; tmpConditionBuilder.constructFilterBuilder(tmpLufaxFilterCondition.getAndParams(),tmpLufaxFilterCondition.getOrParams(),tmpLufaxFilterCondition.getNotParams());</span><br><span class="line">    filtersAggregationBuilder.filter(key, tmpFilterBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调整成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;FiltersAggregator.KeyedFilter&gt; keyedFilters &#x3D; new LinkedList&lt;FiltersAggregator.KeyedFilter&gt;();</span><br><span class="line">LufaxSearchConditionBuilder tmpConditionBuilder &#x3D; new LufaxSearchConditionBuilder();</span><br><span class="line">for (String key : aggregationField.getFiltersMap().keySet()) &#123;</span><br><span class="line">    LufaxFilterCondition tmpLufaxFilterCondition &#x3D; aggregationField.getFiltersMap().get(key);</span><br><span class="line">    QueryBuilder tmpFilterBuilder &#x3D; tmpConditionBuilder.constructFilterBuilder(tmpLufaxFilterCondition.getAndParams(),tmpLufaxFilterCondition.getOrParams(),tmpLufaxFilterCondition.getNotParams());</span><br><span class="line">    keyedFilters.add(new FiltersAggregator.KeyedFilter(key, tmpFilterBuilder));</span><br><span class="line">&#125;</span><br><span class="line">FiltersAggregationBuilder filtersAggregationBuilder &#x3D; AggregationBuilders.filters(aggregationField.getAggName(), keyedFilters.toArray(new FiltersAggregator.KeyedFilter[]&#123;&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="11-HighlightBuilder"><a href="#11-HighlightBuilder" class="headerlink" title="11.HighlightBuilder;"></a>11.HighlightBuilder;</h2><p>org.elasticsearch.search.highlight.HighlightBuilder弃用，相关功能由org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder实现。</p>
<h2 id="12-OptimizeRequestBuilder"><a href="#12-OptimizeRequestBuilder" class="headerlink" title="12.OptimizeRequestBuilder"></a>12.OptimizeRequestBuilder</h2><p>org.elasticsearch.action.admin.indices.optimize.OptimizeRequestBuilder 已经弃用，聚合索引的功能由org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequestBuilder来实现。</p>
<h2 id="13-IndicesAliasesRequestBuilder"><a href="#13-IndicesAliasesRequestBuilder" class="headerlink" title="13.IndicesAliasesRequestBuilder"></a>13.IndicesAliasesRequestBuilder</h2><h3 id="1-newAddAliasAction"><a href="#1-newAddAliasAction" class="headerlink" title="1.newAddAliasAction"></a>1.newAddAliasAction</h3><p>旧版删除了AliasAction类的newAddAliasAction方法，故而IndicesAliasesRequestBuilder添加AliasActions应该：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(AliasAction.newAddAliasAction(toIndex, indexAlias));</span><br></pre></td></tr></table></figure>

<p>调整成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(IndicesAliasesRequest.AliasActions.add().index(toIndex).alias(indexAlias));</span><br></pre></td></tr></table></figure>

<h3 id="2-newRemoveAliasAction"><a href="#2-newRemoveAliasAction" class="headerlink" title="2.newRemoveAliasAction"></a>2.newRemoveAliasAction</h3><p>旧版删除了AliasAction类的newRemoveAliasAction方法，故而IndicesAliasesRequestBuilder删除AliasActions应该：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(AliasAction.newRemoveAliasAction(fromIdx, indexAlias));</span><br></pre></td></tr></table></figure>

<p>调整成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(IndicesAliasesRequest.AliasActions.remove().index(fromIdx).alias(indexAlias));</span><br></pre></td></tr></table></figure>

<h2 id="14-AbstractAggregationBuilder的子类变更"><a href="#14-AbstractAggregationBuilder的子类变更" class="headerlink" title="14.AbstractAggregationBuilder的子类变更"></a>14.AbstractAggregationBuilder的子类变更</h2><h3 id="1-org-elasticsearch-search-aggregations-bucket-terms-TermsBuilder"><a href="#1-org-elasticsearch-search-aggregations-bucket-terms-TermsBuilder" class="headerlink" title="1.org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder"></a>1.org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder</h3><p>org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder更名为<br>org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder</p>
<h3 id="2-org-elasticsearch-search-aggregations-bucket-range-date-DateRangeBuilder"><a href="#2-org-elasticsearch-search-aggregations-bucket-range-date-DateRangeBuilder" class="headerlink" title="2.org.elasticsearch.search.aggregations.bucket.range.date.DateRangeBuilder"></a>2.org.elasticsearch.search.aggregations.bucket.range.date.DateRangeBuilder</h3><p>org.elasticsearch.search.aggregations.bucket.range.date.DateRangeBuilder更名为<br>org.elasticsearch.search.aggregations.bucket.range.date.DateRangeAggregationBuilder</p>
<h3 id="3-org-elasticsearch-search-aggregations-metrics-tophits-TopHitsBuilder"><a href="#3-org-elasticsearch-search-aggregations-metrics-tophits-TopHitsBuilder" class="headerlink" title="3.org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder"></a>3.org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder</h3><p>org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder更名为<br>org.elasticsearch.search.aggregations.metrics.tophits.TopHitsAggregationBuilder</p>
<h2 id="15-SearchHit类"><a href="#15-SearchHit类" class="headerlink" title="15.SearchHit类"></a>15.SearchHit类</h2><p>org.elasticsearch.search.SearchHit#isSourceEmpty方法改为org.elasticsearch.search.SearchHit#hasSource方法，反向替换。</p>
<h2 id="16-DeleteByQueryResponse"><a href="#16-DeleteByQueryResponse" class="headerlink" title="16.DeleteByQueryResponse"></a>16.DeleteByQueryResponse</h2><p>org.elasticsearch.action.deletebyquery.DeleteByQueryResponse已经弃用，</p>
<h1 id="调整关键字等结构性问题"><a href="#调整关键字等结构性问题" class="headerlink" title="调整关键字等结构性问题"></a>调整关键字等结构性问题</h1><h2 id="1-String数据类型弃用"><a href="#1-String数据类型弃用" class="headerlink" title="1. String数据类型弃用"></a>1. String数据类型弃用</h2><p>在 ES2.x 版本字符串数据是没有 keyword 和 text 类型的，只有string类型，ES更新到5版本后，取消了 string 数据类型，代替它的是 keyword 和 text 数据类型。区别在于：</p>
<p>text类型定义的文本会被分析，在建立索引前会将这些文本进行分词，转化为词的组合，建立索引。允许 ES来检索这些词语。text 数据类型不能用来排序和聚合。</p>
<p>keyWord类型表示精确查找的文本，不需要进行分词。可以被用来检索过滤、排序和聚合。keyword 类型字段只能用本身来进行检索。</p>
<p>在没有显性定义时，es默认为“text”类型。</p>
<h2 id="2-multi-field关键字弃用"><a href="#2-multi-field关键字弃用" class="headerlink" title="2. multi_field关键字弃用"></a>2. multi_field关键字弃用</h2><p>相关mapping方式改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#对需要设置的字段，在&#39;type&#39;属性后增加&quot;fields&quot;: </span><br><span class="line">#其中的&quot;raw&quot;为自定义的名称,想象它是city的一个分身。</span><br><span class="line">PUT &#x2F;my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;city&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;raw&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">查询raw字段时，使用city.raw表示</span><br></pre></td></tr></table></figure>
<h2 id="3-analyzer"><a href="#3-analyzer" class="headerlink" title="3. analyzer"></a>3. analyzer</h2><h3 id="1-改版后，设置了search-analyzer的情况下，analyzer也要设置，否则会报："><a href="#1-改版后，设置了search-analyzer的情况下，analyzer也要设置，否则会报：" class="headerlink" title="1.改版后，设置了search_analyzer的情况下，analyzer也要设置，否则会报："></a>1.改版后，设置了search_analyzer的情况下，analyzer也要设置，否则会报：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyzer on field [name] must be set when search_analyzer is set。</span><br></pre></td></tr></table></figure>
<h3 id="2-改版后，index-analyzer设置被弃用，如果设置，会报"><a href="#2-改版后，index-analyzer设置被弃用，如果设置，会报" class="headerlink" title="2.改版后，index_analyzer设置被弃用，如果设置，会报"></a>2.改版后，index_analyzer设置被弃用，如果设置，会报</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapperParsingException[Mapping definition for [fields] has unsupported parameters:  [index_analyzer : ik_max_word]];</span><br></pre></td></tr></table></figure>


<p><img src="https://oscimg.oschina.net/oscnet/17d3a80c1adff9f8b379c9006036a58cdb0.jpg" alt=""></p>
<p>这里扩展一下，在原来的版本中，index_analyzer负责建立索引时的分词器定义，search_analyzer负责搜索时的分词器定义。</p>
<p>索引期间查找解析器的完整顺序是这样的：</p>
<ul>
<li>定义在字段映射中的index_analyzer</li>
<li>定义在字段映射中的analyzer</li>
<li>定义在文档_analyzer字段中的解析器</li>
<li>type的默认index_analyzer</li>
<li>type的默认analyzer</li>
<li>索引设置中default_index对应的解析器</li>
<li>索引设置中default对应的解析器</li>
<li>节点上default_index对应的解析器</li>
<li>节点上default对应的解析器</li>
<li>standard解析器</li>
</ul>
<p>而查询期间的完整顺序则是：</p>
<ul>
<li>直接定义在查询中的analyzer</li>
<li>定义在字段映射中的search_analyzer</li>
<li>定义在字段映射中的analyzer</li>
<li>type的默认search_analyzer</li>
<li>type的默认analyzer</li>
<li>索引设置中的default_search对应的解析器</li>
<li>索引设置中的default对应的解析器</li>
<li>节点上default_search对应的解析器</li>
<li>节点上default对应的解析器</li>
<li>standard解析器</li>
</ul>
<p><strong>现在新版删除index_analyzer，具体功能由analyzer关键字承担，analyzer关键字生效与index时和search时（除非search_analyzer已经被显性定义）。</strong></p>
<h2 id="3-timestamp在2-0弃用"><a href="#3-timestamp在2-0弃用" class="headerlink" title="3. _timestamp在2.0弃用"></a>3. _timestamp在2.0弃用</h2><p>_timestamp官方建议自定义一个字段，自己赋值用来表示时间戳。</p>
<p><img src="https://oscimg.oschina.net/oscnet/83fad879140e27f9bdece1502d0076ef9db.jpg" alt=""></p>
<h2 id="4-嵌套字段排序时字段名称调整"><a href="#4-嵌套字段排序时字段名称调整" class="headerlink" title="4. 嵌套字段排序时字段名称调整"></a>4. 嵌套字段排序时字段名称调整</h2><p>对于如下的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;my_index&#x2F;blogpost&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Investment secrets&quot;,</span><br><span class="line">  &quot;body&quot;:  &quot;What they don&#39;t tell you ...&quot;,</span><br><span class="line">  &quot;tags&quot;:  [ &quot;shares&quot;, &quot;equities&quot; ],</span><br><span class="line">  &quot;comments&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;Mary Brown&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;Lies, lies, lies&quot;,</span><br><span class="line">      &quot;age&quot;:     42,</span><br><span class="line">      &quot;stars&quot;:   1,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-10-18&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;John Smith&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;You&#39;re making it up!&quot;,</span><br><span class="line">      &quot;age&quot;:     28,</span><br><span class="line">      &quot;stars&quot;:   2,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-10-16&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老版本中，对stars字段进行排序时，直接可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;stars&quot; : &#123;</span><br><span class="line">      &quot;order&quot; : &quot;desc&quot;,</span><br><span class="line">      &quot;mode&quot; : &quot;min&quot;,</span><br><span class="line">      &quot;nested_path&quot; : &quot;comments&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>但在新版中，上述报文会报</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No mapping found for [stars] in order to sort on</span><br></pre></td></tr></table></figure>
<p>需要改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;comments.stars&quot; : &#123;</span><br><span class="line">       &quot;order&quot; : &quot;desc&quot;,</span><br><span class="line">       &quot;mode&quot; : &quot;min&quot;</span><br><span class="line">     &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>

<h2 id="5-script脚本参数名变更"><a href="#5-script脚本参数名变更" class="headerlink" title="5. _script脚本参数名变更"></a>5. _script脚本参数名变更</h2><p>老版中，_script可以这样定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_script&quot; : &#123;</span><br><span class="line">        &quot;script&quot; : &#123;</span><br><span class="line">          &quot;inline&quot; : &quot;paramsMap.containsKey(doc[\&quot;id\&quot;].value) ? params.paramsMap.get(doc[\&quot;id\&quot;].value) : params.paramsMap.get(&#39;other&#39;)&quot;,</span><br><span class="line">          &quot;lang&quot; : &quot;painless&quot;,</span><br><span class="line">          &quot;params&quot; : &#123;</span><br><span class="line">            &quot;paramsMap&quot; : &#123;</span><br><span class="line">              &quot;1&quot; : 1,</span><br><span class="line">              &quot;2&quot; : 1,</span><br><span class="line">              &quot;3&quot; : 2,</span><br><span class="line">              &quot;other&quot; : 3</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;type&quot; : &quot;number&quot;,</span><br><span class="line">        &quot;order&quot; : &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>新版中，对于params的参数paramsMap必须用params.paramsMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_script&quot; : &#123;</span><br><span class="line">        &quot;script&quot; : &#123;</span><br><span class="line">          &quot;inline&quot; : &quot;params.paramsMap.containsKey(doc[\&quot;productCategory\&quot;].value) ? params.paramsMap.get(doc[\&quot;productCategory\&quot;].value) : params.paramsMap.get(&#39;other&#39;)&quot;,</span><br><span class="line">          &quot;lang&quot; : &quot;painless&quot;,</span><br><span class="line">          &quot;params&quot; : &#123;</span><br><span class="line">            &quot;paramsMap&quot; : &#123;</span><br><span class="line">              &quot;901&quot; : 1,</span><br><span class="line">              &quot;902&quot; : 1,</span><br><span class="line">              &quot;701&quot; : 2,</span><br><span class="line">              &quot;other&quot; : 3</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;type&quot; : &quot;number&quot;,</span><br><span class="line">        &quot;order&quot; : &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>注意：<strong>es 5.2.0默认禁用了动态语言，所以lang为painless之外的语言</strong>，默认情况下会报</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScriptException[scripts of type [inline], operation [update] and lang [groovy] are disabled];</span><br></pre></td></tr></table></figure>

<p>需要在yml文件中添加配置（如groovy）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">script.engine.groovy.inline:true </span><br><span class="line">script.engine.groovy.stored.search:true </span><br><span class="line">script.engine.groovy.stored.aggs:true</span><br></pre></td></tr></table></figure>

<h2 id="6-获取特定字段返回"><a href="#6-获取特定字段返回" class="headerlink" title="6 .获取特定字段返回"></a>6 .获取特定字段返回</h2><p>在旧版本中，获取特定文档特定字段返回，可以使用stored_fields：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;from&quot; : 0,</span><br><span class="line">  &quot;size&quot; : 1,</span><br><span class="line">  &quot;query&quot; : &#123;&#125;,</span><br><span class="line">  &quot;stored_fields&quot; : &quot;timestamp&quot;,</span><br><span class="line">  &quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;order&quot; : &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版本中，引入了更为强大的_source过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;from&quot; : 0,</span><br><span class="line">  &quot;size&quot; : 1,</span><br><span class="line">  &quot;query&quot; : &#123;&#125;,</span><br><span class="line">  &quot;_source&quot; : &quot;timestamp&quot;,</span><br><span class="line">  &quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;order&quot; : &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot; : 0,</span><br><span class="line">  &quot;size&quot; : 1,</span><br><span class="line">  &quot;query&quot; : &#123;&#125;,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;includes&quot; : [ &quot;timestamp&quot; ],</span><br><span class="line">    &quot;excludes&quot; : [ &quot;&quot; ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;order&quot; : &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java的api主要调用SearchRequestBuilder的setFetchSource方法</p>
<h2 id="7-date字段的format定义"><a href="#7-date字段的format定义" class="headerlink" title="7. date字段的format定义"></a>7. date字段的format定义</h2><p>改版后，date字段最好再mapping时定义好format信息，以防止在请求前后因为格式转换问题报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElasticsearchParseException[failed to parse date field [Thu Jun 18 00:00:00 CST 2015] with format [strict_date_optional_time||epoch_millis]]; nested: IllegalArgumentException[Parse failure at index [0] of [Thu Jun 18 00:00:00 CST 2015]]; &#125;</span><br></pre></td></tr></table></figure>
<p>[strict_date_optional_time||epoch_millis]是es默认的date字段解析格式</p>
<h2 id="8-UncategorizedExecutionException"><a href="#8-UncategorizedExecutionException" class="headerlink" title="8. UncategorizedExecutionException"></a>8. UncategorizedExecutionException</h2><p>改版前，transport client发送数据之前将java代码中的字段序列化成了json然后进行传输和请求，而在5.x以后，es改用使用的内部的transport protocol，这时候，如果定义一个比如bigDecimal类型，es不支持bigDecimal，数据类型不匹配会抛错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UncategorizedExecutionException[Failed execution]; nested: IOException[can not write type [class java.math.BigDecimal]];</span><br></pre></td></tr></table></figure>


<p>es支持的格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Writer&gt; writers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    writers.put(String.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 0);</span><br><span class="line">        o.writeString((String) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Integer.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 1);</span><br><span class="line">        o.writeInt((Integer) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Long.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 2);</span><br><span class="line">        o.writeLong((Long) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Float.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 3);</span><br><span class="line">        o.writeFloat((float) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Double.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 4);</span><br><span class="line">        o.writeDouble((double) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Boolean.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 5);</span><br><span class="line">        o.writeBoolean((boolean) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(byte[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 6);</span><br><span class="line">        final byte[] bytes &#x3D; (byte[]) v;</span><br><span class="line">        o.writeVInt(bytes.length);</span><br><span class="line">        o.writeBytes(bytes);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(List.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 7);</span><br><span class="line">        final List list &#x3D; (List) v;</span><br><span class="line">        o.writeVInt(list.size());</span><br><span class="line">        for (Object item : list) &#123;</span><br><span class="line">            o.writeGenericValue(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Object[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 8);</span><br><span class="line">        final Object[] list &#x3D; (Object[]) v;</span><br><span class="line">        o.writeVInt(list.length);</span><br><span class="line">        for (Object item : list) &#123;</span><br><span class="line">            o.writeGenericValue(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Map.class, (o, v) -&gt; &#123;</span><br><span class="line">        if (v instanceof LinkedHashMap) &#123;</span><br><span class="line">            o.writeByte((byte) 9);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o.writeByte((byte) 10);</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        final Map&lt;String, Object&gt; map &#x3D; (Map&lt;String, Object&gt;) v;</span><br><span class="line">        o.writeVInt(map.size());</span><br><span class="line">        for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            o.writeString(entry.getKey());</span><br><span class="line">            o.writeGenericValue(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Byte.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 11);</span><br><span class="line">        o.writeByte((Byte) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Date.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 12);</span><br><span class="line">        o.writeLong(((Date) v).getTime());</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(ReadableInstant.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 13);</span><br><span class="line">        final ReadableInstant instant &#x3D; (ReadableInstant) v;</span><br><span class="line">        o.writeString(instant.getZone().getID());</span><br><span class="line">        o.writeLong(instant.getMillis());</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(BytesReference.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 14);</span><br><span class="line">        o.writeBytesReference((BytesReference) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Text.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 15);</span><br><span class="line">        o.writeText((Text) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Short.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 16);</span><br><span class="line">        o.writeShort((Short) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(int[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 17);</span><br><span class="line">        o.writeIntArray((int[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(long[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 18);</span><br><span class="line">        o.writeLongArray((long[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(float[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 19);</span><br><span class="line">        o.writeFloatArray((float[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(double[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 20);</span><br><span class="line">        o.writeDoubleArray((double[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(BytesRef.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 21);</span><br><span class="line">        o.writeBytesRef((BytesRef) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(GeoPoint.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 22);</span><br><span class="line">        o.writeGeoPoint((GeoPoint) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    WRITERS &#x3D; Collections.unmodifiableMap(writers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-hand-o-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-hand-o-right" aria-label="accessibility.next_page"></i></a>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">417.6k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
