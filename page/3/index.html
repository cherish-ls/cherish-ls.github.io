<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/JAVA%E7%9A%84CAS%E5%8F%8A%E5%85%B6ABA%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/JAVA%E7%9A%84CAS%E5%8F%8A%E5%85%B6ABA%E9%97%AE%E9%A2%98/" itemprop="url">JAVA的CAS及其ABA问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T23:35:26+08:00">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA线程与并发控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/05/JAVA%E7%9A%84CAS%E5%8F%8A%E5%85%B6ABA%E9%97%AE%E9%A2%98/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/05/JAVA的CAS及其ABA问题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-CAS是什么"><a href="#1-CAS是什么" class="headerlink" title="1 CAS是什么"></a>1 CAS是什么</h1><p>CAS是Compare-And-Swap的缩写，即<strong>对比和替换</strong>，它在保证数据原子性的前提下尽可能的减少了锁的使用，很多编程语言或者系统实现上都大量的使用了CAS。</p>
<p>因为没有没有线程阻塞唤醒带来的性能消耗问题。这也是为什么CAS比synchronized性能高的原因！</p>
<h2 id="1-1-JAVA中CAS的实现"><a href="#1-1-JAVA中CAS的实现" class="headerlink" title="1.1 JAVA中CAS的实现"></a>1.1 JAVA中CAS的实现</h2><p>JAVA中的CAS主要使用的是Unsafe类。Unsafe的CAS操作主要是基于硬件平台的汇编指令，目前的处理器基本都支持CAS，只不过不同的厂家的实现不一样罢了。</p>
<p>sun.misc.Unsafe虽然类提供了一系列直接操作内存对象的方法，但只是在 jdk 内部使用，JAVA官方不建议开发者直接调用Unsafe类；所以我们一般直接使用到的，都是java.util.concurrent.atomic 包下的Atomic*类，比如 AtomicBoolean、AtomicInteger 等，其compareAndSet方法，也都是调用的Unsafe的CAS方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class Unsafe &#123;</span><br><span class="line">	...</span><br><span class="line">	public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);</span><br><span class="line">	public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span><br><span class="line">	public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>value 表示 需要操作的对象</li>
<li>valueOffset 表示 对象(value)的地址的偏移量（通过Unsafe.objectFieldOffset(Field valueField)获取）</li>
<li>expect 表示更新时value的期待值</li>
<li>update 表示将要更新的值</li>
</ul>
<p>具体过程为每次在执行CAS操作时，线程会根据valueOffset去内存中获取当前值去跟expect的值做对比如果一致则修改并返回true，如果不一致说明有别的线程也在修改此对象的值，则返回false。</p>
<p>Unsafe类中compareAndSwapInt的具体实现所对应的cpp代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<h2 id="1-2-CAS和自旋的配合"><a href="#1-2-CAS和自旋的配合" class="headerlink" title="1.2 CAS和自旋的配合"></a>1.2 CAS和自旋的配合</h2><blockquote>
<p>很多文章都信誓旦旦的说CAS底层使用自旋，从而达到高效的无锁并发。这时将Atomic的CAS实现和Unsafe的CAS实现混淆的结果，JAVA的CAS追本溯源都在Unsafe的CAS方法中，它顾名思义，只有比较和替换，没有自旋。</p>
</blockquote>
<p>但不可否认，当CAS和自旋搭配使用的时候，确实效果更佳，尤其是在并发做加减的时候，所以Unsafe类提供了一个将CAS和自旋搭配使用的自增方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndSetInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;getIntVolatile方法获取对象var1中offset&#x3D;var2偏移地址对应的整型field的值,支持volatile load语义。</span><br><span class="line">        &#x2F;&#x2F;说人话就是取出var1内存中偏移量为var2位置对应的整型field的值</span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">        &#x2F;&#x2F;自旋操作，不停比较该值，如果CAS成功，则退出，否则一直循环。</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同原理的还有getAndSetLong/getAndSetObject/getAndAddLong/getAndAddInt等方法。</p>
<h2 id="1-3-Java-8对CAS机制的优化——LongAdder"><a href="#1-3-Java-8对CAS机制的优化——LongAdder" class="headerlink" title="1.3 Java 8对CAS机制的优化——LongAdder"></a>1.3 Java 8对CAS机制的优化——LongAdder</h2><p>当并发操作一个AtomicInteger而不是使用synchronize时，我们确实可以享受到CAS无锁并发带来的高性能，但CAS就完美无缺么？肯定不是的，比如说大量的线程同时并发修改一个AtomicInteger，可能有很多线程会不停的自旋，进入一个无限重复的循环中。</p>
<p>这些线程不停地获取值，然后发起CAS操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起CAS操作又失败了，再次进入下一个循环。</p>
<p>在大量线程高并发更新AtomicInteger的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。</p>
<p>于是，Java 8推出了一个新的类，LongAdder，他尝试使用分段CAS以及自动分段迁移的方式来大幅度提升多线程高并发执行CAS操作的性能！</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-610bcb236b50f94729fea4711c012e101fa.png" alt=""></p>
<p>在LongAdder的底层实现中，首先有一个base值，刚开始多线程来不停的累加数值，都是对base进行累加的，比如刚开始累加成了base = 5。</p>
<p>接着如果发现并发更新的线程数量过多，就会开始施行分段CAS的机制，也就是内部会搞一个Cell数组，每个数组是一个数值分段。这时，<strong>让大量的线程分别去对不同Cell内部的value值进行CAS累加操作</strong>，这样就把CAS计算压力分散到了不同的Cell分段数值中。</p>
<p>如此操作可以大幅度的降低多线程并发更新同一个数值时出现的无限循环的问题，大幅度提升了多线程并发更新数值的性能和效率！</p>
<p>更重要的是他内部实现了<strong>自动分段迁移的机制</strong>，也就是如果某个Cell的value执行CAS失败了，那么就会自动去找另外一个Cell分段内的value值进行CAS操作。这样也解决了线程空旋转、自旋不停等待执行CAS操作的问题，让一个线程过来执行CAS时可以尽快的完成这个操作。</p>
<p>最后，如果你要从LongAdder中获取当前累加的总值，<strong>就会把base值和所有Cell分段数值加起来返回给你</strong>。</p>
<h1 id="2-CAS的ABA问题"><a href="#2-CAS的ABA问题" class="headerlink" title="2 CAS的ABA问题"></a>2 CAS的ABA问题</h1><p>CAS还存在一个更加严重的问题——ABA问题：</p>
<p>线程1准备用CAS修改变量值A，在此之前，其它线程将变量的值由A替换为B，又由B替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-36b9583db6094422fbc837b64cceb1cf483.png" alt=""></p>
<p>有没有解决方案呢？有的，JAVA中ABA中解决方案有两种，我们依次介绍</p>
<h2 id="2-1-AtomicStampedReference类"><a href="#2-1-AtomicStampedReference类" class="headerlink" title="2.1 AtomicStampedReference类"></a>2.1 AtomicStampedReference类</h2><p>解决ABA最简单的方案就是给值加一个修改版本号，每次值变化，都会修改它版本号，CAS操作时都对比此版本号。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2594f459d269ecbecaca0fbea9d4b37d1ce.png" alt=""></p>
<p>AtomicStampedReference就是这种思路在JAVA中的产物，它主要维护包含一个对象引用以及一个可以自动更新的整数”stamp”的pair对象来解决ABA问题。</p>
<p>其关键代码如下（省略无用代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;关键代码</span><br><span class="line">public class AtomicStampedReference&lt;V&gt; &#123;</span><br><span class="line">    private static class Pair&lt;T&gt; &#123;</span><br><span class="line">        final T reference;  &#x2F;&#x2F;维护对象引用</span><br><span class="line">        final int stamp;  &#x2F;&#x2F;用于标志版本</span><br><span class="line">        private Pair(T reference, int stamp) &#123;</span><br><span class="line">            this.reference &#x3D; reference;</span><br><span class="line">            this.stamp &#x3D; stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;</span><br><span class="line">            return new Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private volatile Pair&lt;V&gt; pair;</span><br><span class="line">    ....</span><br><span class="line">    &#x2F;**</span><br><span class="line">      * expectedReference ：更新之前的原始值</span><br><span class="line">      * newReference : 将要更新的新值</span><br><span class="line">      * expectedStamp : 期待更新的标志版本</span><br><span class="line">      * newStamp : 将要更新的标志版本</span><br><span class="line">      *&#x2F;</span><br><span class="line">    public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                                 V   newReference,</span><br><span class="line">                                 int expectedStamp,</span><br><span class="line">                                 int newStamp) &#123;</span><br><span class="line">        Pair&lt;V&gt; current &#x3D; pair; &#x2F;&#x2F;获取当前pair</span><br><span class="line">        return</span><br><span class="line">            expectedReference &#x3D;&#x3D; current.reference &amp;&amp; &#x2F;&#x2F;原始值等于当前pair的值引用，说明值未变化</span><br><span class="line">            expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp; &#x2F;&#x2F; 原始标记版本等于当前pair的标记版本，说明标记未变化</span><br><span class="line">            ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">              newStamp &#x3D;&#x3D; current.stamp) || &#x2F;&#x2F; 将要更新的值和标记都没有变化</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp))); &#x2F;&#x2F; cas 更新pair</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要过分在意源码，我们只要知道怎么用就好，demo如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        AtomicStampedReference&lt;String&gt; reference &#x3D; new AtomicStampedReference&lt;String&gt;(&quot;aaa&quot;,1);</span><br><span class="line">        reference.compareAndSet(&quot;aaa&quot;,&quot;bbb&quot;,reference.getStamp(),reference.getStamp()+1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-AtomicMarkableReference类"><a href="#2-2-AtomicMarkableReference类" class="headerlink" title="2.2 AtomicMarkableReference类"></a>2.2 AtomicMarkableReference类</h2><p>AtomicMarkableReference可以理解为AtomicStampedReference的简化版，就是不关心修改过几次，仅仅关心是否修改过。因此变量mark是boolean类型，仅记录值是否有过修改。</p>
<p>关键代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Pair对象维护对象的引用和对象标记</span><br><span class="line">private static class Pair&lt;T&gt; &#123;</span><br><span class="line">    final T reference;</span><br><span class="line">    final boolean mark;&#x2F;&#x2F; 通过标记的状态区分对象是否有更改</span><br><span class="line"></span><br><span class="line">    private Pair(T reference, boolean mark) &#123;</span><br><span class="line">        this.reference &#x3D; reference;</span><br><span class="line">        this.mark &#x3D; mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &lt;T&gt; Pair&lt;T&gt; of(T reference, boolean mark) &#123;</span><br><span class="line">        return new Pair&lt;T&gt;(reference, mark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param expectedReference 期待的原始对象</span><br><span class="line"> * @param newReference      将要更新的对象</span><br><span class="line"> * @param expectedMark      期待原始对象的标记</span><br><span class="line"> * @param newMark           将要更新对象的标记</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean compareAndSet(V expectedReference,</span><br><span class="line">                             V newReference,</span><br><span class="line">                             boolean expectedMark,</span><br><span class="line">                             boolean newMark) &#123;</span><br><span class="line">    Pair&lt;V&gt; current &#x3D; pair;</span><br><span class="line">    return</span><br><span class="line">            expectedReference &#x3D;&#x3D; current.reference &amp;&amp; &#x2F;&#x2F; 如果期待的原始对象与Pair的reference一样则返回true</span><br><span class="line">                    expectedMark &#x3D;&#x3D; current.mark &amp;&amp; &#x2F;&#x2F; 如果期待的原始对象的标记与Pair的mark一样则返回true</span><br><span class="line">                    ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">                            newMark &#x3D;&#x3D; current.mark) || &#x2F;&#x2F; 如果要更新的对象和对象标记与Pair的refernce和mark一样的话直接返回true，否则执行CAS操作</span><br><span class="line">                            casPair(current, Pair.of(newReference, newMark)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不需要过分在意源码，我们只要知道怎么用就好，demo如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicMarkableReferenceDemo &#123;</span><br><span class="line"></span><br><span class="line">    private static final Integer INIT_NUM &#x3D; 10;</span><br><span class="line"></span><br><span class="line">    private static final Integer TEM_NUM &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    private static final Integer UPDATE_NUM &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    private static final Boolean INITIAL_MARK &#x3D; Boolean.FALSE;</span><br><span class="line"></span><br><span class="line">    private static AtomicMarkableReference atomicMarkableReference &#x3D; new AtomicMarkableReference(INIT_NUM, INITIAL_MARK);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; ： 初始值为：&quot; + INIT_NUM + &quot; , 标记为： &quot; + INITIAL_MARK);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if (atomicMarkableReference.compareAndSet(INIT_NUM, UPDATE_NUM, atomicMarkableReference.isMarked(), Boolean.TRUE)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; ： 修改后的值为：&quot; + atomicMarkableReference.getReference() + &quot; , 标记为： &quot; + atomicMarkableReference.isMarked());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  &quot; CAS返回false&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;线程A&quot;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; ： 初始值为：&quot; + atomicMarkableReference.getReference() + &quot; , 标记为： &quot; + INITIAL_MARK);</span><br><span class="line">            atomicMarkableReference.compareAndSet(atomicMarkableReference.getReference(), TEM_NUM, atomicMarkableReference.isMarked(), Boolean.TRUE);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; ： 修改后的值为：&quot; + atomicMarkableReference.getReference() + &quot; , 标记为： &quot; + atomicMarkableReference.isMarked());</span><br><span class="line">        &#125;, &quot;线程B&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程A ： 初始值为：10 , 标记为： false</span><br><span class="line">线程B ： 初始值为：10 , 标记为： false</span><br><span class="line">线程B ： 修改后的值为：20 , 标记为： true</span><br><span class="line">线程A CAS返回false</span><br></pre></td></tr></table></figure>

<p>由于线程B修改了对象，标记由false改为true，所以当上下文切换为线程A的时候，如果标记不一致，线程A执行CAS方法就会返回false。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/" itemprop="url">LRU和LFU算法以及其在Redis中的实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-04T23:34:29+08:00">
                2020-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/04/LRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/08/04/LRU和LFU算法以及其在Redis中的实现/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文讲述的两个缓存淘汰算法，LRU算法（Least recently used）和LFU算法（Least Frequently used），两者看起来很相似，但我们要明确其区别在于：</p>
<ul>
<li><p>LRU是按访问时间排序，发生淘汰的时候，把访问时间最旧的淘汰掉。</p>
</li>
<li><p>LFU是按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。</p>
</li>
</ul>
<p>本文旨在描述LRU/LFU算法定义，并给出性能最佳的实现方式，最后再延伸至当前最热门的缓存中间件Redis中二者的实现。</p>
<p>其中，LRU/LFU算法性能最优的实现，也是各大厂技术面的常问题。leetcode上有两个这样的题目，要求是缓存的加入put()，缓存读取get()，都要在O(1)内实现：</p>
<ul>
<li>LRU：<a href="https://leetcode.com/problems/lru-cache/description/" target="_blank" rel="noopener">https://leetcode.com/problems/lru-cache/description/</a> 或者 <a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache/</a></li>
<li>LFU：<a href="https://leetcode.com/problems/lfu-cache/description/" target="_blank" rel="noopener">https://leetcode.com/problems/lfu-cache/description/</a> 或者 <a href="https://leetcode-cn.com/problems/lfu-cache/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lfu-cache/</a></li>
</ul>
<h1 id="1-LRU算法"><a href="#1-LRU算法" class="headerlink" title="1 LRU算法"></a>1 LRU算法</h1><p>LRU（Least recently used）算法，也叫作<strong>最近最久未使用算法</strong>，顾名思义，就是哪个是最近不用的，就把他淘汰掉。它根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。它经常使用在内存/缓存空间不足的场景，以便在受限时舍弃掉不常用的数据。</p>
<h2 id="1-1-链表实现简单LRU"><a href="#1-1-链表实现简单LRU" class="headerlink" title="1.1 链表实现简单LRU"></a>1.1 链表实现简单LRU</h2><p>使用链表，可以实现最简单的LRU算法：</p>
<ol>
<li>维护一个定长的链表</li>
<li>当一个新的key被访问时<ul>
<li>如果这个key不存在链表中，那么新key插入到链表头部；</li>
<li>如果这个key存在链表中，那么将这个key移到链表头部；</li>
</ul>
</li>
<li>当链表满的时候，如果还有新的key要插入，则将链表尾部的key丢弃。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-c609868da6b2cfefb197343aeee43d3d711.png" alt=""></p>
<p>这种简单的实现固然能达到我们的目的，但也有致命的要求：这种实现的性能不是很好，查询一个key是否存在链表中，以及在链表中的具体位置的时间复杂度是O(n)，这在数据数量巨大的场景下是灾难的。</p>
<h2 id="1-2-HashMap和双向链表实现高性能LRU"><a href="#1-2-HashMap和双向链表实现高性能LRU" class="headerlink" title="1.2 HashMap和双向链表实现高性能LRU"></a>1.2 HashMap和双向链表实现高性能LRU</h2><p>链表实现的LRU算法瓶颈主要在<strong>定位一个key在链表中位置的消耗</strong>。</p>
<p>为了规避这个代价，我们可以引入在查询和定位方面具有极高优势的HashMap来作为互补，整体的设计思路是，可以使用 HashMap 存储 key，而HashMap的Value指向双向链表实现的LRU的 Node 节点。这样可以做到save和get的时间都是 O(1)。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-04a2a22decea9ebd74bd5aab3ad4de3fbb6.png" alt=""></p>
<p>假如我们预设链表的大小是3，下图展示了LRU链表在存储和访问过程中的变化。为了简化图复杂度，图中没有展示HashMap部分的变化，仅仅演示了上图LRU双向链表的变化。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9bbae79816c5ac35c34cd21e3bb7f20a342.png" alt=""></p>
<h2 id="1-3-继承LinkedHashMap实现LRU"><a href="#1-3-继承LinkedHashMap实现LRU" class="headerlink" title="1.3 继承LinkedHashMap实现LRU"></a>1.3 继承LinkedHashMap实现LRU</h2><p>LinkedHashMap底层就是用的HashMap加双链表实现的，而且本身已经实现了按照访问顺序的存储（也就是其put方法会将最近访问的数据放到表头）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e15263be2c99e9a89332fc6c464029aa4df.png" alt=""></p>
<p>此外，LinkedHashMap中本身就实现了一个方法removeEldestEntry，用于在每次数据发生变更时（put和get）判断是否需要移除最不常读取的数，方法默认是直接返回false，不会移除元素（也正因此，LinkedHashMap是无限长的）。所以为了将其改造为一个定长且会自动移除队尾数据的链表，需要重写removeEldestEntry方法，即当缓存满后就移除最不常用的数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private final int CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里就是传递进来最多能缓存多少数据</span><br><span class="line">    public LRUCache(int cacheSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置一个hashmap的初始大小，最后一个true指的是让linkedhashmap按照访问顺序来进行排序，最近访问的放在头，最老访问的就在尾</span><br><span class="line">        super((int) Math.ceil(cacheSize &#x2F; 0.75) + 1, 0.75f, true);</span><br><span class="line">        CACHE_SIZE &#x3D; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry eldest) &#123;</span><br><span class="line">        &#x2F;&#x2F; 当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据</span><br><span class="line">        return size() &gt; CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2-Redis中的LRU"><a href="#2-Redis中的LRU" class="headerlink" title="2 Redis中的LRU"></a>2 Redis中的LRU</h1><blockquote>
<p>在讨论Redis的LRU之前，需要明确，Redis的缓存淘汰策略（LRU）与Redis键的过期删除策略不是一回事，LRU是在Redis内存使用超过一定值的时候（一般这个值可以配置）使用的淘汰降级策略；而后者是通过定期删除+惰性删除两者结合的方式进行过期删除的。</p>
</blockquote>
<h2 id="2-1-Redis缓存淘汰策略"><a href="#2-1-Redis缓存淘汰策略" class="headerlink" title="2.1 Redis缓存淘汰策略"></a>2.1 Redis缓存淘汰策略</h2><p>当内存达到极限时，Redis就要开始利用回收策略对内存进行回收释放。回收的配置在 redis.conf 中填写，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 1073741824</span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line">maxmemory-samples 5</span><br></pre></td></tr></table></figure>

<ul>
<li>maxmemory： 指定了内存使用的极限，以字节为单位。当内存达到极限时，他会尝试去删除一些键值。</li>
<li>maxmemory-policy：指定删除的策略。Redis提供了如下几种缓存淘汰策略的取值<ul>
<li>noeviction：当内存使用超过配置的时候（如SET、LPUSH 等等命令）会返回错误，不会驱逐任何键。</li>
<li>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</li>
<li>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</li>
<li>allkeys-random：加入键的时候如果过限，从所有key随机删除</li>
<li>volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐</li>
<li>volatile-ttl：从配置了过期时间的键中驱逐过期时间最近 (TTL 最小)的键</li>
<li>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</li>
<li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li>
</ul>
</li>
<li>maxmemory-samples ：指定了在进行删除时的键的采样数量。LRU 和 TTL 都是近似算法，所以可以根据参数来进行取舍，到底是要速度还是精确度。默认值一般填 5。10 的话已经非常近似正式的 LRU 算法了，但是会多一些 CPU 消耗；3 的话执行更快，然而不够精确。</li>
</ul>
<p>上述说到的缓存淘汰策略中，带lru后缀的，就是采用Redis LRU算法的策略，带有lfu后缀的策略，就是采用Redis LFU算法的策略（后文详述）。</p>
<h2 id="2-2-Redis中的LRU时钟"><a href="#2-2-Redis中的LRU时钟" class="headerlink" title="2.2 Redis中的LRU时钟"></a>2.2 Redis中的LRU时钟</h2><p>在LRU实现中，最核心的要点就是标记哪些数据是“最久”的，前文提到的LRU实现，我们利用链表的顺序来确定哪个数据“最久”，但如果按照性能较好的HashMap和双向链表来实现，在Redis key数量巨大的情况下，HashMap和双向链表的长度也会非常巨大，会牺牲比较大的存储空间，显然是不划算的。</p>
<p> 我们知道Redis中的所有对象都被定义为redisObject结构体。Redis LRU算法回收的数据，也正是这些对象。</p>
<p>Redis不采用链表来确定哪些redisObject是最久的，而是在redisObject结构体中定义了一个lru成员来用来记录该对象的最近一次被访问的时间。由于时钟的最大值只需要 24 个比特位就能表示，所以结构体定义时采用了位域。定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:LRU_BITS;</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>


<p>而在Redis在全局中也维护了一个24位全局时钟，可以简单理解为当前系统的时间戳。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line">       pid_t pid;</span><br><span class="line">       char *configfile;</span><br><span class="line">       &#x2F;&#x2F;全局时钟</span><br><span class="line">       unsigned lruclock:LRU_BITS;</span><br><span class="line">       ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Redis每隔一定时间会通过全局的定时器函数serverCron来更新这个时钟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int serverCron(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    server.lruclock &#x3D; getLRUClock();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个时钟的刷新频率由 server.hz 决定，即每秒钟会调用 server.hz （默认值为 10）次 serverCron 函数。那么，服务器每 1 / server.hz 秒就会调用一次定时器函数 serverCron。</p>
</blockquote>
<p>当一个对象redisObject新建或者被访问时，redis使用全局lru时钟来赋值对象内的lru时钟。</p>
<p>基于上面的基础，redis就可以很轻易的得到一个对象的空闲时间了：<strong>用全局的lru时钟减去对象本身的lru时钟，得到的就是这个对象没有被访问的时间间隔（也称空闲时间，idle time），空闲时间最大的就是需要淘汰的对象</strong>。</p>
<h2 id="2-3-Redis-LRU回收流程"><a href="#2-3-Redis-LRU回收流程" class="headerlink" title="2.3 Redis LRU回收流程"></a>2.3 Redis LRU回收流程</h2><p>Redis并不需要一个完全准确的LRU算法，就算移除了一个最近访问过的Key，影响也不大。为了性能计，Redis采用了一个近似LRU的实现：</p>
<p>Redis的数据库是一个巨大的字典，redisDb结构体中，维护着一个全局的，保存了数据库中的所有键值对的字典——dict字典，我们也称它做键空间。还维护着一个保存了所有带过期配置的键值对的字典——expire字典。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d6e14f11d52889dd33329a8330c815e5b10.png" alt=""></p>
<p>当内存使用超过最大使用数（即超过maxmemory的上限）时，就需要采用回收策略进行内存回收。如果回收策略采用带有LRU算法的策略，那么就会使用到Redis的近似LRU算法实现，流程如下</p>
<ol>
<li><p><strong>触发淘汰</strong>：在每一次处理客户端命令时。当 server.maxmemory的值非 0，则检测是否有需要回收淘汰的内存，如果有则触发redis.c/freeMemoryIfNeeded(void)函数以清理超出的内存，即步骤2的逻辑</p>
</li>
<li><p><strong>更新回收池</strong>：随机按策略从dict或者expire中取出maxmemory_samples个键（实际取到的数量取决于大字典原本的大小）</p>
<ul>
<li>然后用一个长度为16（由宏 MAXMEMORY_EVICTION_POOL_SIZE 指定）的evictionPool（回收池）对这几个键进行筛选</li>
<li>依次将取出的键的idle time和evictionPool中最小的idle time比较。将随机取出的键中，idle time比当前evictionPool中最小的idle time还要大的键，按idle time从小到大的顺序插入到evictionPool内的相应位置中（因为evictionPool是定长，所以如果在evictionPool已满的情况下插入新key，则要释放idle time较小的key）。</li>
</ul>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-fe014848ed18d0f5f5cc817267d06dc2268.png" alt=""></p>
<ol start="3">
<li><strong>删除淘汰的键</strong>：最后再从evictionPool池中取出idle time最大且在字典中存在的键作为bestkey执行删除，并且将该key从evictionPool池中移除；</li>
</ol>
<blockquote>
<p>注意这个清理过程是阻塞的，直到清理出足够的内存空间。所以如果在达到maxmemory并且调用方还在不断写入的情况下，可能会反复触发主动清理策略，导致请求会有一定的延迟。</p>
</blockquote>
<p>Redis采用回收池，把一个<strong>全局排序问题</strong>转化成为了<strong>局部的比较问题</strong>。要想知道idle time最大的key，精确的LRU需要对全局的key的idle time排序，这样的成本对于Redis来说太高了。Redis的LRU算法采用一种近似的思想，即随机采样(samping)若干个key，这若干个key就代表着全局的key，把samping得到的key放到pool里面，每次采样之后更新pool，使得pool里面总是保存着随机选择过的key的idle time最大的那些key。</p>
<p>需要evict key时，直接从pool里面取出idle time最大的key，将之evict掉。这种思想是很值得借鉴的。</p>
<p>而且，Redis团队经过试验，发现当samples=10时，Redis随机的LRU算法，已经能够很准确的淘汰掉最久没有使用的键，其效果和精确的LRU基本持平。如下图（浅灰色表示已经删除的键，深灰色表示没有被删除的键，绿色表示新加入的键，越往上表示键加入的时间越久）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-da6975d89b1e5c0929529b709d71d0d0840.png" alt=""></p>
<h1 id="3-LFU算法"><a href="#3-LFU算法" class="headerlink" title="3 LFU算法"></a>3 LFU算法</h1><p>LFU（Least Frequently used）算法，也叫作<strong>最近最少使用算法</strong>，顾名思义，就是淘汰缓存里面用的最少的数据。它根据数据的访问频次来进行淘汰数据，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。</p>
<h2 id="3-1-使用双哈希表实现高性能LFU"><a href="#3-1-使用双哈希表实现高性能LFU" class="headerlink" title="3.1 使用双哈希表实现高性能LFU"></a>3.1 使用双哈希表实现高性能LFU</h2><p>有了LRU的打底，我们知道，在排序问题中（LFU和LRU本质都是排序问题）要想实现O(1)时间复杂度的get性能，必须要借助哈希表来实现。但LFU相比LRU有个难点：<strong>频次相比于访问时间，更容易重复，即容易同时出现多于一个的key，他们的频次是一样的，且都是最低的。这时候出现平局，则需要在频次最低的基础上，再在重复的key中间，找到最久未使用的key，并淘汰</strong>。</p>
<p>也就是说，LFU的实现，除了要按照访问频率来排序，还要按照访问时间来排序。排序顺序是：访问频率降序&gt;访问时间降序。</p>
<p>为了达到上述目的，并且达到put和get都为O(1)复杂度，那么我们引入了双哈希表。</p>
<ul>
<li>第一个哈希表的含义是<strong>HashMap&lt;缓存的key，缓存数据节点的地址&gt;</strong><ul>
<li>第一个哈希表，和lru的实现一样，是用来实现O(1)时间查找key对应的节点。</li>
</ul>
</li>
<li>第一个哈希表的含义是<strong>HashMap&lt;访问频率，链表的头结点的地址&gt;</strong><ul>
<li>这个哈希表的每一个value，都是采用拉链法，挂上了一个缓存数据节点组成的双向链表（链表节点按照访问时间从近到远排序，表头访问时间最近，表尾访问时间最远）。</li>
<li>该哈希表的value值指向链表头部，而这个双向链表内存的，都是目前访问频率为其value对应的key值的缓存数据。</li>
<li>比如key=3的value是一个三个节点的链表，则表示这个链表内的三个缓存节点，访问频次都是3次。</li>
</ul>
</li>
</ul>
<p>一图胜万言：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-07e66e8579884f9a6e2e02cc87c79c8889b.png" alt=""></p>
<p>这样的实现下，我们对于get和put操作就可以：</p>
<ul>
<li><strong>get</strong>：如果第一个哈希表中能查到key，那么取得相应链表节点数据。接下来在第二个哈希表中，把该节点<strong>移到</strong>其访问频率+1位置的链表头部。</li>
<li><strong>put</strong>：如果第一个哈希表中能查找key，那么操作和get(key)一样，只是最后要把新节点的value更新为新value。</li>
<li><strong>当发生淘汰时</strong>：也就是要执行put操作，但是容量已经达到限制时，这时直接找到第二个哈希表中最小引用计数的链表，删除其末尾节点（最晚使用）。之后再添加新节点即可。</li>
</ul>
<blockquote>
<p>容量超限需要删除节点时，删除了第二个哈希表中的项的同时，第一个哈希表中对应的映射也应该删掉。</p>
</blockquote>
<blockquote>
<p>需要在双哈希表之外维护一个额外的min_cnt变量用来保存当前的最小访问频率。因为容量超限需要删除节点时，我们需要O(1)时间找到需要删除的节点。及调用get(min_cnt)来定位到要被删除的那个链表。</p>
</blockquote>
<h1 id="4-Redis中的LFU"><a href="#4-Redis中的LFU" class="headerlink" title="4 Redis中的LFU"></a>4 Redis中的LFU</h1><p>Redis4.0开始，maxmemory_policy淘汰策略添加了两个LFU模式：</p>
<ul>
<li>volatile-lfu：对有过期时间的key采用LFU淘汰算法</li>
<li>allkeys-lfu：对全部key采用LFU淘汰算法</li>
</ul>
<p>使用这两种淘汰策略，便会使用到Redis的LFU算法，一种<strong>近似计数算法</strong>。</p>
<h2 id="4-1-常规LFU算法面临的问题"><a href="#4-1-常规LFU算法面临的问题" class="headerlink" title="4.1 常规LFU算法面临的问题"></a>4.1 常规LFU算法面临的问题</h2><p>在数据请求模式比较稳定（没有对于某个数据突发的高频访问这样的不稳定模式）的情况下，LFU的表现还是很不错的。</p>
<p>但在数据的请求模式大多不稳定的情况下，LFU一般会有这样一些问题：</p>
<ol>
<li><strong>热点数据问题</strong>：热点数据一般只是几天内有较高的访问频次，过了这段时间就没那么大意义去缓存了。但是因为在热点期间他的频次被刷上去了，导致之后很长一段时间内很难被淘汰；</li>
<li><strong>新增数据问题</strong>：如果采用只记录缓存中的数据的访问信息，新加入的高频访问数据在刚加入的时候由于没有累积优势，很容易被淘汰掉；</li>
<li><strong>空间问题</strong>：如果记录全部出现过的数据的访问信息，会占用更多的内存空间。</li>
</ol>
<p>对于上面这些问题，其实也都有一些对应的解决方式，相应的出现了很多LFU的变种。如：Window-LFU、LFU*、LFU-Aging。在Redis的LFU算法实现中，也有其解决方案。</p>
<h2 id="4-2-Redis中的频次计算"><a href="#4-2-Redis中的频次计算" class="headerlink" title="4.2 Redis中的频次计算"></a>4.2 Redis中的频次计算</h2><p>在常规操作中，我们一般会引入一个字段作为计数器，对每个key的访问频次做简单的加法，但这样的实现显然无法规避上述的三个问题：一味做加法，过期的热点数据很难淘汰；新增的数据频次太低，容易被淘汰；Redis的访问频次量级非常大，每个key都维护一个长的字段，空间代价太大。</p>
<p>为了解决这三个问题，Redis的频次计算实现，引入了三个策略：</p>
<ol>
<li><strong>概率量级计数</strong>：该策略可以解决空间问题。<ul>
<li>可配参数server.lfu_log_factor就服务于该策略，它能够影响计数的量级范围，整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。</li>
</ul>
</li>
<li><strong>计数衰减</strong>：该策略可以解决热点数据问题。<ul>
<li>可配参数server.lfu-decay-time就服务于该策略，它能够控制LFU计数衰减，是一个以分钟为单位的数值，可以调整counter的减少速度。</li>
</ul>
</li>
<li><strong>新增数据赋值</strong>：该策略可以解决新增数据问题。<ul>
<li>固定常量LFU_INIT_VAL就服务于该策略，其值默认为5，即为新生key的counter设置一个初始频次，默认为5。</li>
</ul>
</li>
</ol>
<h3 id="4-2-1-概率量级计数"><a href="#4-2-1-概率量级计数" class="headerlink" title="4.2.1 概率量级计数"></a>4.2.1 概率量级计数</h3><p>Redis的LFU实现也是需要为每个key维护一个字段来承载该key的访问频次的，而且<strong>这个字段不能太大</strong>，不然Redis这么多key，那么消耗的空间将是一个可怕的数字，同时，本着Redis一贯对空间锱铢必较的心态，能重复利用的字段，我们绝不维护新的字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;</span><br><span class="line">    unsigned encoding:4;</span><br><span class="line">    unsigned lru:LRU_BITS; &#x2F;* LRU time (relative to global lru_clock) or</span><br><span class="line">                            * LFU data (least significant 8 bits frequency</span><br><span class="line">                            * and most significant 16 bits access time). *&#x2F;</span><br><span class="line">    int refcount;</span><br><span class="line">    void *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>看来看去，redisObject结构中，也只有lru字段可以重复利用了，因为淘汰策略是互斥的，Redis同时只能选择一种淘汰策略，要么LRU，要么LFU，要么其他，所以lru字段重复利用不会冲突。</p>
<p>在LRU算法中，24 bits的lru是用来记录LRU time的，<strong>在LFU中使用这个字段，却是分成16 bits与8 bits使用</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*          16 bits      8 bits</span><br><span class="line">*     +----------------+--------+</span><br><span class="line">*     + Last decr time | LOG_C  |</span><br><span class="line">*     +----------------+--------+</span><br></pre></td></tr></table></figure>

<p>高16 bits用来记录最近一次计数器衰减的时间ldt，单位是分钟，这个我们下文再说。</p>
<p><strong>低8 bits记录计数器数值counter</strong>。8个bit位最大为255，显然如果只是简单的对counter做加法，那8 bit的counter根本无法容纳Redis那动辄百万或千万级别的命中频次。</p>
<p>那么，Redis如何使用8 bit的counter来承载百万或者千万级别的命中频次呢？相关源码在<code>evict.c</code>文件中的<code>LFULogIncr</code>方法中实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Logarithmically increment a counter. The greater is the current counter value</span><br><span class="line"> * the less likely is that it gets really implemented. Saturate it at 255. *&#x2F;</span><br><span class="line">uint8_t LFULogIncr(uint8_t counter) &#123;</span><br><span class="line">    if (counter &#x3D;&#x3D; 255) return 255;</span><br><span class="line">    &#x2F;&#x2F;这里的rand()方法会生成一个 0 ~ RAND_MAX 之间的随机数，所以r的范围也就是0~1之间。</span><br><span class="line">    double r &#x3D; (double)rand()&#x2F;RAND_MAX;</span><br><span class="line">    double baseval &#x3D; counter - LFU_INIT_VAL;</span><br><span class="line">    if (baseval &lt; 0) baseval &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;根据目前counter和server.lfu_log_factor值得出一个p</span><br><span class="line">    double p &#x3D; 1.0&#x2F;(baseval*server.lfu_log_factor+1);</span><br><span class="line">    &#x2F;&#x2F;如果r &lt; p，counter才+1</span><br><span class="line">    if (r &lt; p) counter++;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先看p字段：</p>
<p>对于<code>p=1.0/(baseval*server.lfu_log_factor+1);</code></p>
<p>等价于<code>p=1/((counter−LFU_INIT_VAL)*factor+1);</code></p>
<p>因为LFU_INIT_VAL是常数，所以当counter够大时，近似等于：<code>p=1/(counter*factor+1)</code></p>
<p>factor是个常数，server.lfu_log_factor默认值是10，下图展示了factor不同时，p=f(counter)的函数曲线</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bc7b790c06e282c599c94a25afdb0d0736c.png" alt=""></p>
<p>紧接着再来看r，r是由random函数随机出来的范围在0~1之间的值，我们可以认为r的值是随机的，那么我们可以认为：</p>
<p>r的值在0 ~ 1范围内，也就是r&lt;=1的概率为100%（1）；</p>
<p>r的值在0 ~ 0.9范围内，也就是r&lt;=0.9的概率为90%（0.9）；</p>
<p>以此类推。</p>
<p>r的值在0 ~ p的范围内，也就是r&lt;=p的概率为p；</p>
<p><strong>所以综上所诉</strong>，Redis的概率量级计数的核心逻辑就是：</p>
<ol>
<li><p><strong>每一次key被访问，counter都有近似<code>p=1/(counter*factor+1)</code>的概率会+1。在factor是常数的情况下，counter+1的概率随着counter值的增大而减小</strong>。</p>
</li>
<li><p><strong>factor值我们设置的越大，则counter+1的概率在同等情况下则会越低，counter字段8 bit一共255的上限也就越不容易被触达，换句话说，factor越大，Redis的counter字段能够记录的访问频次量级也就越高</strong>。</p>
</li>
</ol>
<blockquote>
<p>概率量级计数，就体现在p和factor上，p控制的是counter的概率上升，factor控制的是counter承载的访问量级。</p>
</blockquote>
<p>下表是不同的factor的值能够控制计数代表的量级的范围，当factor为100时，能够最大代表10M，也就是千万级别的命中数。</p>
<table>
<thead>
<tr>
<th align="center">factor</th>
<th align="center">100 hits</th>
<th align="center">1000 hits</th>
<th align="center">100K hits</th>
<th align="center">1M hits</th>
<th align="center">10M hits</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">104</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">18</td>
<td align="center">49</td>
<td align="center">255</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">10</td>
<td align="center">18</td>
<td align="center">142</td>
<td align="center">255</td>
<td align="center">255</td>
</tr>
<tr>
<td align="center">100</td>
<td align="center">8</td>
<td align="center">11</td>
<td align="center">49</td>
<td align="center">143</td>
<td align="center">255</td>
</tr>
</tbody></table>
<p>下图是不同factor场景下，不同key的counter字段的值（颜色不同的线）在固定访问频率下随着时间的上升走势。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ddad582bc4e83b730a0c8fff3336ddd3158.png" alt=""></p>
<h3 id="4-2-2-计数衰减"><a href="#4-2-2-计数衰减" class="headerlink" title="4.2.2 计数衰减"></a>4.2.2 计数衰减</h3><p>上一章节我们讲了counter是概率增加，但为了解决热点问题，使热点数据能够随着时间推移慢慢的降低频次，以至于最后淘汰，那么Redis引入了计数衰减的策略。</p>
<p><strong>某个key的counter被衰减的时机是在它被访问的时候</strong>。在缓存被访问时，会更新数据的访问计数，更新的步骤是：</p>
<ol>
<li>先在现有数据的计数上进行计数衰减。</li>
<li>再对完成衰减后的计数进行概率增加。</li>
</ol>
<blockquote>
<p>所以要注意，计数衰减的触发也是被动的，而非Redis主动或者定时触发的。</p>
</blockquote>
<p>计数衰减的实现在LFUDecrAndReturn方法中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Return the current time in minutes, just taking the least significant</span><br><span class="line"> * 16 bits. The returned time is suitable to be stored as LDT (last decrement</span><br><span class="line"> * time) for the LFU implementation. *&#x2F;</span><br><span class="line">unsigned long LFUGetTimeInMinutes(void) &#123;</span><br><span class="line">    return (server.unixtime&#x2F;60) &amp; 65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* Given an object last access time, compute the minimum number of minutes</span><br><span class="line"> * that elapsed since the last access. Handle overflow (ldt greater than</span><br><span class="line"> * the current 16 bits minutes time) considering the time as wrapping</span><br><span class="line"> * exactly once. *&#x2F;</span><br><span class="line">unsigned long LFUTimeElapsed(unsigned long ldt) &#123;</span><br><span class="line">    &#x2F;&#x2F;计算当前时间和ldt的时间差值，如果now &lt; ldt，默认为过了一个周期了，那么差值应该是65535-ldt+now。</span><br><span class="line">    unsigned long now &#x3D; LFUGetTimeInMinutes();</span><br><span class="line">    if (now &gt;&#x3D; ldt) return now-ldt;</span><br><span class="line">    return 65535-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* If the object decrement time is reached decrement the LFU counter but</span><br><span class="line"> * do not update LFU fields of the object, we update the access time</span><br><span class="line"> * and counter in an explicit way when the object is really accessed.</span><br><span class="line"> * And we will times halve the counter according to the times of</span><br><span class="line"> * elapsed time than server.lfu_decay_time.</span><br><span class="line"> * Return the object frequency counter.</span><br><span class="line"> *</span><br><span class="line"> * This function is used in order to scan the dataset for the best object</span><br><span class="line"> * to fit: as we check for the candidate, we incrementally decrement the</span><br><span class="line"> * counter of the scanned objects if needed. *&#x2F;</span><br><span class="line">unsigned long LFUDecrAndReturn(robj *o) &#123;</span><br><span class="line">    unsigned long ldt &#x3D; o-&gt;lru &gt;&gt; 8;</span><br><span class="line">    unsigned long counter &#x3D; o-&gt;lru &amp; 255;</span><br><span class="line">    &#x2F;&#x2F;算出该key已经经历过num_periods个周期了</span><br><span class="line">    unsigned long num_periods &#x3D; server.lfu_decay_time ? LFUTimeElapsed(ldt) &#x2F; server.lfu_decay_time : 0;</span><br><span class="line">    if (num_periods)</span><br><span class="line">        counter &#x3D; (num_periods &gt; counter) ? 0 : counter - num_periods;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很晦涩，没关系，逻辑其实并不复杂：</p>
<ol>
<li><p>可配参数server.lfu-decay-time所代表的含义是计数衰减的周期长度，单位是分钟。当时间过去一个周期（也就是lfu-decay-time分钟），计数值就会减1。</p>
</li>
<li><p>redisObject结构中的lru字段的高16bit，记录的是该key上次进行衰减的时间。</p>
</li>
<li><p>有上述两个数据可以算出从上次衰减到现在，该key已经经历过n个周期了，这也表示着，key需要先将counter衰减n。</p>
<ul>
<li>n的计算过程如代码所示，即从上次衰减到现在经过的时间除以衰减周期长度 server.lfu_decay_time：</li>
<li><code>unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;</code></li>
</ul>
</li>
<li><p>通过<code>LFUDecrAndReturn</code>方法得到该key的counter需要衰减的值n，将counter=counter-n，然后再执行概率增加计数的操作。</p>
</li>
</ol>
<h3 id="4-2-3-新增数据赋值"><a href="#4-2-3-新增数据赋值" class="headerlink" title="4.2.3 新增数据赋值"></a>4.2.3 新增数据赋值</h3><p>为了解决新增数据问题，即如果采用只记录缓存中的数据的访问信息，新加入的高频访问数据在刚加入的时候由于没有累积优势，很容易被淘汰掉；</p>
<p>那么对于新增加的key，则不能将他们的counter设为0，Redis为新增的key的counter设置了一个初始值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">robj *createObject(int type, void *ptr) &#123;</span><br><span class="line">    robj *o &#x3D; zmalloc(sizeof(*o));</span><br><span class="line">    o-&gt;type &#x3D; type;</span><br><span class="line">    o-&gt;encoding &#x3D; OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr &#x3D; ptr;</span><br><span class="line">    o-&gt;refcount &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set the LRU to the current lruclock (minutes resolution), or</span><br><span class="line">     * alternatively the LFU counter. *&#x2F;</span><br><span class="line">    if (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru &#x3D; (LFUGetTimeInMinutes()&lt;&lt;8) | LFU_INIT_VAL;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        o-&gt;lru &#x3D; LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即counter会被初始化为LFU_INIT_VAL，默认5。</p>
<blockquote>
<p>回顾我们上文说道的p=1/((counter−LFU_INIT_VAL)*factor+1)，可以看到，当计数值等于LFU_INIT_VAL时， p=1，也就是说，对于新增的key，下一次访问时，counter增加的概率为100%</p>
</blockquote>
<h2 id="4-3-Redis-LFU回收流程"><a href="#4-3-Redis-LFU回收流程" class="headerlink" title="4.3 Redis LFU回收流程"></a>4.3 Redis LFU回收流程</h2><p>Redis LFU回收流程和Redis LRU的回收流程<strong>一模一样</strong>（有所遗忘可以回顾本文2.3章），<strong>都是采用抽样+回收池的实现方式，不同的是LRU比较的是idle time空闲时间，而LFU比较的是counter访问频次</strong>。故不再赘述。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" itemprop="url">JAVA静态/动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T17:02:42+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E5%AE%9E%E7%8E%B0%E6%88%96%E7%89%B9%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA实现或特性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/26/JAVA静态-动态代理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-静态代理（简单描述）"><a href="#1-静态代理（简单描述）" class="headerlink" title="1 静态代理（简单描述）"></a>1 静态代理（简单描述）</h1><p>先定义一个接口，里面定义目标方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;目标类要实现的接口</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;目标方法</span><br><span class="line">	void doFunc(String words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class StaticProxy implements ITarget&#123;</span><br><span class="line">	</span><br><span class="line">	private ITarget target &#x3D; null;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;关联要增强的目标类</span><br><span class="line">    public StaticProxy(ITarget target)&#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F;在这里增强目标类的目标方法</span><br><span class="line">	@Override</span><br><span class="line">	public void doFunc() &#123;</span><br><span class="line">	    ...</span><br><span class="line">	    ...</span><br><span class="line">	    ...</span><br><span class="line">        &#x2F;&#x2F;增强目标方法</span><br><span class="line">        target.doFunc();</span><br><span class="line">        ...</span><br><span class="line">	    ...</span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后，任意的一个ITarget接口的子类，都可以注入给StaticProxy类，然后实现一套增强，不再赘述。</p>
<h1 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2 动态代理"></a>2 动态代理</h1><p>代理类在程序运行时创建的代理方式被成为 动态代理。也就是说，这种情况下，代理类并不是像静态代理一样，是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。</p>
<p>动态代理是spring AOP的实现原理，spring有两种动态代理模式，cglib和jdk，我们先来将java jdk的动态代理。</p>
<h2 id="2-1-jdk的动态代理"><a href="#2-1-jdk的动态代理" class="headerlink" title="2.1 jdk的动态代理"></a>2.1 jdk的动态代理</h2><p>首先，我们需要知道，jdk的动态代理只能代理实现了接口的类 没有实现接口的类不能实现JDK动态代理。其次，我们还要了解一个重要的中介接口InvocationHandler，这是jdk的动态代理的基石，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">        throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来写一个jdk的动态代理实例，再来讨论其中的原理吧</p>
<h3 id="2-1-1-jdk动态代理实例"><a href="#2-1-1-jdk动态代理实例" class="headerlink" title="2.1.1 jdk动态代理实例"></a>2.1.1 jdk动态代理实例</h3><p>我们先来定义一个目标类，或者说委托类，或者又叫被代理类，它实现了我们上面定义的那个接口ITarget：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Entrust implements ITarget &#123;</span><br><span class="line">    public void doFunc(String words)&#123;</span><br><span class="line">        System.out.println(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个中介类，实现InvocationHandler接口，这个中介类，持有被代理的对象，在invoke中利用反射，调用目标类的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class JdkDynamicProxyHandler&lt;T&gt;  implements InvocationHandler &#123;</span><br><span class="line">    &#x2F;&#x2F;invocationHandler持有的被代理对象</span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    public JdkDynamicProxyHandler(T target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * proxy:代表动态代理对象</span><br><span class="line">     * method：代表正在执行的方法</span><br><span class="line">     * args：代表调用目标方法时传入的实参</span><br><span class="line">     * </span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;do before&quot;);</span><br><span class="line">        Object result &#x3D; method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;do after&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我们现在来写一个代理demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        ITarget attorney = <span class="keyword">new</span> Attorney();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler jdkDynamicProxyHandler = <span class="keyword">new</span> JdkDynamicProxyHandler&lt;ITarget&gt;(attorney);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个代理对象proxy来代理attorney，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        ITarget proxy = (ITarget) Proxy.newProxyInstance(ITarget.class.getClassLoader(), new Class&lt;?&gt;[]&#123;ITarget.class&#125;, jdkDynamicProxyHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        proxy.doFunc(<span class="string">"hello word"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将生成的代理类写到桌面</span></span><br><span class="line">        writeProxyClassToHardDisk(<span class="string">"/home/ls/Desktop/$Proxy22.class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeProxyClassToHardDisk</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy22"</span>, Attorney<span class="class">.<span class="keyword">class</span>.<span class="title">getInterfaces</span>())</span>;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f546dfbc4dc94c8202ee7ec822f109c869c.png" alt=""></p>
<h3 id="2-1-2-原理剖析"><a href="#2-1-2-原理剖析" class="headerlink" title="2.1.2 原理剖析"></a>2.1.2 原理剖析</h3><p>我们来看看Proxy.newProxyInstance方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        final Class&lt;?&gt;[] intfs &#x3D; interfaces.clone();</span><br><span class="line">        final SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">        if (sm !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;验证一些参数</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Look up or generate the designated proxy class.</span><br><span class="line">         * 从缓存里面获取某个类的代理类，如果该类的代理类不存在，就根据该类的类型创建一个</span><br><span class="line">         * 如果要深挖逻辑，可以看看ProxyClassFactory的apply方法。</span><br><span class="line">         * 其实生成代理类字节码文件的工作是通过 ProxyGenerate类中的generateProxyClass方法来完成的。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Invoke its constructor with the designated invocation handler.</span><br><span class="line">         *</span><br><span class="line">         * &#x2F;** parameter types of a proxy class constructor *&#x2F;</span><br><span class="line">         * private static final Class&lt;?&gt;[] constructorParams &#x3D; &#123; InvocationHandler.class &#125;;</span><br><span class="line">         * </span><br><span class="line">         *&#x2F;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (sm !&#x3D; null) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;看上面的注释，constructorParams&#x3D;&#123; InvocationHandler.class &#125;，</span><br><span class="line">            &#x2F;&#x2F;这是在生成代理类的构造函数,获得一个参数为InvocationHandler的构造方法</span><br><span class="line">            final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih &#x3D; h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        cons.setAccessible(true);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;这行代码的意思是将h,也就是实现InvocationHandler的实现类，</span><br><span class="line">            &#x2F;&#x2F;我们传入的是jdkDynamicProxyHandler，注入到cons中。</span><br><span class="line">            &#x2F;&#x2F;然后newInstance生成一个已经组装过参数的代理类。</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t &#x3D; e.getCause();</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的。</p>
<p>我们对这个代理类进行反编译：（本次使用<a href="http://www.javadecompilers.com/在线反编译工具）" target="_blank" rel="noopener">http://www.javadecompilers.com/在线反编译工具）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import aopLearn.ITarget;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; Decompiled by Procyon v0.5.30</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line"></span><br><span class="line">public final class $Proxy22 extends Proxy implements ITarget</span><br><span class="line">&#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m0;</span><br><span class="line">    &#x2F;**</span><br><span class="line">      *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白了</span><br><span class="line">      *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span><br><span class="line">      *被代理对象的实例</span><br><span class="line">      *</span><br><span class="line">      *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span><br><span class="line">      *父类持有：protected InvocationHandler h;</span><br><span class="line">      *Proxy构造方法：</span><br><span class="line">      *    protected Proxy(InvocationHandler h) &#123;</span><br><span class="line">      *         Objects.requireNonNull(h);</span><br><span class="line">      *         this.h &#x3D; h;</span><br><span class="line">      *     &#125;</span><br><span class="line">      *</span><br><span class="line">      *&#x2F;</span><br><span class="line">    public $Proxy22(final InvocationHandler invocationHandler) &#123;</span><br><span class="line">        super(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;这个静态块本来是在最后的，我把它拿到前面来，方便描述</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;doFunc通过反射得到的名字m3</span><br><span class="line">            $Proxy22.m1 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            $Proxy22.m3 &#x3D; Class.forName(&quot;aopLearn.ITarget&quot;).getMethod(&quot;doFunc&quot;, Class.forName(&quot;java.lang.String&quot;));</span><br><span class="line">            $Proxy22.m2 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, (Class&lt;?&gt;[])new Class[0]);</span><br><span class="line">            $Proxy22.m0 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, (Class&lt;?&gt;[])new Class[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (NoSuchMethodException ex) &#123;</span><br><span class="line">            throw new NoSuchMethodError(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ClassNotFoundException ex2) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(ex2.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final boolean equals(final Object o) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (boolean)super.h.invoke(this, $Proxy22.m1, new Object[] &#123; o &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">      * </span><br><span class="line">      *这里调用代理对象的doFunc方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span><br><span class="line">      *this.h.invoke(this, m3, null);这里简单，明了。</span><br><span class="line">      *代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span><br><span class="line">      *再联系到InvacationHandler中的invoke方法。其实就是代理对象调用InvocationHandler，</span><br><span class="line">      * InvocationHandler对象反射调用委托类对象。</span><br><span class="line">      *&#x2F;</span><br><span class="line">    public final void doFunc(final String s) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, $Proxy22.m3, new Object[] &#123; s &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final String toString() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, $Proxy22.m2, null);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (int)super.h.invoke(this, $Proxy22.m0, null);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了这些，我们来想一下，为什么jdk的动态代理，一定要委托类实现一个接口？这是因为我们可以看到，<strong>我们生成的代理类Proxy22 extends Proxy implements ITarget，已经继承了Proxy类，而java中不能多继承，为了让$Proxy22和委托类建立联系，只能实现一个接口</strong>。这里的建立联系，是指通过接口，得到委托类方法的反射等，<strong>并且，委托类实现自接口的方法，才能被增强</strong>。</p>
<p>故而，本质上来说，jdk的动态代理，<strong>是为接口产生代理</strong>。</p>
<p>在spring AOP中，我们使用jdk动态代理时当然也要定义InvocationHandler的实现类对象，spring中的是org.springframework.aop.framework.JdkDynamicAopProxy类。</p>
<h2 id="2-2-cglib的动态代理"><a href="#2-2-cglib的动态代理" class="headerlink" title="2.2 cglib的动态代理"></a>2.2 cglib的动态代理</h2><p>cglib的动态代理针对类来实现代理,对指定目标产生一个子类 通过方法拦截技术拦截所有父类方法的调用。我们要使用cglib代理必须引入cglib的jar包。</p>
<h3 id="2-2-1-cglib动态代理实例"><a href="#2-2-1-cglib动态代理实例" class="headerlink" title="2.2.1 cglib动态代理实例"></a>2.2.1 cglib动态代理实例</h3><p>同样，定义一个跟上面例子一样的委托类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Entrust &#123;</span><br><span class="line">    public void doFunc(String words)&#123;</span><br><span class="line">        System.out.println(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现MethodInterceptor接口生成方法拦截器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class EntrustInterceptor implements MethodInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        Object o &#x3D; proxy.invokeSuper(obj,args);</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] a)&#123;</span><br><span class="line">    &#x2F;&#x2F;cglib自带的debug工具，可以将代理类输出到指定路径</span><br><span class="line">    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;&#x2F;home&#x2F;ls&#x2F;Desktop&#x2F;cglib&quot;);</span><br><span class="line">    Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">    &#x2F;&#x2F;继承被代理类</span><br><span class="line">    enhancer.setSuperclass(Entrust.class);</span><br><span class="line">    enhancer.setCallback(new EntrustInterceptor());</span><br><span class="line">    &#x2F;&#x2F;生成的代理类对象</span><br><span class="line">    Entrust entrust &#x3D; (Entrust) enhancer.create();</span><br><span class="line">    &#x2F;&#x2F;在调用我们代理类中的方法时会被我们实现的方法拦截器拦截</span><br><span class="line">    entrust.doFunc(&quot;hello word&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：<br><img src="https://oscimg.oschina.net/oscnet/up-b3377d0e8764157f3d7b386c8cf3223b381.png" alt=""></p>
<h3 id="2-2-2-原理剖析"><a href="#2-2-2-原理剖析" class="headerlink" title="2.2.2 原理剖析"></a>2.2.2 原理剖析</h3><p>CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。</p>
<p>我们看到，代理类对象是由Enhancer类创建的。Enhancer是CGLIB的字节码增强器，可以很方便的对类进行拓展，创建代理对象的几个步骤:</p>
<ol>
<li>生成代理类的二进制字节码文件；</li>
<li>加载二进制字节码，生成Class对象( 例如使用Class.forName()方法 )；</li>
<li>通过反射机制获得实例构造，并创建代理类对象</li>
</ol>
<p>我们来看看将代理类Class文件反编译之后的Java代码，一个动态代理，产生了三个类：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6c31ef9c2dc4797d243753037ae6e48b39b.png" alt=""></p>
<p>主要的代理类是 </p>
<pre><code>Entrust$$EnhancerByCGLIB$$832e20ab</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Decompiled by Procyon v0.5.30</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.lufax.util.aopCache.cglibProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.Signature;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Factory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成的代理类Entrust$$EnhancerByCGLIB$$832e20ab继承被代理类Entrust。</span></span><br><span class="line"><span class="comment"> * 在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；</span></span><br><span class="line"><span class="comment"> * 同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entrust</span>$$<span class="title">EnhancerByCGLIB</span>$$832<span class="title">e20ab</span> <span class="keyword">extends</span> <span class="title">Entrust</span> <span class="keyword">implements</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$doFunc$<span class="number">0</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$doFunc$<span class="number">0</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$finalize$<span class="number">1</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$finalize$<span class="number">1</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$equals$<span class="number">2</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$equals$<span class="number">2</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$toString$<span class="number">3</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$toString$<span class="number">3</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$hashCode$<span class="number">4</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$hashCode$<span class="number">4</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$clone$<span class="number">5</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$clone$<span class="number">5</span>$Proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName = Class.forName(<span class="string">"com.lufax.util.aopCache.cglibProxy.Entrust$$EnhancerByCGLIB$$832e20ab"</span>);</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName2;</span><br><span class="line">        <span class="keyword">final</span> Method[] methods = ReflectUtils.findMethods(<span class="keyword">new</span> String[] &#123; <span class="string">"finalize"</span>, <span class="string">"()V"</span>, <span class="string">"equals"</span>, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"hashCode"</span>, <span class="string">"()I"</span>, <span class="string">"clone"</span>, <span class="string">"()Ljava/lang/Object;"</span> &#125;, (forName2 = Class.forName(<span class="string">"java.lang.Object"</span>)).getDeclaredMethods());</span><br><span class="line">        CGLIB$finalize$<span class="number">1</span>$Method = methods[<span class="number">0</span>];</span><br><span class="line">        CGLIB$finalize$<span class="number">1</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()V"</span>, <span class="string">"finalize"</span>, <span class="string">"CGLIB$finalize$1"</span>);</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Method = methods[<span class="number">1</span>];</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"equals"</span>, <span class="string">"CGLIB$equals$2"</span>);</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Method = methods[<span class="number">2</span>];</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"toString"</span>, <span class="string">"CGLIB$toString$3"</span>);</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Method = methods[<span class="number">3</span>];</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()I"</span>, <span class="string">"hashCode"</span>, <span class="string">"CGLIB$hashCode$4"</span>);</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Method = methods[<span class="number">4</span>];</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()Ljava/lang/Object;"</span>, <span class="string">"clone"</span>, <span class="string">"CGLIB$clone$5"</span>);</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName3;</span><br><span class="line">        CGLIB$doFunc$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[] &#123; <span class="string">"doFunc"</span>, <span class="string">"(Ljava/lang/String;)V"</span> &#125;, (forName3 = Class.forName(<span class="string">"com.lufax.util.aopCache.cglibProxy.Entrust"</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">        CGLIB$doFunc$<span class="number">0</span>$Proxy = MethodProxy.create((Class)forName3, (Class)forName, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="string">"doFunc"</span>, <span class="string">"CGLIB$doFunc$0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理类会为委托方法生成两个方法，一个是重写的doFunc方法，</span></span><br><span class="line">    <span class="comment">//另一个是CGLIB$doFunc$0方法，我们可以看到它是直接调用父类的doFunc方法；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$doFunc$<span class="number">0</span>(<span class="keyword">final</span> String s) &#123;</span><br><span class="line">        <span class="keyword">super</span>.doFunc(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当执行代理对象的doFunc方法时，会首先判断一下是否存在实现了MethodInterceptor接口的CGLIB$CALLBACK_0;</span></span><br><span class="line">    <span class="comment">//如果存在，则将调用MethodInterceptor中的intercept方法，如图2.1。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doFunc</span><span class="params">(<span class="keyword">final</span> String s)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里开始调用我们定义的EntrustInterceptor中的intercept方法。</span></span><br><span class="line">            <span class="comment">//参数1、代理对象；2、委托类方法；3、方法参数；4、代理方法的MethodProxy对象（注意这个对象）。</span></span><br><span class="line">            cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$doFunc$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[] &#123; s &#125;, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$doFunc$<span class="number">0</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.doFunc(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$finalize$<span class="number">1</span>() <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$finalize$<span class="number">1</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$finalize$<span class="number">1</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> CGLIB$equals$<span class="number">2</span>(<span class="keyword">final</span> Object o) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object intercept = cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$equals$<span class="number">2</span>$Method, <span class="keyword">new</span> Object[] &#123; o &#125;, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$equals$<span class="number">2</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> intercept != <span class="keyword">null</span> &amp;&amp; (<span class="keyword">boolean</span>)intercept;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> String CGLIB$toString$<span class="number">3</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$toString$<span class="number">3</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$toString$<span class="number">3</span>$Proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CGLIB$hashCode$<span class="number">4</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object intercept = cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$hashCode$<span class="number">4</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$hashCode$<span class="number">4</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> (intercept == <span class="keyword">null</span>) ? <span class="number">0</span> : ((Number)intercept).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Object CGLIB$clone$<span class="number">5</span>() <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$clone$<span class="number">5</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$clone$<span class="number">5</span>$Proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodProxy CGLIB$findMethodProxy(<span class="keyword">final</span> Signature signature) &#123;</span><br><span class="line">        <span class="keyword">final</span> String string = signature.toString();</span><br><span class="line">        <span class="keyword">switch</span> (string.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">1574182249</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"finalize()V"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$finalize$<span class="number">1</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">508378822</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"clone()Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$clone$<span class="number">5</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">346793840</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"doFunc(Ljava/lang/String;)V"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$doFunc$<span class="number">0</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1826985398</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"equals(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$equals$<span class="number">2</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1913648695</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"toString()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$toString$<span class="number">3</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1984935277</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"hashCode()I"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$hashCode$<span class="number">4</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">final</span> Callback[] array) &#123;</span><br><span class="line">        Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$THREAD_CALLBACKS.set(array);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(<span class="keyword">final</span> Callback[] cglib$STATIC_CALLBACKS) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = cglib$STATIC_CALLBACKS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(<span class="keyword">final</span> Object o) &#123;</span><br><span class="line">        <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = (Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab)o;</span><br><span class="line">        <span class="keyword">if</span> (!entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$BOUND) &#123;</span><br><span class="line">            entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object o2;</span><br><span class="line">            <span class="keyword">if</span> ((o2 = Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$THREAD_CALLBACKS.get()) != <span class="keyword">null</span> || (o2 = Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$STATIC_CALLBACKS) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])o2)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Callback[] array)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(array);</span><br><span class="line">        <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = <span class="keyword">new</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">new</span> Callback[] &#123; callback &#125;);</span><br><span class="line">        <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = <span class="keyword">new</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Class[] array, <span class="keyword">final</span> Object[] array2, <span class="keyword">final</span> Callback[] array3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(array3);</span><br><span class="line">        <span class="keyword">switch</span> (array.length) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = <span class="keyword">new</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab();</span><br><span class="line">                CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Constructor not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        Object cglib$CALLBACK_0 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                cglib$CALLBACK_0 = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Callback)cglib$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> n, <span class="keyword">final</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)callback;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[] &#123; <span class="keyword">this</span>.CGLIB$CALLBACK_0 &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(<span class="keyword">final</span> Callback[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑进入到我们在EntrustInterceptor 中定义的intercept方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;before&quot;);</span><br><span class="line">    Object o &#x3D; proxy.invokeSuper(obj,args);</span><br><span class="line">    System.out.println(&quot;after&quot;);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看MethodProxy的invokeSuper方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Invoke the original (super) method on the specified object.</span><br><span class="line">     * @param obj the enhanced object, must be the object passed as the first</span><br><span class="line">     * argument to the MethodInterceptor</span><br><span class="line">     * @param args the arguments passed to the intercepted method; you may substitute a different</span><br><span class="line">     * argument array as long as the types are compatible</span><br><span class="line">     * @see MethodInterceptor#intercept</span><br><span class="line">     * @throws Throwable the bare exceptions thrown by the called method are passed through</span><br><span class="line">     * without wrapping in an &lt;code&gt;InvocationTargetException&lt;&#x2F;code&gt;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            init();</span><br><span class="line">            FastClassInfo fci &#x3D; fastClassInfo;</span><br><span class="line">            &#x2F;&#x2F;f2是由CGlib生成的,在输出的class中有这个类。</span><br><span class="line">            &#x2F;&#x2F;它就是Entrust$$EnhancerByCGLIB$$832e20ab$$FastClassByCGLIB$$817a77c.class</span><br><span class="line">            return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            throw e.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们把</p>
<pre><code>Entrust$$EnhancerByCGLIB$$832e20ab$$FastClassByCGLIB$$817a77c.class</code></pre><p>也反编译出来，然后贴出invoke方法,注意case14调用了</p>
<pre><code>entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$doFunc$0((String)array[0]);：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(final int n, final Object o, final Object[] array) throws InvocationTargetException &#123;</span><br><span class="line">        final Entrust$$EnhancerByCGLIB$$832e20ab entrust$$EnhancerByCGLIB$$832e20ab &#x3D; (Entrust$$EnhancerByCGLIB$$832e20ab)o;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (n) &#123;</span><br><span class="line">                case 0: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.setCallbacks((Callback[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 1: &#123;</span><br><span class="line">                    Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$SET_STATIC_CALLBACKS((Callback[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 2: &#123;</span><br><span class="line">                    Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$SET_THREAD_CALLBACKS((Callback[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 3: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.getCallback(((Number)array[0]).intValue());</span><br><span class="line">                &#125;</span><br><span class="line">                case 4: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.getCallbacks();</span><br><span class="line">                &#125;</span><br><span class="line">                case 5: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.doFunc((String)array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 6: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.setCallback(((Number)array[0]).intValue(), (Callback)array[1]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 7: &#123;</span><br><span class="line">                    return Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$findMethodProxy((Signature)array[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 8: &#123;</span><br><span class="line">                    Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$STATICHOOK1();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 9: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$finalize$1();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 10: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$toString$3();</span><br><span class="line">                &#125;</span><br><span class="line">                case 11: &#123;</span><br><span class="line">                    return new Integer(entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$hashCode$4());</span><br><span class="line">                &#125;</span><br><span class="line">                case 12: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$clone$5();</span><br><span class="line">                &#125;</span><br><span class="line">                case 13: &#123;</span><br><span class="line">                    return new Boolean(entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$equals$2(array[0]));</span><br><span class="line">                &#125;</span><br><span class="line">                case 14: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$doFunc$0((String)array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 15: &#123;</span><br><span class="line">                    return new Boolean(entrust$$EnhancerByCGLIB$$832e20ab.equals(array[0]));</span><br><span class="line">                &#125;</span><br><span class="line">                case 16: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                case 17: &#123;</span><br><span class="line">                    return new Integer(entrust$$EnhancerByCGLIB$$832e20ab.hashCode());</span><br><span class="line">                &#125;</span><br><span class="line">                case 18: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.newInstance((Callback)array[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 19: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.newInstance((Class[])array[0], (Object[])array[1], (Callback[])array[2]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 20: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.newInstance((Callback[])array[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 21: &#123;</span><br><span class="line">                    Entrust.main((String[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 22: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.wait(((Number)array[0]).longValue(), ((Number)array[1]).intValue());</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 23: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.wait(((Number)array[0]).longValue());</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 24: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.wait();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 25: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.getClass();</span><br><span class="line">                &#125;</span><br><span class="line">                case 26: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.notify();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 27: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.notifyAll();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new InvocationTargetException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot find matching method&#x2F;constructor&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>事实证明，最后确实是进入了case14，调用了代理类的代理doFunc方法，最后再回到EntrustInterceptor.invoke中。完成逻辑</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" itemprop="url">ZAB协议分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T16:18:54+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分布式算法&理论</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务和数据一致性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/26/ZAB协议分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ZAB并不是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p>
<h1 id="1-ZAB协议内容"><a href="#1-ZAB协议内容" class="headerlink" title="1 ZAB协议内容"></a>1 ZAB协议内容</h1><ul>
<li>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为leader服务器，而余下的其他服务器则成为follower服务器。</li>
<li>leader服务器负责将一个客户端事务请求转换成一个事务proposal，并将该proposal分发给集群中所有的follower服务器。之后leader服务器需要等待所有follower服务器的反馈，一旦超过半数的follower服务器进行了正确的反馈后，那么leader就会自己先commit这个事务，并再次向所有的follower服务器分发commit消息，要求其将前一个proposal进行提交。</li>
</ul>
<p>ZAB有两种基本的模式：<strong>崩溃恢复</strong>和<strong>消息广播</strong>。</p>
<ul>
<li><p>当整个服务框架启动过程中或Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。</p>
</li>
<li><p>当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式，那么整个服务框架就可以进入消息广播模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够与leader服务器的数据状态保持一致。</p>
</li>
<li><p>Leader选举算法不仅仅需要让Leader自身知道已经被选举为Leader，同时还需要让集群中的所有其他机器也能够快速地感知到选举产生的新的Leader服务器。</p>
</li>
<li><p>当一台同样遵守ZAB协议的服务器启动并加入集群后，如果已经存在leader，那么它会自觉的找到leader，与其进行数据同步，然后一起参与消息广播。</p>
</li>
<li><p>如果follower服务器接收到客户端的事务请求，那么他们会将这个事务请求转发给leader服务器。</p>
</li>
<li><p>当Leader服务器出现崩溃或者机器重启、集群中已经不存在过半的服务器与Leader服务器保持正常通信时，那么在重新开始新的一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此到达一致状态，于是整个ZAB流程就会从消息广播模式进入到崩溃恢复模式。</p>
</li>
<li><p>一个机器要成为leader，要获得过半机器的支持，而由于每台机器都可能崩溃，因此整个过程可能出现多个leader，一个机器也可能多次成为leader。</p>
</li>
</ul>
<h1 id="2-消息广播"><a href="#2-消息广播" class="headerlink" title="2 消息广播"></a>2 消息广播</h1><ul>
<li><p>ZAB协议的消息广播过程使用原子广播协议，类似于一个二阶段提交过程，针对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal，并将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交。</p>
<p>  <img src="https://oscimg.oschina.net/oscnet/ffe6905ecbbad6dd3f977e0ef78de5e1c8e.jpg" alt=""></p>
</li>
<li><p>此处ZAB的二阶段提交和一般的二阶段提交略有不同，ZAB移除了二阶段提交中的事务中断的逻辑，follower服务器要么正常反馈，要么抛弃leader。好处是我们不需要等待所有follower都反馈响应才能提交事务，坏处是集群无法处理leader崩溃而带来的数据不一致的问题。后者需要崩溃恢复模式来解决这个问题。</p>
</li>
<li><p>整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能够很容易保证消息广播过程中消息接受与发送的顺序性。</p>
</li>
<li><p>整个消息广播过程中，Leader服务器会为每个事务生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会先为这个Proposal分配一个全局单调递增的唯一ID，称之为事务ID（ZXID），由于ZAB协议需要保证每个消息严格的因果关系，因此必须将每个事务Proposal按照其ZXID的先后顺序来进行排序和处理。</p>
</li>
<li><p>在广播过程中，leader会为每一个follower分配一个单独的队列，然后将需要广播的事务proposal依次放入，并且根据FIFO策略进行消息发送。每个follower接收到proposal之后，都会首先将其以事务日志的形式写入本地磁盘，写入成功后反馈leader一个ack响应。当leader收到超过半数的follower的ack响应之后，就会广播一个commit消息给所有follower以通知其进行事务提交，同时leader自身也完成事务的提交。每个follower在接收到commit之后，也会完成对事务的提交。</p>
</li>
<li><p>在广播过程中，follower接收到proposal之后记录事务日志失败，或者proposal丢失，而是直接接到了这个proposal的commit，那么follower就会向leader发送请求重新申请这个任务，leader会再次发送proposal和commit。</p>
</li>
</ul>
<h1 id="3-崩溃恢复"><a href="#3-崩溃恢复" class="headerlink" title="3 崩溃恢复"></a>3 崩溃恢复</h1><ul>
<li>当整个服务框架启动过程中或Leader服务器出现网络中断、崩溃退出与重启等异常情况无法与半数以上的follower联系时，ZAB协议就会进入恢复模式。</li>
</ul>
<h2 id="3-1-崩溃恢复下的两种情况和所要保证的特性"><a href="#3-1-崩溃恢复下的两种情况和所要保证的特性" class="headerlink" title="3.1 崩溃恢复下的两种情况和所要保证的特性"></a>3.1 崩溃恢复下的两种情况和所要保证的特性</h2><ol>
<li><p>ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交。</p>
<ul>
<li>如果leader在崩溃前发出了proposal1，proposal2，commit1（proposal1的commit），proposal3，commit2（说明leader自己已经commit了proposal2），那么ZAB需要确保恢复后proposal2在所有服务器上都被提交成功，否则会出现不一致。</li>
</ul>
</li>
<li><p>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务</p>
<ul>
<li>如果leader服务器A在崩溃前发出了proposal1，proposal2，commit1（proposal1的commit），proposal3，commit2，并且执行了commit3（说明leader自己已经commit了proposal3），但是commit3还未发出，leader便宕机了，那么ZAB需要确保恢复后，A重新加入集群（大概率不是leader了）后，要舍弃proposal3这个事务。<h2 id="3-2-进入崩溃恢复模式的流程"><a href="#3-2-进入崩溃恢复模式的流程" class="headerlink" title="3.2 进入崩溃恢复模式的流程"></a>3.2 进入崩溃恢复模式的流程</h2></li>
</ul>
</li>
<li><p>当leader出现问题，zab协议进入崩溃恢复模式，并且选举出新的leader。当新的leader选举出来以后，如果集群中已经有过半机器完成了leader服务器的状态同（数据同步），退出崩溃恢复，进入消息广播模式。</p>
</li>
</ol>
<ol start="2">
<li>当新的机器加入到集群中的时候，如果已经存在leader服务器，那么新加入的服务器就会自觉进入崩溃恢复模式，找到leader进行数据同步。</li>
</ol>
<h3 id="3-2-1-leader选举算法"><a href="#3-2-1-leader选举算法" class="headerlink" title="3.2.1 leader选举算法"></a>3.2.1 leader选举算法</h3><p>在崩溃恢复过程中需要处理的特殊情况，就决定了ZAB协议必须设计这样的</p>
<ul>
<li>能够确保提交已经被Leader提交的事务的Proposal，同时丢弃已经被跳过的事务Proposal。</li>
<li>如果让Leader选举算法能够保证新选举出来的Leader服务器拥有集群所有机器中最高编号（ZXID最大）的事务Proposal，那么就可以保证这个新选举出来的Leader一定具有所有已经提交的更改。</li>
<li>更为重要的是如果让具有最高编号事务的Proposal机器成为Leader，就可以省去Leader服务器查询Proposal的提交和丢弃工作这一步骤了。</li>
</ul>
<h3 id="3-2-2-数据同步"><a href="#3-2-2-数据同步" class="headerlink" title="3.2.2 数据同步"></a>3.2.2 数据同步</h3><ul>
<li>完成Leader选举后，在正式开始工作前，Leader服务器首先会确认日志中的所有Proposal是否都已经被集群中的过半机器提交了，即是否完成了数据同步。</li>
<li>基于上文讲到的两种情况，数据同步会有不同的处理：</li>
</ul>
<hr>
<ul>
<li>同步事务的提交：<ul>
<li>leader为每一个follower都准备一个队列，并将那些没有被各follower同步的事务以proposal消息的形式逐个发送给follower，并在每个proposal消息后面紧跟一个commit消息表示该事务已经被leader提交。等到某个follower同步了所有之前尚未同步的事务并将其成功应用到本地数据库，leader会将该follower加入到可用follower列表中。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>处理丢弃的事务<ul>
<li>下面分析ZAB协议如何处理需要丢弃的事务Proposal的，ZXID是一个64位的数字，其中低32位可以看做是一个简单的单调递增的计数器，针对客户端的每一个事务请求，Leader服务器在产生一个新的事务Proposal时，都会对该计数器进行加1操作；而高32位则代表了Leader周期epoch的编号，每当选举产生一个新的Leader时，就会从这个Leader上取出其本地日志中最大事务Proposal的ZXID，并解析出epoch值，然后加1，之后以该编号作为新的epoch，低32位从0来开始生成新的ZXID。</li>
</ul>
</li>
</ul>
<blockquote>
<p>epoch：可以理解为当前集群所处的年代或者周期，每个 leader 就像皇帝，都有自己的年号，所以每次改朝换代，leader 变更之后，都会在前一个年代的基础上加 1。这样就算旧的 leader 崩溃恢复之后，也没有人听他的了，因为 follower 只听从当前年代的 leader 的命令。</p>
</blockquote>
<pre><code>- ZAB协议通过epoch号来区分Leader周期变化的策略，能够有效地避免不同的Leader服务器错误地使用不同的ZXID编号提出不一样的事务Proposal的异常情况。当一个包含了上一个Leader周期中尚未提交过的事务Proposal的服务器启动时，其肯定无法成为Leader，因为当前集群中一定包含了一个Quorum（过半）集合，该集合中的机器一定包含了更高epoch的事务的Proposal，因此这台机器的事务Proposal并非最高，也就无法成为Leader。

- 当这台机器以follower身份连上leader之后，leader会根据自己最后被提交的proposal来和这台机器的proposal作比较，发现需要舍弃的事务后，leader会要求该台机器进行回滚操作，回滚到某个被半数机器执行的最新的事务版本。</code></pre><h1 id="4-ZAB和paxos的联系和区别"><a href="#4-ZAB和paxos的联系和区别" class="headerlink" title="4 ZAB和paxos的联系和区别"></a>4 ZAB和paxos的联系和区别</h1><h2 id="4-1-联系"><a href="#4-1-联系" class="headerlink" title="4.1 联系"></a>4.1 联系</h2><ol>
<li>都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行。</li>
<li>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提议进行提交。</li>
<li>在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前的Leader周期，在Paxos算法中，同样存在这样的一个标识，名字为Ballot。</li>
</ol>
<h2 id="4-2-区别"><a href="#4-2-区别" class="headerlink" title="4.2 区别"></a>4.2 区别</h2><ol>
<li>Paxos算法中，新选举产生的主进程会进行两个阶段的工作，第一阶段称为读阶段，新的主进程和其他进程通信来收集主进程提出的提议，并将它们提交。第二阶段称为写阶段，当前主进程开始提出自己的提议。</li>
<li>ZAB协议在Paxos基础上添加了同步阶段，此时，新的Leader会确保存在过半的Follower已经提交了之前的Leader周期中的所有事务Proposal。</li>
<li>ZAB协议主要用于构建一个高可用的分布式数据主备系统，而Paxos算法则用于构建一个分布式的一致性状态机系统。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" itemprop="url">一致性hash算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T15:52:16+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">分布式相关</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">负载均衡算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/26/一致性hash算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在解决分布式系统中负载均衡问题的时候，我们可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），进而起到负载均衡的作用。</p>
<p>但是普通的hash取模算法伸缩性很差，当新增或者下线服务器机器时候，用户id与服务器的映射关系会大量失效。这在分布式缓存系统中，是非常严重的问题。</p>
<p>例如我们原先有10台服务器，故而hash取模我们一般会这么算：<code>hash(key)%10</code>，从而得到一个在0-9之间的余数，确定请求由哪个服务器处理。</p>
<p>此时如果我们上线新服务器，或下线旧服务器，都会使服务器数量发生改变，这时候不论是<code>hash(key)%11</code>还是<code>hash(key)%9</code>，都会使近乎所有的key的hash取模结果和原先不一样，进而引发问题。比如缓存场景中的负载均衡，如果遇到这种情况，会使短时间内近乎所有的key失效，进而引发缓存雪崩。</p>
<p>为了解决这个问题，使得分布式系统可以自由且无顾虑的增减服务器，我们引入了一致性hash算法，利用hash环对其原本的hash取模算法进行了改进。</p>
<h1 id="1-一致性hash算法"><a href="#1-一致性hash算法" class="headerlink" title="1 一致性hash算法"></a>1 一致性hash算法</h1><p>一致性哈希算法在1997年由麻省理工学院提出，是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。</p>
<blockquote>
<p>一致性hash算法主要用于解决cache miss问题</p>
</blockquote>
<p>一致性哈希算法是在哈希算法基础上提出的，在动态变化的分布式环境中，哈希算法应该满足的几个条件：</p>
<ol>
<li>平衡性<ul>
<li>是指hash的结果应该平均分配到各个节点，这样从算法上解决了负载均衡问题。</li>
</ul>
</li>
<li>单调性<ul>
<li>是指在新增或者删减节点时，不影响系统正常运行。</li>
</ul>
</li>
<li>分散性<ul>
<li>是指数据应该分散地存放在分布式集群中的各个节点(节点自己可以有备份)，不必每个节点都存储所有的数据。</li>
</ul>
</li>
</ol>
<h2 id="1-1-算法概述"><a href="#1-1-算法概述" class="headerlink" title="1.1 算法概述"></a>1.1 算法概述</h2><p>为了能直观的理解一致性hash原理，这里结合一个简单的例子来讲解，假设有4台服务器，地址为ip1,ip2,ip3,ip4。</p>
<p>一致性hash是首先计算四个ip地址对应的hash值<br><code>hash(ip1),hash(ip2),hash(ip3),hash(ip3)</code>，计算出来的hash值是0~最大正整数（2^32）之间的一个值，这四个值在一致性hash环上呈现如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4391ab6c977b13c200508d135cb099b9d4c.png" alt=""></p>
<p>hash环上顺时针从整数0开始，一直到最大正整数，我们根据四个ip计算的hash值肯定会落到这个hash环上的某一个点，至此我们把服务器的四个ip映射到了一致性hash环。</p>
<p>当用户在客户端进行请求时候，首先根据hash(userId)计算路由规则，然后看hash值落到了hash环的那个地方，根据hash值在hash环上的位置顺时针找距离最近的ip作为路由ip。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b6c08822defde6081f28f35f8b4ce4e036c.png" alt=""></p>
<p>如上图可知，user1和user2由ip2的服务器处理，user3由ip3服务器处理，以此类推</p>
<blockquote>
<p>0~2^32的区间导致了hash值数量远超过服务器数量，使得hash碰撞的概率降到了极低。</p>
</blockquote>
<h2 id="1-2-上线服务器"><a href="#1-2-上线服务器" class="headerlink" title="1.2 上线服务器"></a>1.2 上线服务器</h2><p>当新增一个ip5的服务器后，一致性hash环大致如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-54cd082a9f13300b86d1ca9e36bdf5e299c.png" alt=""></p>
<p>根据顺时针规则可知之前user5的请求应该被ip5服务器处理，现在被新增的ip5服务器处理，其他用户的请求处理服务器不变，也就是说，新增服务器顺时针方向最近的服务器的一部分请求会被新增的服务器所替代。</p>
<h2 id="1-3-下线服务器"><a href="#1-3-下线服务器" class="headerlink" title="1.3 下线服务器"></a>1.3 下线服务器</h2><p>当ip2的服务器挂了的时候，一致性hash环大致如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e65b067374c1bf1d75ff571fe9febd9c152.png" alt=""></p>
<p>根据顺时针规则可知user1,user2的请求会被服务器ip3进行处理，而其它用户的请求对应的处理服务器不变，也就是只有之前被ip2处理的一部分用户的映射关系被破坏了，并且其负责处理的请求被顺时针下一个节点委托处理。</p>
<h1 id="2-一致性hash倾斜问题"><a href="#2-一致性hash倾斜问题" class="headerlink" title="2 一致性hash倾斜问题"></a>2 一致性hash倾斜问题</h1><p>一致性hash可以做到每个服务器都进行处理请求，但是不能保证每个服务器处理的请求的数量大致相同，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-551a6029640f2d81b118bef2dfc03f7ffcf.png" alt=""></p>
<p>服务器ip1,ip2,ip3经过hash后落到了一致性hash环上，从图中hash值分布可知ip1会负责处理大概80%的请求，而ip2和ip3则只会负责处理大概20%的请求，虽然三个机器都在处理请求，但是明显每个机器的负载不均衡，这样称为一致性hash的倾斜，我们可以使用设置虚拟节点的方式解决这个问题。</p>
<h2 id="2-1-设置虚拟节点"><a href="#2-1-设置虚拟节点" class="headerlink" title="2.1 设置虚拟节点"></a>2.1 设置虚拟节点</h2><p>当服务器节点比较少的时候会出现上节所说的一致性hash倾斜的问题，一个解决方法是多加机器，但是加机器是有成本的，那么就加虚拟节点，比如上面三个机器，<strong>每个机器引入1个虚拟节点</strong>后的一致性hash环的图如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-67344339d941bc965c8d5381a4458d36dad.png" alt=""></p>
<p>其中ip1-1是ip1的虚拟节点，ip2-1是ip2的虚拟节点，ip3-1是ip3的虚拟节点。命中ip3-1的请求，则会被导向到ip3服务器。</p>
<p>可知当物理机器数目为M，虚拟节点为N的时候，实际hash环上节点个数为<code>M*N</code>。比如当客户端计算的hash值处于ip2和ip3或者处于ip2-1和ip3-1之间时候使用ip3服务器进行处理。</p>
<blockquote>
<p>当然，我们很难得到一个完美均衡的一致性hash环，但理论上虚拟节点数量的增加，和一致性hash环的均衡性呈正相关。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
</blockquote>
<h1 id="3-一致性hash的优点"><a href="#3-一致性hash的优点" class="headerlink" title="3 一致性hash的优点"></a>3 一致性hash的优点</h1><ol>
<li><p>可扩展性。</p>
<ul>
<li>一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销</li>
</ul>
</li>
<li><p>更好地适应数据的快速增长。</p>
<ul>
<li>采用一致性哈希算法分布数据，当数据不断增长时，部分虚拟节点中可能包含很多数据、造成数据在虚拟节点上分布不均衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二、不需要对全部的数据进行重新哈希和划分。</li>
<li>虚拟节点分裂后，如果物理服务器的负载仍然不均衡，只需在服务器之间调整部分虚拟节点的存储分布。这样可以随数据的增长而动态的扩展物理服务器的数量，且代价远比传统哈希算法重新分布所有数据要小很多</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/Spring-IoC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/15/Spring-IoC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/" itemprop="url">Spring IoC源码详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T23:00:10+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/15/Spring-IoC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/15/Spring-IoC源码详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  15.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  77
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文中，所有spring framework源码，均采用5.0.x版本</p>
</blockquote>
<p>在《Spring IoC概念分析》一文中，我们对Spring IoC的前置概念和整体流程有了一个初步的了解，在本文中，我们会解读源码，力图将spring IoC的逻辑扁平化，可视化。</p>
<h1 id="1-Spring-IoC容器的启动"><a href="#1-Spring-IoC容器的启动" class="headerlink" title="1. Spring IoC容器的启动"></a>1. Spring IoC容器的启动</h1><p>applicationContext是Spring的核心，Context我们通常解释为上下文环境，我想用“容器”来表述它更容易理解一些，ApplicationContext则是“应用的容器”了；在Web应用中，我们会用到WebApplicationContext，WebApplicationContext继承自ApplicationContext；</p>
<p><strong>以企业级java项目最常用的web项目为例</strong>；我们知道，在web项目中，Spring启动是在web.xml配置监听器，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring上下文监听器 --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，ContextLoaderListener类是spring IoC容器启动的核心，也是整个Spring框架的启动入口：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5dc2965cc62b4769c88079950beb40dacf0.png" alt=""></p>
<p>ContextLoaderListener类实现了Tomcat容器的ServletContextListener接口，所以它与普通的Servlet监听是一样的。同样是重写到两个方法：</p>
<ul>
<li>contextInitialized()方法在web容器初始化时执行</li>
<li>contextDestroyed()方法在容器销毁时执行。</li>
</ul>
<p>WEB容器启动时会触发初始化事件，ContextLoaderListener监听到这个事件，其contextInitialized()方法会被调用，在这个方法中Spring会初始化一个root上下文，即WebApplicationContext。</p>
<p>WebApplicationContext是一个接口，其实际默认实现类是XmlWebApplicationContext。（重点关注红色箭头指示的两条继承/实现关系）</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-17ccc43554b5fda2180fb653d0646b31914.png" alt=""></p>
<p>这个就是Spring IOC的容器，其对应bean定义的配置信息由web.xml中的context-param来指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring配置文件路径 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>在ContextLoaderListener类中，只是实现了ServletContextListener提供的到两个方法，Spring启动主要的逻辑在父类ContextLoader的方法initWebApplicationContext实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">	public ContextLoaderListener() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public ContextLoaderListener(WebApplicationContext context) &#123;</span><br><span class="line">		super(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Initialize the root web application context.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void contextInitialized(ServletContextEvent event) &#123;</span><br><span class="line">		initWebApplicationContext(event.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Close the root web application context.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void contextDestroyed(ServletContextEvent event) &#123;</span><br><span class="line">		closeWebApplicationContext(event.getServletContext());</span><br><span class="line">		ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ContextLoaderListener的作用就是启动web容器时自动装配ApplicationContext的配置信息。更细化一点讲，Spring的启动过程其实就是Spring IOC容器的启动过程。</p>
</blockquote>
<h2 id="1-1-ContextLoader剖析"><a href="#1-1-ContextLoader剖析" class="headerlink" title="1.1 ContextLoader剖析"></a>1.1 ContextLoader剖析</h2><p>上文说过，Spring启动主要的逻辑在父类ContextLoader的方法initWebApplicationContext实现。所以我们有必要重点看下ContextLoader类：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2d9116f17f39e0f66409d490c3c00b4aac2.png" alt=""></p>
<p>这里面，最核心的方法是initWebApplicationContext()，它被ContextLoaderListene的contextInitialized()调用，负责spring容器的初始化。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-aa26938c4529a044c005dd5be15ec5f2138.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bf5c4a1709ad4caa111342055031fe6275c.png" alt=""></p>
<blockquote>
<p>注意，该图代码非5.0.x版本，但核心逻辑变化不大，可以参考。</p>
</blockquote>
<h2 id="1-2-Context的生成门面"><a href="#1-2-Context的生成门面" class="headerlink" title="1.2 Context的生成门面"></a>1.2 Context的生成门面</h2><p> 在这个方法中，入参ServletContext是由web容器监听器（ContextLoaderListener）提供。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize Spring's web application context for the given servlet context,</span></span><br><span class="line"><span class="comment"> * using the application context provided at construction time, or creating a new one</span></span><br><span class="line"><span class="comment"> * according to the "&#123;<span class="doctag">@link</span> #CONTEXT_CLASS_PARAM contextClass&#125;" and</span></span><br><span class="line"><span class="comment"> * "&#123;<span class="doctag">@link</span> #CONFIG_LOCATION_PARAM contextConfigLocation&#125;" context-params.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用构造时提供的应用程序上下文，或者根据“ &#123;<span class="doctag">@link</span> #CONTEXT_CLASS_PARAM contextClass&#125;”</span></span><br><span class="line"><span class="comment"> * 和“ &#123;<span class="doctag">@link</span> #CONFIG_LOCATION_PARAM contextConfigLocation&#125;”上下文参数，</span></span><br><span class="line"><span class="comment"> * 为给定的servlet上下文初始化Spring的Web应用程序上下文。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> servletContext current servlet context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new WebApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #ContextLoader(WebApplicationContext)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CONTEXT_CLASS_PARAM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CONFIG_LOCATION_PARAM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	 </span><br><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断给定的ServletContext是否已经存在WebApplicationContext，如果存在则抛出异常。</span></span><br><span class="line">	<span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">"Cannot initialize context because there is already a root application context present - "</span> +</span><br><span class="line">				<span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Log logger = LogFactory.getLog(ContextLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line">		<span class="comment">// it is available on ServletContext shutdown.</span></span><br><span class="line">		<span class="comment">//判断ContextLoader的context属性是否为空，为空表示WebApplicationContext还不存在。</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//不存在则创建WebApplicationContext，该方法也是核心方法，我们后面详解。</span></span><br><span class="line">			<span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//WebApplicationContext默认实现是XmlWebApplicationContext，</span></span><br><span class="line">		<span class="comment">//XmlWebApplicationContext是ConfigurableWebApplicationContext子类</span></span><br><span class="line">		<span class="comment">//所以该判断基本上都是正确的。</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">			ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line">			<span class="keyword">if</span> (!cwac.isActive()) &#123;<span class="comment">//这个context还未执行refresh方法。</span></span><br><span class="line">				<span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">				<span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">				<span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">					<span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">					<span class="comment">//通过loadParentContext()方法为其设置父上下文。</span></span><br><span class="line">					ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">					cwac.setParent(parent);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//通过configureAndRefreshWebApplicationContext为根上下文构建bean工厂和bean对象。</span></span><br><span class="line">				configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将ApplicationContext放入ServletContext中，其key为</span></span><br><span class="line">		<span class="comment">//WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span></span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line">		</span><br><span class="line">		ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (ccl == ContextLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()) </span>&#123;<span class="comment">//如果当前线程的类加载器和ContextLoader类加载器一致</span></span><br><span class="line">			<span class="comment">//那么创建的ApplicationContext赋值给ContextLoader.currentContext</span></span><br><span class="line">			<span class="comment">//即在ContextLoader类被加载的进程中，如果创建了context的话，context赋值currentContext，方便取用</span></span><br><span class="line">			<span class="comment">//而不是放在全局静态常量Map存起来。</span></span><br><span class="line">			currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;<span class="comment">//否则</span></span><br><span class="line">			<span class="comment">//将ApplicationContext放入ContextLoader的全局静态常量Map中</span></span><br><span class="line">			<span class="comment">//其中key为：Thread.currentThread().getContextClassLoader()即当前线程类加载器</span></span><br><span class="line">			<span class="comment">//正常的context创建流程，走这里。</span></span><br><span class="line">			currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +</span><br><span class="line">					WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">			<span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">			logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">		logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">		logger.error(<span class="string">"Context initialization failed"</span>, err);</span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">		<span class="keyword">throw</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归纳一下：</p>
<ul>
<li>首先判断servlectContext中是否已经存在根上下文，如果存在，则抛出异常；</li>
<li>否则通过createWebApplicationContext方法创建新的根上下文。</li>
<li>然后通过loadParentContext()方法为其设置父上下文。</li>
<li>再通过configureAndRefreshWebApplicationContext为根上下文构建bean工厂和bean对象。</li>
<li>最后把上下文存入servletContext，并且存入currentContextPerThread。</li>
<li>至此初始化过程完毕，接下来可以获取WebApplicationContext，进而用getBean(“bean name”)得到bean。</li>
</ul>
<h2 id="1-3-创建Context"><a href="#1-3-创建Context" class="headerlink" title="1.3 创建Context"></a>1.3 创建Context</h2><p>我们刚刚看到，initWebApplicationContext方法主要调用createWebApplicationContext方法来创建上下文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Instantiate the root WebApplicationContext for this loader, either the</span><br><span class="line"> * default context class or a custom context class if specified.</span><br><span class="line"> * &lt;p&gt;This implementation expects custom contexts to implement the</span><br><span class="line"> * &#123;@link ConfigurableWebApplicationContext&#125; interface.</span><br><span class="line"> * Can be overridden in subclasses.</span><br><span class="line"> *</span><br><span class="line"> * 实例化此加载程序的根WebApplicationContext（默认上下文类或自定义上下文类（如果已指定））。</span><br><span class="line"> * &lt;p&gt;此实现期望自定义上下文实现&#123;@link ConfigurableWebApplicationContext&#125;接口。 可以在子类中覆盖。</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;In addition, &#123;@link #customizeContext&#125; gets called prior to refreshing the</span><br><span class="line"> * context, allowing subclasses to perform custom modifications to the context.</span><br><span class="line"> * @param sc current servlet context</span><br><span class="line"> * @return the root WebApplicationContext</span><br><span class="line"> * @see ConfigurableWebApplicationContext</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123;</span><br><span class="line">	&#x2F;&#x2F;从web.xml配置的contextClass参数中获取上下文的实现类，如果contextClass为空，则使用默认的。</span><br><span class="line">	&#x2F;&#x2F;下文有说明  </span><br><span class="line">	Class&lt;?&gt; contextClass &#x3D; determineContextClass(sc);</span><br><span class="line">	&#x2F;&#x2F;根上下文的实现类必须是ConfigurableWebApplicationContext的子类，否则抛出异常</span><br><span class="line">	if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;Custom context class [&quot; + contextClass.getName() +</span><br><span class="line">				&quot;] is not of type [&quot; + ConfigurableWebApplicationContext.class.getName() + &quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;BeanUtils.instantiateClass工具方法，通过反射得到contextClass的构造方法，根据类名创建类</span><br><span class="line">	return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归纳一下：</p>
<ul>
<li>createWebApplicationContext方法使用determineContextClass方法，从web.xml配置的contextClass参数中，获取要创建的context的具体实现类，如果没有指定，则默认使用XmlWebApplicationContext为其实现类。</li>
<li>限制根上下文的实现类必须是ConfigurableWebApplicationContext的子类。</li>
<li>使用BeanUtils.instantiateClass工具方法，根据类名创建类实例。</li>
</ul>
<h2 id="1-4-确定Context实现类"><a href="#1-4-确定Context实现类" class="headerlink" title="1.4 确定Context实现类"></a>1.4 确定Context实现类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Return the WebApplicationContext implementation class to use, either the</span><br><span class="line"> * default XmlWebApplicationContext or a custom context class if specified.</span><br><span class="line"> *</span><br><span class="line"> * 返回要使用的WebApplicationContext实现类，</span><br><span class="line"> * 如果指定，则为自定义上下文类。否则默认为XmlWebApplicationContext</span><br><span class="line"> *</span><br><span class="line"> * @param servletContext current servlet context</span><br><span class="line"> * @return the WebApplicationContext implementation class to use</span><br><span class="line"> * @see #CONTEXT_CLASS_PARAM</span><br><span class="line"> * @see org.springframework.web.context.support.XmlWebApplicationContext</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">	&#x2F;&#x2F;从web.xml获得参数contextClass，在一般的web项目中，此参数为null，即没有指定。</span><br><span class="line">	&#x2F;&#x2F;（spring源生的XmlWebApplicationContext就挺好，没必要重复造轮子）</span><br><span class="line">	String contextClassName &#x3D; servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">	if (contextClassName !&#x3D; null) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;如果指定了，返回类名</span><br><span class="line">			return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Failed to load custom context class [&quot; + contextClassName + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;获得根上下文WebApplicationContext的默认实现类的类名，defaultStrategies是Properties类型，</span><br><span class="line">		&#x2F;&#x2F;在CotnextLoader类开头static语句块中初始化</span><br><span class="line">		&#x2F;&#x2F;获取当前包下面的ContextLoader.properties文件，文件内容是：</span><br><span class="line">		&#x2F;&#x2F;org.springframework.web.context.WebApplicationContext&#x3D;org.springframework.web.context.support.XmlWebApplicationContext</span><br><span class="line">		contextClassName &#x3D; defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class="line">		try &#123;</span><br><span class="line">			return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Failed to load default context class [&quot; + contextClassName + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);方法获取的，就是web.xml中配置指定的IoC容器类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextClass&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>截止到这里为止，WebApplicationContext的实例就已经创建出来了。然后逻辑往下走，到了configureAndRefreshWebApplicationContext(cwac, servletContext)方法，该方法为根上下文构建bean工厂和bean对象。</p>
<h2 id="1-5-配置和刷新Context"><a href="#1-5-配置和刷新Context" class="headerlink" title="1.5 配置和刷新Context"></a>1.5 配置和刷新Context</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123;</span><br><span class="line">	if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">		&#x2F;&#x2F; The application context id is still set to its original default value</span><br><span class="line">		&#x2F;&#x2F; -&gt; assign a more useful id based on available information</span><br><span class="line">		&#x2F;&#x2F;如果web.xml中配置了context的id，那么读取配置的id并使用。</span><br><span class="line">		String idParam &#x3D; sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">		if (idParam !&#x3D; null) &#123;</span><br><span class="line">			wac.setId(idParam);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;如果没有配置context的id，则使用默认的id。</span><br><span class="line">			&#x2F;&#x2F; Generate default id...</span><br><span class="line">			wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">					ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;把ServletContext塞入WebApplicationContext</span><br><span class="line">	wac.setServletContext(sc);</span><br><span class="line">	&#x2F;&#x2F;读取web.xml中的&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;的value值</span><br><span class="line">	&#x2F;&#x2F;获取上下文的配置xml地址和文件名。</span><br><span class="line">	String configLocationParam &#x3D; sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line">	if (configLocationParam !&#x3D; null) &#123;</span><br><span class="line">		wac.setConfigLocation(configLocationParam);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; The wac environment&#39;s #initPropertySources will be called in any case when the context</span><br><span class="line">	&#x2F;&#x2F; is refreshed; do it eagerly here to ensure servlet property sources are in place for</span><br><span class="line">	&#x2F;&#x2F; use in any post-processing or initialization that occurs below prior to #refresh</span><br><span class="line">	ConfigurableEnvironment env &#x3D; wac.getEnvironment();</span><br><span class="line">	if (env instanceof ConfigurableWebEnvironment) &#123;</span><br><span class="line">		((ConfigurableWebEnvironment) env).initPropertySources(sc, null);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;customizeContext方法的功能是：</span><br><span class="line">	&#x2F;&#x2F;对从web.xml的&lt;context-param&gt;中读取globalInitializerClasses和contextInitializerClasses参数</span><br><span class="line">	&#x2F;&#x2F;获取配置的ApplicationContextInitializer实现类，然后对他们的实现类依次回调他们的initialize方法。</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;ApplicationContextInitializer是Spring框架原有的接口，这个接口的主要作用就是</span><br><span class="line">	&#x2F;&#x2F;在ConfigurableApplicationContext类型(或者子类型)的ApplicationContext做refresh之前</span><br><span class="line">	&#x2F;&#x2F;允许我们对ConfiurableApplicationContext的实例做进一步的设置和处理。例如，根据上下文环境注册属性源或激活概要文件。</span><br><span class="line">	&#x2F;&#x2F;ApplicationContextInitializer支持Order注解，表示执行顺序，越小越早执行；</span><br><span class="line">	customizeContext(sc, wac);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;核心代码，开始容器的初始化</span><br><span class="line">	wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);方法获取的，就是web.xml中配置指定的IoC容器配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring配置文件路径 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，容器的初始化逻辑，都在wac.refresh();中。</p>
<h2 id="1-6-阶段性流程图"><a href="#1-6-阶段性流程图" class="headerlink" title="1.6 阶段性流程图"></a>1.6 阶段性流程图</h2><p><img src="https://oscimg.oschina.net/oscnet/up-8553a091ba36acb65cfef255e27192f896f.png" alt=""></p>
<h1 id="2-refresh-核心方法"><a href="#2-refresh-核心方法" class="headerlink" title="2 refresh()核心方法"></a>2 refresh()核心方法</h1><p>我们之前说过，WebApplicationContext方法的默认实现是XmlWebApplicationContext，而XmlWebApplicationContext的refresh()方法，继承自它的父类AbstractApplicationContext。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">	synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">		&#x2F;&#x2F; Prepare this context for refreshing.</span><br><span class="line">		&#x2F;&#x2F;刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等，同时给容器设置同步标识</span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Tell the subclass to refresh the internal bean factory.</span><br><span class="line">		&#x2F;&#x2F;该方法调用链路，会启动Bean定义资源文件的载入方法loadBeanDefinitions方法</span><br><span class="line">		&#x2F;&#x2F;值得下文讨论。</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Prepare the bean factory for use in this context.</span><br><span class="line">		&#x2F;&#x2F;为BeanFactory配置容器特性，例如类加载器、事件处理器等</span><br><span class="line">		&#x2F;&#x2F;还是一些准备工作，添加了两个后置处理器：ApplicationContextAwareProcessor，ApplicationListenerDetector</span><br><span class="line">		&#x2F;&#x2F;还设置了 忽略自动装配 和 允许自动装配 的接口，如果不存在某个bean的时候，spring就自动注册singleton bean</span><br><span class="line">		&#x2F;&#x2F;还设置了bean表达式解析器 等</span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">			&#x2F;&#x2F;这是一个空方法，给子类继承用，执行自定义的BeanPost事件</span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Invoke factory processors registered as beans in the context.</span><br><span class="line">			&#x2F;&#x2F;调用所有注册的BeanFactoryPostProcessor的Bean</span><br><span class="line">			&#x2F;&#x2F;执行自定义的BeanFactoryProcessor和内置的BeanFactoryProcessor</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Register bean processors that intercept bean creation.</span><br><span class="line">			&#x2F;&#x2F; 注册BeanPostProcessor</span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Initialize message source for this context.</span><br><span class="line">			&#x2F;&#x2F;初始化信息源，和国际化相关.</span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Initialize event multicaster for this context.</span><br><span class="line">			&#x2F;&#x2F;初始化容器事件传播器.</span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Initialize other special beans in specific context subclasses.</span><br><span class="line">			&#x2F;&#x2F; 空方法，给子类做定制</span><br><span class="line">			&#x2F;&#x2F;调用子类的某些特殊Bean初始化方法</span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Check for listener beans and register them.</span><br><span class="line">			&#x2F;&#x2F;为事件传播器注册事件监听器.</span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">			&#x2F;&#x2F;初始化所有剩余的，非懒加载的单例Bean</span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Last step: publish corresponding event.</span><br><span class="line">			&#x2F;&#x2F;初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">						&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">			&#x2F;&#x2F;销毁已创建的Bean</span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">			&#x2F;&#x2F;取消refresh操作，重置容器的同步标识。</span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Propagate exception to caller.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		finally &#123;</span><br><span class="line">			&#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">			&#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">			&#x2F;&#x2F;重设公共缓存</span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-加载xml文件的beanDefinition"><a href="#3-加载xml文件的beanDefinition" class="headerlink" title="3 加载xml文件的beanDefinition"></a>3 加载xml文件的beanDefinition</h1><p>refresh()方法调用了obtainFreshBeanFactory()方法，在这个方法中，会发起IoC容器对配置文件的读取，并将其加载为beanDefinition，不过在了解beanDefinition加载过程之前，我们有需要了解一些前置知识点。</p>
<h2 id="3-1-Resource资源文件框架"><a href="#3-1-Resource资源文件框架" class="headerlink" title="3.1 Resource资源文件框架"></a>3.1 Resource资源文件框架</h2><p>详见文章本博客《Spring Resource资源文件体系》；</p>
<h2 id="3-2-加载前的准备工作"><a href="#3-2-加载前的准备工作" class="headerlink" title="3.2 加载前的准备工作"></a>3.2 加载前的准备工作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * 让子类refresh内部bean工厂。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//核心方法在这，拆开看看</span></span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refreshBeanFactory()方法的实现在AbstractRefreshableApplicationContext类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * This implementation performs an actual refresh of this context&#39;s underlying</span><br><span class="line"> * bean factory, shutting down the previous bean factory (if any) and</span><br><span class="line"> * initializing a fresh bean factory for the next phase of the context&#39;s lifecycle.</span><br><span class="line"> * 此实现对该上下文的基础bean工厂执行实际的刷新，</span><br><span class="line"> * 关闭前一个bean工厂（如果有），并为上下文生命周期的下一阶段初始化一个新的bean工厂。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">	if (hasBeanFactory()) &#123;&#x2F;&#x2F;关闭前一个bean工厂（如果有）</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;初始化一个新的bean工厂</span><br><span class="line">		DefaultListableBeanFactory beanFactory &#x3D; createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		&#x2F;&#x2F;加载BeanDefinitions，核心方法，加载配置信息</span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">			this.beanFactory &#x3D; beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;I&#x2F;O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-设置和获取Reader工具类"><a href="#3-3-设置和获取Reader工具类" class="headerlink" title="3.3 设置和获取Reader工具类"></a>3.3 设置和获取Reader工具类</h2><p>前文说过，XmlWebApplicationContext类是默认的Context类，所以默认情况下，loadBeanDefinitions(DefaultListableBeanFactory)调用的是XmlWebApplicationContext类中实现的loadBeanDefinitions(DefaultListableBeanFactory);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">	&#x2F;&#x2F; Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">	&#x2F;&#x2F;初始化XmlBeanDefinitionReader，Reader是将配置文件转为beanDefinition文件的主要工具类。</span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader &#x3D; new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Configure the bean definition reader with this context&#39;s</span><br><span class="line">	&#x2F;&#x2F; resource loading environment.</span><br><span class="line">	beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">	&#x2F;&#x2F;注意这里，将this，也就是XmlWebApplicationContext本身，作为XmlBeanDefinitionReader的ResourceLoader。</span><br><span class="line">	&#x2F;&#x2F;XmlWebApplicationContext是实现了ResourceLoader接口的，并且它是ResourcePatternResolver接口的子类。</span><br><span class="line">	beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">	&#x2F;&#x2F; then proceed with actually loading the bean definitions.</span><br><span class="line">	&#x2F;&#x2F;空方法，给自定义的context类一个变更Reader类的回调机会</span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	&#x2F;&#x2F;核心方法，继续往下看</span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadBeanDefinitions(beanDefinitionReader)方法调用的是loadBeanDefinitions(XmlBeanDefinitionReader)方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load the bean definitions with the given XmlBeanDefinitionReader.</span><br><span class="line"> * &lt;p&gt;The lifecycle of the bean factory is handled by the refreshBeanFactory method;</span><br><span class="line"> * therefore this method is just supposed to load and&#x2F;or register bean definitions.</span><br><span class="line"> * &lt;p&gt;Delegates to a ResourcePatternResolver for resolving location patterns</span><br><span class="line"> * into Resource instances.</span><br><span class="line"> </span><br><span class="line"> * 使用给定的XmlBeanDefinitionReader加载Bean定义。beanFactory的生命周期由refreshBeanFactory方法处理；</span><br><span class="line"> * 因此该方法仅应加载 或 注册Bean定义。委托ResourcePatternResolver将位置模式解析为Resource实例。</span><br><span class="line"> </span><br><span class="line"> * @throws IOException if the required XML document isn&#39;t found</span><br><span class="line"> * @see #refreshBeanFactory</span><br><span class="line"> * @see #getConfigLocations</span><br><span class="line"> * @see #getResources</span><br><span class="line"> * @see #getResourcePatternResolver</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws IOException &#123;</span><br><span class="line">	&#x2F;&#x2F;获取web.xml配置的configLocations，即配置文件的路径</span><br><span class="line">	String[] configLocations &#x3D; getConfigLocations();</span><br><span class="line">	if (configLocations !&#x3D; null) &#123;</span><br><span class="line">		for (String configLocation : configLocations) &#123;</span><br><span class="line">			&#x2F;&#x2F;遍历得到的configLocation路径，依次调用reader的loadBeanDefinitions方法解析每个路径</span><br><span class="line">			reader.loadBeanDefinitions(configLocation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-通配-完整路径解析策略"><a href="#3-4-通配-完整路径解析策略" class="headerlink" title="3.4 通配/完整路径解析策略"></a>3.4 通配/完整路径解析策略</h2><p>核心逻辑又进入了reader.loadBeanDefinitions(configLocation)方法，这个方法，XmlBeanDefinitionReader自己没有实现，是继承自AbstractBeanDefinitionReader的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load bean definitions from the specified resource location.</span><br><span class="line"> * &lt;p&gt;The location can also be a location pattern, provided that the</span><br><span class="line"> * ResourceLoader of this bean definition reader is a ResourcePatternResolver.</span><br><span class="line"> * @param location the resource location, to be loaded with the ResourceLoader</span><br><span class="line"> * (or ResourcePatternResolver) of this bean definition reader</span><br><span class="line"> * @param actualResources a Set to be filled with the actual Resource objects</span><br><span class="line"> * that have been resolved during the loading process. May be &#123;@code null&#125;</span><br><span class="line"> * to indicate that the caller is not interested in those Resource objects.</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> * @see #getResourceLoader()</span><br><span class="line"> * @see #loadBeanDefinitions(org.springframework.core.io.Resource)</span><br><span class="line"> * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) </span><br><span class="line">	throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F;获取ResourceLoader，ResourceLoader是用来确定location用哪种resource策略的逻辑封装。</span><br><span class="line">	&#x2F;&#x2F;当前类XmlBeanDefinitionReader，在XmlWebApplicationContext类的loadBeanDefinitions(DefaultListableBeanFactory)方法中</span><br><span class="line">	&#x2F;&#x2F;就已经指定了XmlBeanDefinitionReader的ResourceLoader。</span><br><span class="line">	&#x2F;&#x2F;XmlBeanDefinitionReader的ResourceLoader就是XmlWebApplicationContext</span><br><span class="line">	ResourceLoader resourceLoader &#x3D; getResourceLoader();</span><br><span class="line">	if (resourceLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;Cannot import bean definitions from location [&quot; + location + &quot;]: </span><br><span class="line">					no ResourceLoader available&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果该reader注入的ResourceLoader是ResourcePatternResolver的子类。</span><br><span class="line">	&#x2F;&#x2F;也就是支持解析配置路径是通配符形式的location。</span><br><span class="line">	&#x2F;&#x2F;在web应用场景中，ResourceLoader已经指定了是XmlWebApplicationContext</span><br><span class="line">	&#x2F;&#x2F;而XmlWebApplicationContext是ResourcePatternResolver的子类，所以判断必然为真</span><br><span class="line">	if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">		&#x2F;&#x2F; Resource pattern matching available.</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;那么，一个带通配符的路径，是可能返回多个Resource的</span><br><span class="line">			Resource[] resources &#x3D; ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">			int loadCount &#x3D; loadBeanDefinitions(resources);</span><br><span class="line">			if (actualResources !&#x3D; null) &#123;</span><br><span class="line">				for (Resource resource : resources) &#123;</span><br><span class="line">					actualResources.add(resource);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions </span><br><span class="line">					from location pattern [&quot; + location + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return loadCount;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(</span><br><span class="line">					&quot;Could not resolve bean definition resource </span><br><span class="line">						pattern [&quot; + location + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Can only load single resources by absolute URL.</span><br><span class="line">		&#x2F;&#x2F;否则，则l该reader注入的ResourceLoader只支持解析配置路径是完整路径形式</span><br><span class="line">		&#x2F;&#x2F;那么一个绝对路径，只会取回来一个resource</span><br><span class="line">		Resource resource &#x3D; resourceLoader.getResource(location);</span><br><span class="line">		int loadCount &#x3D; loadBeanDefinitions(resource);</span><br><span class="line">		if (actualResources !&#x3D; null) &#123;</span><br><span class="line">			actualResources.add(resource);</span><br><span class="line">		&#125;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions </span><br><span class="line">				from location [&quot; + location + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return loadCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的两个分支，即<strong>resourceLoader支持解析location为通配符形式的</strong>和<strong>resourceLoader支持解析location为完整路径形式的</strong>，二者分别调用了：</p>
<ol>
<li>resourceLoader支持解析location为通配符形式的<ul>
<li>PathMatchingResourcePatternResolver#getResources(String locationPattern)</li>
<li>AbstractBeanDefinitionReader#loadBeanDefinitions(Resource… resources)方法</li>
</ul>
</li>
<li>resourceLoader支持解析location为完整路径形式的<ul>
<li>DefaultResourceLoader#getResources(String locationPattern)</li>
<li>XmlBeanDefinitionReader#loadBeanDefinitions(Resource resource)</li>
</ul>
</li>
</ol>
<p>而AbstractBeanDefinitionReader#loadBeanDefinitions(Resource… resources)方法的逻辑很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(resources, &quot;Resource array must not be null&quot;);</span><br><span class="line">	int counter &#x3D; 0;</span><br><span class="line">	for (Resource resource : resources) &#123;</span><br><span class="line">		&#x2F;&#x2F;遍历Resource，依次调用loadBeanDefinitions(Resource resource)</span><br><span class="line">		counter +&#x3D; loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后殊途同归，最后都是落在了XmlBeanDefinitionReader#loadBeanDefinitions(Resource resource)方法上。</p>
<h2 id="3-5-编码设置和循环依赖检测"><a href="#3-5-编码设置和循环依赖检测" class="headerlink" title="3.5 编码设置和循环依赖检测"></a>3.5 编码设置和循环依赖检测</h2><p>XmlBeanDefinitionReader的loadBeanDefinitions(Resource resource)重写方法，主要就是加载xml文件配置的beanDefinition：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load bean definitions from the specified XML file.</span><br><span class="line"> * @param resource the resource descriptor for the XML file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F;对传进来的Resource又进行了一次封装，变成了编码后的Resource</span><br><span class="line">	return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，resource在这里被封装为了EncodedResource，我们继续往下看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load bean definitions from the specified XML file.</span><br><span class="line"> * @param encodedResource the resource descriptor for the XML file,</span><br><span class="line"> * allowing to specify an encoding to use for parsing the file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">	if (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;resourcesCurrentlyBeingLoaded是一个ThreadLocal，里面存放Resource包装类EncodedResource的set集合</span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources &#x3D; this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	if (currentResources &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果set不存在，new一个</span><br><span class="line">		currentResources &#x3D; new HashSet&lt;&gt;(4);</span><br><span class="line">		this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果set中已有这个元素则返回false，进入该条件抛出异常</span><br><span class="line">	if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		&#x2F;&#x2F;只有当前线程重复加载了某个资源，这里才会抛出异常</span><br><span class="line">		&#x2F;&#x2F;用来检测是否循环加载某个Resource，如果是，提醒需要检查导入的definitions</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;获取封装的InputStream</span><br><span class="line">		InputStream inputStream &#x3D; encodedResource.getResource().getInputStream();</span><br><span class="line">		try &#123;</span><br><span class="line">			InputSource inputSource &#x3D; new InputSource(inputStream);</span><br><span class="line">			&#x2F;&#x2F;没有设置编码集，跳过</span><br><span class="line">			if (encodedResource.getEncoding() !&#x3D; null) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		if (currentResources.isEmpty()) &#123;</span><br><span class="line">			this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，核心逻辑，又进入了doLoadBeanDefinitions方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Actually load bean definitions from the specified XML file.</span><br><span class="line"> * @param inputSource the SAX InputSource to read from</span><br><span class="line"> * @param resource the resource descriptor for the XML file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> * @see #doLoadDocument</span><br><span class="line"> * @see #registerBeanDefinitions</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;根据不同的xml约束（dtd，xsd等），将xml文件生成对应的文档对象</span><br><span class="line">		&#x2F;&#x2F;这个方法里面涉及xml的解析，不赘述，简单来说：</span><br><span class="line">		&#x2F;&#x2F;检测解析传入的xml文件（也就是resource）时该用哪种验证方式</span><br><span class="line">		&#x2F;&#x2F;如果这个文件有DOCTYPE声明，那么就用DTD验证，否则就使用XSD验证模式。</span><br><span class="line">		&#x2F;&#x2F;使用标准JAXP配置XML解析器，加载InputSource的Document对象，然后返回一个新的DOM对象</span><br><span class="line">		&#x2F;&#x2F;注意，这个Document对象，是W3C定义的标准XML对象，跟spring无关。</span><br><span class="line">		Document doc &#x3D; doLoadDocument(inputSource, resource);</span><br><span class="line">		&#x2F;&#x2F;核心方法，beanDefinitions的注册</span><br><span class="line">		return registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXParseException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ParserConfigurationException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Parser configuration exception parsing XML from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Unexpected exception parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，两个核心方法，doLoadDocument和registerBeanDefinitions方法，前者负责解析xml文件，后者负责注册BeanDefinitions，我们分别来分析。先看doLoadDocument()方法</p>
<h2 id="3-6-解析XML文件"><a href="#3-6-解析XML文件" class="headerlink" title="3.6 解析XML文件"></a>3.6 解析XML文件</h2><p>此方法在XmlBeanDefinitionReader类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Actually load the specified document using the configured DocumentLoader.</span><br><span class="line">* @param inputSource the SAX InputSource to read from --从中读取的SAX输入源</span><br><span class="line">* @param resource the resource descriptor for the XML file --xml文件的资源描述符</span><br><span class="line">* @return the DOM Document DOM文档对象</span><br><span class="line">* </span><br><span class="line">* 使用配置好的DocumentLoader文档加载器加载指定的文档</span><br><span class="line">*&#x2F;</span><br><span class="line">protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123;</span><br><span class="line">	return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,</span><br><span class="line">											getValidationModeForResource(resource), isNamespaceAware());</span><br></pre></td></tr></table></figure>
<h3 id="3-6-1-参数1"><a href="#3-6-1-参数1" class="headerlink" title="3.6.1 参数1"></a>3.6.1 参数1</h3><p>上文中的getEntityResolver() 方法返回 XmlBeanDefinitionReader 类的 entityResolver 属性。</p>
<p>entityResolver 属性在 loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 方法中被赋值。</p>
<p><code>beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</code></p>
<p>和resourceLoader一样，this拿的是XmlWebApplicationContext实例，我们再来看下ResourceEntityResolver的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Create a ResourceEntityResolver for the specified ResourceLoader</span><br><span class="line">* (usually, an ApplicationContext).</span><br><span class="line">* @param resourceLoader the ResourceLoader (or ApplicationContext)</span><br><span class="line">* to load XML entity includes with</span><br><span class="line">*</span><br><span class="line">* 为指定的ResourceLoade（通常是应用上下文）r创建一个ResourceEntityResolver</span><br><span class="line">*&#x2F;</span><br><span class="line">public ResourceEntityResolver(ResourceLoader resourceLoader) &#123;</span><br><span class="line">    super(resourceLoader.getClassLoader());</span><br><span class="line">    &#x2F;&#x2F;此处解析器拿到了上下文的引用</span><br><span class="line">    this.resourceLoader &#x3D; resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了父类构造，再跟进一层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Create a new DelegatingEntityResolver that delegates to</span><br><span class="line">* a default &#123;@link BeansDtdResolver&#125; and a default &#123;@link PluggableSchemaResolver&#125;.</span><br><span class="line">* &lt;p&gt;Configures the &#123;@link PluggableSchemaResolver&#125; with the supplied</span><br><span class="line">* &#123;@link ClassLoader&#125;.</span><br><span class="line">* @param classLoader the ClassLoader to use for loading</span><br><span class="line">* (can be &#123;@code null&#125;) to use the default ClassLoader)</span><br><span class="line">*&#x2F;</span><br><span class="line">public DelegatingEntityResolver(ClassLoader classLoader) &#123;</span><br><span class="line">    &#x2F;&#x2F;这两个解析器和约束的类型有关，DTD</span><br><span class="line">    this.dtdResolver &#x3D; new BeansDtdResolver();</span><br><span class="line">    &#x2F;&#x2F;可插拔的Schema解析器，拿的上下文的类加载器</span><br><span class="line">    this.schemaResolver &#x3D; new PluggableSchemaResolver(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间的this.errorHandler参数可忽略。</p>
<h3 id="3-6-2-参数2"><a href="#3-6-2-参数2" class="headerlink" title="3.6.2 参数2"></a>3.6.2 参数2</h3><p>ok，然后是getValidationModeForResource(resource)入参。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Gets the validation mode for the specified &#123;@link Resource&#125;. If no explicit</span><br><span class="line">* validation mode has been configured then the validation mode is</span><br><span class="line">* &#123;@link #detectValidationMode detected&#125;.</span><br><span class="line">* &lt;p&gt;Override this method if you would like full control over the validation</span><br><span class="line">* mode, even when something other than &#123;@link #VALIDATION_AUTO&#125; was set.</span><br><span class="line">* </span><br><span class="line">* 通过给定Resource给出验证模式。如果没有明确配置验证模式，那么调用detectValidationMode方法去检测。</span><br><span class="line">*&#x2F;</span><br><span class="line">protected int getValidationModeForResource(Resource resource) &#123;</span><br><span class="line">    &#x2F;&#x2F;默认自动验证，为1</span><br><span class="line">    int validationModeToUse &#x3D; getValidationMode();</span><br><span class="line">    &#x2F;&#x2F;如果有给出具体验证方式，则返回结果</span><br><span class="line">    if (validationModeToUse !&#x3D; VALIDATION_AUTO) &#123;</span><br><span class="line">        return validationModeToUse;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;检测验证模式，进入这个方法</span><br><span class="line">    int detectedMode &#x3D; detectValidationMode(resource);</span><br><span class="line">    if (detectedMode !&#x3D; VALIDATION_AUTO) &#123;</span><br><span class="line">        return detectedMode;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Hmm, we didn&#39;t get a clear indication... Let&#39;s assume XSD,</span><br><span class="line">    &#x2F;&#x2F; since apparently no DTD declaration has been found up until</span><br><span class="line">    &#x2F;&#x2F; detection stopped (before finding the document&#39;s root tag).</span><br><span class="line">    &#x2F;&#x2F; 如果实在不能判断验证模式是那种就使用XSD方式，</span><br><span class="line">    &#x2F;&#x2F; 因为检测完后还是没有发现DTD模式的声明（在查找document的根标签之前)。</span><br><span class="line">    &#x2F;&#x2F; 值为3</span><br><span class="line">    return VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getValidationModeForResource的核心方法是detectValidationMode()，我们继续：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Detects which kind of validation to perform on the XML file identified</span><br><span class="line">* by the supplied &#123;@link Resource&#125;. If the file has a &#123;@code DOCTYPE&#125;</span><br><span class="line">* definition then DTD validation is used otherwise XSD validation is assumed.</span><br><span class="line">* &lt;p&gt;Override this method if you would like to customize resolution</span><br><span class="line">* of the &#123;@link #VALIDATION_AUTO&#125; mode.</span><br><span class="line">* </span><br><span class="line">* 检测执行xml文件时该用哪种验证方式，这个xml由Resource对象提供</span><br><span class="line">* 如果这个文件有DOCTYPE声明，那么就用DTD验证，否则就默认使用XSD。</span><br><span class="line">* 如果你想要自定义自动验证模式的解决方式，你可以覆盖这个方法</span><br><span class="line">*&#x2F;</span><br><span class="line">protected int detectValidationMode(Resource resource) &#123;</span><br><span class="line">    &#x2F;&#x2F;默认false</span><br><span class="line">    if (resource.isOpen()) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;Passed-in Resource [&quot; + resource + &quot;] contains an open stream: &quot; +</span><br><span class="line">            &quot;cannot determine validation mode automatically. Either pass in a Resource &quot; +</span><br><span class="line">            &quot;that is able to create fresh streams, or explicitly specify the validationMode &quot; +</span><br><span class="line">            &quot;on your XmlBeanDefinitionReader instance.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    InputStream inputStream;</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream &#x3D; resource.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;Unable to determine validation mode for [&quot; + resource + &quot;]: cannot open InputStream. &quot; +</span><br><span class="line">            &quot;Did you attempt to load directly from a SAX InputSource without specifying the &quot; +</span><br><span class="line">            &quot;validationMode on your XmlBeanDefinitionReader instance?&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;XmlBeanDefinitionReader的validationModeDetector属性有默认实现XmlValidationModeDetector</span><br><span class="line">        &#x2F;&#x2F;核心方法，接下来进入这个方法看下</span><br><span class="line">        return this.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(&quot;Unable to determine validation mode for [&quot; +</span><br><span class="line">                                               resource + &quot;]: an error occurred whilst reading from the InputStream.&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以来看validationModeDetector调用的detectValidationMode方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Detect the validation mode for the XML document in the supplied &#123;@link InputStream&#125;.</span><br><span class="line">* Note that the supplied &#123;@link InputStream&#125; is closed by this method before returning.</span><br><span class="line">* </span><br><span class="line">* 在提供的InputStream中检测XML文档的验证模式</span><br><span class="line">* 注意，提供的InputStream在这个方法return之前会被关闭</span><br><span class="line">*&#x2F;</span><br><span class="line">public int detectValidationMode(InputStream inputStream) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Peek into the file to look for DOCTYPE.</span><br><span class="line">    &#x2F;&#x2F; 查找文件的DOCTYPE</span><br><span class="line">    BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean isDtdValidated &#x3D; false;</span><br><span class="line">        String content;</span><br><span class="line">        while ((content &#x3D; reader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;读一行字符串就干掉字符串里面的注释，如果全是注释全干掉</span><br><span class="line">            &#x2F;&#x2F;主要为了剥离注释，因为非注释内容要么是DOCTYPE声明要么是文档的根元素对象</span><br><span class="line">            content &#x3D; consumeCommentTokens(content);</span><br><span class="line">            &#x2F;&#x2F;剥离注释后完全没内容就继续循环</span><br><span class="line">            if (this.inComment || !StringUtils.hasText(content)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;有DOCTYPE声明，就跳出去</span><br><span class="line">            if (hasDoctype(content)) &#123;</span><br><span class="line">                isDtdValidated &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;注释不能进去。开头是&quot;&lt;&quot;,后面第一个字符是字母，就进入。</span><br><span class="line">            &#x2F;&#x2F;比如&#39;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;&#39;</span><br><span class="line">            &#x2F;&#x2F;进去后跳出循环</span><br><span class="line">            if (hasOpeningTag(content)) &#123;</span><br><span class="line">                &#x2F;&#x2F; End of meaningful data...</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当遍历到名称空间了也就是&quot;&lt;beans xmlns&#x3D;...&gt;&quot;还没有DOCTYPE声明，</span><br><span class="line">        &#x2F;&#x2F;那么就判定他为XSD验证</span><br><span class="line">        return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CharConversionException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; Choked on some character encoding...</span><br><span class="line">        &#x2F;&#x2F; Leave the decision up to the caller.</span><br><span class="line">        return VALIDATION_AUTO;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        &#x2F;&#x2F;关流</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-3-解析的核心逻辑"><a href="#3-6-3-解析的核心逻辑" class="headerlink" title="3.6.3 解析的核心逻辑"></a>3.6.3 解析的核心逻辑</h3><p>讲完核心的两个入参后进入正主，loadDocument方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,</span><br><span class="line">				getValidationModeForResource(resource), isNamespaceAware());</span><br></pre></td></tr></table></figure>
<p>documentLoader属性的默认实现是DefaultDocumentLoader；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Load the &#123;@link Document&#125; at the supplied &#123;@link InputSource&#125; using the standard JAXP-configured</span><br><span class="line">* XML parser.</span><br><span class="line">*</span><br><span class="line">* 使用标准JAXP配置XML解析器加载InputSource的Document对象</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,</span><br><span class="line">                             ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建文档构建器工厂对象，并初始化一些属性</span><br><span class="line">    &#x2F;&#x2F;如果验证模式为XSD，那么强制支持XML名称空间，并加上schema属性</span><br><span class="line">    DocumentBuilderFactory factory &#x3D; createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个JAXP文档构建器</span><br><span class="line">    DocumentBuilder builder &#x3D; createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;按照XML文档解析给定inputSource的内容，然后返回一个新的DOM对象</span><br><span class="line">    return builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步，DocumentBuilder的默认实现是DocumentBuilderImpl，这个是jdk里面的xml解析器了，不再赘述。</p>
<p>至此，我们拿到了Document对象</p>
<h2 id="3-7-准备注册BeanDefinitions"><a href="#3-7-准备注册BeanDefinitions" class="headerlink" title="3.7 准备注册BeanDefinitions"></a>3.7 准备注册BeanDefinitions</h2><p>两个核心方法，看完了doLoadDocument方法，我们再来看registerBeanDefinitions方法，后者负责注册BeanDefinitions，我们分别来分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Register the bean definitions contained in the given DOM document.</span><br><span class="line"> * Called by &#123;@code loadBeanDefinitions&#125;.</span><br><span class="line"> * &lt;p&gt;Creates a new instance of the parser class and invokes</span><br><span class="line"> * &#123;@code registerBeanDefinitions&#125; on it.</span><br><span class="line"> * 注册包含在给定DOM文档中的bean定义。由&#123;@code loadBeanDefinitions&#125;调用。&lt;p&gt;创建解析器类的新实例，并在其上调用&#123;@code registerBeanDefinitions&#125;。</span><br><span class="line"> *</span><br><span class="line"> * 注册包含在给定DOM文档对象中的 bean definition</span><br><span class="line"> * 被loadBeanDefinitions方法所调用</span><br><span class="line"> * 解析class后创建一个新的实例，并调用registerBeanDefinitions方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F;其实就是new了一个DefaultBeanDefinitionDocumentReader工具类。</span><br><span class="line">	BeanDefinitionDocumentReader documentReader &#x3D; createBeanDefinitionDocumentReader();</span><br><span class="line">	&#x2F;&#x2F;getRegistry()方法拿的是bean工厂对象，beanDefinition注册在工厂中</span><br><span class="line">	&#x2F;&#x2F;这个方法就是返回已经被注册在工厂中的beanDefinitions数量</span><br><span class="line">	int countBefore &#x3D; getRegistry().getBeanDefinitionCount();</span><br><span class="line">	&#x2F;&#x2F;核心方法</span><br><span class="line">	&#x2F;&#x2F;createReaderContext创建了XmlReaderContext对象</span><br><span class="line">	&#x2F;&#x2F;XmlReaderContext对象是BeanDefinition读取过程中传递的上下文，封装相关的的配置和状态</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	&#x2F;&#x2F;返回上文这个核心方法真正注册在工厂中的beanDefinition数量</span><br><span class="line">	return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心方法documentReader.registerBeanDefinitions实现在DefaultBeanDefinitionDocumentReader类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 这个方法在刚创建的DefaultBeanDefinitionDocumentReader中</span><br><span class="line">*</span><br><span class="line">* This implementation parses bean definitions according to the &quot;spring-beans&quot; XSD</span><br><span class="line">* (or DTD, historically).</span><br><span class="line">* &lt;p&gt;Opens a DOM Document; then initializes the default settings</span><br><span class="line">* specified at the &#123;@code &lt;beans&#x2F;&gt;&#125; level; then parses the contained bean definitions.</span><br><span class="line">*</span><br><span class="line">* 根据“spring-beans&quot;的XSD（或者DTD）去解析bean definition</span><br><span class="line">* 打开一个DOM文档，然后初始化在&lt;beans&#x2F;&gt;层级上指定的默认设置，然后解析包含在其中的bean definitions</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">	&#x2F;&#x2F;入参时创建的XmlReaderContext对象</span><br><span class="line">	this.readerContext &#x3D; readerContext;</span><br><span class="line">	logger.debug(&quot;Loading bean definitions&quot;);</span><br><span class="line">	&#x2F;&#x2F;拿到了xml文档对象的根元素</span><br><span class="line">	Element root &#x3D; doc.getDocumentElement();</span><br><span class="line">	&#x2F;&#x2F;进入这个方法进行查看</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看DefaultBeanDefinitionDocumentReader类的doRegisterBeanDefinitions方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Register each bean definition within the given root &#123;@code &lt;beans&#x2F;&gt;&#125; element.</span><br><span class="line">*</span><br><span class="line">* 从&lt;beans &#x2F;&gt;配置中注册每一个bean，如果有嵌套的beans，那么递归执行这个方法。</span><br><span class="line">*&#x2F;</span><br><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">    &#x2F;&#x2F; Any nested &lt;beans&gt; elements will cause recursion in this method. In</span><br><span class="line">    &#x2F;&#x2F; order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span><br><span class="line">    &#x2F;&#x2F; keep track of the current (parent) delegate, which may be null. Create</span><br><span class="line">    &#x2F;&#x2F; the new (child) delegate with a reference to the parent for fallback purposes,</span><br><span class="line">    &#x2F;&#x2F; then ultimately reset this.delegate back to its original (parent) reference.</span><br><span class="line">    &#x2F;&#x2F; this behavior emulates a stack of delegates without actually necessitating one.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; delegate可以理解为配置参数&#x2F;属性，传递的上下文，封装相关的的配置和状态等信息的集合对象</span><br><span class="line">    &#x2F;&#x2F; 任何被嵌套的&lt;beans&gt;元素都会导致此方法的递归。为了正确的传播和保存delegate内的信息，所以这里需要做delegate交接</span><br><span class="line">    &#x2F;&#x2F; 它可能为null</span><br><span class="line">    &#x2F;&#x2F; 为了能够回退，新的（子）delegate具有父的引用，最终会重置this.delegate回到它的初始（父）引用。</span><br><span class="line">    BeanDefinitionParserDelegate parent &#x3D; this.delegate;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重要方法，创建一个新的代理，继承父delegate，并初始化一些默认值</span><br><span class="line">    this.delegate &#x3D; createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;默认明明空间是&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        String profileSpec &#x3D; root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果当前层级的&lt;beans &#x2F;&gt;配置有profile属性，那么处理这个属性。不是很重要不赘述</span><br><span class="line">        if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            String[] specifiedProfiles &#x3D; StringUtils.tokenizeToStringArray(</span><br><span class="line">                profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +</span><br><span class="line">                                &quot;] not matching: &quot; + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;xml预处理，子类没有重写里面就是空实现</span><br><span class="line">    preProcessXml(root);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重要方法，生成BeanDefinition，并注册在工厂中</span><br><span class="line">    parseBeanDefinitions(root, this.delegate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;xml后处理，子类没有重写里面就是空实现</span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    this.delegate &#x3D; parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好，这里两个核心方法，我们一个一个来</p>
<h2 id="3-8-生成代理和传递基础配置"><a href="#3-8-生成代理和传递基础配置" class="headerlink" title="3.8 生成代理和传递基础配置"></a>3.8 生成代理和传递基础配置</h2><p>先看DefaultBeanDefinitionDocumentReader类的createDelegate方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">protected BeanDefinitionParserDelegate createDelegate(</span><br><span class="line">		XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;生成用来解析XML bean definition的有状态Delegate类，用来被主解析器和其他扩展使用。</span><br><span class="line">	&#x2F;&#x2F;上下文readerContext继承在其内部</span><br><span class="line">	BeanDefinitionParserDelegate delegate &#x3D; new BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">	&#x2F;&#x2F;给新生成的delegate做继承和赋初值</span><br><span class="line">	delegate.initDefaults(root, parentDelegate);</span><br><span class="line">	return delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Initialize the default lazy-init, autowire, dependency check settings,</span><br><span class="line"> * init-method, destroy-method and merge settings. Support nested &#39;beans&#39;</span><br><span class="line"> * element use cases by falling back to the given parent in case the</span><br><span class="line"> * defaults are not explicitly set locally.</span><br><span class="line"> *</span><br><span class="line"> * 用默认的值填充DocumentDefaultsDefinition实例</span><br><span class="line"> * 通过使用parentDefaults（父代理的default属性），来解决嵌套的&#39;beans&#39;元素情况，以防默认值在局部设定不明确</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void initDefaults(Element root, BeanDefinitionParserDelegate parent) &#123;</span><br><span class="line"></span><br><span class="line">	 &#x2F;&#x2F;重要方法，构造当前delegate的默认配置信息封装类，为其赋初值。</span><br><span class="line">	 &#x2F;&#x2F;this.defaults，也就是当前delegate的默认配置信息封装类，它的类型是DocumentDefaultsDefinition</span><br><span class="line">	 &#x2F;&#x2F;如果有父delegate，也要让新生成的defaults继承父delegate的defaults</span><br><span class="line">	populateDefaults(this.defaults, (parent !&#x3D; null ? parent.defaults : null), root);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;默认没做任何实现</span><br><span class="line">	this.readerContext.fireDefaultsRegistered(this.defaults);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Populate the given DocumentDefaultsDefinition instance with the default lazy-init,</span><br><span class="line"> * autowire, dependency check settings, init-method, destroy-method and merge settings.</span><br><span class="line"> * Support nested &#39;beans&#39; element use cases by falling back to &#123;@code parentDefaults&#125;</span><br><span class="line"> * in case the defaults are not explicitly set locally.</span><br><span class="line"> * 用默认的值填充DocumentDefaultsDefinition实例</span><br><span class="line"> * 通过使用parentDefaults（父代理的default属性），来解决嵌套的&#39;beans&#39;元素情况，以防默认值在局部设定不明确</span><br><span class="line"> * @param defaults the defaults to populate</span><br><span class="line"> * @param parentDefaults the parent BeanDefinitionParserDelegate (if any) defaults to fall back to</span><br><span class="line"> * @param root the root element of the current bean definition document (or nested beans element)</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root) &#123;</span><br><span class="line">	&#x2F;&#x2F;根元素上如果没有设定值，则返回&quot;default&quot;字符串</span><br><span class="line">	String lazyInit &#x3D; root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);</span><br><span class="line">	&#x2F;&#x2F;如果为&quot;default&quot;，先看parentDefaults有没有，有用它的，没有用&quot;false&quot;</span><br><span class="line">	if (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to false.</span><br><span class="line">		&#x2F;&#x2F; 可能从外部&lt;beans&gt;继承，否则返回false</span><br><span class="line">		lazyInit &#x3D; (parentDefaults !&#x3D; null ? parentDefaults.getLazyInit() : FALSE_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	defaults.setLazyInit(lazyInit);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;下面的逻辑和lazyInit差不多，即看本级是否有显性配置，没有的话，看父类有没有继承，也没有就设默认值。</span><br><span class="line"></span><br><span class="line">	String merge &#x3D; root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(merge)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to false.</span><br><span class="line">		merge &#x3D; (parentDefaults !&#x3D; null ? parentDefaults.getMerge() : FALSE_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	defaults.setMerge(merge);</span><br><span class="line"></span><br><span class="line">	String autowire &#x3D; root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(autowire)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to &#39;no&#39;.</span><br><span class="line">		autowire &#x3D; (parentDefaults !&#x3D; null ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	defaults.setAutowire(autowire);</span><br><span class="line"></span><br><span class="line">	if (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) &#123;</span><br><span class="line">		defaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (parentDefaults !&#x3D; null) &#123;</span><br><span class="line">		defaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		defaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (parentDefaults !&#x3D; null) &#123;</span><br><span class="line">		defaults.setInitMethod(parentDefaults.getInitMethod());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		defaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (parentDefaults !&#x3D; null) &#123;</span><br><span class="line">		defaults.setDestroyMethod(parentDefaults.getDestroyMethod());</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;extractSource方法这里没有做任何实现，默认返回null</span><br><span class="line">	defaults.setSource(this.readerContext.extractSource(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-拆解根层级，并根据子标签命名空间做不同处理"><a href="#3-9-拆解根层级，并根据子标签命名空间做不同处理" class="headerlink" title="3.9 拆解根层级，并根据子标签命名空间做不同处理"></a>3.9 拆解根层级，并根据子标签命名空间做不同处理</h2><p>我们再来看另一个核心方法：DefaultBeanDefinitionDocumentReader类的parseBeanDefinitions方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse the elements at the root level in the document:</span><br><span class="line"> * 将文档中&lt;beans&#x2F;&gt;层级下的元素一层层剥开，为子标签的不同命名空间选择不同策略。</span><br><span class="line"> * 主要两种命名空间：beans命名空间 +其他命名空间（context&#x2F;aop等命名空间）</span><br><span class="line"> </span><br><span class="line"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;等标签都属于beans命名空间</span><br><span class="line"> *</span><br><span class="line"> * 这里判断是否是不同的命名空间，不同命名空间，后续会使用不同解析器来解析。</span><br><span class="line"> *</span><br><span class="line"> * @param root the DOM root element of the document</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;判断默认命名空间是&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		&#x2F;&#x2F;获取根元素(&lt;beans &#x2F;&gt;)下的子Node，注意，Node不一定是子标签，可能是回车，可能是注释</span><br><span class="line">		NodeList nl &#x3D; root.getChildNodes();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node &#x3D; nl.item(i);</span><br><span class="line">			if (node instanceof Element) &#123;</span><br><span class="line">				&#x2F;&#x2F;拿到了&lt;beans&gt;下的子标签</span><br><span class="line">				Element ele &#x3D; (Element) node;</span><br><span class="line">				&#x2F;&#x2F;如果该标签属于beans的名称空间，则进入这个方法</span><br><span class="line">				&#x2F;&#x2F;xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">				if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					&#x2F;&#x2F;如果该标签属于其他的名称空间比如：context,aop等</span><br><span class="line">					&#x2F;&#x2F;xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">					&#x2F;&#x2F;xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">					&#x2F;&#x2F;比如我们使用注解注入的话，会在spring的配置文件加&lt;context:annotation-config&#x2F;&gt;</span><br><span class="line">					&#x2F;&#x2F;这个启用注解的标签，就属于context命名空间</span><br><span class="line">					&#x2F;&#x2F;在接下来的逻辑中，不同命名空间，使用不同处理器来解析</span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-解析beans命名空间的配置"><a href="#3-10-解析beans命名空间的配置" class="headerlink" title="3.10 解析beans命名空间的配置"></a>3.10 解析beans命名空间的配置</h2><p>前文我们说到，如果该标签属于beans的名称空间，则进入parseDefaultElement(ele, delegate)方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;&lt;import&gt;标签进入这个方法</span><br><span class="line">	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;&lt;alias&gt;标签进入这个方法</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;&lt;bean&gt;标签进入这个方法</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F;核心方法</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;&#x2F;&#x2F;又嵌套一层&lt;beans&gt;标签进入这个方法</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F; recurse</span><br><span class="line">		&#x2F;&#x2F; 如果是嵌套的beans，那么就会重新调用doRegisterBeanDefinitions进行递归</span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述几个标签中，我们主要来看<code>&lt;bean&gt;</code>标签的解析方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Process the given bean element, parsing the bean definition</span><br><span class="line"> * and registering it with the registry.</span><br><span class="line"> * 处理bean元素，解析成bean definition并注册到工厂中</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;使用delegate的内容（默认配置）来解析bean元素，核心方法</span><br><span class="line">	BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	if (bdHolder !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有要求的话渲染beanDefinition</span><br><span class="line">		bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Register the final decorated instance.</span><br><span class="line">			&#x2F;&#x2F;注册最终被渲染的实例到工厂中</span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +</span><br><span class="line">					bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; Send registration event.</span><br><span class="line">		&#x2F;&#x2F; 发送注册事件</span><br><span class="line">		&#x2F;&#x2F; 这里是空实现</span><br><span class="line">		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-11-解析并生成BeanDefinition实例"><a href="#3-11-解析并生成BeanDefinition实例" class="headerlink" title="3.11 解析并生成BeanDefinition实例"></a>3.11 解析并生成BeanDefinition实例</h2><p>进入BeanDefinitionParserDelegate类的parseBeanDefinitionElement方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Parses the supplied &#123;@code &lt;bean&gt;&#125; element. May return &#123;@code null&#125;</span><br><span class="line">* if there were errors during parse. Errors are reported to the</span><br><span class="line">* &#123;@link org.springframework.beans.factory.parsing.ProblemReporter&#125;.</span><br><span class="line">*</span><br><span class="line">* 解析bean元素。如果解析过程中发生错误则返回空</span><br><span class="line">*&#x2F;</span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">    &#x2F;&#x2F;拿bean标签上的id</span><br><span class="line">    String id &#x3D; ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    &#x2F;&#x2F;拿bean标签上的name属性</span><br><span class="line">    String nameAttr &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    List&lt;String&gt; aliases &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">    &#x2F;&#x2F;有name属性进入</span><br><span class="line">    if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        &#x2F;&#x2F;name属性对应的name值如果有分隔符&quot;,; &quot;，那么切分成数组</span><br><span class="line">        String[] nameArr &#x3D; StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        &#x2F;&#x2F;这些name值就是别名</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;指定了id就用id值作为bean名称</span><br><span class="line">    String beanName &#x3D; id;</span><br><span class="line">    &#x2F;&#x2F;如果没有id，但是指定了name，就用name值作为bean名称</span><br><span class="line">    if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        &#x2F;&#x2F;拿第一个name值作为bean名称，其余的还是别名</span><br><span class="line">        beanName &#x3D; aliases.remove(0);</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +</span><br><span class="line">                         &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (containingBean &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;检查bean名称和别名是否已经被使用了，如果用了就报错</span><br><span class="line">        &#x2F;&#x2F;同时把这个bean的名称和别名加入代理的usedNames属性中</span><br><span class="line">        &#x2F;&#x2F;private final Set&lt;String&gt; usedNames &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;直接进入这个方法</span><br><span class="line">    AbstractBeanDefinition beanDefinition &#x3D; parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    if (beanDefinition !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;既没有指定id，也没有指定name就走这里面</span><br><span class="line">        if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;前面containingBean传递时为null，这里不走这个方法</span><br><span class="line">                if (containingBean !&#x3D; null) &#123;</span><br><span class="line">                    beanName &#x3D; BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                        beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F;生成一个bean名称，beanName</span><br><span class="line">                    &#x2F;&#x2F;如果这个bean是内部bean，全限定名后加#号再加哈希值</span><br><span class="line">                    &#x2F;&#x2F;如果是顶层bean，那么后面加#号再从0开始加数字，id已被注册数字就增1，直到唯一</span><br><span class="line">                    &#x2F;&#x2F;比如：tk.mybatis.spring.mapper.MapperScannerConfigurer#0</span><br><span class="line">                    beanName &#x3D; this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    &#x2F;&#x2F; Register an alias for the plain bean class name, if still possible,</span><br><span class="line">                    &#x2F;&#x2F; if the generator returned the class name plus a suffix.</span><br><span class="line">                    &#x2F;&#x2F; This is expected for Spring 1.2&#x2F;2.0 backwards compatibility.</span><br><span class="line">                    &#x2F;&#x2F;如果可能的话，如果生成器返回类名加后缀，则注册一个别名，这个别名就是该类的类名。</span><br><span class="line">                    &#x2F;&#x2F;这是为了向后兼容</span><br><span class="line">                    String beanClassName &#x3D; beanDefinition.getBeanClassName();</span><br><span class="line">                    if (beanClassName !&#x3D; null &amp;&amp;</span><br><span class="line">                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                        !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果该类名没有被使用，那么注册该类名作为别名，比如：</span><br><span class="line">                        &#x2F;&#x2F;tk.mybatis.spring.mapper.MapperScannerConfigurer作为</span><br><span class="line">                        &#x2F;&#x2F;tk.mybatis.spring.mapper.MapperScannerConfigurer#0的别名</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +</span><br><span class="line">                                 &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray &#x3D; StringUtils.toStringArray(aliases);</span><br><span class="line">        &#x2F;&#x2F;返回beanDefinition的持有者</span><br><span class="line">        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上文中，核心方法是这句话：</p>
<p><code>AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse the bean definition itself, without regard to name or aliases. May return</span><br><span class="line"> * 不关注名称和别名，只解析bean definition自身</span><br><span class="line"> * &#123;@code null&#125; if problems occurred during the parsing of the bean definition.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">		Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123;</span><br><span class="line">	&#x2F;&#x2F;栈结构，解析的时候放入bean标签，解析完成弹出</span><br><span class="line">	&#x2F;&#x2F;如果还嵌套有子标签，则后续放入子标签</span><br><span class="line">	&#x2F;&#x2F;栈结构当然后进先出，所以子标签先弹出</span><br><span class="line">	this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">	String className &#x3D; null;</span><br><span class="line">	if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有指定class属性，则拿到class属性值</span><br><span class="line">		className &#x3D; ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">	&#125;</span><br><span class="line">	String parent &#x3D; null;</span><br><span class="line">	if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有指定parent属性，则拿到parent属性值</span><br><span class="line">		parent &#x3D; ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;创建BeanDefinition并设置两属性，核心方法</span><br><span class="line">		AbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);</span><br><span class="line">		&#x2F;&#x2F;将bean标签上的属性设置到bean definition中，核心方法2</span><br><span class="line">		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为description，拿到标签中的文本，设置到bean definition中</span><br><span class="line">		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为meta，拿到他的key和value属性，设置到bean definition中</span><br><span class="line">		parseMetaElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为lookup-method，拿到他的name和bean属性，设置到bean definition中</span><br><span class="line">		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为replaced-method，设置bean definition </span><br><span class="line">		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为constructor-arg，设置bean definition的构造方式</span><br><span class="line">		parseConstructorArgElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;这个标签比较常用，为Property标签</span><br><span class="line">		&#x2F;&#x2F;解析Property的属性设置到bean definition中</span><br><span class="line">		parsePropertyElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;有qualifier子标签才走这个方法</span><br><span class="line">		parseQualifierElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;设置资源</span><br><span class="line">		bd.setResource(this.readerContext.getResource());</span><br><span class="line">		&#x2F;&#x2F;这里为null</span><br><span class="line">		bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">		return bd;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (NoClassDefFoundError err) &#123;</span><br><span class="line">		error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		&#x2F;&#x2F;解析的时候放入，解析完成弹出</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个重要的核心方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建BeanDefinition并设置两属性，核心方法</span><br><span class="line">AbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);</span><br><span class="line">&#x2F;&#x2F;将bean标签上的属性设置到bean definition中，核心方法2</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;这个标签比较常用，为Property标签</span><br><span class="line">&#x2F;&#x2F;解析Property的属性设置到bean definition中</span><br><span class="line">parsePropertyElements(ele, bd);</span><br></pre></td></tr></table></figure>

<p>我们依次来看：</p>
<h3 id="3-11-1-创建实例"><a href="#3-11-1-创建实例" class="headerlink" title="3.11.1 创建实例"></a>3.11.1 创建实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Create a bean definition for the given class name and parent name.</span><br><span class="line"> * 通过给定的className和parentName创建beanDefinition</span><br><span class="line"> * </span><br><span class="line"> * @param className the name of the bean class</span><br><span class="line"> * @param parentName the name of the bean&#39;s parent bean</span><br><span class="line"> * @return the newly created bean definition</span><br><span class="line"> * @throws ClassNotFoundException if bean class resolution was attempted but failed</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)</span><br><span class="line">		throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">	return BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">			parentName, className, this.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用BeanDefinitionReaderUtils的静态方法createBeanDefinition():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Create a new GenericBeanDefinition for the given parent name and class name,</span><br><span class="line"> * eagerly loading the bean class if a ClassLoader has been specified.</span><br><span class="line"> </span><br><span class="line"> * 通过给定的parentName和className穿件一个新的GenericBeanDefinition</span><br><span class="line"> * 如果指定了ClassLoader，就提前加载bean class</span><br><span class="line"> </span><br><span class="line"> * @param parentName the name of the parent bean, if any</span><br><span class="line"> * @param className the name of the bean class, if any</span><br><span class="line"> * @param classLoader the ClassLoader to use for loading bean classes</span><br><span class="line"> * (can be &#123;@code null&#125; to just register bean classes by name)</span><br><span class="line"> * @return the bean definition</span><br><span class="line"> * @throws ClassNotFoundException if the bean class could not be loaded</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static AbstractBeanDefinition createBeanDefinition(</span><br><span class="line">		@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader)</span><br><span class="line">		throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">	GenericBeanDefinition bd &#x3D; new GenericBeanDefinition();</span><br><span class="line">	bd.setParentName(parentName);</span><br><span class="line">	if (className !&#x3D; null) &#123;</span><br><span class="line">		if (classLoader !&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F;有classloader，则通过反射，动态加载一个实例返回</span><br><span class="line">			bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F;没有classloader，先存个className</span><br><span class="line">			bd.setBeanClassName(className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-11-2-标签的属性注入"><a href="#3-11-2-标签的属性注入" class="headerlink" title="3.11.2 标签的属性注入"></a>3.11.2 标签的属性注入</h3><p>看完了create，我们再来看parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);方法，该方法会将bean标签的属性值注入到BeanDefinition实例中，也就是给BeanDefinition赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Apply the attributes of the given bean element to the given bean * definition.</span><br><span class="line"> * 将bean标签上的属性设置到bean definition中</span><br><span class="line"> * @param ele bean declaration element</span><br><span class="line"> * @param beanName bean name</span><br><span class="line"> * @param containingBean containing bean definition</span><br><span class="line"> * @return a bean definition initialized according to the bean element attributes</span><br><span class="line"> *&#x2F;</span><br><span class="line">public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,</span><br><span class="line">		@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) &#123;</span><br><span class="line">	&#x2F;&#x2F;bean标签上已经没有singleton属性了，新版用scope代替，所以出现singleton就报错提醒</span><br><span class="line">	if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">		error(&quot;Old 1.x &#39;singleton&#39; attribute in use - upgrade to &#39;scope&#39; declaration&quot;, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果设置了scope就拿其值</span><br><span class="line">	else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;此处containingBean为空</span><br><span class="line">	else if (containingBean !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F; Take default from containing bean in case of an inner bean definition.</span><br><span class="line">		&#x2F;&#x2F; 如果bd是一个内部的beanDefinition，用包含它的bean的配置</span><br><span class="line">		bd.setScope(containingBean.getScope());</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果设置了abstract就拿其值</span><br><span class="line">	if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;lazyInit如果没有设置则为默认值，默认值用的代理类中defaults属性，</span><br><span class="line">	&#x2F;&#x2F;也就是this.defaults</span><br><span class="line">	String lazyInit &#x3D; ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">		lazyInit &#x3D; this.defaults.getLazyInit();</span><br><span class="line">	&#125;</span><br><span class="line">	bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line">	&#x2F;&#x2F;拿autowire配置，无则用默认值，默认值用的代理类中defaults属性，即不进行autowire</span><br><span class="line">	String autowire &#x3D; ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">	bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line">	&#x2F;&#x2F;拿depends-on配置</span><br><span class="line">	if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line">		String dependsOn &#x3D; ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">		bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有autowire-candidate属性，没有或者为默认则不设置</span><br><span class="line">	String autowireCandidate &#x3D; ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(autowireCandidate)) &#123;</span><br><span class="line">		String candidatePattern &#x3D; this.defaults.getAutowireCandidates();</span><br><span class="line">		if (candidatePattern !&#x3D; null) &#123;</span><br><span class="line">			String[] patterns &#x3D; StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">			bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有primary属性</span><br><span class="line">	if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有init-method属性</span><br><span class="line">	if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		String initMethodName &#x3D; ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">		bd.setInitMethodName(initMethodName);</span><br><span class="line">	&#125;&#x2F;&#x2F;没有init-method属性，就拿代理类defaults属性的</span><br><span class="line">	else if (this.defaults.getInitMethod() !&#x3D; null) &#123;</span><br><span class="line">		bd.setInitMethodName(this.defaults.getInitMethod());</span><br><span class="line">		bd.setEnforceInitMethod(false);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有destroy-method属性</span><br><span class="line">	if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		String destroyMethodName &#x3D; ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">		bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">	&#125;&#x2F;&#x2F;没有destroy-method属性，就拿代理类defaults属性的</span><br><span class="line">	else if (this.defaults.getDestroyMethod() !&#x3D; null) &#123;</span><br><span class="line">		bd.setDestroyMethodName(this.defaults.getDestroyMethod());</span><br><span class="line">		bd.setEnforceDestroyMethod(false);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有factory-method属性</span><br><span class="line">	if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有factory-bean属性</span><br><span class="line">	if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，bean标签上的属性也就解析完成了，对其属性的描述不管设置了还是没有设置的，都有相应的值对应到bean definition中。</p>
<h3 id="3-11-3-bean标签下的property注入"><a href="#3-11-3-bean标签下的property注入" class="headerlink" title="3.11.3 bean标签下的property注入"></a>3.11.3 bean标签下的property注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.sgcc.bean.Student&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;无敌&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;20&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>如上述配置，我们知道property的存在，parsePropertyElements()负责解析Property的属性设置到beanDefinition中，此方法在BeanDefinitionParserDelegate类中实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse property sub-elements of the given bean element.</span><br><span class="line"> * 解析bean标签下property子标签</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void parsePropertyElements(Element beanEle, BeanDefinition bd) &#123;</span><br><span class="line">	NodeList nl &#x3D; beanEle.getChildNodes();</span><br><span class="line">	&#x2F;&#x2F;循环查找元素的子元素，也就是bean标签的子元素</span><br><span class="line">	for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		Node node &#x3D; nl.item(i);</span><br><span class="line">		&#x2F;&#x2F;标签名为property才能进入，进入这个方法</span><br><span class="line">		if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">			parsePropertyElement((Element) node, bd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse a property element.</span><br><span class="line"> * 解析property元素，核心的属性只有name和value</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void parsePropertyElement(Element ele, BeanDefinition bd) &#123;</span><br><span class="line">	&#x2F;&#x2F;拿到property标签的name属性</span><br><span class="line">	String propertyName &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	if (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">		error(&quot;Tag &#39;property&#39; must have a &#39;name&#39; attribute&quot;, ele);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;解析的时候放入，解析完成弹出，这里放入property标签，</span><br><span class="line">	&#x2F;&#x2F;注意，此时这里还存有bean父标签，子标签解析完成后先弹出</span><br><span class="line">	this.parseState.push(new PropertyEntry(propertyName));</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;bean标签下可以有多个property，但是不能重复name属性，有重复报错</span><br><span class="line">		if (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">			error(&quot;Multiple &#39;property&#39; definitions for property &#39;&quot; + propertyName + &quot;&#39;&quot;, ele);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;核心方法，解析property标签属性</span><br><span class="line">		Object val &#x3D; parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">		&#x2F;&#x2F;将name属性和对应的value封装为PropertyValue对象</span><br><span class="line">		PropertyValue pv &#x3D; new PropertyValue(propertyName, val);</span><br><span class="line">		&#x2F;&#x2F;解析property标签的子标签meta，</span><br><span class="line">		&#x2F;&#x2F;拿到meta的key和value属性，设置到PropertyValue中</span><br><span class="line">		parseMetaElements(ele, pv);</span><br><span class="line">		&#x2F;&#x2F;这里没有实现，为null</span><br><span class="line">		pv.setSource(extractSource(ele));</span><br><span class="line">		&#x2F;&#x2F;将PropertyValue添加到bean definition中</span><br><span class="line">		bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		&#x2F;&#x2F;解析的时候放入，解析完成弹出，这里弹出的是property标签</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Get the value of a property element. May be a list etc.</span><br><span class="line"> * Also used for constructor arguments, &quot;propertyName&quot; being null in this case.</span><br><span class="line"> * 拿到property标签的value值，可能是list</span><br><span class="line"> * 也可能被constructor标签使用，这种情况propertyName为null</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) &#123;</span><br><span class="line">	&#x2F;&#x2F;如果propertyName为null，则ele是constructor-arg标签</span><br><span class="line">	&#x2F;&#x2F;否则为property标签</span><br><span class="line">	String elementName &#x3D; (propertyName !&#x3D; null ?</span><br><span class="line">			&quot;&lt;property&gt; element for property &#39;&quot; + propertyName + &quot;&#39;&quot; :</span><br><span class="line">			&quot;&lt;constructor-arg&gt; element&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Should only have one child element: ref, value, list, etc.</span><br><span class="line">	&#x2F;&#x2F;不管是哪种标签，下面都应该只有一个子标签: ref, value, list等.</span><br><span class="line">	NodeList nl &#x3D; ele.getChildNodes();</span><br><span class="line">	Element subElement &#x3D; null;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		Node node &#x3D; nl.item(i);</span><br><span class="line">		if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">				!nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">			&#x2F;&#x2F; Child element is what we&#39;re looking for.</span><br><span class="line">			&#x2F;&#x2F;除开description和meta标签，子标签最多只能有一个</span><br><span class="line">			&#x2F;&#x2F;如果该判断为真，说明不止一个除开description和meta的标签</span><br><span class="line">			if (subElement !&#x3D; null) &#123;</span><br><span class="line">				error(elementName + &quot; must not contain more than one sub-element&quot;, ele);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				&#x2F;&#x2F;得到除开description和meta之外的子标签</span><br><span class="line">				&#x2F;&#x2F;比如下面这种配置，那么&lt;value&gt;helloworld&lt;&#x2F;value&gt;就是子元素subElement。</span><br><span class="line">				&#x2F;&#x2F;&lt;property name&#x3D;&quot;Nnnn&quot;&gt;</span><br><span class="line">				&#x2F;&#x2F;	&lt;value&gt;helloworld&lt;&#x2F;value&gt;</span><br><span class="line">				&#x2F;&#x2F;&lt;&#x2F;property&gt;</span><br><span class="line">				subElement &#x3D; (Element) node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;看标签属性用的是value还是ref</span><br><span class="line">	boolean hasRefAttribute &#x3D; ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">	boolean hasValueAttribute &#x3D; ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">	&#x2F;&#x2F;value和ref属性不能同时存在，如果有子标签，则value和ref都不能存在，否则报错</span><br><span class="line">	if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">			((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement !&#x3D; null)) &#123;</span><br><span class="line">		error(elementName +</span><br><span class="line">				&quot; is only allowed to contain either &#39;ref&#39; attribute OR &#39;value&#39; attribute OR sub-element&quot;, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;用的ref的情况，如&lt;property name&#x3D;&quot;name&quot; ref&#x3D;&quot;......&quot;&#x2F;&gt;</span><br><span class="line">	if (hasRefAttribute) &#123;</span><br><span class="line">		&#x2F;&#x2F;拿到ref属性</span><br><span class="line">		String refName &#x3D; ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">		if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(elementName + &quot; contains empty &#39;ref&#39; attribute&quot;, ele);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;通过ref属性来构建一个RuntimeBeanReference实例对象</span><br><span class="line">		RuntimeBeanReference ref &#x3D; new RuntimeBeanReference(refName);</span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		return ref;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;用的value的情况，如&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line">	else if (hasValueAttribute) &#123;</span><br><span class="line">		TypedStringValue valueHolder &#x3D; new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">		valueHolder.setSource(extractSource(ele));</span><br><span class="line">		return valueHolder;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;子标签不为null的情况，比如</span><br><span class="line">	&#x2F;&#x2F;&lt;property name&#x3D;&quot;Nnnn&quot;&gt;</span><br><span class="line">	&#x2F;&#x2F;	&lt;value&gt;helloworld&lt;&#x2F;value&gt;</span><br><span class="line">	&#x2F;&#x2F;&lt;&#x2F;property&gt;</span><br><span class="line">	else if (subElement !&#x3D; null) &#123;</span><br><span class="line">		return parsePropertySubElement(subElement, bd);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.</span><br><span class="line">		&#x2F;&#x2F;没指定ref或者value或者子标签，返回null</span><br><span class="line">		error(elementName + &quot; must specify a ref or value&quot;, ele);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse a value, ref or collection sub-element of a property or</span><br><span class="line"> * constructor-arg element.</span><br><span class="line"> * 解析property或者constructor-arg标签的子标签，可能为value, ref或者集合</span><br><span class="line"> * @param ele subelement of property element; we don&#39;t know which yet</span><br><span class="line"> * @param bd the current bean definition (if any)</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) &#123;</span><br><span class="line">	return parsePropertySubElement(ele, bd, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse a value, ref or collection sub-element of a property or</span><br><span class="line"> * constructor-arg element.</span><br><span class="line"> * 解析property或者constructor-arg标签的子标签，可能为value, ref或者集合</span><br><span class="line"> * @param ele subelement of property element; we don&#39;t know which yet</span><br><span class="line"> * @param bd the current bean definition (if any)</span><br><span class="line"> * @param defaultValueType the default type (class name) for any</span><br><span class="line"> * &#123;@code &lt;value&gt;&#125; tag that might be created</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) &#123;</span><br><span class="line">	if (!isDefaultNamespace(ele)) &#123;&#x2F;&#x2F;如果这个子标签不属于beans的名称空间，则走这个方法</span><br><span class="line">		return parseNestedCustomElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是bean子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		BeanDefinitionHolder nestedBd &#x3D; parseBeanDefinitionElement(ele, bd);</span><br><span class="line">		if (nestedBd !&#x3D; null) &#123;</span><br><span class="line">			nestedBd &#x3D; decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">		&#125;</span><br><span class="line">		return nestedBd;</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是ref子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F; A generic reference to any name of any bean.</span><br><span class="line">		String refName &#x3D; ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">		boolean toParent &#x3D; false;</span><br><span class="line">		if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">			&#x2F;&#x2F; A reference to the id of another bean in a parent context.</span><br><span class="line">			refName &#x3D; ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">			toParent &#x3D; true;</span><br><span class="line">			if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">				error(&quot;&#39;bean&#39; or &#39;parent&#39; is required for &lt;ref&gt; element&quot;, ele);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		RuntimeBeanReference ref &#x3D; new RuntimeBeanReference(refName, toParent);</span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		return ref;</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是idref子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">		return parseIdRefElement(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是value子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F;以这个方法作为演示，其他的方法都是大同小异，进入。</span><br><span class="line">		return parseValueElement(ele, defaultValueType);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是null子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F; It&#39;s a distinguished null value. Let&#39;s wrap it in a TypedStringValue</span><br><span class="line">		&#x2F;&#x2F; object in order to preserve the source location.</span><br><span class="line">		TypedStringValue nullHolder &#x3D; new TypedStringValue(null);</span><br><span class="line">		nullHolder.setSource(extractSource(ele));</span><br><span class="line">		return nullHolder;</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是array子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">		return parseArrayElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是list子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">		return parseListElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是set子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">		return parseSetElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是map子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">		return parseMapElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是props子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">		return parsePropsElement(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;否则返回null，报错</span><br><span class="line">	else &#123;</span><br><span class="line">		error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Return a typed String value Object for the given value element.</span><br><span class="line"> * 通过指定的value标签，返回指定的字符串value对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Object parseValueElement(Element ele, @Nullable String defaultTypeName) &#123;</span><br><span class="line">	&#x2F;&#x2F; It&#39;s a literal value.</span><br><span class="line">	&#x2F;&#x2F;拿到value中的文本，包括回车、tab制表符、空格</span><br><span class="line">	String value &#x3D; DomUtils.getTextValue(ele);</span><br><span class="line">	&#x2F;&#x2F;有无type属性</span><br><span class="line">	String specifiedTypeName &#x3D; ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">	String typeName &#x3D; specifiedTypeName;</span><br><span class="line">	if (!StringUtils.hasText(typeName)) &#123;</span><br><span class="line">		&#x2F;&#x2F;没有就用入参defaultTypeName，其实这里defaultTypeName也是null</span><br><span class="line">		typeName &#x3D; defaultTypeName;</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;构建一个value的封装类。</span><br><span class="line">		TypedStringValue typedValue &#x3D; buildTypedStringValue(value, typeName);</span><br><span class="line">		&#x2F;&#x2F;这里设置为空</span><br><span class="line">		typedValue.setSource(extractSource(ele));</span><br><span class="line">		&#x2F;&#x2F;这里为空字符串</span><br><span class="line">		typedValue.setSpecifiedTypeName(specifiedTypeName);</span><br><span class="line">		&#x2F;&#x2F;返回typedValue</span><br><span class="line">		return typedValue;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(&quot;Type class [&quot; + typeName + &quot;] not found for &lt;value&gt; element&quot;, ele, ex);</span><br><span class="line">		return value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-12-注册BeanDefinition到工厂中"><a href="#3-12-注册BeanDefinition到工厂中" class="headerlink" title="3.12 注册BeanDefinition到工厂中"></a>3.12 注册BeanDefinition到工厂中</h2><p>好，回到processBeanDefinition方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Process the given bean element, parsing the bean definition</span><br><span class="line"> * and registering it with the registry.</span><br><span class="line"> * 处理bean元素，解析成bean definition并注册到工厂中</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;使用delegate的内容（默认配置）来解析bean元素，核心方法</span><br><span class="line">	BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	if (bdHolder !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有要求的话渲染beanDefinition，不是很重要</span><br><span class="line">		bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Register the final decorated instance.</span><br><span class="line">			&#x2F;&#x2F;注册最终被渲染的实例到工厂中</span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +</span><br><span class="line">					bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; Send registration event.</span><br><span class="line">		&#x2F;&#x2F; 发送注册事件</span><br><span class="line">		&#x2F;&#x2F; 这里是空实现</span><br><span class="line">		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);这一句我们已经在3.11章节中详细介绍了，接下来我们视角继续往下，看下BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Register the given bean definition with the given bean factory.</span><br><span class="line"> * @param definitionHolder the bean definition including name and aliases</span><br><span class="line"> * @param registry the bean factory to register with</span><br><span class="line"> * @throws BeanDefinitionStoreException if registration failed</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void registerBeanDefinition(</span><br><span class="line">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Register bean definition under primary name.</span><br><span class="line">	&#x2F;&#x2F; 注册beanDefinition的beanName</span><br><span class="line">	&#x2F;&#x2F; 比如tk.mybatis.spring.mapper.MapperScannerConfigurer#0</span><br><span class="line">	String beanName &#x3D; definitionHolder.getBeanName();</span><br><span class="line">	&#x2F;&#x2F; 核心方法，比较重要，待会儿详解</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Register aliases for bean name, if any.</span><br><span class="line">	&#x2F;&#x2F; 如果有别名的话，为bean name注册别名</span><br><span class="line">	String[] aliases &#x3D; definitionHolder.getAliases();</span><br><span class="line">	if (aliases !&#x3D; null) &#123;</span><br><span class="line">		for (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主流程由此进入了registry.registerBeanDefinition中，其中registry实例是DefaultListableBeanFactory的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">	Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">	if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;做一个验证，静态工厂方法和覆盖方法不能组合使用</span><br><span class="line">			&#x2F;&#x2F;如果bean definition中的beanClass属性不是String类型而是Class类型</span><br><span class="line">			&#x2F;&#x2F;那么就要验证和准备这个bean定义的覆盖方法，检查指定名称的方法是否存在</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Validation of bean definition failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;查看beanName是否已经被注册在工厂的beanDefinitionMap属性中</span><br><span class="line">	BeanDefinition existingDefinition &#x3D; this.beanDefinitionMap.get(beanName);</span><br><span class="line">	&#x2F;&#x2F;已经被注册的情况走这个方法，覆盖或者抛异常</span><br><span class="line">	if (existingDefinition !&#x3D; null) &#123;</span><br><span class="line">		if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &#39;&quot; + beanName +</span><br><span class="line">					&quot;&#39;: There is already [&quot; + existingDefinition + &quot;] bound.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			&#x2F;&#x2F; e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Overriding user-defined bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">						&quot;&#39; with a framework-generated bean definition: replacing [&quot; +</span><br><span class="line">						existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Overriding bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">						&quot;&#39; with a different definition: replacing [&quot; + existingDefinition +</span><br><span class="line">						&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">						&quot;&#39; with an equivalent definition: replacing [&quot; + existingDefinition +</span><br><span class="line">						&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;这场景表示beanName还没有被注册</span><br><span class="line">		&#x2F;&#x2F;然后根据阶段不同又有一层判断</span><br><span class="line">		if (hasBeanCreationStarted()) &#123;</span><br><span class="line">			&#x2F;&#x2F; Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">			&#x2F;&#x2F;这个阶段是bean已经开始创建，启动阶段不会进入这里</span><br><span class="line">			&#x2F;&#x2F;如果在非启动阶段注册beanDefinition，那么要加锁后才能操作beanDefinitionMap、beanDefinitionNames</span><br><span class="line">			&#x2F;&#x2F;和manualSingletonNames</span><br><span class="line">			synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">				this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions &#x3D; new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">				updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				this.beanDefinitionNames &#x3D; updatedDefinitions;</span><br><span class="line">				if (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">					Set&lt;String&gt; updatedSingletons &#x3D; new LinkedHashSet&lt;&gt;(this.manualSingletonNames);</span><br><span class="line">					updatedSingletons.remove(beanName);</span><br><span class="line">					this.manualSingletonNames &#x3D; updatedSingletons;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F; 仍然处于启动时的注册阶段</span><br><span class="line">			&#x2F;&#x2F; 所以这里走这个方法</span><br><span class="line">			&#x2F;&#x2F; beanDefinitionMap是工厂的一个属性，ConcurrentHashMap类型</span><br><span class="line">			&#x2F;&#x2F;他保存所有解析好的bean Definition的名称和实例的映射</span><br><span class="line">			&#x2F;&#x2F; Still in startup registration phase</span><br><span class="line">			this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			&#x2F;&#x2F;beanName也单独使用了一个ArrayList来保存，方便遍历</span><br><span class="line">			this.beanDefinitionNames.add(beanName);</span><br><span class="line">			&#x2F;&#x2F;如果该beanDefinition是手动注册的，还要从manualSingletonNames中移除beanDefinition的beanName</span><br><span class="line">			&#x2F;&#x2F;manualSingletonNames是LinkedHashSet</span><br><span class="line">			this.manualSingletonNames.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		this.frozenBeanDefinitionNames &#x3D; null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (existingDefinition !&#x3D; null || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看别名的注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerAlias(String name, String alias) &#123;</span><br><span class="line">	Assert.hasText(name, &quot;&#39;name&#39; must not be empty&quot;);</span><br><span class="line">	Assert.hasText(alias, &quot;&#39;alias&#39; must not be empty&quot;);</span><br><span class="line">	synchronized (this.aliasMap) &#123;</span><br><span class="line">		if (alias.equals(name)) &#123;</span><br><span class="line">			&#x2F;&#x2F;移除别名中的beanName</span><br><span class="line">			&#x2F;&#x2F;aliasMap是ConcurrentHashMap类型，保存别名和beanName的映射</span><br><span class="line">			this.aliasMap.remove(alias);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Alias definition &#39;&quot; + alias + &quot;&#39; ignored since it points to same name&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			String registeredName &#x3D; this.aliasMap.get(alias);</span><br><span class="line">			&#x2F;&#x2F;如果别名对应beanName已经被注册，则不需要再注册一次</span><br><span class="line">			&#x2F;&#x2F;别名不允许被覆盖</span><br><span class="line">			if (registeredName !&#x3D; null) &#123;</span><br><span class="line">				if (registeredName.equals(name)) &#123;</span><br><span class="line">					&#x2F;&#x2F; An existing alias - no need to re-register</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				if (!allowAliasOverriding()) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;Cannot define alias &#39;&quot; + alias + &quot;&#39; for name &#39;&quot; +</span><br><span class="line">							name + &quot;&#39;: It is already registered for name &#39;&quot; + registeredName + &quot;&#39;.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Overriding alias &#39;&quot; + alias + &quot;&#39; definition for registered name &#39;&quot; +</span><br><span class="line">							registeredName + &quot;&#39; with new target name &#39;&quot; + name + &quot;&#39;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;再检查一遍，aliasMap中不能已经存在name和alias</span><br><span class="line">			checkForAliasCircle(name, alias);</span><br><span class="line">			&#x2F;&#x2F;工厂的aliasMap属性保存别名，那么alias已被注册</span><br><span class="line">			this.aliasMap.put(alias, name);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Alias definition &#39;&quot; + alias + &quot;&#39; registered for name &#39;&quot; + name + &quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-13-加载xml文件beanDefinition流程图"><a href="#3-13-加载xml文件beanDefinition流程图" class="headerlink" title="3.13 加载xml文件beanDefinition流程图"></a>3.13 加载xml文件beanDefinition流程图</h2><p><img src="https://oscimg.oschina.net/oscnet/up-0a652bfc13671b2b64650cd88b8b2aec238.png" alt=""></p>
<h1 id="4-加载注解配置的beanDefinition"><a href="#4-加载注解配置的beanDefinition" class="headerlink" title="4 加载注解配置的beanDefinition"></a>4 加载注解配置的beanDefinition</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/" itemprop="url">Spring Resource资源文件体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-29T22:58:12+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/06/29/Spring-Resource资源文件体系/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Resource接口"><a href="#1-Resource接口" class="headerlink" title="1. Resource接口"></a>1. Resource接口</h1><p>Spring对于资源加载有着一套自己的框架——Resource，Resource继承自InputStream。<br>下面的是Resource的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public interface Resource extends InputStreamSource &#123;</span><br><span class="line">    boolean exists();&#x2F;&#x2F;判断资源是否存在</span><br><span class="line">    default boolean isReadable() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断资源是否打开</span><br><span class="line">    default boolean isOpen() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断资源是否是一个文件</span><br><span class="line">    default boolean isFile() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取资源文件的URL</span><br><span class="line">    URL getURL() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;获取资源文件的URI</span><br><span class="line">    URI getURI() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;获取资源文件的File对象</span><br><span class="line">    File getFile() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;这个方法接口中有默认实现，返回的是ReadableByteChannel，这个类属于Java的NIO中的管道。</span><br><span class="line">    default ReadableByteChannel readableChannel() throws IOException &#123;</span><br><span class="line">        return Channels.newChannel(getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取内容的长度，这个方法返回一个long，因为文件内容可能很长。</span><br><span class="line">    long contentLength() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;这个方法返回的是最后修改时间，虽然也返回的是long，但是这个数字是一个时间戳。</span><br><span class="line">    long lastModified() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;这个方法根据relativePath相对路径返回一个相对与该Resource的Resource。</span><br><span class="line">    Resource createRelative(String relativePath) throws IOException;</span><br><span class="line">    @Nullable</span><br><span class="line">    &#x2F;&#x2F;获取文件的名字。</span><br><span class="line">    String getFilename();</span><br><span class="line">    &#x2F;&#x2F;获取一个对该资源的一个描述。</span><br><span class="line">    String getDescription();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-Resource实现类"><a href="#2-Resource实现类" class="headerlink" title="2. Resource实现类"></a>2. Resource实现类</h1><p>你可以理解为，Resource就是一个增强版的InputStreamSource，Resource 接口是Spring资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略（策略模式）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-14643860b1762106730a60406986062587a.png" alt=""></p>
<ul>
<li>UrlResource:<ul>
<li>UrlResource封装了java.net.URL，可用于访问通常可通过url访问的任何对象，如文件、HTTP目标、FTP目标和其他对象。所有URL可以使用一个标准化前缀来表示一个URL类型。例如： file：用于访问文件系统路径。 http：用于通过HTTP协议访问资源。 ftp：用于通过FTP访问资源。</li>
</ul>
</li>
<li>ClassPathResource:<ul>
<li>表示从类路径加载资源。如果资源路径带上前缀ClassPath:，那么会隐式的解析为ClassPathResource。注意，如果类资源文件是在文件系统中，则该资源实现会被解析为java.io.File， 如果是在Jar包中，则会使用java.net.URL来解析。</li>
</ul>
</li>
<li>FileSystemResource:<ul>
<li>他是java.io.File和java.nio.file.Path的Resource实现，支持解析为File或者URL。如D:/aaa/vvv.java</li>
</ul>
</li>
<li>ServletContextResource:<ul>
<li>这是ServletContext的Resource实现，用于解释相关Web应用程序根目录中的相对路径。访问Web容器上下文中的资源而设计的类，负责对于Web应用根目录的路径加载资源。它支持以流和URL的方式访问，在WAR解包的情况下，也可以通过File方式访问。该类还可以直接从JAR包中访问资源。</li>
</ul>
</li>
<li>InputStreamResource:<ul>
<li>InputStreamResource 是InputStream 的Resource实现。只有在其他Resource实现不可用的时候才考虑使用它。和其他的Resource实现相反，它是一个already-opened resource的描述器，所以isOpen()会返回true。 如果你想保存资源描述器或者多次读取一个stream， 那么不要使用它。</li>
</ul>
</li>
<li>ByteArrayResource:<ul>
<li>是byte array的Resource实现， 它创建了ByteArrayInputStream。它对于从任何给定的字节数组加载内容都很有用，而不必求助于单次使用的InputStreamResource。</li>
</ul>
</li>
<li>PathResource:<ul>
<li>Spring4.0提供的读取资源文件的新类。Path封装了java.net.URL、java.nio.Path、文件系统资源，它使用户能够访问任何可以通过URL、Path、系统文件路径表示的资源，如文件系统的资源，HTTP资源、FTP资源等。</li>
</ul>
</li>
</ul>
<h1 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3. 使用示例"></a>3. 使用示例</h1><p>使用示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testResource() throws IOException &#123;</span><br><span class="line">    String filePath &#x3D; &quot;E:\\源码\\Spring源码阅读\\testSpring\\src\\test\\resources\\spring.txt&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 使用系统的文件路径方式加载文件</span><br><span class="line">    WritableResource resource1 &#x3D; new PathResource(filePath);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 使用类路径方式加载文件</span><br><span class="line">    Resource resource2 &#x3D; new ClassPathResource(&quot;spring.txt&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3. 使用WritableResource接口写资源文件</span><br><span class="line">    OutputStream os &#x3D; resource1.getOutputStream();</span><br><span class="line">    os.write(&quot;Spring是一套非常优秀的框架&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4. 使用Resource接口读文件</span><br><span class="line">    InputStream in1 &#x3D; resource1.getInputStream();</span><br><span class="line">    InputStream in2 &#x3D; resource1.getInputStream();</span><br><span class="line">    BufferedInputStream bis &#x3D; new BufferedInputStream(in1);</span><br><span class="line">    byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">    bis.read(bytes);</span><br><span class="line">    System.out.println(new String(bytes));</span><br><span class="line">    System.out.println(&quot;resource1: &quot; + resource1.getFilename());</span><br><span class="line">    System.out.println(&quot;resource2: &quot; + resource2.getFilename());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-资源路径通配符。"><a href="#4-资源路径通配符。" class="headerlink" title="4. 资源路径通配符。"></a>4. 资源路径通配符。</h1><p>Resource解析各种资源路径，依靠资源路径通配符可以带来很多方便。</p>
<h2 id="4-1-Ant-style-Patterns"><a href="#4-1-Ant-style-Patterns" class="headerlink" title="4.1 Ant-style Patterns"></a>4.1 Ant-style Patterns</h2><p>定义资源路径可以是用Ant风格的通配符，下面是 Ant-style patterns 的路径例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;WEB-INF&#x2F;*-context.xml</span><br><span class="line">com&#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml</span><br><span class="line">file:C:&#x2F;some&#x2F;path&#x2F;*-cont?xt.xml</span><br><span class="line">classpath:com&#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml</span><br></pre></td></tr></table></figure>

<p>Ant风格的资源地址支持三种通配符：</p>
<ul>
<li>?:匹配文件名中的一个字符</li>
<li>*：匹配文件名中的多个字符</li>
<li>**:匹配多层路径。</li>
</ul>
<h2 id="4-2-classpath-前缀"><a href="#4-2-classpath-前缀" class="headerlink" title="4.2 classpath*:前缀"></a>4.2 classpath*:前缀</h2><p>构造基于XML的ApplicationContext，路径地址可以使用classpath*: 前缀，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx &#x3D;</span><br><span class="line">    new ClassPathXmlApplicationContext(&quot;classpath*:conf&#x2F;appContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>classpath* 和 classpath 的区别是：classpath* 会去查找所有匹配的classpath， 而classpath 只会找到第一个匹配的资源。</p>
</blockquote>
<h1 id="5-ResourceLoader"><a href="#5-ResourceLoader" class="headerlink" title="5. ResourceLoader"></a>5. ResourceLoader</h1><p>不过有个问题随之而来，那就是Resource的选择，这么多的Resource如何知道选择使用哪一个？Spring提供了一个强大的资源加载机制，他可以通过前缀标识加载资源，如：classpath:, file:,ftp:等，同时还支持使用Ant风格的通配符。</p>
<p>ResourceLoader用来返回Resource实例，下面是其定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ResourceLoader &#123;</span><br><span class="line">    Resource getResource(String location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>前缀</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:</td>
<td>classpath:com/myapp/config.xml</td>
<td>使用ClassPathResource从classpath中加载。</td>
</tr>
<tr>
<td>file:</td>
<td>file:/data/config.xml</td>
<td>作为 URL 加载。使用UrlResource从文件系统目录中装载资源</td>
</tr>
<tr>
<td>http:</td>
<td><a href="http://myserver/logo.png" target="_blank" rel="noopener">http://myserver/logo.png</a></td>
<td>作为 URL 加载。使用UrlResource从Web服务器中装载资源</td>
</tr>
<tr>
<td>ftp:</td>
<td><a href="ftp://www.mcwebsite.top/bean.xml">ftp://www.mcwebsite.top/bean.xml</a></td>
<td>作为 URL 加载。使用UrlResource从ftp服务器中装载资源</td>
</tr>
<tr>
<td>(none)</td>
<td>/data/config.xml</td>
<td>根据ApplicationContext的具体实现选择对应类型的Resource</td>
</tr>
</tbody></table>
<p>上表中最后一种情况，需要说明下：</p>
<p>所有的<strong>ApplicationContext</strong>都实现了ResourceLoader类。因此所有的ApplicationContext都可以用来获取Resource。</p>
<p>当在特定的应用程序上下文上调用getResource（），并且指定的位置路径没有特定的前缀时，将返回适合该特定应用程序上下文的资源类型。</p>
<p>例如，假设对ClassPathXmlApplicationContext实例执行了以下代码片段：</p>
<p><code>Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);</code></p>
<p>在ClassPathXmlApplicationContext中，这个方法返回ClassPathResource。</p>
<p>以此类推，在FileSystemXmlApplicationContext中，方法返回FileSystemResource。在WebApplicationContext， 方法返回ServletContextResource。</p>
<p>当然，就像我们表中说的，我们可以强制使用ClassPathResource，而不管ApplicationContext到底是什么。这样做的话，我们需要添加classpath:前缀。如下：</p>
<p><code>Resource template = ctx.getResource(&quot;classpath:some/resource/path/myTemplate.txt&quot;);</code></p>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>同样的，你可以强制使用UrlResource通过添加标准的java.net.URL前缀(context-param配置的话同理):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource template &#x3D; ctx.getResource(&quot;file:&#x2F;&#x2F;&#x2F;some&#x2F;resource&#x2F;path&#x2F;myTemplate.txt&quot;);</span><br><span class="line"></span><br><span class="line">Resource template &#x3D; ctx.getResource(&quot;https:&#x2F;&#x2F;myhost.com&#x2F;resource&#x2F;path&#x2F;myTemplate.txt&quot;);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/" itemprop="url">Spring IoC概念分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T22:55:51+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/25/Spring-IoC概念分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  13k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  50
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-IoC概念简介"><a href="#1-IoC概念简介" class="headerlink" title="1. IoC概念简介"></a>1. IoC概念简介</h1><p>IoC是随着近年来轻量级容器（Lightweight Container)的兴起而逐渐被很多人提起的一个名词，它的全称为Inversion of Control，中文通常翻译为“控制反转”。好莱坞原则“Don’t call us, we will call you.”恰如其分地表达了“反转”的意味，是用来形容IoC最多的一句话。</p>
<p>它不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</p>
<ul>
<li>正控：若要使用某个对象，需要自己去负责对象的创建</li>
<li>反控：若要使用某个对象，只需要从Spring容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-38d5b7469789631b0fa0fbc1e04e2dfb312.png" alt=""></p>
<h1 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h1><p>依赖注入（Dependency Injection，简称DI），2004年，Martin Fowler探讨了一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“<strong>获得依赖对象的过程被反转了</strong>”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IoC容器主动注入。</p>
<p>于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IoC的方法：<strong>注入</strong>——所谓依赖注入，就是由IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p>所以，依赖注入(DI)和控制反转(IoC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p>
<p><strong>或者说，IoC是一种思想，是一种目标，而DI这时一种手段，一种过程</strong>。</p>
<h2 id="2-1-理论上的依赖注入方式"><a href="#2-1-理论上的依赖注入方式" class="headerlink" title="2.1 理论上的依赖注入方式"></a>2.1 理论上的依赖注入方式</h2><p>在学术理论上，依赖注入有三种实现方式：</p>
<h3 id="2-1-1-三种注入的方式"><a href="#2-1-1-三种注入的方式" class="headerlink" title="2.1.1 三种注入的方式"></a>2.1.1 三种注入的方式</h3><p>当你来到酒吧，想要喝杯啤酒的时候，通常会直接招呼服务生，让他为你送来一杯清凉的啤酒。同样地，作为被注入对象，要想让IoC容器为其提供服务，并将所需要的被依赖对象送过来，也需要通过某种方式通知对方。</p>
<p>这里就牵涉到了三种依赖注入的方式：</p>
<ol>
<li><strong>构造方法注入</strong><ul>
<li>顾名思义，构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表，让外部（通常是IoC容器）知道它需要哪些依赖对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FXNewsProvider(IFXNewsListener newsListner,IFXNewsPersister newsPersister) &#123;</span><br><span class="line">	this.newsListener &#x3D; newsListner;</span><br><span class="line">	this.newPersistener &#x3D; newsPersister;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>IoC Service Provider会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。同一个对象是不可能被构造两次的，因此，被注入对象的构造乃至其整个生命周期，应该是由IoC Service Provider来管理的。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</li>
<li><blockquote>
<p>这就好比你刚进酒吧的门，服务生已经将你喜欢的啤酒摆上了桌面一样。坐下就可马上享受一份清凉与惬意。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>setter 方法注入</strong><ul>
<li>对于JavaBean对象来说，通常会通过setXXX()和getXXX()方法来访问对应属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FXNewsProvider&#123;</span><br><span class="line">	private IFXNewsListener newsListener;</span><br><span class="line"></span><br><span class="line">	public IFXNewsListener getNewsListener() &#123;</span><br><span class="line">	return newsListener;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNewsListener(IFXNewsListener newsListener) &#123;</span><br><span class="line">	this.newsListener &#x3D; newsListener;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样，外界就可以通过调用setNewsListener方法为FXNewsProvider对象注入所依赖的对象了。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再注入。</li>
<li><blockquote>
<p>这就好比你可以到酒吧坐下后再决定要点什么啤酒，可以要百威，也可以要青岛，随意性比较强。如果你不急着喝，这种方式当然是最适合你的。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>接口注入</strong><ul>
<li><strong>首先注意，因为代码侵入性高，所以这种方式Spring框架不支持，只要了解即可。</strong></li>
<li>相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service  Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。</li>
<li>FXNewsProvider为了让IoC Service Provider为其注入所依赖的IFXNewsListener，首先需要实现IFXNewsListenerCallable接口，这个接口会声明一个injectNewsListner方法（方法名随意），该方法的参数，就是所依赖对象的类型。这样，InjectionServiceContainer对象，即对应的IoC Service Provider就可以通过这个接口方法将依赖对象注入到被注入对象FXNewsProvider当中。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-cbadc8320845789e72095140547d4c456b4.png" alt=""></li>
<li>接口注入方式最早并且使用最多的是在一个叫做Avalon的项目中，相对于前两种依赖注入方式，接口注入比较死板和烦琐。如果需要注入依赖对象，被注入对象就必须声明和实现另外的接口。</li>
<li><blockquote>
<p>这就好像你同样在酒吧点啤酒，为了让服务生理解你的意思，你就必须戴上一顶啤酒杯式的帽子<img src="https://oscimg.oschina.net/oscnet/up-020c50b28bcf338955887894a8dccdd5b1e.png" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-三种注入方式的比较"><a href="#2-1-2-三种注入方式的比较" class="headerlink" title="2.1.2 三种注入方式的比较"></a>2.1.2 三种注入方式的比较</h3><ol>
<li>接口注入：<ul>
<li>从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter方法注入则不需要如此。</li>
</ul>
</li>
<li>构造方法注入：<ul>
<li>这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以马上使用。</li>
<li>缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。</li>
</ul>
</li>
<li>setter方法注入：<ul>
<li>因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。另外，setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。</li>
<li>缺点当然就是对象无法在构造完成后马上进入就绪状态。</li>
</ul>
</li>
</ol>
<p>综上所述，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式；而接口注入因为侵入性较强，近年来已经不流行了。</p>
<h2 id="2-2-Spring的依赖注入方式"><a href="#2-2-Spring的依赖注入方式" class="headerlink" title="2.2 Spring的依赖注入方式"></a>2.2 Spring的依赖注入方式</h2><p>因为代码侵入性高的问题，接口注入的方式，spring框架并不支持。Spring的依赖注入方式只有构造方法注入和setter方法注入：</p>
<ol>
<li>构造方法<ul>
<li>开箱即用，适合用于注入实例必须的初始值时使用，但是当参数列表较长时难以维护和使用。构造方法无法被继承，也无法设置默认值。适合较固定的对象使用。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.spring.test.di.LoginImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.spring.test.di.LoginAction"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructorarg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"login"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor­arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>setter方法<ul>
<li>适合依赖对象多，且组成对象灵活多变的场景，是目前最为常见的注入方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;login&quot; class&#x3D;&quot;com.spring.test.di.LoginImpl&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;loginAction&quot; class&#x3D;&quot;com.spring.test.di.LoginAction&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;login&quot; ref&#x3D;&quot;login&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="3-IoC-Service-Provider"><a href="#3-IoC-Service-Provider" class="headerlink" title="3. IoC Service Provider"></a>3. IoC Service Provider</h1><p>了解了IoC和DI的概念中，我们可以知道，在DI的过程中，IoC Service Provider是一个非常重要的概念——业务对象可以通过IoC方式声明相应的依赖，但是最终仍然需要通过某种角色或者服务将这些相互依赖的对象绑定到一起，IoC Service Provider就是这样一个角色。</p>
<p>IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或者IoC容器实现。Spring的IoC容器就是一个提供依赖注入服务的IoC Service Provider。</p>
<h2 id="3-1-IoC-Service-Provider的职责"><a href="#3-1-IoC-Service-Provider的职责" class="headerlink" title="3.1 IoC Service Provider的职责"></a>3.1 IoC Service Provider的职责</h2><p>IoC Service Provider的职责相对来说比较简单，主要有两个：</p>
<ol>
<li>业务对象的注册管理。<ul>
<li>在IoC场景中，业务对象无需关心所依赖的对象如何构建如何取得，但这部分工作始终需要有人来做。所以，IoC Service Provider需要识别这部分需要管理的对象，并且将这些对象的构建逻辑从客户端对象那里剥离出来，以免这部分逻辑污染业务对象的实现。</li>
</ul>
</li>
<li>业务对象间的依赖绑定。<ul>
<li>IoC Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状态。</li>
</ul>
</li>
</ol>
<h2 id="3-2-常见IoC-Service-Provider依赖注册方式"><a href="#3-2-常见IoC-Service-Provider依赖注册方式" class="headerlink" title="3.2 常见IoC Service Provider依赖注册方式"></a>3.2 常见IoC Service Provider依赖注册方式</h2><p>那么，对于IoC Service Provider来说，如何知道哪些对象是被其他对象依赖（即需要它管理起来的）的呢？又是如何知道某个管理的对象，具体要注入到哪一个具体的其他对象中呢？就像一个资深的酒吧服务员，客人点了哪些酒，且每一杯酒分别是被哪个客人点的，他都要了然于心，这时如何做到的呢？</p>
<p>很显然，我们需要记录下来这些的“服务信息”(在Spring的术语中，把BeanFactory需要使用的对象注册和依赖绑定信息称为<strong>Configuration Metadata</strong>)，当前流行的IoC Service Provider产品使用的Configuration Metadata的方式主要有以下几种：</p>
<ol>
<li><strong>直接编码方式</strong><ul>
<li>当前大部分的IoC容器都应该支持直接编码方式，比如PicoContainer、Spring、Avalon等。在容器启动之前，我们就可以通过程序编码的方式将被注入对象和依赖对象注册到容器中，并明确它们相互之间的依赖注入关系。</li>
</ul>
</li>
<li><strong>配置文件方式</strong><ul>
<li>这是一种较为普遍的依赖注入关系管理方式。像普通文本文件、properties文件、XML文件等，都可以成为管理依赖注入关系的载体。不过，最为常见的，还是通过XML文件来管理对象注册和对象间依赖关系，比如Spring IoC容器和在PicoContainer基础上扩展的NanoContainer，都是采用XML文件来管理和保存依赖注入信息的。</li>
</ul>
</li>
<li><strong>元数据方式（注解）</strong><ul>
<li>这种方式的代表实现是Google Guice，这是Bob Lee在Java 5的注解和Generic的基础上开发的一套IoC框架。我们可以直接在类中使用元数据信息来标注各个对象之间的依赖关系，然后由Guice框架根据这些注解所提供的信息将这些对象组装后，交给客户端对象使用。</li>
</ul>
</li>
</ol>
<h2 id="3-3-Spring-IoC-Service-Provider依赖注册方式"><a href="#3-3-Spring-IoC-Service-Provider依赖注册方式" class="headerlink" title="3.3 Spring IoC Service Provider依赖注册方式"></a>3.3 Spring IoC Service Provider依赖注册方式</h2><p>Spring IoC Service Provider的注册依赖方式同样是三种，也就是说，其他IoC Service Provider支持的主流的三种依赖注册方式，Spring都支持。</p>
<ol>
<li><strong>直接编码方式</strong><ul>
<li>使用<code>@Configuration</code>注解可以将java的类文件声明成spring的配置类，使用<code>@Bean</code>来声明方法的返回对象要注册为spring的bean对象。</li>
<li>而当bean中需要注入其他参数或者引用时，将其作为方法的参数即可，Spring会帮你注入这些引用。</li>
<li>默认情况下，方法名即为id名，当然也可以为bean指定名称，通过其<code>@Bean</code>注解的name属性。</li>
<li>同时<code>@Bean</code>注解的initMethod属性和destroyMethod属性，可以指定初始化和销毁时的生命周期回调函数。</li>
<li>而<code>@Scope</code>和<code>@Description</code>注解，则可以给bean设置Scope和Description<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用@Configuration注解可以将java的类文件声明成spring的配置类</span><br><span class="line">@Configuration</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line"></span><br><span class="line">	@Bean &#x2F;&#x2F;你可以理解为定义一个String类型的bean，值是&quot;test&quot;，做依赖注入用。</span><br><span class="line">	public String username()&#123;</span><br><span class="line">		return &quot;test&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public List&lt;String&gt; tags()&#123;</span><br><span class="line">		List&lt;String&gt; tags &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">		tags.add(&quot;cool&quot;);</span><br><span class="line">		tags.add(&quot;nice&quot;);</span><br><span class="line">		return tags;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;使用@Bean 注解表明myBean需要交给Spring进行管理</span><br><span class="line">	&#x2F;&#x2F;如果未指定bean的id，默认采用的是 &quot;方法名&quot; + &quot;首字母小写&quot;的配置方式</span><br><span class="line">	&#x2F;&#x2F;name属性可以定义bean的id ; initMethod和destroyMethod属性指定初始化和销毁时的生命周期回调函数。</span><br><span class="line">	@Bean(name &#x3D; &quot;userInterfaceIml&quot; , initMethod &#x3D; &quot;init&quot; , destroyMethod &#x3D; &quot;cleanup&quot;)</span><br><span class="line">	@Scope(&quot;prototype&quot;) &#x2F;&#x2F;指定该bean的scope</span><br><span class="line">	@Description(&quot;Provides a basic example of a bean&quot;) &#x2F;&#x2F;指定该bean的description</span><br><span class="line">	public UserInterface userInterface()&#123;</span><br><span class="line">		return new UserInterfaceImpl();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	&#x2F;&#x2F;通过参数列表，将bean的依赖注入</span><br><span class="line">	public UserCall userCall(UserInterface userInterface, String username, List&lt;String&gt; tags)&#123;</span><br><span class="line">		UserCall uc &#x3D; new UserCall();</span><br><span class="line">		uc.setUi(userInterface);</span><br><span class="line">		uc.setUsername(username);</span><br><span class="line">		uc.setTags(tags);</span><br><span class="line">		return uc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>配置文件方式</strong><ul>
<li>Spring使用XML文件来管理和保存依赖注入信息，配置组件bean的话只需要使用<code>&lt;bean&gt;</code>标签即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userInterface&quot; class&#x3D;&quot;com.springbean.impl.UserInterfaceImpl&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用构造器注入。使用构造器注入的时候必须在类中存在对应的构造方法才能有效</span><br><span class="line">&lt;util:list id&#x3D;&quot;tagsList&quot;&gt;</span><br><span class="line">	&lt;value&gt;cool&lt;&#x2F;value&gt;</span><br><span class="line">	&lt;value&gt;nice&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;util:list&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;userCall&quot; class&#x3D;&quot;com.springbean.UserCall&quot;&gt;</span><br><span class="line">	&lt;constructor-arg name&#x3D;&quot;ui&quot; ref&#x3D;&quot;userInterface&quot;&#x2F;&gt;</span><br><span class="line">	&lt;constructor-arg name&#x3D;&quot;username&quot; value&#x3D;&quot;test&quot;&#x2F;&gt;</span><br><span class="line">	&lt;constructor-arg name&#x3D;&quot;tags&quot; ref&#x3D;&quot;tagsList&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用属性注入</span><br><span class="line">&lt;bean id&#x3D;&quot;userCall&quot; class&#x3D;&quot;com.springbean.UserCall&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;ui&quot; ref&#x3D;&quot;userInterface&quot; &#x2F;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;test&quot; &#x2F;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;tags&quot; value&#x3D;&quot;tagsList&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>元数据方式（注解）</strong><ul>
<li>spring支持通过注解方式管理依赖，但是需要指定spring扫描注解的包，指定扫描的包有两种方式<ol>
<li>可以在Spring的xml文件中配置（前提是引入了Spring context的命名空间），使用<code>&lt;context:component-scan base-package=&quot;com.springbean.*&quot;/&gt;</code></li>
<li>注解@ComponentScan指定了spring将扫描这个配置类所在的包及其子包下面的所有类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan</span><br><span class="line">public class SpringConfig &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>有了组件扫描后，所有被注解@Component或者它衍生的注解标记类都将被识别为组件类，他们完善了spring通过注解来注册依赖的功能：<ul>
<li>@Component: 自动被comonent扫描。 表示被注解的类会自动被component扫描</li>
<li>@Repository: 用于持久层，主要是数据库存储库。</li>
<li>@Service: 表示被注解的类是位于业务层的业务component。</li>
<li>@Controller:表明被注解的类是控制component，主要用于展现层 。</li>
</ul>
</li>
<li>除此之外，spring使用注解<code>@Autowired</code>等完成依赖装配：<ul>
<li>@Autowired：支持按类型自动转配</li>
<li>@Qualifier：根据byName的方式自动装配，其中@Qualifier不能单独使用。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	@Autowired</span><br><span class="line">	@Qualifier(value&#x3D;&quot;carXXX&quot;)</span><br><span class="line">	private Cat cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>@Resource（这个注解属于J2EE的）：<strong>如果同时指定了name和type</strong>，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常;<strong>如果指定了name</strong>，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常;如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常;<strong>如果既没有指定name，又没有指定type</strong>，则自动按照byName方式(字段名)进行装配；<strong>如果没有匹配</strong>，则回退为一个原始类型进行匹配，如果匹配则自动装配；  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	@Resource</span><br><span class="line">	private Cat cat;</span><br><span class="line">	@Resource(name&#x3D;&quot;dogXXX&quot;)</span><br><span class="line">	private Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="4-Spring的IoC容器"><a href="#4-Spring的IoC容器" class="headerlink" title="4. Spring的IoC容器"></a>4. Spring的IoC容器</h1><p>上文中，我们从浅到深，从思想到概念，了解了DI过程中的一个重要的角色——IoC Service Provider。</p>
<p><strong>IoC Service Provider只是一个概念，不同的框架，对IoC Service Provider的具体的实现也是五花八门，接下来我们了解一个完成度高，重要性高且知名度极高的IoC Service Provider实现产品——Spring IoC容器</strong>。</p>
<p>Spring的IoC容器是一个IoC Service Provider，但不止是一个IoC Service Provider，作为轻量级容器，Spring的IoC容器还提供了IoC之外的支持。如在Spring的IoC容器之上，Spring还提供了相应的AOP框架支持、企业级服务集成等服务。Spring的IoC容器和IoC Service Provider所提供的服务之间存在一定的交集，二者的关系如图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-632d868bd3dc83060bd4dea30a7839f43c3.png" alt=""></p>
<h2 id="4-1-Spring-IoC容器类型"><a href="#4-1-Spring-IoC容器类型" class="headerlink" title="4.1 Spring IoC容器类型"></a>4.1 Spring IoC容器类型</h2><p>Spring提供了两种容器类型：BeanFactory和ApplicationContext。</p>
<ol>
<li><strong>BeanFactory</strong>。<ul>
<li>基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，<strong>默认采用延迟初始化策略（lazy-load）</strong>。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</li>
</ul>
</li>
<li><strong>ApplicationContext</strong>。<ul>
<li>ApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如<strong>事件发布</strong>、<strong>国际化信息支持</strong>等，这些会在后面详述。ApplicationContext所管理的对象，在该类型容器启动之后，<strong>默认全部初始化并绑定完成</strong>。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</li>
</ul>
</li>
</ol>
<blockquote>
<p>ApplicationContext包含BeanFactory的所有功能，<strong>几乎所有的应用系统都选择ApplicationContext而不是BeanFactory</strong>。只有在资源很少的情况下，才会考虑采用BeanFactory，如在移动设备上等。</p>
</blockquote>
<p>通过下图，我们可以对BeanFactory和ApplicationContext之间的关系有一个更清晰的认识：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dfda2270ce6b3b965c4c3f1ffd5420d98c6.png" alt=""></p>
<h3 id="4-1-1-BeanFactory"><a href="#4-1-1-BeanFactory" class="headerlink" title="4.1.1 BeanFactory"></a>4.1.1 BeanFactory</h3><blockquote>
<p>在没有特殊指明的情况下，以BeanFactory为中心所讲述的内容同样适用于ApplicationContext，这一点需要明确一下，二者有差别的地方会在合适的位置给出解释。</p>
</blockquote>
<p>BeanFactory，顾名思义，就是生产Bean的工厂。BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零件送入这个汽车生产厂，最后，只需要从生产线的终点取得成品汽车就可以了。至于业务对象如何组装，你不需要关心。</p>
<p>BeanFactory只是个interface，它核心实现，在DefaultListableBeanFactory实现类中。BeanFactory声明了如下的方法：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7bfb551900305838e32ce2559d6ad2b3c9d.png" alt=""></p>
<p>通过方法名我们也能大概了解每个方法的作用，基本上都是查询相关的方法，例如，取得某个对象的方法（getBean）、查询<br>某个对象是否存在于容器中的方法（containsBean），或者取得某个bean的状态或者类型的方法等。</p>
<p>这些api使得我们可以非常方便的从容器中获取特定类型的bean。那么，BeanFactory如何知道它需要管理和生成哪些bean呢？被托管的bean又是如何注册的呢？后文我们会就bean的注册/绑定/注入做深入介绍。</p>
<h3 id="4-1-2-ApplicationContext"><a href="#4-1-2-ApplicationContext" class="headerlink" title="4.1.2 ApplicationContext"></a>4.1.2 ApplicationContext</h3><p>作为Spring提供的较之BeanFactory更为先进的IoC容器实现，<strong>ApplicationContext是BeanFactory的子类，故而ApplicationContext拥有BeanFactory支持的所有功能</strong>，但除此之外，还进一步扩展了基本容器的功能，如：更易与Spring AOP集成，容器启动后bean实例的自动初始化、国际化的信息支持、容器内事件发布等；</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-def463323553c42f7902c8107e524f8cea7.png" alt=""></p>
<h2 id="4-2-spring-bean和bean定义"><a href="#4-2-spring-bean和bean定义" class="headerlink" title="4.2 spring bean和bean定义"></a>4.2 spring bean和bean定义</h2><p>java bean对我们来说十分熟悉，我们把符合下面四点的java对象叫做java bean。</p>
<ol>
<li>所有属性为private</li>
<li>提供默认构造方法</li>
<li>提供getter和setter</li>
<li>实现serializable接口</li>
</ol>
<h3 id="4-2-1-spring中的bean"><a href="#4-2-1-spring中的bean" class="headerlink" title="4.2.1 spring中的bean"></a>4.2.1 spring中的bean</h3><p>spring中的bean是基于java bean概念的延伸，但为了更好的实现bean的注册/绑定/注入，spring bean的定义显然不能止步于此，为了更好的管理bean，spring在bean上做了许多拓展，不仅对bean本身的属性做纵向拓展，在横向的种类上，也按照不同的职责划分，定义了许多“专业”的，有特点功能的bean。</p>
<blockquote>
<p>注意，特殊的bean也是基于普通bean的拓展，普通bean拥有的特点，特殊bean都有。</p>
</blockquote>
<h4 id="4-2-1-1-普通的spring-bean"><a href="#4-2-1-1-普通的spring-bean" class="headerlink" title="4.2.1.1 普通的spring bean"></a>4.2.1.1 普通的spring bean</h4><p>为了应对许多不同的场景，我们在配置spring bean的Configuration Metadata的时候，需要定义bean的许多属性来达到不同的目的，故而我们有必要了解spring为bean定义了哪些属性可用。</p>
<ol>
<li><p>id属性</p>
<ul>
<li>通常，每个注册到容器的对象都需要一个唯一标志来将其与“同处一室”的“兄弟们”区分开来，就好像我们每一个人都有一个身份证号一样（重号的话就比较麻烦）。通过id属性来指定当前注册对象的beanName是什么。</li>
<li><code>&lt;bean id=&quot;djNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt;</code></li>
</ul>
</li>
<li><p>name属性</p>
<ul>
<li>除了可以使用id来指定<code>&lt;bean&gt;</code>在容器中的标志，还可以使用name属性来指定<code>&lt;bean&gt;</code>的别名（alias）</li>
<li>与id属性相比，name属性的灵活之处在于，name可以使用id不能使用的一些字符，比如/。而且还可以通过逗号、空格或者冒号分割指定多个name。</li>
<li><code>&lt;bean id=&quot;djNewsListener&quot; name=&quot;/news/djNewsListener,dowJonesNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt;</code></li>
</ul>
</li>
<li><p>class属性</p>
<ul>
<li>每个注册到容器的对象都需要通过<code>&lt;bean&gt;</code>元素的class属性指定其类型，否则，容器可不知道这个对象到底是何方神圣。</li>
<li>在大部分情况下，该属性是必须的。仅在少数情况下不需要指定，如后面将提到的在使用抽象配置模板的情况下。</li>
<li><code>&lt;bean id=&quot;djNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt;</code></li>
</ul>
</li>
<li><p>scope属性</p>
<ul>
<li>scope用来声明容器中的对象所应该处的限定场景或者说该对象的存活时间，即容器在对象进入其相应的scope之前，生成并装配这些对象，在该对象不再处于这些scope的限定之后，容器通常会销毁这些对象。</li>
<li>Spring容器最初提供了两种bean的scope类型：singleton和prototype，但发布2.0之后，又引入了另外三种scope类型，即request、session和global session类型。不过这三种类型有所限制，只能在Web应用中使用。</li>
<li><code>&lt;bean id=&quot;mockObject2&quot; class=&quot;...MockBusinessObject&quot; scope=&quot;prototype&quot;/&gt;</code><ol>
<li><strong>singleton</strong>：单例的意思。即标记为拥有singleton scope的对象定义，在Spring的IoC容器中只存在一个实例，所有对该对象的引用将共享这个实例。该实例从容器启动，并因为第一次被请求而初始化之后，将一直存活到容器退出。</li>
<li><strong>prototype</strong>：容器在接到该类型对象的请求的时候，会每次都重新生成一个新的对象实例给请求方。虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不再拥有当前返回对象的引用，请求方需要自己负责当前返回对象的后继生命周期的管理工作，包括该对象的销毁。</li>
<li><strong>request、session和global session</strong>：这三个scope类型是Spirng 2.0之后新增加的，它们不像之前的singleton和prototype那么“通用”，因为它们只适用于Web应用程序，通常是与XmlWebApplicationContext共同使用。三者的作用域顾名思义，分别对应web应用的request、session和global session。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="4-2-1-2-FactoryBean"><a href="#4-2-1-2-FactoryBean" class="headerlink" title="4.2.1.2 FactoryBean"></a>4.2.1.2 FactoryBean</h4><p>FactoryBean是我们接触到的第一个特殊bean，首先它是一个Bean（这表示spring bean的定义它都有），但又不仅仅是一个Bean（它有特殊功能）。<strong>它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式</strong>。它能在需要的时候“改装”一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>
<blockquote>
<p>简而言之，factoryBean是一个bean，一个拥有简单bean工厂职能的bean。</p>
</blockquote>
<p>FactoryBean是一个接口，它只定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个方法最核心的 getObject()方法，其他两个方法都服务于它。</p>
<p>那么FactoryBean有什么作用呢？？</p>
<p>我们知道，在spring Ioc容器中getBean的时候，底层是通过java的反射机制调用bean的构造器来new一个对象返回，如果我希望从容器中返回的对象不是新new出来的对象，而是某个我指定的对象呢？？</p>
<p>比如我们需要从容器中获取一辆车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Car&#123;</span><br><span class="line">	private String color;</span><br><span class="line">	public Car() &#123;</span><br><span class="line">		this.color &#x3D; &quot;黑色&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	...   &#x2F;&#x2F;set&#x2F;get方法省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为反射都是调用无参构造器来new对象，所以我们只能得到一辆黑色的车，那我如果想要一辆白色的车呢？</p>
<p>我们现有的beanFactory只支持生产默认的黑色的车，那为了得到白色的车，我们得拥有指定想要哪台车的能力，如何指定呢？</p>
<p>我们知道，在对象的概念中，A extends B表示的是A是B； A implements B表示的是A有B提供的能力。我们希望我们在提车时可以自己选择自己想要的车，而FactoryBean就提供了这种能力。</p>
<p>Car类实现了FactoryBean，就表示告诉spring IoC：当beanFactory按照Car类的图纸（beanDefinition，下文将详细描述）来生产Car的实例的时候，如果发现我的图纸上有注明要指定我想要的汽车（即实现FactoryBean接口），那么beanFactory就得按照我的要求来生产我制定的汽车。</p>
<p>这时候，我们的“图纸”可以这么定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Car implements FactoryBean&lt;Car&gt;&#123;</span><br><span class="line">	private String color;</span><br><span class="line">	public Car() &#123;</span><br><span class="line">		this.color &#x3D; &quot;黑色&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	...   &#x2F;&#x2F;set&#x2F;get方法省略</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;这座新工厂，要生产白色的车</span><br><span class="line">	@Override</span><br><span class="line">	public Car getObject() throws Exception &#123;</span><br><span class="line">		Car car&#x3D;new Car();</span><br><span class="line">		car.setColor(&quot;白色&quot;);</span><br><span class="line">		return car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		return Car.class;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;表示我要的白车，在全局中单例</span><br><span class="line">	@Override</span><br><span class="line">	public boolean isSingleton() &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候你从容器中取出来的Car类型的实例，都会是白车了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes &#x3D; TestApplication.class)</span><br><span class="line">public class FactoryBeanTest &#123;</span><br><span class="line">	@Autowired</span><br><span class="line">	private ApplicationContext context;</span><br><span class="line">	@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		Car car1 &#x3D; (Car) context.getBean(&quot;car&quot;);</span><br><span class="line">		System.out.println(&quot;car1 &#x3D; &quot; + car1.getColor());</span><br><span class="line">		如果要获取Car非定制的实例，那么需要在名称前面加上&#39;&amp;&#39;符号。</span><br><span class="line">		 Car car2 &#x3D; (Car) context.getBean(&quot;&amp;car&quot;);</span><br><span class="line">		System.out.println(&quot;car2 &#x3D; &quot; + car2.getColor());</span><br><span class="line">		System.out.println(&quot;car1.equals(car2) &#x3D; &quot; + car1.equals(car2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<blockquote>
<p>car1 = 白色<br>car2 = 黑色<br>car1.equals(car2) = false</p>
</blockquote>
<p>说了这么多，为什么要有FactoryBean这个东西呢，有什么具体的作用吗？</p>
<p>其实FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。</p>
<p>我们知道AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的反射机制，在运行时指定了一个定制的代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。</p>
<p>所以，FactoryBean为我们实例化Bean提供了一个更为灵活的方式，我们可以通过FactoryBean创建出更为复杂的Bean实例。</p>
<h3 id="4-2-2-BeanDefinition"><a href="#4-2-2-BeanDefinition" class="headerlink" title="4.2.2 BeanDefinition"></a>4.2.2 BeanDefinition</h3><p>在Java中，一切皆对象。在JDK中使用java.lang.Class来描述类这个对象。</p>
<p>在Spring中，存在bean这样一个概念，那Spring又是怎么抽象bean这个概念，用什么类来描述bean这个对象呢？<strong>Spring使用BeanDefinition来描述bean</strong>。</p>
<p>顾名思义，BeanDefinition就是Spring对bean的定义对象，spring从Configuration Metadata中读取bean的配置，包括它的beanName，是否是单例，具体指向哪个类，是否是懒加载，有哪些依赖等等信息，都存在BeanDefinition对象中，<strong>BeanDefinition就是beanFactory生产bean的图纸</strong>。</p>
<p>将bean定义成BeanDefinition后，spring对bean的操作就可以改为对BeanDefinition进行，比如拿到某个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-607d2dbaeff31870bdaf8d3404790f1302a.png" alt=""></p>
<p>BeanDefinition实现了AttributeAccessor和BeanMetadataElement接口。在Spring中充斥着大量的各种接口，每种接口都拥有不同的能力，某个类实现了某个接口，也就相应的拥有了某种能力:</p>
<ol>
<li>AttributeAccessor：顾名思义，这是一个属性访问者，它提供了对外访问属性的能力。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-1e6fbda257ebbc736e6475307b00b438cd9.png" alt=""></li>
</ul>
</li>
<li>BeanMetadataElement：提供了获取元数据元素的配置源对象的能力。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-81004107878dac4a14374dfc66dd2ac4b44.png" alt=""></li>
</ul>
</li>
</ol>
<p>BeanDefinition的属性和方法如下图所示，大部分方法/属性的作用都能简单从名字区分出来，部分方法的作用，我们下面来简单介绍。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-06c3268fc33840829f3be778fd91baf5fef.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于描述一个具体bean实例</span><br><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line">    &#x2F;&#x2F;scope值，单例</span><br><span class="line">    String SCOPE_SINGLETON &#x3D; ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;scope值，非单例</span><br><span class="line">    String SCOPE_PROTOTYPE &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Bean角色：</span><br><span class="line">    &#x2F;&#x2F;用户</span><br><span class="line">    int ROLE_APPLICATION &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;某些复杂的配置</span><br><span class="line">    int ROLE_SUPPORT &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F;完全内部使用</span><br><span class="line">    int ROLE_INFRASTRUCTURE &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回此bean定义的父bean定义的名称，如果有的话 &lt;bean parent&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String getParentName();</span><br><span class="line">    void setParentName(String parentName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取bean对象className &lt;bean class&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String getBeanClassName();</span><br><span class="line">    void setBeanClassName(String beanClassName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义创建该Bean对象的工厂类  &lt;bean factory-bean&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F;如果该 Bean 采用工厂方法生成，指定工厂名称。</span><br><span class="line">    String getFactoryBeanName();</span><br><span class="line">    void setFactoryBeanName(String factoryBeanName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义创建该Bean对象的工厂方法 &lt;bean factory-method&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String getFactoryMethodName();</span><br><span class="line">    void setFactoryMethodName(String factoryMethodName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&lt;bean scope&#x3D;&quot;singleton&#x2F;prototype&quot;&gt;</span><br><span class="line">    String getScope();</span><br><span class="line">    void setScope(String scope);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;懒加载 &lt;bean lazy-init&#x3D;&quot;true&#x2F;false&quot;&gt;</span><br><span class="line">    boolean isLazyInit();</span><br><span class="line">    void setLazyInit(boolean lazyInit);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;依赖对象  &lt;bean depends-on&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String[] getDependsOn();</span><br><span class="line">    void setDependsOn(String[] dependsOn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否为被自动装配 &lt;bean autowire-candidate&#x3D;&quot;true&#x2F;false&quot;&gt;</span><br><span class="line">    boolean isAutowireCandidate();</span><br><span class="line">    void setAutowireCandidate(boolean autowireCandidate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否为主候选bean    使用注解：@Primary。</span><br><span class="line">    &#x2F;&#x2F;同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span><br><span class="line">    boolean isPrimary();</span><br><span class="line">    void setPrimary(boolean primary);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回此bean的构造函数参数值。</span><br><span class="line">    ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取普通属性集合</span><br><span class="line">    MutablePropertyValues getPropertyValues();</span><br><span class="line">    &#x2F;&#x2F;是否为单例</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">    &#x2F;&#x2F;是否为原型</span><br><span class="line">    boolean isPrototype();</span><br><span class="line">    &#x2F;&#x2F;是否为抽象类</span><br><span class="line">    &#x2F;&#x2F; 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br><span class="line">   &#x2F;&#x2F; 常用于作为 父bean 用于继承，其实也很少用......</span><br><span class="line">    boolean isAbstract();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取这个bean的应用</span><br><span class="line">    int getRole();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回对bean定义的可读描述。</span><br><span class="line">    String getDescription();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回该bean定义来自的资源的描述（用于在出现错误时显示上下文）</span><br><span class="line">    String getResourceDescription();</span><br><span class="line"></span><br><span class="line">    BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinition接口有诸多的实现类，不同的实现类，使用的场景也不尽相同：<br><img src="https://oscimg.oschina.net/oscnet/up-721e187dbcf42aebbc3aca0d339e18062e8.png" alt=""></p>
<ol>
<li>AbstractBeanDefinition，是BeanDefinition的主要实现类，也是所有bean定义的父类。</li>
<li>RootBeanDefinition，是在XML配置时代，注册bean定义时用的类。</li>
<li>ChildBeanDefinition，是在XML配置时代，注册bean定义时用的类，必须在配置时指定一个父bean定义。</li>
<li>GenericBeanDefinition，在注解配置时代，推荐使用的bean定义类，可以在运行时动态指定一个父bean定义，也可以不指定。</li>
<li>AnnotatedGenericBeanDefinition，在注解配置时代，通过编程方式注册bean定义时用的类，继承了GenericBeanDefinition。</li>
<li>ScannedGenericBeanDefinition，在注解配置时代，通过扫描jar包中.class文件的方式注册bean定义时用的类，继承了GenericBeanDefinition。</li>
</ol>
<h2 id="4-3-Spring-IoC容器流程"><a href="#4-3-Spring-IoC容器流程" class="headerlink" title="4.3 Spring IoC容器流程"></a>4.3 Spring IoC容器流程</h2><p>Spring的IoC容器所起的作用，就像下图所展示的那样，它会以某种方式加载Configuration Metadata（通常也就是XML格式的配置信息），然后根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-53938a98292785a01ef1731f32901f4f490.png" alt=""></p>
<p>Spring的IoC容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即容器启动阶段和Bean实例化阶段</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f7c9a513d97f0f4e5abcb2e1f809d42d016.png" alt=""></p>
<h3 id="4-3-1-容器启动阶段"><a href="#4-3-1-容器启动阶段" class="headerlink" title="4.3.1 容器启动阶段"></a>4.3.1 容器启动阶段</h3><ol>
<li><p>容器启动伊始，首先会通过某种途径加载Configuration MetaData。除了代码方式比较直接，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的Configuration MetaData。</p>
</li>
<li><p>对Configuration MetaData进行解析和分析，并将分析后的信息编组为相应的BeanDefinition，最后把这些保存了bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-2c47772c36c20bcf748015c48f8c12fbccb.png" alt=""></p>
<blockquote>
<p>总地来说，该阶段所做的工作可以认为是准备性的，重点更加侧重于对象管理信息的收集。</p>
</blockquote>
<h3 id="4-3-2-Bean实例化阶段"><a href="#4-3-2-Bean实例化阶段" class="headerlink" title="4.3.2 Bean实例化阶段"></a>4.3.2 Bean实例化阶段</h3><p>经过第一阶段，现在所有的bean定义信息都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中。当某个请求方通过容器的getBean方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用getBean方法时，就会触发第二阶段的活动。</p>
<ol>
<li><p>容器会首先检查所请求的对象之前是否已经实例化和初始化。如果没有，则会根据注册的BeanDefinition所提供的信息<strong>实例化</strong>被请求对象，并为其<strong>注入依赖</strong>，然后<strong>初始化</strong>。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。</p>
</li>
<li><p>当该对象装配完毕之后，容器会立即将其返回请求方使用。</p>
</li>
</ol>
<blockquote>
<p>如果说第一阶段只是根据图纸装配生产线的话，那么第二阶段就是使用装配好的生产线来生产具体的产品了</p>
</blockquote>
<blockquote>
<p>注意，我们上面提高的bean的实例化，注入依赖（或者叫依赖装配），初始化，是三个递进的不同阶段，注意区分。</p>
</blockquote>
<h2 id="4-4-spring-bean的生命周期"><a href="#4-4-spring-bean的生命周期" class="headerlink" title="4.4 spring bean的生命周期"></a>4.4 spring bean的生命周期</h2><p>确的了解Spring Bean的生命周期是非常必要的。我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p>
<p>开门见山，我们先直接给出一张总图，然后再分别描述：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-336e2eddd6c632b56f4784f9efa0937cd05.png" alt=""></p>
<p>可以看到，Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p>
<ol>
<li><p>Bean自身的方法：这个包括了Bean本身调用的方法（如构造器，依赖注入的set方法等）和通过配置文件中<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>指定的方法。</p>
</li>
<li><p>Bean级生命周期接口方法：这个包括了Aware接口的相关实现类（如BeanNameAware、BeanFactoryAware）以及InitializingBean、DiposableBean这些接口的方法。</p>
</li>
<li><p>容器级生命周期接口方法：</p>
<ol>
<li><strong>Bean后处理器</strong>接口方法：所有实现了BeanPostProcessor这个接口的实现类，一般称它们为“后处理器”，或者“bean后处理器”。主要作用是对容器中的bean进行后处理，也就是额外的加强。（注意，它的作用对象是它所注册的容器中的所有收管bean）</li>
<li><strong>工厂后处理器</strong>接口方法：所有实现了BeanFactoryPostProcessor这个接口的实现类，一般称它们为“工厂后处理器”，或者“容器后处理器”。主要作用是对IoC容器进行后处理，增强容器功能。（注意，它的作用对象是它所注册的容器的对象）</li>
</ol>
</li>
</ol>
<p>这些类或接口叫做Hook类/接口，这些接口/类的存在，使得Spring Framework具有非常高的扩展性，<strong>使得我们可以在bean的生命周期的关键节点介入，得到一些我们需要的信息，或者做一些对bean的“改装”</strong>。</p>
<p>第一类，Bean自身的方法，这个不再赘述，我们从bean的生命周期中各类的调用顺序，来依次介绍二三类的这些接口方法：</p>
<h3 id="4-4-1-Bean级生命周期接口方法"><a href="#4-4-1-Bean级生命周期接口方法" class="headerlink" title="4.4.1  Bean级生命周期接口方法"></a>4.4.1  Bean级生命周期接口方法</h3><h4 id="4-4-1-1-InitializingBean-DisposableBean接口方法"><a href="#4-4-1-1-InitializingBean-DisposableBean接口方法" class="headerlink" title="4.4.1.1 InitializingBean/DisposableBean接口方法"></a>4.4.1.1 InitializingBean/DisposableBean接口方法</h4><p>InitializingBean和DisposableBean接口十分的简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InitializingBean &#123;</span><br><span class="line">	void afterPropertiesSet() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface DisposableBean &#123;</span><br><span class="line">	void destroy() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能也十分简单：如果想在bean的 创建/销毁 过程中做一些骚操作的话，就实现这两个接口中对应的接口方法，将骚操作逻辑定义在里面。</p>
<p>Spring在创建/销毁bean的过程中，会判断bean是否实现了这二者的接口方法，如果实现了，就在适当的时机调用它。</p>
<p>具体逻辑见AbstractAutowireCapableBeanFactory#initializeBean()和AbstractAutowireCapableBeanFactory#invokeInitMethods()</p>
<h4 id="4-4-1-2-Aware接口方法"><a href="#4-4-1-2-Aware接口方法" class="headerlink" title="4.4.1.2 Aware接口方法"></a>4.4.1.2 Aware接口方法</h4><p>Spring中有很多继承于aware接口的类，如下图，那么这些类到底是做什么用到的呢？？</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ea8fe95bed3c58c5c737e7d70d67fe22138.png" alt=""></p>
<p>有些时候，我们需要在bean的实例化过程中，获取bean的某些信息来做一些工作，这些信息包括bean的beanName，构造这个bean的ApplicationContext，加载这个bean类的beanClassLoader等等。</p>
<p>假设我们有一个Car类，我们希望在bean的初始化过程中能够有机会获取到bean的beanName，以便我们把beanName赋值给carName，让每辆car的carName和beanName一致，那么我们可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements BeanNameAware&#123;  &#x2F;&#x2F;让Car实现BeanNameAware</span><br><span class="line">	private String carName;</span><br><span class="line">	public void setBeanName(String beanName) &#123;</span><br><span class="line">		&#x2F;&#x2F;ID保存BeanName的值</span><br><span class="line">		carName&#x3D;beanName;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们在Configuration MetaData中定义两个Car类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;benchi&quot;  class&#x3D;&quot;balabala.Car&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;baoma&quot;  class&#x3D;&quot;balabala.Car&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;benchi&quot;)</span><br><span class="line">private Car benchi;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;baoma&quot;)</span><br><span class="line">private Car baoma;</span><br></pre></td></tr></table></figure>
<p>那么可以得到结果：<code>benchi.carName=“benchi”，baoma.carName=“baoma”；</code></p>
<p>aware，翻译过来是知道的，已感知的，意识到的，所以，这些接口从字面意思是能感知到所有Aware前缀值的含义。</p>
<p>实际上，这些接口也确实提供了可实现的方法，在bean的实例化过程中，将各个Aware想要获取的信息通过参数的方式传到实现的方法中来，给开发者一个获取到相关信息值的机会。</p>
<p>如上例的<code>Car implements BeanNameAware</code>，BeanNameAware定义的setBeanName(String beanName)方法，就会在实例化过程中把beanName信息传进方法中来让开发者使用，得意于此，我们才能得到beanName，并将其赋值给carName。</p>
<p>至于其他的Aware实现类，他们获取的信息不同，但逻辑也都是一样的。</p>
<ul>
<li><p>BeanNameAware接口是为了让自身Bean能够感知到，获取到自身在Spring容器中的id（也就是beanName）属性。</p>
</li>
<li><p>实现了ApplicationContextAware接口的类，能够获取到ApplicationContext</p>
</li>
<li><p>实现了BeanFactoryAware接口的类，能够获取到BeanFactory对象。</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>在实例化过程中，将相关信息传进接口方法中以供使用，spring怎么做到这一点的呢？？</p>
<p>其实非常简单，bean在初始化前会调用一次ApplicationContextAwareProcessor类的postProcessBeforeInitialization方法，如果bean实现了Aware接口，那么会继续判断bean实现了具体的什么接口，执行对应接口的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">		if (bean instanceof Aware) &#123;</span><br><span class="line">			if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">				((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">				((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">				((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">				((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">				((MessageSourceAware) bean).setMessageSource(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">				((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-容器级生命周期接口方法"><a href="#4-4-2-容器级生命周期接口方法" class="headerlink" title="4.4.2  容器级生命周期接口方法"></a>4.4.2  容器级生命周期接口方法</h3><p>容器级生命周期接口方法主要分为<strong>Bean后处理器</strong>接口方法和<strong>工厂后处理器</strong>接口方法。前者可以对容器中的bean进行增强，后者对容器进行增强，二者我们依次介绍</p>
<h4 id="4-4-2-1-Bean后处理器"><a href="#4-4-2-1-Bean后处理器" class="headerlink" title="4.4.2.1 Bean后处理器"></a>4.4.2.1 Bean后处理器</h4><p><strong>BeanPostProcessor接口是所有Bean后处理器的顶层接口</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;参数：arg1：被增强的bean对象；arg2：被增强的bean对象的id</span><br><span class="line">	@Nullable</span><br><span class="line">	default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;参数：arg1：被增强的bean对象；arg2：被增强的bean对象的id</span><br><span class="line">	@Nullable</span><br><span class="line">	default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，postProcessBeforeInitialization和postProcessAfterInitialization，在接口上就已经有默认实现了，所以其他的Bean后处理器实现类，不一定要重写这两个方法。</p>
</blockquote>
<p>可以看到postProcessBeforeInitialization和postProcessAfterInitialization是一组对称的方法，一个后缀是BeforeInitialization，一个后缀是AfterInitialization。注意，Initialization，初始化的意思，故而一个在初始化前，一个在初始化后。</p>
<p>spring bean的初始化（注意，初始化不是实例化）包含：</p>
<ol>
<li>调用InitializingBean接口的afterPropertiesSet方法（如果有实现的话）。</li>
<li>Configuration Metadata中的init方法，如xml配置的init-method属性指定方法，或@Bean注解注册bean定义时，设置注解initMethod属性指定的方法等。</li>
<li>使用java的注解@PostConstruct，把它标在bean的一个方法上。</li>
</ol>
<p>而postProcessBeforeInitialization和postProcessAfterInitialization方法的调用位置就是：</p>
<p><strong>bean的实例化-&gt; bean的依赖装配 -&gt; BeforeInitialization接口方法（初始化前） -&gt; bean的初始化方法 -&gt; AfterInitialization接口方法（初始化后）</strong></p>
<p>那么bean后处理器如何使用呢？来，我们来自定义一个bean后处理器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyBeanProcessor implements BeanPostProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object arg0, String arg1)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;bean:&quot; + arg1 + &quot; after&quot;);</span><br><span class="line">        return arg0;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object arg0, String arg1)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;bean:&quot; + arg1 + &quot; before&quot;);</span><br><span class="line">        return arg0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring在初始化bean的过程中，会优先初始化那些实现了像BeanPostProcessor这类特殊接口的bean，<strong>如果容器发现初始化的bean实现了BeanPostProcessor 接口，将会将其注册为bean后处理器</strong>。</p>
<p><strong>一经注册，它对它注册的spring容器下的所有bean起作用，任何bean在初始化过程都会通过bean后处理器做额外增强操作</strong>。</p>
<p>作为开发者，我们可以通过实现BeanPostProcessor接口方法，来自定义后处理器类，也可以使用现成，spring为我们准备好的一些后处理器，下面我们简单介绍一些重要的bean后处理器。</p>
<h5 id="4-4-2-1-1-InstantiationAwareBeanPostProcessor"><a href="#4-4-2-1-1-InstantiationAwareBeanPostProcessor" class="headerlink" title="4.4.2.1.1 InstantiationAwareBeanPostProcessor"></a>4.4.2.1.1 InstantiationAwareBeanPostProcessor</h5><p>InstantiationAwareBeanPostProcessor也是一个接口，注意，InstantiationAwareBeanPostProcessor的一对before和after接口方法，不是重写的BeanPostProcessor的postProcessBeforeInitialization和postProcessAfterInitialization。</p>
<p>Instantiation和Initialization，还是不一样的，前者是实例化，后者是初始化，要注意区分。</p>
<p>InstantiationAwareBeanPostProcessor实现BeanPostProcessor接口，更多意义上是为了将自己归类进bean后处理器中，好让容器识别自己的“身份”。它的逻辑载体（即三个方法），都是自实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;注意！！！这个方法是InstantiationAwareBeanPostProcessor自己定义的</span><br><span class="line">	&#x2F;&#x2F;不是重写BeanPostProcessor的postProcessBeforeInitialization，两个方法名很像，但不一样</span><br><span class="line">	&#x2F;&#x2F;在bean实例化前调用，如果返回一个非null对象，则Spring就使用这个对象了，不再进行实例化了。</span><br><span class="line">	&#x2F;&#x2F;所以这里可以返回一个目标bean的代理，来压制（延迟）目标bean的实例化。</span><br><span class="line">	&#x2F;&#x2F;这个方法的参数是bean的类型，因为此时还没有bean实例呢。</span><br><span class="line">	@Nullable</span><br><span class="line">	default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;注意！！！这个方法是InstantiationAwareBeanPostProcessor自己定义的</span><br><span class="line">	&#x2F;&#x2F;不是重写BeanPostProcessor的postProcessAfterInitialization，两个方法名很像，但不一样</span><br><span class="line">	&#x2F;&#x2F;这是一个理想的地方用来执行自定义字段注入，因为此时Spring的自动装配尚未到来。</span><br><span class="line">	&#x2F;&#x2F;通常方法返回true，如果返回false，后续的属性设置将被跳过。</span><br><span class="line">	default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;在bean属性设置前调用，可以用来定制即将为bean实例设置的属性。</span><br><span class="line">	&#x2F;&#x2F;方法pvs是传进来的已有属性。方法默认返回null。表示不对属性进行操作。</span><br><span class="line">	@Nullable</span><br><span class="line">	default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	@Deprecated</span><br><span class="line">	@Nullable</span><br><span class="line">	default PropertyValues postProcessPropertyValues(</span><br><span class="line">			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return pvs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InstantiationAwareBeanPostProcessor的名字中有Instantiation（实例化），说明和BeanPostProcessor只能介入初始化的前后不一样，InstantiationAwareBeanPostProcessor可以介入到bean的实例化的前后，所以它的执行时机是：</p>
<p><strong>bean的实例化准备阶段 -&gt; BeforeInstantiation接口方法（实例化前）-&gt; bean的实例化 -&gt; AfterInstantiation接口方法（实例化后） -&gt; PropertyValues接口方法（定制bean所需的属性值） -&gt; bean的属性设置</strong></p>
<h5 id="4-4-2-1-2-DestructionAwareBeanPostProcessor"><a href="#4-4-2-1-2-DestructionAwareBeanPostProcessor" class="headerlink" title="4.4.2.1.2 DestructionAwareBeanPostProcessor"></a>4.4.2.1.2 DestructionAwareBeanPostProcessor</h5><p>DestructionAwareBeanPostProcessor接口和InstantiationAwareBeanPostProcessor对应，后者负责实例化前后的增强，后者负责销毁前后的增强。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface DestructionAwareBeanPostProcessor extends BeanPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;在bean实例销毁前会被调用，来执行一些定制的销毁代码。</span><br><span class="line">	void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException;</span><br><span class="line">	&#x2F;&#x2F;决定是否要为bean实例调用第一个方法来执行一些销毁代码。返回true表示需要，false表示不需要调用。</span><br><span class="line">	default boolean requiresDestruction(Object bean) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spring bean的销毁包含：</p>
<ol>
<li>调用DisposableBean接口的destroy方法（如果有实现的话）。</li>
<li>Configuration Metadata中的init方法，如xml配置的destroy-method属性指定方法，或@Bean注解注册bean定义时，设置注解destroyMethod属性指定的方法等。</li>
<li>使用java的注解@PreDestroy，把它标在bean的一个方法上。</li>
</ol>
<p>执行时机就在销毁前后，不再细述。</p>
<h5 id="4-4-2-1-3-SmartInstantiationAwareBeanPostProcessor"><a href="#4-4-2-1-3-SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="4.4.2.1.3 SmartInstantiationAwareBeanPostProcessor"></a>4.4.2.1.3 SmartInstantiationAwareBeanPostProcessor</h5><p>占位，知道有这么一个后处理器，可以用来修改bean类型，定制构造方法，还有获取一个早期（初始化还没执行）bean实例的引用，典型的用法是可以用来解决循环引用。</p>
<h5 id="4-4-2-1-4-MergedBeanDefinitionPostProcessor"><a href="#4-4-2-1-4-MergedBeanDefinitionPostProcessor" class="headerlink" title="4.4.2.1.4 MergedBeanDefinitionPostProcessor"></a>4.4.2.1.4 MergedBeanDefinitionPostProcessor</h5><p>占位，知道有这么一个后处理器，这个接口的主要目的不是用来修改合并后的bean定义的，虽然也可以进行一些修改。<br>它主要用来进行一些自省操作，如一些检测，或在处理bean实例之前缓存一些相关的元数据。<br>这些作用都在第一个方法里实现。</p>
<h4 id="4-4-2-2-Bean工厂后处理器"><a href="#4-4-2-2-Bean工厂后处理器" class="headerlink" title="4.4.2.2 Bean工厂后处理器"></a>4.4.2.2 Bean工厂后处理器</h4><p>和Bean后处理器一样，Bean工厂后处理器是一种特殊的Bean，这种Bean并不对外提供服务，它甚至可以无需id属性，它主要负责对容器本身进行某些特殊的处理和增强。</p>
<p>BeanFactoryPostProcessor是所有工厂后处理器的顶层接口，在spring容器实例化bean的逻辑中，spring正是通过<code>instanceof BeanFactoryPostProcessor</code>这一判断语句来确定一个bean是不是工厂后处理器。</p>
<p>如下图所示，spring提供的BeanFactoryPostProcessor实现类有很多，一些常见的功能，我们可以直接选择合适的工厂后处理器来继承或者实现，以免重复造轮子，其中BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor最重要的一个实现类。<br><img src="https://oscimg.oschina.net/oscnet/up-026c8508b80dc53ed001a173d88f0b207f4.png" alt=""></p>
<p>Spring中有两类工厂后处理器，<strong>BeanDefinitionRegistryPostProcessor和其他</strong>。其中其他里面又分为spring源生的，和我们自定义的。</p>
<blockquote>
<p>BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，设计它的目的是为了使用它向容器注册额外的bean的配置信息——BeanDefinition对象。</p>
</blockquote>
<h5 id="4-4-2-2-1-自定义BeanFactoryPostProcessor"><a href="#4-4-2-2-1-自定义BeanFactoryPostProcessor" class="headerlink" title="4.4.2.2.1 自定义BeanFactoryPostProcessor"></a>4.4.2.2.1 自定义BeanFactoryPostProcessor</h5><p>我们把spring提供的源生的Bean工厂后处理器之外的，我们自己通过实现BeanFactoryPostProcessor顶层接口的工厂后处理器称为<strong>普通工厂后处理器，或者自定义BeanFactoryPostProcessor</strong>；</p>
<p>我们先来看下BeanFactoryPostProcessor接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;postProcessBeanFactory方法，它的执行的时机是，所有的bean定义都已经注册完毕，不可能再增多了</span><br><span class="line">	&#x2F;&#x2F;该方法允许去修改bean定义的一些属性。</span><br><span class="line">	&#x2F;&#x2F;它允许覆盖或者设置bean的属性值，甚至是立即实例化bean，比如实例化bean后处理器对象。</span><br><span class="line">	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor能改变bean在实例化之前的一些原配置值，比如Scope，lazy，Primary，DependsOn，Role，Description等等。</p>
<p>比如我们有个单例的bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class Teacher&#123;</span><br><span class="line">	public Teacher()&#123;</span><br><span class="line">		System.out.println(&quot;Construct&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义实现BeanFactoryPostProcessor的处理器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">		BeanDefinition beanDefinition &#x3D; beanFactory.getBeanDefinition(&quot;teacher&quot;);</span><br><span class="line">		beanDefinition.setScope(&quot;prototype&quot;);</span><br><span class="line">		System.out.println(&quot;Scope:&quot;+beanDefinition.getScope());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了对于bean的作用域的变化。</p>
<h5 id="4-4-2-2-2-BeanDefinitionRegistryPostProcessor"><a href="#4-4-2-2-2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="4.4.2.2.2 BeanDefinitionRegistryPostProcessor"></a>4.4.2.2.2 BeanDefinitionRegistryPostProcessor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;bean定义注册后处理器，就是用来向容器中注册bean定义的，造成的结果就是beanDefinition的数目变多。</span><br><span class="line">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;它的接口方法执行的时机是，所有的“常规bean定义”都已注册完毕，该方法允许添加进一步的bean定义注册到容器中。</span><br><span class="line">	void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多说无益，我们来看demo：</p>
<p>首先我们创建一个类并实现BeanDefinitionRegistryPostProcessor接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;</span><br><span class="line">		System.out.println(&quot;TestBeanDefinitionRegistryPostProcessor...postProcessBeanDefinitionRegistry&quot;);</span><br><span class="line">		System.out.println(registry.getBeanDefinitionCount());</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;这里添加一个Dog.class的BeanDefinition进入容器</span><br><span class="line">		&#x2F;&#x2F;RootBeanDefinition beanDefinition &#x3D; new RootBeanDefinition(Dog.class);  作用同下行</span><br><span class="line">		AbstractBeanDefinition beanDefinition &#x3D; BeanDefinitionBuilder.rootBeanDefinition(Dog.class).getBeanDefinition();</span><br><span class="line">		registry.registerBeanDefinition(&quot;dog&quot;,beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">		System.out.println(&quot;TestBeanDefinitionRegistryPostProcessor...postProcessBeanFactory&quot;);</span><br><span class="line">		System.out.println(beanFactory.getBeanDefinitionCount());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就完成了往容器中添加BeanDefinition的操作。</p>
<h5 id="4-4-2-2-3-源生工厂后处理器之ConfigurationClassPostProcessor"><a href="#4-4-2-2-3-源生工厂后处理器之ConfigurationClassPostProcessor" class="headerlink" title="4.4.2.2.3 源生工厂后处理器之ConfigurationClassPostProcessor"></a>4.4.2.2.3 源生工厂后处理器之ConfigurationClassPostProcessor</h5><p>ConfigurationClassPostProcessor是Spring中非常重要的工厂后处理器，它的主要功能是参与BeanFactory的建造，在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。</p>
<p>ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而ConfigurationClassPostProcessor类的作用就是通过这两个方法去实现的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4230db35c74bd0b4acc1f353f7129eab984.png" alt=""></p>
<p>具体代码逻辑，可以见该文：<a href="https://blog.csdn.net/qq_34436819/article/details/100944204" target="_blank" rel="noopener" title="ConfigurationClassPostProcessor源码解析">ConfigurationClassPostProcessor源码解析</a>，介绍的非常的详细。</p>
<pre><code>- </code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/" itemprop="url">JVM学习总结之『一个类的前世今生』</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-07T22:11:44+08:00">
                2020-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA-JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/07/JVM学习总结之『一个类的前世今生』/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  26
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-我乃中山靖王之后"><a href="#1-我乃中山靖王之后" class="headerlink" title="1 我乃中山靖王之后"></a>1 我乃中山靖王之后</h1><p>大家好，我叫李大锤，是一名不入流的演员，我即将参演一部名叫《三国演义》的舞台剧，导演是棺材板按不住的罗贯中老先生。而我，即将扮演三位主角之一的刘皇叔，嘿嘿，想想还有点小激动呢！</p>
<p>按照剧本，我是一名出生低微的屌丝，被嘲笑为“织席贩履”之辈，所以一开始，我长这个B样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，我开局就会收关张两位挂逼做小弟，于是，我变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">	int zhangFei&#x3D;123;&#x2F;&#x2F;张飞</span><br><span class="line">	Object guanYu&#x3D;new Object();&#x2F;&#x2F;关羽 为了嫌麻烦，就不给他们定制特定的类了，就int &amp; Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算了，就不追求麾下武将如云谋士如雨了，人太多写的也累，有二弟和三弟出场就够了。</p>
<p>当然，作为未来的汉昭烈帝，我开局还会一些特殊技能，不亏是主角之一，这技能真是别具一格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void shuaiErZi() &#123;&#x2F;&#x2F;摔儿子</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shouMaiRenXin() &#123;&#x2F;&#x2F;收买人心</span><br><span class="line">	shuaiErZi();</span><br><span class="line">&#125;</span><br><span class="line">public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">	System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">	guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，身残志坚，躺在棺材里还在coding的著名程序员罗贯中先生，已经通过他精湛的代码功底，为我编写了一个详（jian）细（lou）的开局设定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">    int zhangFei&#x3D;123;&#x2F;&#x2F;张飞</span><br><span class="line">    Object guanYu&#x3D;new Object();&#x2F;&#x2F;关羽 为了嫌麻烦，就不给他们定制特定的类了，就int &amp; Object</span><br><span class="line">    public void shuaiErZi() &#123;&#x2F;&#x2F;摔儿子</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shouMaiRenXin() &#123;&#x2F;&#x2F;收买人心</span><br><span class="line">        shuaiErZi();</span><br><span class="line">    &#125;</span><br><span class="line">    public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">        System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">        guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们去为舞台剧做一下准备吧！</p>
<h1 id="2-新手村"><a href="#2-新手村" class="headerlink" title="2 新手村"></a>2 新手村</h1><p>舞台剧开演在即，来，摄影机往前，我们先来俯瞰一下整个会场的布局吧（详细介绍见：<a href="https://cherish-ls.github.io/2019/10/23/JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener" title="JAVA内存结构和内存管理">JAVA内存结构和内存管理</a>）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b6cfe993d5877ce9f6a9bcbe30fa1eb5055.png" alt=""></p>
<p>首先，面积最为广大的，就是我们舞台的后台，我们唤作<strong>堆</strong>，所有有名有幸的三国豪杰们（对象们），都会在后台齐聚，各自准备。</p>
<p>然后，我们可以看到一块巨大的显示屏，我们唤作<strong>方法区</strong>，上面是本剧的台本，上面写着：</p>
<ul>
<li>各个英雄豪杰的设定/经历（类信息）等信息<ul>
<li>刘备会遇到关张，然后还会摔儿子技能（属性，方法）</li>
<li>曹操麾下有曹仁曹纯夏侯兄弟等挂逼，还有好人妻这个技能。（属性，方法）</li>
<li>….</li>
</ul>
</li>
<li>一些人尽皆知的信息（常量）<ul>
<li>比如现在是东汉末年，嗯，比如东汉末年是个常量。</li>
<li>…</li>
</ul>
</li>
<li>某位英雄广为人知的设定（类的静态变量）。<ul>
<li>刘备：说织席贩履的给老子滚出来啊魂淡！！</li>
<li>曹操：梦中杀伦什么的，我真不是故意的。</li>
<li>孙权：就不能不提合肥，不提孙十万吗。。</li>
</ul>
</li>
</ul>
<p>舞台之上，我们看到了有三束聚光灯各自照亮舞台一隅，这是以我们三位主角曹孙刘为视角的三个<strong>线程</strong>，然后被聚光灯照亮的三块方寸之地，主要是<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，还有一个小的牌子，叫做<strong>程序计数器</strong>，用来标记此间主角演到剧情的何处了。</p>
<h1 id="3-英雄要问出身"><a href="#3-英雄要问出身" class="headerlink" title="3 英雄要问出身"></a>3 英雄要问出身</h1><p>逛完了舞台以后，我得去看看我的台本，虽然我在接戏之前已经知道了罗贯中老先生为我量身定做的草稿：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">    int zhangFei&#x3D;123;&#x2F;&#x2F;张飞</span><br><span class="line">    Object guanYu&#x3D;new Object();&#x2F;&#x2F;关羽 为了嫌麻烦，就不给他们定制特定的类了，就int &amp; Object</span><br><span class="line">    public void shuaiErZi() &#123;&#x2F;&#x2F;摔儿子</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shouMaiRenXin() &#123;&#x2F;&#x2F;收买人心</span><br><span class="line">        shuaiErZi();</span><br><span class="line">    &#125;</span><br><span class="line">    public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">        System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">        guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但草稿只是草稿，正经的舞台剧，肯定不能用这么简陋的东西来演出，不说别的，看草稿我只知道我有关张两个小弟，但演出时，我至少得知道关张是谁来演，我到底和谁撘对手戏吧？是胡歌还是霍建华？</p>
<p>所以，还需要把草稿再加工，变成真正的台本，这个过程，叫做<strong>编译</strong>，这时，java文件会编译成class文件。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4ba7398c95ae3265cf9332d9761b6160b9a.png" alt=""></p>
<p>class文件的内容我们不再赘述，详情在<a href="https://cherish-ls.github.io/2019/12/03/Class%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener" title="JAVA Class文件和类加载机制">JAVA Class文件和类加载机制</a>一文中可见。我们只要记得几个核心要素：</p>
<ul>
<li><p>类型信息包含魔数，主次版本号等。</p>
</li>
<li><p>常量池里面存放着字面量和符号引用。</p>
<ul>
<li>常量池中每一项常量都是一个表，在JDK1.7之后共有14种表结构，这14种常量类型各自有自己的结构，下面列出每个常量项的结构及含义</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-49edc6b667c3b7b848c539852736ab72b9c.png" alt=""></li>
<li>字面量可以理解为就是字符文本，class文件中的其他信息要用到字符文本的时候，都是“引用”他，比如字段表中，刘备有关羽这个小弟，那“关羽”这个名字的文本就存放于常量池中。</li>
<li>符号引用包含下面三类：<ul>
<li>全限定名：就是类名全称,例如:org/xxx/class/testClass</li>
<li>简单名称：即没有类型和参数修饰的字段或者方法名称，例如方法test()的简单名称就是test，m字段的简单名称就是m。</li>
<li>描述符：描述符的作用是描述字段的数据类型、方法的参数列表（包括数量、类型及顺序）和返回值。根据描述符的规则，基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名表示<ul>
<li>如“viod main(String[] args)” 的描述符为“([Ljava/lang/String;)V</li>
<li>如“String[][]”,会被记录为”[[Ljava/lang/String”</li>
<li>“int[]”被记录为“[I”。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字段表集合，记录这个类的字段信息，比如我们刘备拥有关张两个小弟做对象，</p>
<ul>
<li>这里我们会记录关张的字段名称，如关羽的名称的值就是常量池中“关羽”常量的引用</li>
<li>记录描述符（descriptor_index中记录），描述这个字段的类型，我们这里是Object类型，那么这个值就是指向常量池中的“Ljava/lang/Object”常量的引用。</li>
<li>以及各种修饰符：类似于：汉寿亭侯·美髯公·武圣·刮骨疗法临床实验者·季汉扛把子·关羽=public transient volatile Object guanYu。</li>
</ul>
</li>
<li><p>方法表集合，记录这个类的方法信息，比如我们刘备拥有摔儿子和收买人心方法。</p>
<ul>
<li>这里我们会记录方法的名称，同样引用常量池。</li>
<li>记录描述符（descriptor_index中记录），描述这个方法的描述符，我们这里是void shuaiErZi()，那么这个值就是指向常量池中的“()V”常量的引用。（注意这里的V是指void，描述符不包括方法名称）</li>
<li>以及各种修饰符：类似于：作用全场的·效果拔群的·刘备角色固有的·摔儿子=public volatile static shuaiErZi</li>
<li>方法体里面有代码的，都会有一个code属性（引用属性表集合），里面有摔儿子说明文本长度（属性长度），操作数栈最大深度等，还有摔儿子的具体操作步骤（代码的字节码指令）。</li>
</ul>
</li>
</ul>
<p>来，我们使用javap工具</p>
<p><code>javap -c -v -p -l -constants /home/lisheng/IdeaProjects/learning/out/production/learning/com/company/LiuBei.class</code></p>
<p>将public class LiuBei的class文件反解析出来，如下，这就是刘备这个角色经过编译后的舞台剧脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;home&#x2F;lisheng&#x2F;IdeaProjects&#x2F;learning&#x2F;out&#x2F;production&#x2F;learning&#x2F;com&#x2F;company&#x2F;LiuBei.class</span><br><span class="line">  Last modified 2019-12-10; size 1018 bytes</span><br><span class="line">  MD5 checksum 7133ac0c7e83a62e1081db1945bc6cf9</span><br><span class="line">  Compiled from &quot;LiuBei.java&quot;</span><br><span class="line">public class com.company.LiuBei</span><br><span class="line">  minor version: 0 &#x2F;&#x2F;次版本</span><br><span class="line">  major version: 52 &#x2F;&#x2F;主版本</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER &#x2F;&#x2F;LiuBei类的修饰符</span><br><span class="line">Constant pool: &#x2F;&#x2F;类的常量池</span><br><span class="line">   #1 &#x3D; Methodref          #3.#32         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V </span><br><span class="line">   &#x2F;&#x2F;#1表示常量池index，此处是一个Methodref类型的常量。</span><br><span class="line">   &#x2F;&#x2F;《JAVA Class文件和类加载机制》一文我们知道Methodref类型内有两个index字段，又引用了两个常量。分别表示方法所属类全限定名，以及方法描述符。</span><br><span class="line">   &#x2F;&#x2F;所以#3.#32 即为#1 &#x3D; Methodref引用了index&#x3D;3和index&#x3D;32的常量。</span><br><span class="line">   &#x2F;&#x2F;我们知道#3是Class类型，引用了#34&#x3D; java&#x2F;lang&#x2F;Object，所以其实#3就是 java&#x2F;lang&#x2F;Object的类常量。这表示#1代表的方法是 java&#x2F;lang&#x2F;Object类的方法。</span><br><span class="line">   &#x2F;&#x2F;我们知道#32是NameAndType类型常量，又引用了 #20&#x3D;&lt;init&gt;，#21&#x3D;()V，合起来就是#32存储了#1代表的方法的方法描述符。</span><br><span class="line">&#x2F;&#x2F;如此，我们得到了一个完整的Methodref，其内容记录了方法所在类的全限定名以及方法描述符。</span><br><span class="line">&#x2F;&#x2F;下面以此类推，不再赘述</span><br><span class="line"></span><br><span class="line">   #2 &#x3D; Fieldref           #15.#33        &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei.zhangFei:I</span><br><span class="line">   #3 &#x3D; Class              #34            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #4 &#x3D; Fieldref           #15.#35        &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei.guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">   #5 &#x3D; Methodref          #15.#36        &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei.shuaiErZi:()V</span><br><span class="line">   #6 &#x3D; Fieldref           #37.#38        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #7 &#x3D; Class              #39            &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">   #8 &#x3D; Methodref          #7.#32         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 &#x3D; Methodref          #7.#40         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #10 &#x3D; String             #41            &#x2F;&#x2F;</span><br><span class="line">  #11 &#x3D; Methodref          #7.#42         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #12 &#x3D; Methodref          #7.#43         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #13 &#x3D; Methodref          #44.#45        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #14 &#x3D; Methodref          #3.#43         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #15 &#x3D; Class              #46            &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei</span><br><span class="line">  #16 &#x3D; Utf8               zhangFei</span><br><span class="line">  #17 &#x3D; Utf8               I</span><br><span class="line">  #18 &#x3D; Utf8               guanYu</span><br><span class="line">  #19 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">  #20 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">  #21 &#x3D; Utf8               ()V</span><br><span class="line">  #22 &#x3D; Utf8               Code</span><br><span class="line">  #23 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #24 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #25 &#x3D; Utf8               this</span><br><span class="line">  #26 &#x3D; Utf8               Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line">  #27 &#x3D; Utf8               shuaiErZi</span><br><span class="line">  #28 &#x3D; Utf8               shouMaiRenXin</span><br><span class="line">  #29 &#x3D; Utf8               geiWoShang</span><br><span class="line">  #30 &#x3D; Utf8               SourceFile</span><br><span class="line">  #31 &#x3D; Utf8               LiuBei.java</span><br><span class="line">  #32 &#x3D; NameAndType        #20:#21        &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #33 &#x3D; NameAndType        #16:#17        &#x2F;&#x2F; zhangFei:I</span><br><span class="line">  #34 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #35 &#x3D; NameAndType        #18:#19        &#x2F;&#x2F; guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">  #36 &#x3D; NameAndType        #27:#21        &#x2F;&#x2F; shuaiErZi:()V</span><br><span class="line">  #37 &#x3D; Class              #47            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #38 &#x3D; NameAndType        #48:#49        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #39 &#x3D; Utf8               java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">  #40 &#x3D; NameAndType        #50:#51        &#x2F;&#x2F; append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #41 &#x3D; Utf8</span><br><span class="line">  #42 &#x3D; NameAndType        #50:#52        &#x2F;&#x2F; append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #43 &#x3D; NameAndType        #53:#54        &#x2F;&#x2F; toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #44 &#x3D; Class              #55            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #45 &#x3D; NameAndType        #56:#57        &#x2F;&#x2F; printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #46 &#x3D; Utf8               com&#x2F;company&#x2F;LiuBei</span><br><span class="line">  #47 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #48 &#x3D; Utf8               out</span><br><span class="line">  #49 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #50 &#x3D; Utf8               append</span><br><span class="line">  #51 &#x3D; Utf8               (I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #52 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #53 &#x3D; Utf8               toString</span><br><span class="line">  #54 &#x3D; Utf8               ()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #55 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #56 &#x3D; Utf8               printf</span><br><span class="line">  #57 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">&#123;</span><br><span class="line">  int zhangFei;&#x2F;&#x2F;字段表，张飞这个字段，name_index指向的是常量池的#16&#x3D;zhangFei</span><br><span class="line">    descriptor: I&#x2F;&#x2F;descriptor_index指向的是常量池的#17&#x3D;I，表示类型是int</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  java.lang.Object guanYu;&#x2F;&#x2F;字段表，关羽这个字段，name_index指向的是常量池的#18&#x3D;guanYu</span><br><span class="line">    descriptor: Ljava&#x2F;lang&#x2F;Object;&#x2F;&#x2F;descriptor_index指向的是常量池的  #19&#x3D;Ljava&#x2F;lang&#x2F;Object;，表示类型是object类</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  public com.company.LiuBei();&#x2F;&#x2F;这里开始是方法表，LiuBei()是LiuBei类的默认构造器。name_index指向常量池LiuBei字面量。</span><br><span class="line">    descriptor: ()V&#x2F;&#x2F;descriptor_index指向常量池的#21 &#x3D; Utf8               ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:&#x2F;&#x2F;code属性，存储着构造器的字节码指令</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1&#x2F;&#x2F;</span><br><span class="line">         0: aload_0 </span><br><span class="line">		 &#x2F;&#x2F;从本地变量表中加载索引为0的变量的值，也即this的引用，压入栈</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">		 &#x2F;&#x2F;出栈，invokespecial表示调用方法，调用哪个方法呢，调用#1代表的java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V 方法初始化对象，就是this指定的对象的init()方法完成初始化</span><br><span class="line">         4: aload_0</span><br><span class="line">		 &#x2F;&#x2F;再一次从本地变量表中加载索引为0的变量的值，也即this的引用，压入栈</span><br><span class="line">         5: bipush        123</span><br><span class="line">		 &#x2F;&#x2F;将123常量压入栈，当int取值-128~127时,JVM采用bipush指令将常量压入操作数栈中。</span><br><span class="line">         7: putfield      #2                  &#x2F;&#x2F; Field zhangFei:I</span><br><span class="line">		 &#x2F;&#x2F; 将123赋值给zhangFei</span><br><span class="line">		 &#x2F;&#x2F;下面同理，new一个Object对象，再执行Object的&lt;init&gt;方法，然后赋值给guanyu，返回。</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: new           #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">        14: dup</span><br><span class="line">        15: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        18: putfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">        21: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">	  &#x2F;&#x2F;指令与代码行数的偏移对应关系，每一行第一个数字对应代码行数，第二个数字对应前面code中指令前面的数字</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 4</span><br><span class="line">        line 5: 10</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">	  &#x2F;&#x2F;局部变量表，start+length表示这个变量在字节码中的生命周期起始和结束的偏移位置</span><br><span class="line">	  &#x2F;&#x2F;slot就是这个变量在局部变量表中的槽位（槽位可复用），name就是变量名称，Signatur局部变量类型描述</span><br><span class="line"></span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      22     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line">&#x2F;&#x2F;下面同理，不再赘述</span><br><span class="line">  public void shuaiErZi();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;0, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       1     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line"></span><br><span class="line">  public void shouMaiRenXin();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokevirtual #5                  &#x2F;&#x2F; Method shuaiErZi:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line"></span><br><span class="line">  public void geiWoShang();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #6                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: new           #7                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: getfield      #2                  &#x2F;&#x2F; Field zhangFei:I</span><br><span class="line">        14: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        17: ldc           #10                 &#x2F;&#x2F; String</span><br><span class="line">        19: invokevirtual #11                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        22: invokevirtual #12                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        25: iconst_0</span><br><span class="line">        26: anewarray     #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">        29: invokevirtual #13                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        32: pop</span><br><span class="line">        33: aload_0</span><br><span class="line">        34: getfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">        37: invokevirtual #14                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        40: pop</span><br><span class="line">        41: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 14: 33</span><br><span class="line">        line 15: 41</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      42     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;LiuBei.java&quot;</span><br></pre></td></tr></table></figure>

<p>看完了上面的反解析内容，我们要明白：方法表和常量池里面Methodref的区别：</p>
<ul>
<li>前者包含包括代码在内的全部方法信息，而后者充其量翻译出来，只包含了方法名+方法描述符+所在类限定名。</li>
<li>Methodref顾名思义，只是一个引用，是作为字节码的参数而存在的，如<code>invokespecial #1</code>，#1就是一个Methodref。<ul>
<li>所以我们可以看到常量池中存在Methodref=com/company/LiuBei.shuaiErZi:()V，却不存在Methodref=com/company/LiuBei.shouMaiRenXin:()V，因为shouMaiRenXin方法在刘备类的代码中没有被调用，所以它不需要一个包含它基本信息的Methodref</li>
</ul>
</li>
<li>再通俗一点比喻，刘备有技能收买人心，而收买人心技能的发动步骤中包含“大声喊出’摔儿子’三个字，同时发动自己的摔儿子技能”，所以刘备需要像记口诀一样记住“摔儿子”这三个字（即需要在常量池里有这个ref），而因为自己根本不会有喊出“收买人心”四个字的机会，所以常量池里没有必要有“收买人心”的ref。</li>
</ul>
<h1 id="4-争天下也要排练"><a href="#4-争天下也要排练" class="headerlink" title="4 争天下也要排练"></a>4 争天下也要排练</h1><p>上面终于搞懂了我们的台本（类信息）的内容，我也终于理解了罗贯中老导演写的代码到底是什么意思了。舞台剧快开始了，大家赶紧排练（类加载）吧。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>排练的第一步，我们每个演员总得拿到我们各自的台本（类信息）吧？</p>
<p>加载的过程，就是将台本纸稿（class文件）的内容导入到<strong>方法区</strong>大屏幕上的过程，这样我们每个人在排练的时候就可以像看提词器一样，偷瞄我们的设定。</p>
<p> 通过一个台本（类）的名称（全限定名），将所有需要的台本文稿（class文件）内容导入到大屏幕，可以使用的导入方式有：</p>
<ul>
<li>目前可以从zip包获取，即jar，ear，war格式的基础。</li>
<li>从网络获取，即applet实现。</li>
<li>运行时计算生成，典型如动态代理。</li>
<li>由其他文件生成，典型如JSP应用，即为JSP文件生成的class类。</li>
<li>从数据库中读取，这种较少见。</li>
</ul>
<blockquote>
<p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。并没有明确存放于要在堆中，实际上它虽然是对象，但是HotSpot虚拟机仍将其存放在方法区中。</p>
</blockquote>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是为了确保台本信息符合这个舞台剧的需求（确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全），一场三国的舞台剧，你不可以乱入一个李逵吧！</p>
<p>验证会检查格式，规范，引用的验证。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>方法区</strong>大屏幕上已经显示出我们导入的台本内容了，我们可以看到上面写着刘备的一些信息，假设他有个“织席贩履”的设定（类变量），即 static String sheDing=“织席贩履”。那么我们要把这四个字摆到显眼的地方去，因为他是人尽皆知的设定（类变量），表演中被引用到的概率还是很高的。（实例变量不会在此时分配内存）</p>
<p>所以在<strong>方法区</strong>大屏幕找一个地方（分配内存），但是注意，只是留了一块空间给它，但是还没有将“织席贩履<br>四个字给写上去，所以它还只是初始值。</p>
<p>基本数据类型的初始值有这些</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7830ff0655c4438bf1d68d3ef786f834dcd.png" alt=""></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>我们之前介绍过，在台本里面存储的很多都是符号引用（全限定名，简单名称，描述符），比如我们只知道张飞和关羽这两个人的名字，类型而已，并不知道具体对应到哪一个演员。</p>
<p>解析就是将台本上的符号引用，跟真正的演员对应起来的过程。（虚拟机将常量池内的符号引用替换为直接引用的过程）</p>
<p>我们来分析一下刘备的解析过程：</p>
<p>首先，类加载器加载LiuBei这个类的信息。</p>
<p>然后，我们根据台本，知道刘备有“给我上”这个技能（真实解析顺序并非如此，但这里只是示例，逻辑是相通的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">		System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">		guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>geiWoShang方法的完整信息，存在方法表集合中（记录了各种修饰符，字段类型，和字段名称，以及各种属性）。</p>
<blockquote>
<p>我们看上文的反编译信息可以看到，常量池中存在shuaiErZi方法的Methodref，那么同样是刘备的方法，为什么常量池中没有geiWoShang方法的Methodref呢？我们要记住，只有作为字节码参数的目标（方法，或者字段），才有必要在常量池中放置他们的引用。shuaiErZi方法被shouMaiRenXin方法引用，所以有shuaiErZi方法的Methodref。</p>
</blockquote>
<p>方法表长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void geiWoShang();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #6                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: new           #7                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: getfield      #2                  &#x2F;&#x2F; Field zhangFei:I</span><br><span class="line">        14: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        17: ldc           #10                 &#x2F;&#x2F; String</span><br><span class="line">        19: invokevirtual #11                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        22: invokevirtual #12                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        25: iconst_0</span><br><span class="line">        26: anewarray     #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">        29: invokevirtual #13                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        32: pop</span><br><span class="line">        33: aload_0</span><br><span class="line">        34: getfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">        37: invokevirtual #14                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        40: pop</span><br><span class="line">        41: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 14: 33</span><br><span class="line">        line 15: 41</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      42     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br></pre></td></tr></table></figure>

<p>其中有一个属性叫做code，里面的内容就是方法体代码的字节码，它长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line">33: aload_0</span><br><span class="line">34: getfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">37: invokevirtual #14                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">40: pop</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>是的，我们忽略其他，只看调用了<code>guanYu.toString();</code>来作为例子。</p>
<p><code>getfield      #4</code>表示将常量池第四项压入栈。好，常量池第4项还没被解析，那么我们要向解析geiWoShang方法的code，就得先解析常量池第四项。</p>
<p>常量池第四项是啥呢，是个Fieldref，对，是关羽这个字段的Fieldref。</p>
<p>结构抽象后大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Fieldref&#123;</span><br><span class="line">	Class&#123;</span><br><span class="line">		index&#x3D;&quot;com&#x2F;company&#x2F;LiuBei&quot;;index指向的是常量池的  #15&#x3D;com&#x2F;company&#x2F;LiuBei;，表示关羽字段是属于LiuBei类的字段。</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameAndType&#123;</span><br><span class="line">		name_index&#x3D;&quot;guanYu&quot;;&#x2F;&#x2F;字段表，关羽这个字段，指向的是常量池的#18&#x3D;guanYu</span><br><span class="line">		descriptor_index&#x3D;&quot;Ljava&#x2F;lang&#x2F;Object&quot;;&#x2F;&#x2F;descriptor_index指向的是常量池的  #19&#x3D;Ljava&#x2F;lang&#x2F;Object;，表示关羽字段的类型是object类</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析字段，前提是它所属的类要被加载，我们根据Fieldref的Class_info知道他所属的类是LiuBei，这个已经加载过了，那忽略。（否则，就进入了别的类的加载过程，即用刘备类的加载器区加载别的类。）</p>
<p>然后根据Fieldref的name_index和descriptor_index得到该字段的名称和描述符，去所属类LiuBei的字段表中寻找名称和描述符完全一致的字段。好，找到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object guanYu;&#x2F;&#x2F;字段表，关羽这个字段，name_index指向的是常量池的#18&#x3D;guanYu</span><br><span class="line">  descriptor: Ljava&#x2F;lang&#x2F;Object;&#x2F;&#x2F;descriptor_index指向的是常量池的  #19&#x3D;Ljava&#x2F;lang&#x2F;Object;，表示类型是object类</span><br><span class="line">  flags:</span><br></pre></td></tr></table></figure>

<p><strong>那么把关羽这个字段表在刘备类中的偏移量当做直接引用，覆盖常量池的第四项，即#4=关羽这个字段表在刘备类中的偏移量</strong>，关羽字段解析完毕，做个标记，解析完成。</p>
<p>这样下次执行<code>getfield      #4</code>时，#4直接指向了关羽字段表的直接引用。</p>
<p>同理，我们接下来解析<code>invokevirtual #14</code>，表示调用#14指向的示例方法。</p>
<p>常量池中#14 = Methodref长这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Methodref&#123;</span><br><span class="line">	Class&#123;</span><br><span class="line">		index&#x3D;&quot;java&#x2F;lang&#x2F;Object&quot;;index指向的是常量池的  #3&#x3D;java&#x2F;lang&#x2F;Object;，表示该方法是Object的方法。</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameAndType&#123;</span><br><span class="line">		name_index&#x3D;&quot; toString&quot;;&#x2F;&#x2F;指向的是常量池的#53&#x3D;toString，表示名称</span><br><span class="line">		descriptor_index&#x3D;&quot;()Ljava&#x2F;lang&#x2F;String&quot;;&#x2F;&#x2F;descriptor_index指向的是常量池的  #54&#x3D;()Ljava&#x2F;lang&#x2F;String;，表示方法描述符</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，先解析所属的Object类，哦，也加载过了。</p>
<p>那么根据名称和描述符，去Object类的方法表中找到toString方法的偏移量，然后赋值给常量池第十四项。</p>
<p>以此类推，完成所有类的符号引用向直接引用的转变。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。<strong>给类变量赋初值</strong>，此时“织席贩履”可以赋值在之前留出的空间上了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/" itemprop="url">理解sql中的group by和having</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-06T22:22:26+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/" itemprop="url" rel="index">
                    <span itemprop="name">SQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/06/理解sql中的group-by和having/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>group by的可以帮助我们在特定场景下查询到我们需要的数据，但group by的用法一直给人一种“飘忽”感，究其原因，还是对于该关键字缺乏深入理解。</p>
<p>下面通过一个例子，来简单解释group by的原理。</p>
<h1 id="1-GROUP-BY"><a href="#1-GROUP-BY" class="headerlink" title="1. GROUP BY"></a>1. GROUP BY</h1><p>假设我们有表1，表名为test：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f560d6cf443d0db4819d8937d7578ea7c68.png" alt=""></p>
<p>如果我们执行如下SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM test GROUP BY name</span><br></pre></td></tr></table></figure>

<p>我们很容易可以得到运行的结果：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9551ddc4e56b11de88135ebbd526595cc93.png" alt=""></p>
<p>为了能够更好的理解“group by”多个列“和”聚合函数“的应用，这里可以在表1到表2的过程中，引入一个虚构的中间表：虚拟表3。</p>
<p>FROM test Group BY name：该句执行后，我们想象生成了虚拟表3，如下所图所示：</p>
<p>生成过程是这样的：group by name，那么找name那一列，具有相同name值的行，合并成一行，如对于name值为aa的，那么&lt;1 aa 2&gt;与&lt;2 aa 3&gt;两行合并成1行，所有的id值和number值写到一个单元格里面。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-edcd036013105bd3619a93114d35d78963c.png" alt=""></p>
<p>接下来再针对虚拟表3执行Select语句：</p>
<ol>
<li><p>如果执行<code>select *</code>的话，那么返回的结果应该是虚拟表3，可是id和number中有的单元格里面的内容是多个值的，而关系数据库就是基于关系的，单元格中是不允许有多个值的，所以，执行<code>select *</code> 语句是不允许的。</p>
<ul>
<li><blockquote>
<p>为了约束使用者在编写group by时select多值字段，设计DBMS的开发者也是伤透了脑筋。开发者并不知道将来这个数据库会被用来做什么，所以，他不可能从逻辑上来检查你的select上出现的语句是不是分组属性的一个子集。所以，最简单的方法就是看你的select上出现的属性在group by上出现过。出现过，就通过编译，否则不会。</p>
</blockquote>
</li>
<li><blockquote>
<p>mysql对group by 进行了非ANSI标准的扩展，允许select后含有非group by 的列。所以在mysql中，group by时执行<code>select *</code>不会报错 ，但也得不到我们想要的数据，只会select出原表中的第一个数据</p>
</blockquote>
</li>
</ul>
</li>
<li><p>我们再看name列，每个单元格只有一个数据，所以我们select name的话，就没有问题了。为什么name列每个单元格只有一个值呢，因为我们就是用name列来group by的。</p>
</li>
<li><p>那么对于id和number里面的单元格有多个数据的情况怎么办呢？答案就是用聚合函数，聚合函数就用来输入多个数据，输出一个数据的。如cout(id)，sum(number)，而每个聚合函数的输入就是每一个多数据的单元格。</p>
<ul>
<li>例如我们执行select name,sum(number) from test group by name，那么sum就对虚拟表3的number列的每个单元格进行sum操作，例如对name为aa的那一行的number列执行sum操作，即2+3，返回5，最后执行结果如下：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-3f894207fcec5efe321e2b909f0792ae5f8.png" alt=""></li>
</ul>
</li>
<li><p>group by 多个字段该怎么理解呢：如group by name,number，我们可以把name和number 看成一个整体字段，以他们整体来进行分组的。如下图</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-1489c508db4ee297aa099d9397969eb9e95.png" alt=""></li>
<li>接下来就可以配合select和聚合函数进行操作了。如执行select name,sum(id) from test group by name,number，结果如下图：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-6a3e63a11874a6f61681dcc8e09acd69bf2.png" alt="">- </li>
</ul>
</li>
</ol>
<h1 id="2-HAVING"><a href="#2-HAVING" class="headerlink" title="2. HAVING"></a>2. HAVING</h1><blockquote>
<p><strong>首先，不要错误的认为having必须和group by 配合使用。其实having可以单独使用</strong></p>
</blockquote>
<p>having关键字在我们的印象中，貌似和where关键字十分相似，那二者有什么区别呢？</p>
<ol>
<li>含义：<ul>
<li>“Where”是一个约束声明，在查询数据库的结果返回结果之前对数据库中的查询条件进行约束，<strong>即在结果返回之前起作用</strong>，且where后面不能使用“聚合函数”；<ul>
<li>where后面之所以不能使用聚合函数是因为where的执行顺序在聚合函数之前，所以在执行where的时候，还没有结果集，更别说对结果集做聚合了。</li>
</ul>
</li>
<li>Having”是一个过滤声明，所谓过滤是在查询数据库的结果返回之后进行过滤，<strong>即在结果返回之后起作用</strong>，并且having后面可以使用“聚合函数”。<ul>
<li>having既然是对查出来的结果进行过滤，那么就不能对没有select出来的字段使用having，如<code>select  id , name from student having score &gt;90;</code>这句话就是错误的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>where和having，一个是起作用在结果返回前，用来过滤记录；一个是起作用在结果返回后，用来过滤结果。这种场景的典型应用如这句：<code>SELECT region,count(school) FROM T02_Bejing_school WHERE region IN (&#39;海淀&#39; , &#39;西城&#39; , &#39;东城&#39;) GROUP BY region HAVING count(school) &gt; 10;</code>该句sql可以筛选出北京西城、东城、海淀三个区中学校数量超过10所的区及各区学校数量。即先用where把这三个区的中学过滤出来，然后对结果集做group by，得到一张组合后的虚拟表，最后通过having对虚拟表做二次过滤。</p>
</blockquote>
<ol start="2">
<li>使用的场景：<ul>
<li>只有WHERE可以使用的场景：<ul>
<li>除select外，where还可以用于update、delete和insert into values(select * from table where ..)语句中，having则不行。</li>
<li>select语句中，没有select出要被约束的字段的时候，也不可以使用having。就如上文提到的非法语句：<code>select  id , name from student having score &gt;90;</code></li>
</ul>
</li>
<li>只有HAVING可以使用的场景：<ul>
<li>如果要过滤的字段是原生表中不存在的字段，而是经过聚合函数计算后的字段，那么不可以使用where，只能用having。如：<ul>
<li>合法语句：<code>select id , avg(price) as ag from goods group by category having ag &gt; 1000</code><ul>
<li>非法语句：<code>select id , avg(price) as ag from goods where ag group by category &gt; 1000</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>二者都可以使用的场景：<ul>
<li>要约束的字段既是原生表的字段，又是sql中被select出来的字段，这时候where和having等效：<ul>
<li><code>select price , name from goods where price &gt; 100</code></li>
<li><code>select price , name from goods having price &gt; 100</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blog.csdn.net/hao1066821456/article/details/69556644" target="_blank" rel="noopener" title="理解group by">理解group by</a></li>
<li><a href="https://blog.csdn.net/suliangkuanjiayou/article/details/94337233" target="_blank" rel="noopener" title="Group by的理解">Group by的理解</a></li>
<li><a href="https://blog.csdn.net/yexudengzhidao/article/details/54924471" target="_blank" rel="noopener" title="正确理解MySQL中的where和having的区别">正确理解MySQL中的where和having的区别</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-hand-o-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-hand-o-right" aria-label="accessibility.next_page"></i></a>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">417.6k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
