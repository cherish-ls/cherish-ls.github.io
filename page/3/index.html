<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" itemprop="url">JAVA静态/动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T17:02:42+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E5%AE%9E%E7%8E%B0%E6%88%96%E7%89%B9%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA实现或特性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/26/JAVA静态-动态代理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-静态代理（简单描述）"><a href="#1-静态代理（简单描述）" class="headerlink" title="1 静态代理（简单描述）"></a>1 静态代理（简单描述）</h1><p>先定义一个接口，里面定义目标方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;目标类要实现的接口</span><br><span class="line">public interface ITarget &#123;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;目标方法</span><br><span class="line">	void doFunc(String words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个代理类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class StaticProxy implements ITarget&#123;</span><br><span class="line">	</span><br><span class="line">	private ITarget target &#x3D; null;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;关联要增强的目标类</span><br><span class="line">    public StaticProxy(ITarget target)&#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	&#x2F;&#x2F;在这里增强目标类的目标方法</span><br><span class="line">	@Override</span><br><span class="line">	public void doFunc() &#123;</span><br><span class="line">	    ...</span><br><span class="line">	    ...</span><br><span class="line">	    ...</span><br><span class="line">        &#x2F;&#x2F;增强目标方法</span><br><span class="line">        target.doFunc();</span><br><span class="line">        ...</span><br><span class="line">	    ...</span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以后，任意的一个ITarget接口的子类，都可以注入给StaticProxy类，然后实现一套增强，不再赘述。</p>
<h1 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2 动态代理"></a>2 动态代理</h1><p>代理类在程序运行时创建的代理方式被成为 动态代理。也就是说，这种情况下，代理类并不是像静态代理一样，是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。</p>
<p>动态代理是spring AOP的实现原理，spring有两种动态代理模式，cglib和jdk，我们先来将java jdk的动态代理。</p>
<h2 id="2-1-jdk的动态代理"><a href="#2-1-jdk的动态代理" class="headerlink" title="2.1 jdk的动态代理"></a>2.1 jdk的动态代理</h2><p>首先，我们需要知道，jdk的动态代理只能代理实现了接口的类 没有实现接口的类不能实现JDK动态代理。其次，我们还要了解一个重要的中介接口InvocationHandler，这是jdk的动态代理的基石，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">        throws Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来写一个jdk的动态代理实例，再来讨论其中的原理吧</p>
<h3 id="2-1-1-jdk动态代理实例"><a href="#2-1-1-jdk动态代理实例" class="headerlink" title="2.1.1 jdk动态代理实例"></a>2.1.1 jdk动态代理实例</h3><p>我们先来定义一个目标类，或者说委托类，或者又叫被代理类，它实现了我们上面定义的那个接口ITarget：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Entrust implements ITarget &#123;</span><br><span class="line">    public void doFunc(String words)&#123;</span><br><span class="line">        System.out.println(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再定义一个中介类，实现InvocationHandler接口，这个中介类，持有被代理的对象，在invoke中利用反射，调用目标类的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class JdkDynamicProxyHandler&lt;T&gt;  implements InvocationHandler &#123;</span><br><span class="line">    &#x2F;&#x2F;invocationHandler持有的被代理对象</span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    public JdkDynamicProxyHandler(T target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * proxy:代表动态代理对象</span><br><span class="line">     * method：代表正在执行的方法</span><br><span class="line">     * args：代表调用目标方法时传入的实参</span><br><span class="line">     * </span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;do before&quot;);</span><br><span class="line">        Object result &#x3D; method.invoke(target, args);</span><br><span class="line">        System.out.println(&quot;do after&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我们现在来写一个代理demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个实例对象，这个对象是被代理的对象</span></span><br><span class="line">        ITarget attorney = <span class="keyword">new</span> Attorney();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个与代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler jdkDynamicProxyHandler = <span class="keyword">new</span> JdkDynamicProxyHandler&lt;ITarget&gt;(attorney);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个代理对象proxy来代理attorney，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">        ITarget proxy = (ITarget) Proxy.newProxyInstance(ITarget.class.getClassLoader(), new Class&lt;?&gt;[]&#123;ITarget.class&#125;, jdkDynamicProxyHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        proxy.doFunc(<span class="string">"hello word"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将生成的代理类写到桌面</span></span><br><span class="line">        writeProxyClassToHardDisk(<span class="string">"/home/ls/Desktop/$Proxy22.class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeProxyClassToHardDisk</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classFile = ProxyGenerator.generateProxyClass(<span class="string">"$Proxy22"</span>, Attorney<span class="class">.<span class="keyword">class</span>.<span class="title">getInterfaces</span>())</span>;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">            out.write(classFile);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f546dfbc4dc94c8202ee7ec822f109c869c.png" alt=""></p>
<h3 id="2-1-2-原理剖析"><a href="#2-1-2-原理剖析" class="headerlink" title="2.1.2 原理剖析"></a>2.1.2 原理剖析</h3><p>我们来看看Proxy.newProxyInstance方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        final Class&lt;?&gt;[] intfs &#x3D; interfaces.clone();</span><br><span class="line">        final SecurityManager sm &#x3D; System.getSecurityManager();</span><br><span class="line">        if (sm !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;验证一些参数</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Look up or generate the designated proxy class.</span><br><span class="line">         * 从缓存里面获取某个类的代理类，如果该类的代理类不存在，就根据该类的类型创建一个</span><br><span class="line">         * 如果要深挖逻辑，可以看看ProxyClassFactory的apply方法。</span><br><span class="line">         * 其实生成代理类字节码文件的工作是通过 ProxyGenerate类中的generateProxyClass方法来完成的。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Class&lt;?&gt; cl &#x3D; getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Invoke its constructor with the designated invocation handler.</span><br><span class="line">         *</span><br><span class="line">         * &#x2F;** parameter types of a proxy class constructor *&#x2F;</span><br><span class="line">         * private static final Class&lt;?&gt;[] constructorParams &#x3D; &#123; InvocationHandler.class &#125;;</span><br><span class="line">         * </span><br><span class="line">         *&#x2F;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (sm !&#x3D; null) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;看上面的注释，constructorParams&#x3D;&#123; InvocationHandler.class &#125;，</span><br><span class="line">            &#x2F;&#x2F;这是在生成代理类的构造函数,获得一个参数为InvocationHandler的构造方法</span><br><span class="line">            final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih &#x3D; h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        cons.setAccessible(true);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;这行代码的意思是将h,也就是实现InvocationHandler的实现类，</span><br><span class="line">            &#x2F;&#x2F;我们传入的是jdkDynamicProxyHandler，注入到cons中。</span><br><span class="line">            &#x2F;&#x2F;然后newInstance生成一个已经组装过参数的代理类。</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t &#x3D; e.getCause();</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们最应该关注的是 Class&lt;?&gt; cl = getProxyClass0(loader, intfs);这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的。</p>
<p>我们对这个代理类进行反编译：（本次使用<a href="http://www.javadecompilers.com/在线反编译工具）" target="_blank" rel="noopener">http://www.javadecompilers.com/在线反编译工具）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import aopLearn.ITarget;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F; Decompiled by Procyon v0.5.30</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line"></span><br><span class="line">public final class $Proxy22 extends Proxy implements ITarget</span><br><span class="line">&#123;</span><br><span class="line">    private static Method m1;</span><br><span class="line">    private static Method m3;</span><br><span class="line">    private static Method m2;</span><br><span class="line">    private static Method m0;</span><br><span class="line">    &#x2F;**</span><br><span class="line">      *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白了</span><br><span class="line">      *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span><br><span class="line">      *被代理对象的实例</span><br><span class="line">      *</span><br><span class="line">      *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span><br><span class="line">      *父类持有：protected InvocationHandler h;</span><br><span class="line">      *Proxy构造方法：</span><br><span class="line">      *    protected Proxy(InvocationHandler h) &#123;</span><br><span class="line">      *         Objects.requireNonNull(h);</span><br><span class="line">      *         this.h &#x3D; h;</span><br><span class="line">      *     &#125;</span><br><span class="line">      *</span><br><span class="line">      *&#x2F;</span><br><span class="line">    public $Proxy22(final InvocationHandler invocationHandler) &#123;</span><br><span class="line">        super(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;这个静态块本来是在最后的，我把它拿到前面来，方便描述</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;doFunc通过反射得到的名字m3</span><br><span class="line">            $Proxy22.m1 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));</span><br><span class="line">            $Proxy22.m3 &#x3D; Class.forName(&quot;aopLearn.ITarget&quot;).getMethod(&quot;doFunc&quot;, Class.forName(&quot;java.lang.String&quot;));</span><br><span class="line">            $Proxy22.m2 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, (Class&lt;?&gt;[])new Class[0]);</span><br><span class="line">            $Proxy22.m0 &#x3D; Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, (Class&lt;?&gt;[])new Class[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (NoSuchMethodException ex) &#123;</span><br><span class="line">            throw new NoSuchMethodError(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (ClassNotFoundException ex2) &#123;</span><br><span class="line">            throw new NoClassDefFoundError(ex2.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final boolean equals(final Object o) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (boolean)super.h.invoke(this, $Proxy22.m1, new Object[] &#123; o &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">      * </span><br><span class="line">      *这里调用代理对象的doFunc方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span><br><span class="line">      *this.h.invoke(this, m3, null);这里简单，明了。</span><br><span class="line">      *代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span><br><span class="line">      *再联系到InvacationHandler中的invoke方法。其实就是代理对象调用InvocationHandler，</span><br><span class="line">      * InvocationHandler对象反射调用委托类对象。</span><br><span class="line">      *&#x2F;</span><br><span class="line">    public final void doFunc(final String s) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            super.h.invoke(this, $Proxy22.m3, new Object[] &#123; s &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final String toString() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (String)super.h.invoke(this, $Proxy22.m2, null);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (int)super.h.invoke(this, $Proxy22.m0, null);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Error | RuntimeException error) &#123;</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new UndeclaredThrowableException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完了这些，我们来想一下，为什么jdk的动态代理，一定要委托类实现一个接口？这是因为我们可以看到，<strong>我们生成的代理类Proxy22 extends Proxy implements ITarget，已经继承了Proxy类，而java中不能多继承，为了让$Proxy22和委托类建立联系，只能实现一个接口</strong>。这里的建立联系，是指通过接口，得到委托类方法的反射等，<strong>并且，委托类实现自接口的方法，才能被增强</strong>。</p>
<p>故而，本质上来说，jdk的动态代理，<strong>是为接口产生代理</strong>。</p>
<p>在spring AOP中，我们使用jdk动态代理时当然也要定义InvocationHandler的实现类对象，spring中的是org.springframework.aop.framework.JdkDynamicAopProxy类。</p>
<h2 id="2-2-cglib的动态代理"><a href="#2-2-cglib的动态代理" class="headerlink" title="2.2 cglib的动态代理"></a>2.2 cglib的动态代理</h2><p>cglib的动态代理针对类来实现代理,对指定目标产生一个子类 通过方法拦截技术拦截所有父类方法的调用。我们要使用cglib代理必须引入cglib的jar包。</p>
<h3 id="2-2-1-cglib动态代理实例"><a href="#2-2-1-cglib动态代理实例" class="headerlink" title="2.2.1 cglib动态代理实例"></a>2.2.1 cglib动态代理实例</h3><p>同样，定义一个跟上面例子一样的委托类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Entrust &#123;</span><br><span class="line">    public void doFunc(String words)&#123;</span><br><span class="line">        System.out.println(words);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现MethodInterceptor接口生成方法拦截器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class EntrustInterceptor implements MethodInterceptor&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">        Object o &#x3D; proxy.invokeSuper(obj,args);</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] a)&#123;</span><br><span class="line">    &#x2F;&#x2F;cglib自带的debug工具，可以将代理类输出到指定路径</span><br><span class="line">    System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;&#x2F;home&#x2F;ls&#x2F;Desktop&#x2F;cglib&quot;);</span><br><span class="line">    Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">    &#x2F;&#x2F;继承被代理类</span><br><span class="line">    enhancer.setSuperclass(Entrust.class);</span><br><span class="line">    enhancer.setCallback(new EntrustInterceptor());</span><br><span class="line">    &#x2F;&#x2F;生成的代理类对象</span><br><span class="line">    Entrust entrust &#x3D; (Entrust) enhancer.create();</span><br><span class="line">    &#x2F;&#x2F;在调用我们代理类中的方法时会被我们实现的方法拦截器拦截</span><br><span class="line">    entrust.doFunc(&quot;hello word&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：<br><img src="https://oscimg.oschina.net/oscnet/up-b3377d0e8764157f3d7b386c8cf3223b381.png" alt=""></p>
<h3 id="2-2-2-原理剖析"><a href="#2-2-2-原理剖析" class="headerlink" title="2.2.2 原理剖析"></a>2.2.2 原理剖析</h3><p>CGLIB会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。在CGLIB底层，其实是借助了ASM这个非常强大的Java字节码生成框架。</p>
<p>我们看到，代理类对象是由Enhancer类创建的。Enhancer是CGLIB的字节码增强器，可以很方便的对类进行拓展，创建代理对象的几个步骤:</p>
<ol>
<li>生成代理类的二进制字节码文件；</li>
<li>加载二进制字节码，生成Class对象( 例如使用Class.forName()方法 )；</li>
<li>通过反射机制获得实例构造，并创建代理类对象</li>
</ol>
<p>我们来看看将代理类Class文件反编译之后的Java代码，一个动态代理，产生了三个类：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6c31ef9c2dc4797d243753037ae6e48b39b.png" alt=""></p>
<p>主要的代理类是 </p>
<pre><code>Entrust$$EnhancerByCGLIB$$832e20ab</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Decompiled by Procyon v0.5.30</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.lufax.util.aopCache.cglibProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.Signature;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.core.ReflectUtils;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Callback;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Factory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成的代理类Entrust$$EnhancerByCGLIB$$832e20ab继承被代理类Entrust。</span></span><br><span class="line"><span class="comment"> * 在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；</span></span><br><span class="line"><span class="comment"> * 同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entrust</span>$$<span class="title">EnhancerByCGLIB</span>$$832<span class="title">e20ab</span> <span class="keyword">extends</span> <span class="title">Entrust</span> <span class="keyword">implements</span> <span class="title">Factory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> CGLIB$BOUND;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CGLIB$STATIC_CALLBACKS;</span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$doFunc$<span class="number">0</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$doFunc$<span class="number">0</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] CGLIB$emptyArgs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$finalize$<span class="number">1</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$finalize$<span class="number">1</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$equals$<span class="number">2</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$equals$<span class="number">2</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$toString$<span class="number">3</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$toString$<span class="number">3</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$hashCode$<span class="number">4</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$hashCode$<span class="number">4</span>$Proxy;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CGLIB$clone$<span class="number">5</span>$Method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodProxy CGLIB$clone$<span class="number">5</span>$Proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$STATICHOOK1() &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName = Class.forName(<span class="string">"com.lufax.util.aopCache.cglibProxy.Entrust$$EnhancerByCGLIB$$832e20ab"</span>);</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName2;</span><br><span class="line">        <span class="keyword">final</span> Method[] methods = ReflectUtils.findMethods(<span class="keyword">new</span> String[] &#123; <span class="string">"finalize"</span>, <span class="string">"()V"</span>, <span class="string">"equals"</span>, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"toString"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"hashCode"</span>, <span class="string">"()I"</span>, <span class="string">"clone"</span>, <span class="string">"()Ljava/lang/Object;"</span> &#125;, (forName2 = Class.forName(<span class="string">"java.lang.Object"</span>)).getDeclaredMethods());</span><br><span class="line">        CGLIB$finalize$<span class="number">1</span>$Method = methods[<span class="number">0</span>];</span><br><span class="line">        CGLIB$finalize$<span class="number">1</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()V"</span>, <span class="string">"finalize"</span>, <span class="string">"CGLIB$finalize$1"</span>);</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Method = methods[<span class="number">1</span>];</span><br><span class="line">        CGLIB$equals$<span class="number">2</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"(Ljava/lang/Object;)Z"</span>, <span class="string">"equals"</span>, <span class="string">"CGLIB$equals$2"</span>);</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Method = methods[<span class="number">2</span>];</span><br><span class="line">        CGLIB$toString$<span class="number">3</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()Ljava/lang/String;"</span>, <span class="string">"toString"</span>, <span class="string">"CGLIB$toString$3"</span>);</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Method = methods[<span class="number">3</span>];</span><br><span class="line">        CGLIB$hashCode$<span class="number">4</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()I"</span>, <span class="string">"hashCode"</span>, <span class="string">"CGLIB$hashCode$4"</span>);</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Method = methods[<span class="number">4</span>];</span><br><span class="line">        CGLIB$clone$<span class="number">5</span>$Proxy = MethodProxy.create((Class)forName2, (Class)forName, <span class="string">"()Ljava/lang/Object;"</span>, <span class="string">"clone"</span>, <span class="string">"CGLIB$clone$5"</span>);</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; forName3;</span><br><span class="line">        CGLIB$doFunc$<span class="number">0</span>$Method = ReflectUtils.findMethods(<span class="keyword">new</span> String[] &#123; <span class="string">"doFunc"</span>, <span class="string">"(Ljava/lang/String;)V"</span> &#125;, (forName3 = Class.forName(<span class="string">"com.lufax.util.aopCache.cglibProxy.Entrust"</span>)).getDeclaredMethods())[<span class="number">0</span>];</span><br><span class="line">        CGLIB$doFunc$<span class="number">0</span>$Proxy = MethodProxy.create((Class)forName3, (Class)forName, <span class="string">"(Ljava/lang/String;)V"</span>, <span class="string">"doFunc"</span>, <span class="string">"CGLIB$doFunc$0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//代理类会为委托方法生成两个方法，一个是重写的doFunc方法，</span></span><br><span class="line">    <span class="comment">//另一个是CGLIB$doFunc$0方法，我们可以看到它是直接调用父类的doFunc方法；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$doFunc$<span class="number">0</span>(<span class="keyword">final</span> String s) &#123;</span><br><span class="line">        <span class="keyword">super</span>.doFunc(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当执行代理对象的doFunc方法时，会首先判断一下是否存在实现了MethodInterceptor接口的CGLIB$CALLBACK_0;</span></span><br><span class="line">    <span class="comment">//如果存在，则将调用MethodInterceptor中的intercept方法，如图2.1。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doFunc</span><span class="params">(<span class="keyword">final</span> String s)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//这里开始调用我们定义的EntrustInterceptor中的intercept方法。</span></span><br><span class="line">            <span class="comment">//参数1、代理对象；2、委托类方法；3、方法参数；4、代理方法的MethodProxy对象（注意这个对象）。</span></span><br><span class="line">            cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$doFunc$<span class="number">0</span>$Method, <span class="keyword">new</span> Object[] &#123; s &#125;, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$doFunc$<span class="number">0</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.doFunc(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$finalize$<span class="number">1</span>() <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$finalize$<span class="number">1</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$finalize$<span class="number">1</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> CGLIB$equals$<span class="number">2</span>(<span class="keyword">final</span> Object o) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">final</span> Object o)</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object intercept = cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$equals$<span class="number">2</span>$Method, <span class="keyword">new</span> Object[] &#123; o &#125;, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$equals$<span class="number">2</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> intercept != <span class="keyword">null</span> &amp;&amp; (<span class="keyword">boolean</span>)intercept;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> String CGLIB$toString$<span class="number">3</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$toString$<span class="number">3</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$toString$<span class="number">3</span>$Proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> CGLIB$hashCode$<span class="number">4</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object intercept = cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$hashCode$<span class="number">4</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$hashCode$<span class="number">4</span>$Proxy);</span><br><span class="line">            <span class="keyword">return</span> (intercept == <span class="keyword">null</span>) ? <span class="number">0</span> : ((Number)intercept).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Object CGLIB$clone$<span class="number">5</span>() <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_2;</span><br><span class="line">        MethodInterceptor cglib$CALLBACK_0;</span><br><span class="line">        <span class="keyword">if</span> ((cglib$CALLBACK_0 = (cglib$CALLBACK_2 = <span class="keyword">this</span>.CGLIB$CALLBACK_0)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">            cglib$CALLBACK_2 = (cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cglib$CALLBACK_0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cglib$CALLBACK_2.intercept((Object)<span class="keyword">this</span>, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$clone$<span class="number">5</span>$Method, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$emptyArgs, Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$clone$<span class="number">5</span>$Proxy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodProxy CGLIB$findMethodProxy(<span class="keyword">final</span> Signature signature) &#123;</span><br><span class="line">        <span class="keyword">final</span> String string = signature.toString();</span><br><span class="line">        <span class="keyword">switch</span> (string.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">1574182249</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"finalize()V"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$finalize$<span class="number">1</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">508378822</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"clone()Ljava/lang/Object;"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$clone$<span class="number">5</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">346793840</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"doFunc(Ljava/lang/String;)V"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$doFunc$<span class="number">0</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1826985398</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"equals(Ljava/lang/Object;)Z"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$equals$<span class="number">2</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1913648695</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"toString()Ljava/lang/String;"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$toString$<span class="number">3</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1984935277</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (string.equals(<span class="string">"hashCode()I"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$hashCode$<span class="number">4</span>$Proxy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">final</span> Callback[] array) &#123;</span><br><span class="line">        Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$THREAD_CALLBACKS.set(array);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> CGLIB$SET_STATIC_CALLBACKS(<span class="keyword">final</span> Callback[] cglib$STATIC_CALLBACKS) &#123;</span><br><span class="line">        CGLIB$STATIC_CALLBACKS = cglib$STATIC_CALLBACKS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> CGLIB$BIND_CALLBACKS(<span class="keyword">final</span> Object o) &#123;</span><br><span class="line">        <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = (Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab)o;</span><br><span class="line">        <span class="keyword">if</span> (!entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$BOUND) &#123;</span><br><span class="line">            entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$BOUND = <span class="keyword">true</span>;</span><br><span class="line">            Object o2;</span><br><span class="line">            <span class="keyword">if</span> ((o2 = Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$THREAD_CALLBACKS.get()) != <span class="keyword">null</span> || (o2 = Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$STATIC_CALLBACKS) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])o2)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Callback[] array)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(array);</span><br><span class="line">        <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = <span class="keyword">new</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">new</span> Callback[] &#123; callback &#125;);</span><br><span class="line">        <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = <span class="keyword">new</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab();</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newInstance</span><span class="params">(<span class="keyword">final</span> Class[] array, <span class="keyword">final</span> Object[] array2, <span class="keyword">final</span> Callback[] array3)</span> </span>&#123;</span><br><span class="line">        CGLIB$SET_THREAD_CALLBACKS(array3);</span><br><span class="line">        <span class="keyword">switch</span> (array.length) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">final</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab = <span class="keyword">new</span> Entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab();</span><br><span class="line">                CGLIB$SET_THREAD_CALLBACKS(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> entrust$$EnhancerByCGLIB$$<span class="number">832e20</span>ab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Constructor not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callback <span class="title">getCallback</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        Object cglib$CALLBACK_0 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                cglib$CALLBACK_0 = <span class="keyword">this</span>.CGLIB$CALLBACK_0;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                cglib$CALLBACK_0 = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Callback)cglib$CALLBACK_0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallback</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> n, <span class="keyword">final</span> Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)callback;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Callback[] getCallbacks() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Callback[] &#123; <span class="keyword">this</span>.CGLIB$CALLBACK_0 &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCallbacks</span><span class="params">(<span class="keyword">final</span> Callback[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CGLIB$CALLBACK_0 = (MethodInterceptor)array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        CGLIB$STATICHOOK1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑进入到我们在EntrustInterceptor 中定义的intercept方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;before&quot;);</span><br><span class="line">    Object o &#x3D; proxy.invokeSuper(obj,args);</span><br><span class="line">    System.out.println(&quot;after&quot;);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看MethodProxy的invokeSuper方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * Invoke the original (super) method on the specified object.</span><br><span class="line">     * @param obj the enhanced object, must be the object passed as the first</span><br><span class="line">     * argument to the MethodInterceptor</span><br><span class="line">     * @param args the arguments passed to the intercepted method; you may substitute a different</span><br><span class="line">     * argument array as long as the types are compatible</span><br><span class="line">     * @see MethodInterceptor#intercept</span><br><span class="line">     * @throws Throwable the bare exceptions thrown by the called method are passed through</span><br><span class="line">     * without wrapping in an &lt;code&gt;InvocationTargetException&lt;&#x2F;code&gt;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object invokeSuper(Object obj, Object[] args) throws Throwable &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            init();</span><br><span class="line">            FastClassInfo fci &#x3D; fastClassInfo;</span><br><span class="line">            &#x2F;&#x2F;f2是由CGlib生成的,在输出的class中有这个类。</span><br><span class="line">            &#x2F;&#x2F;它就是Entrust$$EnhancerByCGLIB$$832e20ab$$FastClassByCGLIB$$817a77c.class</span><br><span class="line">            return fci.f2.invoke(fci.i2, obj, args);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            throw e.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们把</p>
<pre><code>Entrust$$EnhancerByCGLIB$$832e20ab$$FastClassByCGLIB$$817a77c.class</code></pre><p>也反编译出来，然后贴出invoke方法,注意case14调用了</p>
<pre><code>entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$doFunc$0((String)array[0]);：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(final int n, final Object o, final Object[] array) throws InvocationTargetException &#123;</span><br><span class="line">        final Entrust$$EnhancerByCGLIB$$832e20ab entrust$$EnhancerByCGLIB$$832e20ab &#x3D; (Entrust$$EnhancerByCGLIB$$832e20ab)o;</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (n) &#123;</span><br><span class="line">                case 0: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.setCallbacks((Callback[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 1: &#123;</span><br><span class="line">                    Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$SET_STATIC_CALLBACKS((Callback[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 2: &#123;</span><br><span class="line">                    Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$SET_THREAD_CALLBACKS((Callback[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 3: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.getCallback(((Number)array[0]).intValue());</span><br><span class="line">                &#125;</span><br><span class="line">                case 4: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.getCallbacks();</span><br><span class="line">                &#125;</span><br><span class="line">                case 5: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.doFunc((String)array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 6: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.setCallback(((Number)array[0]).intValue(), (Callback)array[1]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 7: &#123;</span><br><span class="line">                    return Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$findMethodProxy((Signature)array[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 8: &#123;</span><br><span class="line">                    Entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$STATICHOOK1();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 9: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$finalize$1();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 10: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$toString$3();</span><br><span class="line">                &#125;</span><br><span class="line">                case 11: &#123;</span><br><span class="line">                    return new Integer(entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$hashCode$4());</span><br><span class="line">                &#125;</span><br><span class="line">                case 12: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$clone$5();</span><br><span class="line">                &#125;</span><br><span class="line">                case 13: &#123;</span><br><span class="line">                    return new Boolean(entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$equals$2(array[0]));</span><br><span class="line">                &#125;</span><br><span class="line">                case 14: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.CGLIB$doFunc$0((String)array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 15: &#123;</span><br><span class="line">                    return new Boolean(entrust$$EnhancerByCGLIB$$832e20ab.equals(array[0]));</span><br><span class="line">                &#125;</span><br><span class="line">                case 16: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                case 17: &#123;</span><br><span class="line">                    return new Integer(entrust$$EnhancerByCGLIB$$832e20ab.hashCode());</span><br><span class="line">                &#125;</span><br><span class="line">                case 18: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.newInstance((Callback)array[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 19: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.newInstance((Class[])array[0], (Object[])array[1], (Callback[])array[2]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 20: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.newInstance((Callback[])array[0]);</span><br><span class="line">                &#125;</span><br><span class="line">                case 21: &#123;</span><br><span class="line">                    Entrust.main((String[])array[0]);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 22: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.wait(((Number)array[0]).longValue(), ((Number)array[1]).intValue());</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 23: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.wait(((Number)array[0]).longValue());</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 24: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.wait();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 25: &#123;</span><br><span class="line">                    return entrust$$EnhancerByCGLIB$$832e20ab.getClass();</span><br><span class="line">                &#125;</span><br><span class="line">                case 26: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.notify();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                case 27: &#123;</span><br><span class="line">                    entrust$$EnhancerByCGLIB$$832e20ab.notifyAll();</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable t) &#123;</span><br><span class="line">            throw new InvocationTargetException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot find matching method&#x2F;constructor&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>事实证明，最后确实是进入了case14，调用了代理类的代理doFunc方法，最后再回到EntrustInterceptor.invoke中。完成逻辑</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" itemprop="url">ZAB协议分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T16:18:54+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分布式算法&理论</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务和数据一致性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/26/ZAB协议分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ZAB并不是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p>
<h1 id="1-ZAB协议内容"><a href="#1-ZAB协议内容" class="headerlink" title="1 ZAB协议内容"></a>1 ZAB协议内容</h1><ul>
<li>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为leader服务器，而余下的其他服务器则成为follower服务器。</li>
<li>leader服务器负责将一个客户端事务请求转换成一个事务proposal，并将该proposal分发给集群中所有的follower服务器。之后leader服务器需要等待所有follower服务器的反馈，一旦超过半数的follower服务器进行了正确的反馈后，那么leader就会自己先commit这个事务，并再次向所有的follower服务器分发commit消息，要求其将前一个proposal进行提交。</li>
</ul>
<p>ZAB有两种基本的模式：<strong>崩溃恢复</strong>和<strong>消息广播</strong>。</p>
<ul>
<li><p>当整个服务框架启动过程中或Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader服务器。</p>
</li>
<li><p>当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式，那么整个服务框架就可以进入消息广播模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够与leader服务器的数据状态保持一致。</p>
</li>
<li><p>Leader选举算法不仅仅需要让Leader自身知道已经被选举为Leader，同时还需要让集群中的所有其他机器也能够快速地感知到选举产生的新的Leader服务器。</p>
</li>
<li><p>当一台同样遵守ZAB协议的服务器启动并加入集群后，如果已经存在leader，那么它会自觉的找到leader，与其进行数据同步，然后一起参与消息广播。</p>
</li>
<li><p>如果follower服务器接收到客户端的事务请求，那么他们会将这个事务请求转发给leader服务器。</p>
</li>
<li><p>当Leader服务器出现崩溃或者机器重启、集群中已经不存在过半的服务器与Leader服务器保持正常通信时，那么在重新开始新的一轮的原子广播事务操作之前，所有进程首先会使用崩溃恢复协议来使彼此到达一致状态，于是整个ZAB流程就会从消息广播模式进入到崩溃恢复模式。</p>
</li>
<li><p>一个机器要成为leader，要获得过半机器的支持，而由于每台机器都可能崩溃，因此整个过程可能出现多个leader，一个机器也可能多次成为leader。</p>
</li>
</ul>
<h1 id="2-消息广播"><a href="#2-消息广播" class="headerlink" title="2 消息广播"></a>2 消息广播</h1><ul>
<li><p>ZAB协议的消息广播过程使用原子广播协议，类似于一个二阶段提交过程，针对客户端的事务请求，Leader服务器会为其生成对应的事务Proposal，并将其发送给集群中其余所有的机器，然后再分别收集各自的选票，最后进行事务提交。</p>
<p>  <img src="https://oscimg.oschina.net/oscnet/ffe6905ecbbad6dd3f977e0ef78de5e1c8e.jpg" alt=""></p>
</li>
<li><p>此处ZAB的二阶段提交和一般的二阶段提交略有不同，ZAB移除了二阶段提交中的事务中断的逻辑，follower服务器要么正常反馈，要么抛弃leader。好处是我们不需要等待所有follower都反馈响应才能提交事务，坏处是集群无法处理leader崩溃而带来的数据不一致的问题。后者需要崩溃恢复模式来解决这个问题。</p>
</li>
<li><p>整个消息广播协议是基于具有FIFO特性的TCP协议来进行网络通信的，因此能够很容易保证消息广播过程中消息接受与发送的顺序性。</p>
</li>
<li><p>整个消息广播过程中，Leader服务器会为每个事务生成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会先为这个Proposal分配一个全局单调递增的唯一ID，称之为事务ID（ZXID），由于ZAB协议需要保证每个消息严格的因果关系，因此必须将每个事务Proposal按照其ZXID的先后顺序来进行排序和处理。</p>
</li>
<li><p>在广播过程中，leader会为每一个follower分配一个单独的队列，然后将需要广播的事务proposal依次放入，并且根据FIFO策略进行消息发送。每个follower接收到proposal之后，都会首先将其以事务日志的形式写入本地磁盘，写入成功后反馈leader一个ack响应。当leader收到超过半数的follower的ack响应之后，就会广播一个commit消息给所有follower以通知其进行事务提交，同时leader自身也完成事务的提交。每个follower在接收到commit之后，也会完成对事务的提交。</p>
</li>
<li><p>在广播过程中，follower接收到proposal之后记录事务日志失败，或者proposal丢失，而是直接接到了这个proposal的commit，那么follower就会向leader发送请求重新申请这个任务，leader会再次发送proposal和commit。</p>
</li>
</ul>
<h1 id="3-崩溃恢复"><a href="#3-崩溃恢复" class="headerlink" title="3 崩溃恢复"></a>3 崩溃恢复</h1><ul>
<li>当整个服务框架启动过程中或Leader服务器出现网络中断、崩溃退出与重启等异常情况无法与半数以上的follower联系时，ZAB协议就会进入恢复模式。</li>
</ul>
<h2 id="3-1-崩溃恢复下的两种情况和所要保证的特性"><a href="#3-1-崩溃恢复下的两种情况和所要保证的特性" class="headerlink" title="3.1 崩溃恢复下的两种情况和所要保证的特性"></a>3.1 崩溃恢复下的两种情况和所要保证的特性</h2><ol>
<li><p>ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有服务器都提交。</p>
<ul>
<li>如果leader在崩溃前发出了proposal1，proposal2，commit1（proposal1的commit），proposal3，commit2（说明leader自己已经commit了proposal2），那么ZAB需要确保恢复后proposal2在所有服务器上都被提交成功，否则会出现不一致。</li>
</ul>
</li>
<li><p>ZAB协议需要确保丢弃那些只在Leader服务器上被提出的事务</p>
<ul>
<li>如果leader服务器A在崩溃前发出了proposal1，proposal2，commit1（proposal1的commit），proposal3，commit2，并且执行了commit3（说明leader自己已经commit了proposal3），但是commit3还未发出，leader便宕机了，那么ZAB需要确保恢复后，A重新加入集群（大概率不是leader了）后，要舍弃proposal3这个事务。<h2 id="3-2-进入崩溃恢复模式的流程"><a href="#3-2-进入崩溃恢复模式的流程" class="headerlink" title="3.2 进入崩溃恢复模式的流程"></a>3.2 进入崩溃恢复模式的流程</h2></li>
</ul>
</li>
<li><p>当leader出现问题，zab协议进入崩溃恢复模式，并且选举出新的leader。当新的leader选举出来以后，如果集群中已经有过半机器完成了leader服务器的状态同（数据同步），退出崩溃恢复，进入消息广播模式。</p>
</li>
</ol>
<ol start="2">
<li>当新的机器加入到集群中的时候，如果已经存在leader服务器，那么新加入的服务器就会自觉进入崩溃恢复模式，找到leader进行数据同步。</li>
</ol>
<h3 id="3-2-1-leader选举算法"><a href="#3-2-1-leader选举算法" class="headerlink" title="3.2.1 leader选举算法"></a>3.2.1 leader选举算法</h3><p>在崩溃恢复过程中需要处理的特殊情况，就决定了ZAB协议必须设计这样的</p>
<ul>
<li>能够确保提交已经被Leader提交的事务的Proposal，同时丢弃已经被跳过的事务Proposal。</li>
<li>如果让Leader选举算法能够保证新选举出来的Leader服务器拥有集群所有机器中最高编号（ZXID最大）的事务Proposal，那么就可以保证这个新选举出来的Leader一定具有所有已经提交的更改。</li>
<li>更为重要的是如果让具有最高编号事务的Proposal机器成为Leader，就可以省去Leader服务器查询Proposal的提交和丢弃工作这一步骤了。</li>
</ul>
<h3 id="3-2-2-数据同步"><a href="#3-2-2-数据同步" class="headerlink" title="3.2.2 数据同步"></a>3.2.2 数据同步</h3><ul>
<li>完成Leader选举后，在正式开始工作前，Leader服务器首先会确认日志中的所有Proposal是否都已经被集群中的过半机器提交了，即是否完成了数据同步。</li>
<li>基于上文讲到的两种情况，数据同步会有不同的处理：</li>
</ul>
<hr>
<ul>
<li>同步事务的提交：<ul>
<li>leader为每一个follower都准备一个队列，并将那些没有被各follower同步的事务以proposal消息的形式逐个发送给follower，并在每个proposal消息后面紧跟一个commit消息表示该事务已经被leader提交。等到某个follower同步了所有之前尚未同步的事务并将其成功应用到本地数据库，leader会将该follower加入到可用follower列表中。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>处理丢弃的事务<ul>
<li>下面分析ZAB协议如何处理需要丢弃的事务Proposal的，ZXID是一个64位的数字，其中低32位可以看做是一个简单的单调递增的计数器，针对客户端的每一个事务请求，Leader服务器在产生一个新的事务Proposal时，都会对该计数器进行加1操作；而高32位则代表了Leader周期epoch的编号，每当选举产生一个新的Leader时，就会从这个Leader上取出其本地日志中最大事务Proposal的ZXID，并解析出epoch值，然后加1，之后以该编号作为新的epoch，低32位从0来开始生成新的ZXID。</li>
</ul>
</li>
</ul>
<blockquote>
<p>epoch：可以理解为当前集群所处的年代或者周期，每个 leader 就像皇帝，都有自己的年号，所以每次改朝换代，leader 变更之后，都会在前一个年代的基础上加 1。这样就算旧的 leader 崩溃恢复之后，也没有人听他的了，因为 follower 只听从当前年代的 leader 的命令。</p>
</blockquote>
<pre><code>- ZAB协议通过epoch号来区分Leader周期变化的策略，能够有效地避免不同的Leader服务器错误地使用不同的ZXID编号提出不一样的事务Proposal的异常情况。当一个包含了上一个Leader周期中尚未提交过的事务Proposal的服务器启动时，其肯定无法成为Leader，因为当前集群中一定包含了一个Quorum（过半）集合，该集合中的机器一定包含了更高epoch的事务的Proposal，因此这台机器的事务Proposal并非最高，也就无法成为Leader。

- 当这台机器以follower身份连上leader之后，leader会根据自己最后被提交的proposal来和这台机器的proposal作比较，发现需要舍弃的事务后，leader会要求该台机器进行回滚操作，回滚到某个被半数机器执行的最新的事务版本。</code></pre><h1 id="4-ZAB和paxos的联系和区别"><a href="#4-ZAB和paxos的联系和区别" class="headerlink" title="4 ZAB和paxos的联系和区别"></a>4 ZAB和paxos的联系和区别</h1><h2 id="4-1-联系"><a href="#4-1-联系" class="headerlink" title="4.1 联系"></a>4.1 联系</h2><ol>
<li>都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行。</li>
<li>Leader进程都会等待超过半数的Follower做出正确的反馈后，才会将一个提议进行提交。</li>
<li>在ZAB协议中，每个Proposal中都包含了一个epoch值，用来代表当前的Leader周期，在Paxos算法中，同样存在这样的一个标识，名字为Ballot。</li>
</ol>
<h2 id="4-2-区别"><a href="#4-2-区别" class="headerlink" title="4.2 区别"></a>4.2 区别</h2><ol>
<li>Paxos算法中，新选举产生的主进程会进行两个阶段的工作，第一阶段称为读阶段，新的主进程和其他进程通信来收集主进程提出的提议，并将它们提交。第二阶段称为写阶段，当前主进程开始提出自己的提议。</li>
<li>ZAB协议在Paxos基础上添加了同步阶段，此时，新的Leader会确保存在过半的Follower已经提交了之前的Leader周期中的所有事务Proposal。</li>
<li>ZAB协议主要用于构建一个高可用的分布式数据主备系统，而Paxos算法则用于构建一个分布式的一致性状态机系统。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" itemprop="url">一致性hash算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-26T15:52:16+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">分布式相关</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">负载均衡算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/26/一致性hash算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在解决分布式系统中负载均衡问题的时候，我们可以使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），进而起到负载均衡的作用。</p>
<p>但是普通的hash取模算法伸缩性很差，当新增或者下线服务器机器时候，用户id与服务器的映射关系会大量失效。这在分布式缓存系统中，是非常严重的问题。</p>
<p>例如我们原先有10台服务器，故而hash取模我们一般会这么算：<code>hash(key)%10</code>，从而得到一个在0-9之间的余数，确定请求由哪个服务器处理。</p>
<p>此时如果我们上线新服务器，或下线旧服务器，都会使服务器数量发生改变，这时候不论是<code>hash(key)%11</code>还是<code>hash(key)%9</code>，都会使近乎所有的key的hash取模结果和原先不一样，进而引发问题。比如缓存场景中的负载均衡，如果遇到这种情况，会使短时间内近乎所有的key失效，进而引发缓存雪崩。</p>
<p>为了解决这个问题，使得分布式系统可以自由且无顾虑的增减服务器，我们引入了一致性hash算法，利用hash环对其原本的hash取模算法进行了改进。</p>
<h1 id="1-一致性hash算法"><a href="#1-一致性hash算法" class="headerlink" title="1 一致性hash算法"></a>1 一致性hash算法</h1><p>一致性哈希算法在1997年由麻省理工学院提出，是一种特殊的哈希算法，目的是解决分布式缓存的问题。在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。一致性哈希解决了简单哈希算法在分布式哈希表( Distributed Hash Table，DHT) 中存在的动态伸缩等问题。</p>
<blockquote>
<p>一致性hash算法主要用于解决cache miss问题</p>
</blockquote>
<p>一致性哈希算法是在哈希算法基础上提出的，在动态变化的分布式环境中，哈希算法应该满足的几个条件：</p>
<ol>
<li>平衡性<ul>
<li>是指hash的结果应该平均分配到各个节点，这样从算法上解决了负载均衡问题。</li>
</ul>
</li>
<li>单调性<ul>
<li>是指在新增或者删减节点时，不影响系统正常运行。</li>
</ul>
</li>
<li>分散性<ul>
<li>是指数据应该分散地存放在分布式集群中的各个节点(节点自己可以有备份)，不必每个节点都存储所有的数据。</li>
</ul>
</li>
</ol>
<h2 id="1-1-算法概述"><a href="#1-1-算法概述" class="headerlink" title="1.1 算法概述"></a>1.1 算法概述</h2><p>为了能直观的理解一致性hash原理，这里结合一个简单的例子来讲解，假设有4台服务器，地址为ip1,ip2,ip3,ip4。</p>
<p>一致性hash是首先计算四个ip地址对应的hash值<br><code>hash(ip1),hash(ip2),hash(ip3),hash(ip3)</code>，计算出来的hash值是0~最大正整数（2^32）之间的一个值，这四个值在一致性hash环上呈现如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4391ab6c977b13c200508d135cb099b9d4c.png" alt=""></p>
<p>hash环上顺时针从整数0开始，一直到最大正整数，我们根据四个ip计算的hash值肯定会落到这个hash环上的某一个点，至此我们把服务器的四个ip映射到了一致性hash环。</p>
<p>当用户在客户端进行请求时候，首先根据hash(userId)计算路由规则，然后看hash值落到了hash环的那个地方，根据hash值在hash环上的位置顺时针找距离最近的ip作为路由ip。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b6c08822defde6081f28f35f8b4ce4e036c.png" alt=""></p>
<p>如上图可知，user1和user2由ip2的服务器处理，user3由ip3服务器处理，以此类推</p>
<blockquote>
<p>0~2^32的区间导致了hash值数量远超过服务器数量，使得hash碰撞的概率降到了极低。</p>
</blockquote>
<h2 id="1-2-上线服务器"><a href="#1-2-上线服务器" class="headerlink" title="1.2 上线服务器"></a>1.2 上线服务器</h2><p>当新增一个ip5的服务器后，一致性hash环大致如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-54cd082a9f13300b86d1ca9e36bdf5e299c.png" alt=""></p>
<p>根据顺时针规则可知之前user5的请求应该被ip5服务器处理，现在被新增的ip5服务器处理，其他用户的请求处理服务器不变，也就是说，新增服务器顺时针方向最近的服务器的一部分请求会被新增的服务器所替代。</p>
<h2 id="1-3-下线服务器"><a href="#1-3-下线服务器" class="headerlink" title="1.3 下线服务器"></a>1.3 下线服务器</h2><p>当ip2的服务器挂了的时候，一致性hash环大致如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e65b067374c1bf1d75ff571fe9febd9c152.png" alt=""></p>
<p>根据顺时针规则可知user1,user2的请求会被服务器ip3进行处理，而其它用户的请求对应的处理服务器不变，也就是只有之前被ip2处理的一部分用户的映射关系被破坏了，并且其负责处理的请求被顺时针下一个节点委托处理。</p>
<h1 id="2-一致性hash倾斜问题"><a href="#2-一致性hash倾斜问题" class="headerlink" title="2 一致性hash倾斜问题"></a>2 一致性hash倾斜问题</h1><p>一致性hash可以做到每个服务器都进行处理请求，但是不能保证每个服务器处理的请求的数量大致相同，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-551a6029640f2d81b118bef2dfc03f7ffcf.png" alt=""></p>
<p>服务器ip1,ip2,ip3经过hash后落到了一致性hash环上，从图中hash值分布可知ip1会负责处理大概80%的请求，而ip2和ip3则只会负责处理大概20%的请求，虽然三个机器都在处理请求，但是明显每个机器的负载不均衡，这样称为一致性hash的倾斜，我们可以使用设置虚拟节点的方式解决这个问题。</p>
<h2 id="2-1-设置虚拟节点"><a href="#2-1-设置虚拟节点" class="headerlink" title="2.1 设置虚拟节点"></a>2.1 设置虚拟节点</h2><p>当服务器节点比较少的时候会出现上节所说的一致性hash倾斜的问题，一个解决方法是多加机器，但是加机器是有成本的，那么就加虚拟节点，比如上面三个机器，<strong>每个机器引入1个虚拟节点</strong>后的一致性hash环的图如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-67344339d941bc965c8d5381a4458d36dad.png" alt=""></p>
<p>其中ip1-1是ip1的虚拟节点，ip2-1是ip2的虚拟节点，ip3-1是ip3的虚拟节点。命中ip3-1的请求，则会被导向到ip3服务器。</p>
<p>可知当物理机器数目为M，虚拟节点为N的时候，实际hash环上节点个数为<code>M*N</code>。比如当客户端计算的hash值处于ip2和ip3或者处于ip2-1和ip3-1之间时候使用ip3服务器进行处理。</p>
<blockquote>
<p>当然，我们很难得到一个完美均衡的一致性hash环，但理论上虚拟节点数量的增加，和一致性hash环的均衡性呈正相关。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
</blockquote>
<h1 id="3-一致性hash的优点"><a href="#3-一致性hash的优点" class="headerlink" title="3 一致性hash的优点"></a>3 一致性hash的优点</h1><ol>
<li><p>可扩展性。</p>
<ul>
<li>一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销</li>
</ul>
</li>
<li><p>更好地适应数据的快速增长。</p>
<ul>
<li>采用一致性哈希算法分布数据，当数据不断增长时，部分虚拟节点中可能包含很多数据、造成数据在虚拟节点上分布不均衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二、不需要对全部的数据进行重新哈希和划分。</li>
<li>虚拟节点分裂后，如果物理服务器的负载仍然不均衡，只需在服务器之间调整部分虚拟节点的存储分布。这样可以随数据的增长而动态的扩展物理服务器的数量，且代价远比传统哈希算法重新分布所有数据要小很多</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/15/Spring-IoC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/15/Spring-IoC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/" itemprop="url">Spring IoC源码详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T23:00:10+08:00">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/07/15/Spring-IoC%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/07/15/Spring-IoC源码详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  15.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  77
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文中，所有spring framework源码，均采用5.0.x版本</p>
</blockquote>
<p>在《Spring IoC概念分析》一文中，我们对Spring IoC的前置概念和整体流程有了一个初步的了解，在本文中，我们会解读源码，力图将spring IoC的逻辑扁平化，可视化。</p>
<h1 id="1-Spring-IoC容器的启动"><a href="#1-Spring-IoC容器的启动" class="headerlink" title="1. Spring IoC容器的启动"></a>1. Spring IoC容器的启动</h1><p>applicationContext是Spring的核心，Context我们通常解释为上下文环境，我想用“容器”来表述它更容易理解一些，ApplicationContext则是“应用的容器”了；在Web应用中，我们会用到WebApplicationContext，WebApplicationContext继承自ApplicationContext；</p>
<p><strong>以企业级java项目最常用的web项目为例</strong>；我们知道，在web项目中，Spring启动是在web.xml配置监听器，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring上下文监听器 --&gt;</span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，ContextLoaderListener类是spring IoC容器启动的核心，也是整个Spring框架的启动入口：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5dc2965cc62b4769c88079950beb40dacf0.png" alt=""></p>
<p>ContextLoaderListener类实现了Tomcat容器的ServletContextListener接口，所以它与普通的Servlet监听是一样的。同样是重写到两个方法：</p>
<ul>
<li>contextInitialized()方法在web容器初始化时执行</li>
<li>contextDestroyed()方法在容器销毁时执行。</li>
</ul>
<p>WEB容器启动时会触发初始化事件，ContextLoaderListener监听到这个事件，其contextInitialized()方法会被调用，在这个方法中Spring会初始化一个root上下文，即WebApplicationContext。</p>
<p>WebApplicationContext是一个接口，其实际默认实现类是XmlWebApplicationContext。（重点关注红色箭头指示的两条继承/实现关系）</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-17ccc43554b5fda2180fb653d0646b31914.png" alt=""></p>
<p>这个就是Spring IOC的容器，其对应bean定义的配置信息由web.xml中的context-param来指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring配置文件路径 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>在ContextLoaderListener类中，只是实现了ServletContextListener提供的到两个方法，Spring启动主要的逻辑在父类ContextLoader的方法initWebApplicationContext实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">	public ContextLoaderListener() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public ContextLoaderListener(WebApplicationContext context) &#123;</span><br><span class="line">		super(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Initialize the root web application context.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void contextInitialized(ServletContextEvent event) &#123;</span><br><span class="line">		initWebApplicationContext(event.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Close the root web application context.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Override</span><br><span class="line">	public void contextDestroyed(ServletContextEvent event) &#123;</span><br><span class="line">		closeWebApplicationContext(event.getServletContext());</span><br><span class="line">		ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ContextLoaderListener的作用就是启动web容器时自动装配ApplicationContext的配置信息。更细化一点讲，Spring的启动过程其实就是Spring IOC容器的启动过程。</p>
</blockquote>
<h2 id="1-1-ContextLoader剖析"><a href="#1-1-ContextLoader剖析" class="headerlink" title="1.1 ContextLoader剖析"></a>1.1 ContextLoader剖析</h2><p>上文说过，Spring启动主要的逻辑在父类ContextLoader的方法initWebApplicationContext实现。所以我们有必要重点看下ContextLoader类：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2d9116f17f39e0f66409d490c3c00b4aac2.png" alt=""></p>
<p>这里面，最核心的方法是initWebApplicationContext()，它被ContextLoaderListene的contextInitialized()调用，负责spring容器的初始化。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-aa26938c4529a044c005dd5be15ec5f2138.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bf5c4a1709ad4caa111342055031fe6275c.png" alt=""></p>
<blockquote>
<p>注意，该图代码非5.0.x版本，但核心逻辑变化不大，可以参考。</p>
</blockquote>
<h2 id="1-2-Context的生成门面"><a href="#1-2-Context的生成门面" class="headerlink" title="1.2 Context的生成门面"></a>1.2 Context的生成门面</h2><p> 在这个方法中，入参ServletContext是由web容器监听器（ContextLoaderListener）提供。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize Spring's web application context for the given servlet context,</span></span><br><span class="line"><span class="comment"> * using the application context provided at construction time, or creating a new one</span></span><br><span class="line"><span class="comment"> * according to the "&#123;<span class="doctag">@link</span> #CONTEXT_CLASS_PARAM contextClass&#125;" and</span></span><br><span class="line"><span class="comment"> * "&#123;<span class="doctag">@link</span> #CONFIG_LOCATION_PARAM contextConfigLocation&#125;" context-params.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用构造时提供的应用程序上下文，或者根据“ &#123;<span class="doctag">@link</span> #CONTEXT_CLASS_PARAM contextClass&#125;”</span></span><br><span class="line"><span class="comment"> * 和“ &#123;<span class="doctag">@link</span> #CONFIG_LOCATION_PARAM contextConfigLocation&#125;”上下文参数，</span></span><br><span class="line"><span class="comment"> * 为给定的servlet上下文初始化Spring的Web应用程序上下文。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> servletContext current servlet context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new WebApplicationContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #ContextLoader(WebApplicationContext)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CONTEXT_CLASS_PARAM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #CONFIG_LOCATION_PARAM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	 </span><br><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//判断给定的ServletContext是否已经存在WebApplicationContext，如果存在则抛出异常。</span></span><br><span class="line">	<span class="keyword">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">"Cannot initialize context because there is already a root application context present - "</span> +</span><br><span class="line">				<span class="string">"check whether you have multiple ContextLoader* definitions in your web.xml!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Log logger = LogFactory.getLog(ContextLoader<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	servletContext.log(<span class="string">"Initializing Spring root WebApplicationContext"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">"Root WebApplicationContext: initialization started"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line">		<span class="comment">// it is available on ServletContext shutdown.</span></span><br><span class="line">		<span class="comment">//判断ContextLoader的context属性是否为空，为空表示WebApplicationContext还不存在。</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//不存在则创建WebApplicationContext，该方法也是核心方法，我们后面详解。</span></span><br><span class="line">			<span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//WebApplicationContext默认实现是XmlWebApplicationContext，</span></span><br><span class="line">		<span class="comment">//XmlWebApplicationContext是ConfigurableWebApplicationContext子类</span></span><br><span class="line">		<span class="comment">//所以该判断基本上都是正确的。</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">			ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line">			<span class="keyword">if</span> (!cwac.isActive()) &#123;<span class="comment">//这个context还未执行refresh方法。</span></span><br><span class="line">				<span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">				<span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">				<span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line">					<span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">					<span class="comment">//通过loadParentContext()方法为其设置父上下文。</span></span><br><span class="line">					ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">					cwac.setParent(parent);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//通过configureAndRefreshWebApplicationContext为根上下文构建bean工厂和bean对象。</span></span><br><span class="line">				configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将ApplicationContext放入ServletContext中，其key为</span></span><br><span class="line">		<span class="comment">//WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span></span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line">		</span><br><span class="line">		ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (ccl == ContextLoader<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()) </span>&#123;<span class="comment">//如果当前线程的类加载器和ContextLoader类加载器一致</span></span><br><span class="line">			<span class="comment">//那么创建的ApplicationContext赋值给ContextLoader.currentContext</span></span><br><span class="line">			<span class="comment">//即在ContextLoader类被加载的进程中，如果创建了context的话，context赋值currentContext，方便取用</span></span><br><span class="line">			<span class="comment">//而不是放在全局静态常量Map存起来。</span></span><br><span class="line">			currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;<span class="comment">//否则</span></span><br><span class="line">			<span class="comment">//将ApplicationContext放入ContextLoader的全局静态常量Map中</span></span><br><span class="line">			<span class="comment">//其中key为：Thread.currentThread().getContextClassLoader()即当前线程类加载器</span></span><br><span class="line">			<span class="comment">//正常的context创建流程，走这里。</span></span><br><span class="line">			currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> +</span><br><span class="line">					WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">			<span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">			logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">		logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Error err) &#123;</span><br><span class="line">		logger.error(<span class="string">"Context initialization failed"</span>, err);</span><br><span class="line">		servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">		<span class="keyword">throw</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归纳一下：</p>
<ul>
<li>首先判断servlectContext中是否已经存在根上下文，如果存在，则抛出异常；</li>
<li>否则通过createWebApplicationContext方法创建新的根上下文。</li>
<li>然后通过loadParentContext()方法为其设置父上下文。</li>
<li>再通过configureAndRefreshWebApplicationContext为根上下文构建bean工厂和bean对象。</li>
<li>最后把上下文存入servletContext，并且存入currentContextPerThread。</li>
<li>至此初始化过程完毕，接下来可以获取WebApplicationContext，进而用getBean(“bean name”)得到bean。</li>
</ul>
<h2 id="1-3-创建Context"><a href="#1-3-创建Context" class="headerlink" title="1.3 创建Context"></a>1.3 创建Context</h2><p>我们刚刚看到，initWebApplicationContext方法主要调用createWebApplicationContext方法来创建上下文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Instantiate the root WebApplicationContext for this loader, either the</span><br><span class="line"> * default context class or a custom context class if specified.</span><br><span class="line"> * &lt;p&gt;This implementation expects custom contexts to implement the</span><br><span class="line"> * &#123;@link ConfigurableWebApplicationContext&#125; interface.</span><br><span class="line"> * Can be overridden in subclasses.</span><br><span class="line"> *</span><br><span class="line"> * 实例化此加载程序的根WebApplicationContext（默认上下文类或自定义上下文类（如果已指定））。</span><br><span class="line"> * &lt;p&gt;此实现期望自定义上下文实现&#123;@link ConfigurableWebApplicationContext&#125;接口。 可以在子类中覆盖。</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;In addition, &#123;@link #customizeContext&#125; gets called prior to refreshing the</span><br><span class="line"> * context, allowing subclasses to perform custom modifications to the context.</span><br><span class="line"> * @param sc current servlet context</span><br><span class="line"> * @return the root WebApplicationContext</span><br><span class="line"> * @see ConfigurableWebApplicationContext</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected WebApplicationContext createWebApplicationContext(ServletContext sc) &#123;</span><br><span class="line">	&#x2F;&#x2F;从web.xml配置的contextClass参数中获取上下文的实现类，如果contextClass为空，则使用默认的。</span><br><span class="line">	&#x2F;&#x2F;下文有说明  </span><br><span class="line">	Class&lt;?&gt; contextClass &#x3D; determineContextClass(sc);</span><br><span class="line">	&#x2F;&#x2F;根上下文的实现类必须是ConfigurableWebApplicationContext的子类，否则抛出异常</span><br><span class="line">	if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;Custom context class [&quot; + contextClass.getName() +</span><br><span class="line">				&quot;] is not of type [&quot; + ConfigurableWebApplicationContext.class.getName() + &quot;]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;BeanUtils.instantiateClass工具方法，通过反射得到contextClass的构造方法，根据类名创建类</span><br><span class="line">	return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归纳一下：</p>
<ul>
<li>createWebApplicationContext方法使用determineContextClass方法，从web.xml配置的contextClass参数中，获取要创建的context的具体实现类，如果没有指定，则默认使用XmlWebApplicationContext为其实现类。</li>
<li>限制根上下文的实现类必须是ConfigurableWebApplicationContext的子类。</li>
<li>使用BeanUtils.instantiateClass工具方法，根据类名创建类实例。</li>
</ul>
<h2 id="1-4-确定Context实现类"><a href="#1-4-确定Context实现类" class="headerlink" title="1.4 确定Context实现类"></a>1.4 确定Context实现类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Return the WebApplicationContext implementation class to use, either the</span><br><span class="line"> * default XmlWebApplicationContext or a custom context class if specified.</span><br><span class="line"> *</span><br><span class="line"> * 返回要使用的WebApplicationContext实现类，</span><br><span class="line"> * 如果指定，则为自定义上下文类。否则默认为XmlWebApplicationContext</span><br><span class="line"> *</span><br><span class="line"> * @param servletContext current servlet context</span><br><span class="line"> * @return the WebApplicationContext implementation class to use</span><br><span class="line"> * @see #CONTEXT_CLASS_PARAM</span><br><span class="line"> * @see org.springframework.web.context.support.XmlWebApplicationContext</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class="line">	&#x2F;&#x2F;从web.xml获得参数contextClass，在一般的web项目中，此参数为null，即没有指定。</span><br><span class="line">	&#x2F;&#x2F;（spring源生的XmlWebApplicationContext就挺好，没必要重复造轮子）</span><br><span class="line">	String contextClassName &#x3D; servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class="line">	if (contextClassName !&#x3D; null) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;如果指定了，返回类名</span><br><span class="line">			return ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Failed to load custom context class [&quot; + contextClassName + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;获得根上下文WebApplicationContext的默认实现类的类名，defaultStrategies是Properties类型，</span><br><span class="line">		&#x2F;&#x2F;在CotnextLoader类开头static语句块中初始化</span><br><span class="line">		&#x2F;&#x2F;获取当前包下面的ContextLoader.properties文件，文件内容是：</span><br><span class="line">		&#x2F;&#x2F;org.springframework.web.context.WebApplicationContext&#x3D;org.springframework.web.context.support.XmlWebApplicationContext</span><br><span class="line">		contextClassName &#x3D; defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class="line">		try &#123;</span><br><span class="line">			return ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (ClassNotFoundException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(</span><br><span class="line">					&quot;Failed to load default context class [&quot; + contextClassName + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>String contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);方法获取的，就是web.xml中配置指定的IoC容器类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextClass&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;org.springframework.web.context.support.AnnotationConfigWebApplicationContext&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>截止到这里为止，WebApplicationContext的实例就已经创建出来了。然后逻辑往下走，到了configureAndRefreshWebApplicationContext(cwac, servletContext)方法，该方法为根上下文构建bean工厂和bean对象。</p>
<h2 id="1-5-配置和刷新Context"><a href="#1-5-配置和刷新Context" class="headerlink" title="1.5 配置和刷新Context"></a>1.5 配置和刷新Context</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) &#123;</span><br><span class="line">	if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">		&#x2F;&#x2F; The application context id is still set to its original default value</span><br><span class="line">		&#x2F;&#x2F; -&gt; assign a more useful id based on available information</span><br><span class="line">		&#x2F;&#x2F;如果web.xml中配置了context的id，那么读取配置的id并使用。</span><br><span class="line">		String idParam &#x3D; sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line">		if (idParam !&#x3D; null) &#123;</span><br><span class="line">			wac.setId(idParam);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;如果没有配置context的id，则使用默认的id。</span><br><span class="line">			&#x2F;&#x2F; Generate default id...</span><br><span class="line">			wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">					ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;把ServletContext塞入WebApplicationContext</span><br><span class="line">	wac.setServletContext(sc);</span><br><span class="line">	&#x2F;&#x2F;读取web.xml中的&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;的value值</span><br><span class="line">	&#x2F;&#x2F;获取上下文的配置xml地址和文件名。</span><br><span class="line">	String configLocationParam &#x3D; sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line">	if (configLocationParam !&#x3D; null) &#123;</span><br><span class="line">		wac.setConfigLocation(configLocationParam);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; The wac environment&#39;s #initPropertySources will be called in any case when the context</span><br><span class="line">	&#x2F;&#x2F; is refreshed; do it eagerly here to ensure servlet property sources are in place for</span><br><span class="line">	&#x2F;&#x2F; use in any post-processing or initialization that occurs below prior to #refresh</span><br><span class="line">	ConfigurableEnvironment env &#x3D; wac.getEnvironment();</span><br><span class="line">	if (env instanceof ConfigurableWebEnvironment) &#123;</span><br><span class="line">		((ConfigurableWebEnvironment) env).initPropertySources(sc, null);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;customizeContext方法的功能是：</span><br><span class="line">	&#x2F;&#x2F;对从web.xml的&lt;context-param&gt;中读取globalInitializerClasses和contextInitializerClasses参数</span><br><span class="line">	&#x2F;&#x2F;获取配置的ApplicationContextInitializer实现类，然后对他们的实现类依次回调他们的initialize方法。</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;ApplicationContextInitializer是Spring框架原有的接口，这个接口的主要作用就是</span><br><span class="line">	&#x2F;&#x2F;在ConfigurableApplicationContext类型(或者子类型)的ApplicationContext做refresh之前</span><br><span class="line">	&#x2F;&#x2F;允许我们对ConfiurableApplicationContext的实例做进一步的设置和处理。例如，根据上下文环境注册属性源或激活概要文件。</span><br><span class="line">	&#x2F;&#x2F;ApplicationContextInitializer支持Order注解，表示执行顺序，越小越早执行；</span><br><span class="line">	customizeContext(sc, wac);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;核心代码，开始容器的初始化</span><br><span class="line">	wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);方法获取的，就是web.xml中配置指定的IoC容器配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置Spring配置文件路径 --&gt;</span><br><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，容器的初始化逻辑，都在wac.refresh();中。</p>
<h2 id="1-6-阶段性流程图"><a href="#1-6-阶段性流程图" class="headerlink" title="1.6 阶段性流程图"></a>1.6 阶段性流程图</h2><p><img src="https://oscimg.oschina.net/oscnet/up-8553a091ba36acb65cfef255e27192f896f.png" alt=""></p>
<h1 id="2-refresh-核心方法"><a href="#2-refresh-核心方法" class="headerlink" title="2 refresh()核心方法"></a>2 refresh()核心方法</h1><p>我们之前说过，WebApplicationContext方法的默认实现是XmlWebApplicationContext，而XmlWebApplicationContext的refresh()方法，继承自它的父类AbstractApplicationContext。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">	synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line">		&#x2F;&#x2F; Prepare this context for refreshing.</span><br><span class="line">		&#x2F;&#x2F;刷新预处理，和主流程关系不大，就是保存了容器的启动时间，启动标志等，同时给容器设置同步标识</span><br><span class="line">		prepareRefresh();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Tell the subclass to refresh the internal bean factory.</span><br><span class="line">		&#x2F;&#x2F;该方法调用链路，会启动Bean定义资源文件的载入方法loadBeanDefinitions方法</span><br><span class="line">		&#x2F;&#x2F;值得下文讨论。</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory &#x3D; obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Prepare the bean factory for use in this context.</span><br><span class="line">		&#x2F;&#x2F;为BeanFactory配置容器特性，例如类加载器、事件处理器等</span><br><span class="line">		&#x2F;&#x2F;还是一些准备工作，添加了两个后置处理器：ApplicationContextAwareProcessor，ApplicationListenerDetector</span><br><span class="line">		&#x2F;&#x2F;还设置了 忽略自动装配 和 允许自动装配 的接口，如果不存在某个bean的时候，spring就自动注册singleton bean</span><br><span class="line">		&#x2F;&#x2F;还设置了bean表达式解析器 等</span><br><span class="line">		prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Allows post-processing of the bean factory in context subclasses.</span><br><span class="line">			&#x2F;&#x2F;这是一个空方法，给子类继承用，执行自定义的BeanPost事件</span><br><span class="line">			postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Invoke factory processors registered as beans in the context.</span><br><span class="line">			&#x2F;&#x2F;调用所有注册的BeanFactoryPostProcessor的Bean</span><br><span class="line">			&#x2F;&#x2F;执行自定义的BeanFactoryProcessor和内置的BeanFactoryProcessor</span><br><span class="line">			invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Register bean processors that intercept bean creation.</span><br><span class="line">			&#x2F;&#x2F; 注册BeanPostProcessor</span><br><span class="line">			registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Initialize message source for this context.</span><br><span class="line">			&#x2F;&#x2F;初始化信息源，和国际化相关.</span><br><span class="line">			initMessageSource();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Initialize event multicaster for this context.</span><br><span class="line">			&#x2F;&#x2F;初始化容器事件传播器.</span><br><span class="line">			initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Initialize other special beans in specific context subclasses.</span><br><span class="line">			&#x2F;&#x2F; 空方法，给子类做定制</span><br><span class="line">			&#x2F;&#x2F;调用子类的某些特殊Bean初始化方法</span><br><span class="line">			onRefresh();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Check for listener beans and register them.</span><br><span class="line">			&#x2F;&#x2F;为事件传播器注册事件监听器.</span><br><span class="line">			registerListeners();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Instantiate all remaining (non-lazy-init) singletons.</span><br><span class="line">			&#x2F;&#x2F;初始化所有剩余的，非懒加载的单例Bean</span><br><span class="line">			finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Last step: publish corresponding event.</span><br><span class="line">			&#x2F;&#x2F;初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span><br><span class="line">			finishRefresh();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		catch (BeansException ex) &#123;</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">						&quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Destroy already created singletons to avoid dangling resources.</span><br><span class="line">			&#x2F;&#x2F;销毁已创建的Bean</span><br><span class="line">			destroyBeans();</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Reset &#39;active&#39; flag.</span><br><span class="line">			&#x2F;&#x2F;取消refresh操作，重置容器的同步标识。</span><br><span class="line">			cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Propagate exception to caller.</span><br><span class="line">			throw ex;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		finally &#123;</span><br><span class="line">			&#x2F;&#x2F; Reset common introspection caches in Spring&#39;s core, since we</span><br><span class="line">			&#x2F;&#x2F; might not ever need metadata for singleton beans anymore...</span><br><span class="line">			&#x2F;&#x2F;重设公共缓存</span><br><span class="line">			resetCommonCaches();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-加载xml文件的beanDefinition"><a href="#3-加载xml文件的beanDefinition" class="headerlink" title="3 加载xml文件的beanDefinition"></a>3 加载xml文件的beanDefinition</h1><p>refresh()方法调用了obtainFreshBeanFactory()方法，在这个方法中，会发起IoC容器对配置文件的读取，并将其加载为beanDefinition，不过在了解beanDefinition加载过程之前，我们有需要了解一些前置知识点。</p>
<h2 id="3-1-Resource资源文件框架"><a href="#3-1-Resource资源文件框架" class="headerlink" title="3.1 Resource资源文件框架"></a>3.1 Resource资源文件框架</h2><p>详见文章本博客《Spring Resource资源文件体系》；</p>
<h2 id="3-2-加载前的准备工作"><a href="#3-2-加载前的准备工作" class="headerlink" title="3.2 加载前的准备工作"></a>3.2 加载前的准备工作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * 让子类refresh内部bean工厂。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//核心方法在这，拆开看看</span></span><br><span class="line">	refreshBeanFactory();</span><br><span class="line">	ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>refreshBeanFactory()方法的实现在AbstractRefreshableApplicationContext类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * This implementation performs an actual refresh of this context&#39;s underlying</span><br><span class="line"> * bean factory, shutting down the previous bean factory (if any) and</span><br><span class="line"> * initializing a fresh bean factory for the next phase of the context&#39;s lifecycle.</span><br><span class="line"> * 此实现对该上下文的基础bean工厂执行实际的刷新，</span><br><span class="line"> * 关闭前一个bean工厂（如果有），并为上下文生命周期的下一阶段初始化一个新的bean工厂。</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">	if (hasBeanFactory()) &#123;&#x2F;&#x2F;关闭前一个bean工厂（如果有）</span><br><span class="line">		destroyBeans();</span><br><span class="line">		closeBeanFactory();</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;初始化一个新的bean工厂</span><br><span class="line">		DefaultListableBeanFactory beanFactory &#x3D; createBeanFactory();</span><br><span class="line">		beanFactory.setSerializationId(getId());</span><br><span class="line">		customizeBeanFactory(beanFactory);</span><br><span class="line">		&#x2F;&#x2F;加载BeanDefinitions，核心方法，加载配置信息</span><br><span class="line">		loadBeanDefinitions(beanFactory);</span><br><span class="line">		synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">			this.beanFactory &#x3D; beanFactory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new ApplicationContextException(&quot;I&#x2F;O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-设置和获取Reader工具类"><a href="#3-3-设置和获取Reader工具类" class="headerlink" title="3.3 设置和获取Reader工具类"></a>3.3 设置和获取Reader工具类</h2><p>前文说过，XmlWebApplicationContext类是默认的Context类，所以默认情况下，loadBeanDefinitions(DefaultListableBeanFactory)调用的是XmlWebApplicationContext类中实现的loadBeanDefinitions(DefaultListableBeanFactory);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">	&#x2F;&#x2F; Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br><span class="line">	&#x2F;&#x2F;初始化XmlBeanDefinitionReader，Reader是将配置文件转为beanDefinition文件的主要工具类。</span><br><span class="line">	XmlBeanDefinitionReader beanDefinitionReader &#x3D; new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Configure the bean definition reader with this context&#39;s</span><br><span class="line">	&#x2F;&#x2F; resource loading environment.</span><br><span class="line">	beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">	&#x2F;&#x2F;注意这里，将this，也就是XmlWebApplicationContext本身，作为XmlBeanDefinitionReader的ResourceLoader。</span><br><span class="line">	&#x2F;&#x2F;XmlWebApplicationContext是实现了ResourceLoader接口的，并且它是ResourcePatternResolver接口的子类。</span><br><span class="line">	beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">	beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Allow a subclass to provide custom initialization of the reader,</span><br><span class="line">	&#x2F;&#x2F; then proceed with actually loading the bean definitions.</span><br><span class="line">	&#x2F;&#x2F;空方法，给自定义的context类一个变更Reader类的回调机会</span><br><span class="line">	initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">	&#x2F;&#x2F;核心方法，继续往下看</span><br><span class="line">	loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loadBeanDefinitions(beanDefinitionReader)方法调用的是loadBeanDefinitions(XmlBeanDefinitionReader)方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load the bean definitions with the given XmlBeanDefinitionReader.</span><br><span class="line"> * &lt;p&gt;The lifecycle of the bean factory is handled by the refreshBeanFactory method;</span><br><span class="line"> * therefore this method is just supposed to load and&#x2F;or register bean definitions.</span><br><span class="line"> * &lt;p&gt;Delegates to a ResourcePatternResolver for resolving location patterns</span><br><span class="line"> * into Resource instances.</span><br><span class="line"> </span><br><span class="line"> * 使用给定的XmlBeanDefinitionReader加载Bean定义。beanFactory的生命周期由refreshBeanFactory方法处理；</span><br><span class="line"> * 因此该方法仅应加载 或 注册Bean定义。委托ResourcePatternResolver将位置模式解析为Resource实例。</span><br><span class="line"> </span><br><span class="line"> * @throws IOException if the required XML document isn&#39;t found</span><br><span class="line"> * @see #refreshBeanFactory</span><br><span class="line"> * @see #getConfigLocations</span><br><span class="line"> * @see #getResources</span><br><span class="line"> * @see #getResourcePatternResolver</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws IOException &#123;</span><br><span class="line">	&#x2F;&#x2F;获取web.xml配置的configLocations，即配置文件的路径</span><br><span class="line">	String[] configLocations &#x3D; getConfigLocations();</span><br><span class="line">	if (configLocations !&#x3D; null) &#123;</span><br><span class="line">		for (String configLocation : configLocations) &#123;</span><br><span class="line">			&#x2F;&#x2F;遍历得到的configLocation路径，依次调用reader的loadBeanDefinitions方法解析每个路径</span><br><span class="line">			reader.loadBeanDefinitions(configLocation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-通配-完整路径解析策略"><a href="#3-4-通配-完整路径解析策略" class="headerlink" title="3.4 通配/完整路径解析策略"></a>3.4 通配/完整路径解析策略</h2><p>核心逻辑又进入了reader.loadBeanDefinitions(configLocation)方法，这个方法，XmlBeanDefinitionReader自己没有实现，是继承自AbstractBeanDefinitionReader的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load bean definitions from the specified resource location.</span><br><span class="line"> * &lt;p&gt;The location can also be a location pattern, provided that the</span><br><span class="line"> * ResourceLoader of this bean definition reader is a ResourcePatternResolver.</span><br><span class="line"> * @param location the resource location, to be loaded with the ResourceLoader</span><br><span class="line"> * (or ResourcePatternResolver) of this bean definition reader</span><br><span class="line"> * @param actualResources a Set to be filled with the actual Resource objects</span><br><span class="line"> * that have been resolved during the loading process. May be &#123;@code null&#125;</span><br><span class="line"> * to indicate that the caller is not interested in those Resource objects.</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> * @see #getResourceLoader()</span><br><span class="line"> * @see #loadBeanDefinitions(org.springframework.core.io.Resource)</span><br><span class="line"> * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) </span><br><span class="line">	throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F;获取ResourceLoader，ResourceLoader是用来确定location用哪种resource策略的逻辑封装。</span><br><span class="line">	&#x2F;&#x2F;当前类XmlBeanDefinitionReader，在XmlWebApplicationContext类的loadBeanDefinitions(DefaultListableBeanFactory)方法中</span><br><span class="line">	&#x2F;&#x2F;就已经指定了XmlBeanDefinitionReader的ResourceLoader。</span><br><span class="line">	&#x2F;&#x2F;XmlBeanDefinitionReader的ResourceLoader就是XmlWebApplicationContext</span><br><span class="line">	ResourceLoader resourceLoader &#x3D; getResourceLoader();</span><br><span class="line">	if (resourceLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;Cannot import bean definitions from location [&quot; + location + &quot;]: </span><br><span class="line">					no ResourceLoader available&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果该reader注入的ResourceLoader是ResourcePatternResolver的子类。</span><br><span class="line">	&#x2F;&#x2F;也就是支持解析配置路径是通配符形式的location。</span><br><span class="line">	&#x2F;&#x2F;在web应用场景中，ResourceLoader已经指定了是XmlWebApplicationContext</span><br><span class="line">	&#x2F;&#x2F;而XmlWebApplicationContext是ResourcePatternResolver的子类，所以判断必然为真</span><br><span class="line">	if (resourceLoader instanceof ResourcePatternResolver) &#123;</span><br><span class="line">		&#x2F;&#x2F; Resource pattern matching available.</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;那么，一个带通配符的路径，是可能返回多个Resource的</span><br><span class="line">			Resource[] resources &#x3D; ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">			int loadCount &#x3D; loadBeanDefinitions(resources);</span><br><span class="line">			if (actualResources !&#x3D; null) &#123;</span><br><span class="line">				for (Resource resource : resources) &#123;</span><br><span class="line">					actualResources.add(resource);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions </span><br><span class="line">					from location pattern [&quot; + location + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			return loadCount;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(</span><br><span class="line">					&quot;Could not resolve bean definition resource </span><br><span class="line">						pattern [&quot; + location + &quot;]&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Can only load single resources by absolute URL.</span><br><span class="line">		&#x2F;&#x2F;否则，则l该reader注入的ResourceLoader只支持解析配置路径是完整路径形式</span><br><span class="line">		&#x2F;&#x2F;那么一个绝对路径，只会取回来一个resource</span><br><span class="line">		Resource resource &#x3D; resourceLoader.getResource(location);</span><br><span class="line">		int loadCount &#x3D; loadBeanDefinitions(resource);</span><br><span class="line">		if (actualResources !&#x3D; null) &#123;</span><br><span class="line">			actualResources.add(resource);</span><br><span class="line">		&#125;</span><br><span class="line">		if (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(&quot;Loaded &quot; + loadCount + &quot; bean definitions </span><br><span class="line">				from location [&quot; + location + &quot;]&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return loadCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的两个分支，即<strong>resourceLoader支持解析location为通配符形式的</strong>和<strong>resourceLoader支持解析location为完整路径形式的</strong>，二者分别调用了：</p>
<ol>
<li>resourceLoader支持解析location为通配符形式的<ul>
<li>PathMatchingResourcePatternResolver#getResources(String locationPattern)</li>
<li>AbstractBeanDefinitionReader#loadBeanDefinitions(Resource… resources)方法</li>
</ul>
</li>
<li>resourceLoader支持解析location为完整路径形式的<ul>
<li>DefaultResourceLoader#getResources(String locationPattern)</li>
<li>XmlBeanDefinitionReader#loadBeanDefinitions(Resource resource)</li>
</ul>
</li>
</ol>
<p>而AbstractBeanDefinitionReader#loadBeanDefinitions(Resource… resources)方法的逻辑很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(resources, &quot;Resource array must not be null&quot;);</span><br><span class="line">	int counter &#x3D; 0;</span><br><span class="line">	for (Resource resource : resources) &#123;</span><br><span class="line">		&#x2F;&#x2F;遍历Resource，依次调用loadBeanDefinitions(Resource resource)</span><br><span class="line">		counter +&#x3D; loadBeanDefinitions(resource);</span><br><span class="line">	&#125;</span><br><span class="line">	return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以最后殊途同归，最后都是落在了XmlBeanDefinitionReader#loadBeanDefinitions(Resource resource)方法上。</p>
<h2 id="3-5-编码设置和循环依赖检测"><a href="#3-5-编码设置和循环依赖检测" class="headerlink" title="3.5 编码设置和循环依赖检测"></a>3.5 编码设置和循环依赖检测</h2><p>XmlBeanDefinitionReader的loadBeanDefinitions(Resource resource)重写方法，主要就是加载xml文件配置的beanDefinition：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load bean definitions from the specified XML file.</span><br><span class="line"> * @param resource the resource descriptor for the XML file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F;对传进来的Resource又进行了一次封装，变成了编码后的Resource</span><br><span class="line">	return loadBeanDefinitions(new EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，resource在这里被封装为了EncodedResource，我们继续往下看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Load bean definitions from the specified XML file.</span><br><span class="line"> * @param encodedResource the resource descriptor for the XML file,</span><br><span class="line"> * allowing to specify an encoding to use for parsing the file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);</span><br><span class="line">	if (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;resourcesCurrentlyBeingLoaded是一个ThreadLocal，里面存放Resource包装类EncodedResource的set集合</span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources &#x3D; this.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	if (currentResources &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;如果set不存在，new一个</span><br><span class="line">		currentResources &#x3D; new HashSet&lt;&gt;(4);</span><br><span class="line">		this.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果set中已有这个元素则返回false，进入该条件抛出异常</span><br><span class="line">	if (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		&#x2F;&#x2F;只有当前线程重复加载了某个资源，这里才会抛出异常</span><br><span class="line">		&#x2F;&#x2F;用来检测是否循环加载某个Resource，如果是，提醒需要检查导入的definitions</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;获取封装的InputStream</span><br><span class="line">		InputStream inputStream &#x3D; encodedResource.getResource().getInputStream();</span><br><span class="line">		try &#123;</span><br><span class="line">			InputSource inputSource &#x3D; new InputSource(inputStream);</span><br><span class="line">			&#x2F;&#x2F;没有设置编码集，跳过</span><br><span class="line">			if (encodedResource.getEncoding() !&#x3D; null) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			return doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		if (currentResources.isEmpty()) &#123;</span><br><span class="line">			this.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，核心逻辑，又进入了doLoadBeanDefinitions方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Actually load bean definitions from the specified XML file.</span><br><span class="line"> * @param inputSource the SAX InputSource to read from</span><br><span class="line"> * @param resource the resource descriptor for the XML file</span><br><span class="line"> * @return the number of bean definitions found</span><br><span class="line"> * @throws BeanDefinitionStoreException in case of loading or parsing errors</span><br><span class="line"> * @see #doLoadDocument</span><br><span class="line"> * @see #registerBeanDefinitions</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;根据不同的xml约束（dtd，xsd等），将xml文件生成对应的文档对象</span><br><span class="line">		&#x2F;&#x2F;这个方法里面涉及xml的解析，不赘述，简单来说：</span><br><span class="line">		&#x2F;&#x2F;检测解析传入的xml文件（也就是resource）时该用哪种验证方式</span><br><span class="line">		&#x2F;&#x2F;如果这个文件有DOCTYPE声明，那么就用DTD验证，否则就使用XSD验证模式。</span><br><span class="line">		&#x2F;&#x2F;使用标准JAXP配置XML解析器，加载InputSource的Document对象，然后返回一个新的DOM对象</span><br><span class="line">		&#x2F;&#x2F;注意，这个Document对象，是W3C定义的标准XML对象，跟spring无关。</span><br><span class="line">		Document doc &#x3D; doLoadDocument(inputSource, resource);</span><br><span class="line">		&#x2F;&#x2F;核心方法，beanDefinitions的注册</span><br><span class="line">		return registerBeanDefinitions(doc, resource);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXParseException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (SAXException ex) &#123;</span><br><span class="line">		throw new XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ParserConfigurationException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Parser configuration exception parsing XML from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (IOException ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;IOException parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		throw new BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">				&quot;Unexpected exception parsing XML document from &quot; + resource, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，两个核心方法，doLoadDocument和registerBeanDefinitions方法，前者负责解析xml文件，后者负责注册BeanDefinitions，我们分别来分析。先看doLoadDocument()方法</p>
<h2 id="3-6-解析XML文件"><a href="#3-6-解析XML文件" class="headerlink" title="3.6 解析XML文件"></a>3.6 解析XML文件</h2><p>此方法在XmlBeanDefinitionReader类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Actually load the specified document using the configured DocumentLoader.</span><br><span class="line">* @param inputSource the SAX InputSource to read from --从中读取的SAX输入源</span><br><span class="line">* @param resource the resource descriptor for the XML file --xml文件的资源描述符</span><br><span class="line">* @return the DOM Document DOM文档对象</span><br><span class="line">* </span><br><span class="line">* 使用配置好的DocumentLoader文档加载器加载指定的文档</span><br><span class="line">*&#x2F;</span><br><span class="line">protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123;</span><br><span class="line">	return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,</span><br><span class="line">											getValidationModeForResource(resource), isNamespaceAware());</span><br></pre></td></tr></table></figure>
<h3 id="3-6-1-参数1"><a href="#3-6-1-参数1" class="headerlink" title="3.6.1 参数1"></a>3.6.1 参数1</h3><p>上文中的getEntityResolver() 方法返回 XmlBeanDefinitionReader 类的 entityResolver 属性。</p>
<p>entityResolver 属性在 loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 方法中被赋值。</p>
<p><code>beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</code></p>
<p>和resourceLoader一样，this拿的是XmlWebApplicationContext实例，我们再来看下ResourceEntityResolver的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Create a ResourceEntityResolver for the specified ResourceLoader</span><br><span class="line">* (usually, an ApplicationContext).</span><br><span class="line">* @param resourceLoader the ResourceLoader (or ApplicationContext)</span><br><span class="line">* to load XML entity includes with</span><br><span class="line">*</span><br><span class="line">* 为指定的ResourceLoade（通常是应用上下文）r创建一个ResourceEntityResolver</span><br><span class="line">*&#x2F;</span><br><span class="line">public ResourceEntityResolver(ResourceLoader resourceLoader) &#123;</span><br><span class="line">    super(resourceLoader.getClassLoader());</span><br><span class="line">    &#x2F;&#x2F;此处解析器拿到了上下文的引用</span><br><span class="line">    this.resourceLoader &#x3D; resourceLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了父类构造，再跟进一层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Create a new DelegatingEntityResolver that delegates to</span><br><span class="line">* a default &#123;@link BeansDtdResolver&#125; and a default &#123;@link PluggableSchemaResolver&#125;.</span><br><span class="line">* &lt;p&gt;Configures the &#123;@link PluggableSchemaResolver&#125; with the supplied</span><br><span class="line">* &#123;@link ClassLoader&#125;.</span><br><span class="line">* @param classLoader the ClassLoader to use for loading</span><br><span class="line">* (can be &#123;@code null&#125;) to use the default ClassLoader)</span><br><span class="line">*&#x2F;</span><br><span class="line">public DelegatingEntityResolver(ClassLoader classLoader) &#123;</span><br><span class="line">    &#x2F;&#x2F;这两个解析器和约束的类型有关，DTD</span><br><span class="line">    this.dtdResolver &#x3D; new BeansDtdResolver();</span><br><span class="line">    &#x2F;&#x2F;可插拔的Schema解析器，拿的上下文的类加载器</span><br><span class="line">    this.schemaResolver &#x3D; new PluggableSchemaResolver(classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间的this.errorHandler参数可忽略。</p>
<h3 id="3-6-2-参数2"><a href="#3-6-2-参数2" class="headerlink" title="3.6.2 参数2"></a>3.6.2 参数2</h3><p>ok，然后是getValidationModeForResource(resource)入参。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Gets the validation mode for the specified &#123;@link Resource&#125;. If no explicit</span><br><span class="line">* validation mode has been configured then the validation mode is</span><br><span class="line">* &#123;@link #detectValidationMode detected&#125;.</span><br><span class="line">* &lt;p&gt;Override this method if you would like full control over the validation</span><br><span class="line">* mode, even when something other than &#123;@link #VALIDATION_AUTO&#125; was set.</span><br><span class="line">* </span><br><span class="line">* 通过给定Resource给出验证模式。如果没有明确配置验证模式，那么调用detectValidationMode方法去检测。</span><br><span class="line">*&#x2F;</span><br><span class="line">protected int getValidationModeForResource(Resource resource) &#123;</span><br><span class="line">    &#x2F;&#x2F;默认自动验证，为1</span><br><span class="line">    int validationModeToUse &#x3D; getValidationMode();</span><br><span class="line">    &#x2F;&#x2F;如果有给出具体验证方式，则返回结果</span><br><span class="line">    if (validationModeToUse !&#x3D; VALIDATION_AUTO) &#123;</span><br><span class="line">        return validationModeToUse;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;检测验证模式，进入这个方法</span><br><span class="line">    int detectedMode &#x3D; detectValidationMode(resource);</span><br><span class="line">    if (detectedMode !&#x3D; VALIDATION_AUTO) &#123;</span><br><span class="line">        return detectedMode;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Hmm, we didn&#39;t get a clear indication... Let&#39;s assume XSD,</span><br><span class="line">    &#x2F;&#x2F; since apparently no DTD declaration has been found up until</span><br><span class="line">    &#x2F;&#x2F; detection stopped (before finding the document&#39;s root tag).</span><br><span class="line">    &#x2F;&#x2F; 如果实在不能判断验证模式是那种就使用XSD方式，</span><br><span class="line">    &#x2F;&#x2F; 因为检测完后还是没有发现DTD模式的声明（在查找document的根标签之前)。</span><br><span class="line">    &#x2F;&#x2F; 值为3</span><br><span class="line">    return VALIDATION_XSD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getValidationModeForResource的核心方法是detectValidationMode()，我们继续：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Detects which kind of validation to perform on the XML file identified</span><br><span class="line">* by the supplied &#123;@link Resource&#125;. If the file has a &#123;@code DOCTYPE&#125;</span><br><span class="line">* definition then DTD validation is used otherwise XSD validation is assumed.</span><br><span class="line">* &lt;p&gt;Override this method if you would like to customize resolution</span><br><span class="line">* of the &#123;@link #VALIDATION_AUTO&#125; mode.</span><br><span class="line">* </span><br><span class="line">* 检测执行xml文件时该用哪种验证方式，这个xml由Resource对象提供</span><br><span class="line">* 如果这个文件有DOCTYPE声明，那么就用DTD验证，否则就默认使用XSD。</span><br><span class="line">* 如果你想要自定义自动验证模式的解决方式，你可以覆盖这个方法</span><br><span class="line">*&#x2F;</span><br><span class="line">protected int detectValidationMode(Resource resource) &#123;</span><br><span class="line">    &#x2F;&#x2F;默认false</span><br><span class="line">    if (resource.isOpen()) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;Passed-in Resource [&quot; + resource + &quot;] contains an open stream: &quot; +</span><br><span class="line">            &quot;cannot determine validation mode automatically. Either pass in a Resource &quot; +</span><br><span class="line">            &quot;that is able to create fresh streams, or explicitly specify the validationMode &quot; +</span><br><span class="line">            &quot;on your XmlBeanDefinitionReader instance.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    InputStream inputStream;</span><br><span class="line">    try &#123;</span><br><span class="line">        inputStream &#x3D; resource.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(</span><br><span class="line">            &quot;Unable to determine validation mode for [&quot; + resource + &quot;]: cannot open InputStream. &quot; +</span><br><span class="line">            &quot;Did you attempt to load directly from a SAX InputSource without specifying the &quot; +</span><br><span class="line">            &quot;validationMode on your XmlBeanDefinitionReader instance?&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;XmlBeanDefinitionReader的validationModeDetector属性有默认实现XmlValidationModeDetector</span><br><span class="line">        &#x2F;&#x2F;核心方法，接下来进入这个方法看下</span><br><span class="line">        return this.validationModeDetector.detectValidationMode(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new BeanDefinitionStoreException(&quot;Unable to determine validation mode for [&quot; +</span><br><span class="line">                                               resource + &quot;]: an error occurred whilst reading from the InputStream.&quot;, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以来看validationModeDetector调用的detectValidationMode方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Detect the validation mode for the XML document in the supplied &#123;@link InputStream&#125;.</span><br><span class="line">* Note that the supplied &#123;@link InputStream&#125; is closed by this method before returning.</span><br><span class="line">* </span><br><span class="line">* 在提供的InputStream中检测XML文档的验证模式</span><br><span class="line">* 注意，提供的InputStream在这个方法return之前会被关闭</span><br><span class="line">*&#x2F;</span><br><span class="line">public int detectValidationMode(InputStream inputStream) throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Peek into the file to look for DOCTYPE.</span><br><span class="line">    &#x2F;&#x2F; 查找文件的DOCTYPE</span><br><span class="line">    BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean isDtdValidated &#x3D; false;</span><br><span class="line">        String content;</span><br><span class="line">        while ((content &#x3D; reader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;读一行字符串就干掉字符串里面的注释，如果全是注释全干掉</span><br><span class="line">            &#x2F;&#x2F;主要为了剥离注释，因为非注释内容要么是DOCTYPE声明要么是文档的根元素对象</span><br><span class="line">            content &#x3D; consumeCommentTokens(content);</span><br><span class="line">            &#x2F;&#x2F;剥离注释后完全没内容就继续循环</span><br><span class="line">            if (this.inComment || !StringUtils.hasText(content)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;有DOCTYPE声明，就跳出去</span><br><span class="line">            if (hasDoctype(content)) &#123;</span><br><span class="line">                isDtdValidated &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;注释不能进去。开头是&quot;&lt;&quot;,后面第一个字符是字母，就进入。</span><br><span class="line">            &#x2F;&#x2F;比如&#39;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;&#39;</span><br><span class="line">            &#x2F;&#x2F;进去后跳出循环</span><br><span class="line">            if (hasOpeningTag(content)) &#123;</span><br><span class="line">                &#x2F;&#x2F; End of meaningful data...</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;当遍历到名称空间了也就是&quot;&lt;beans xmlns&#x3D;...&gt;&quot;还没有DOCTYPE声明，</span><br><span class="line">        &#x2F;&#x2F;那么就判定他为XSD验证</span><br><span class="line">        return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (CharConversionException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; Choked on some character encoding...</span><br><span class="line">        &#x2F;&#x2F; Leave the decision up to the caller.</span><br><span class="line">        return VALIDATION_AUTO;</span><br><span class="line">    &#125;</span><br><span class="line">    finally &#123;</span><br><span class="line">        &#x2F;&#x2F;关流</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-3-解析的核心逻辑"><a href="#3-6-3-解析的核心逻辑" class="headerlink" title="3.6.3 解析的核心逻辑"></a>3.6.3 解析的核心逻辑</h3><p>讲完核心的两个入参后进入正主，loadDocument方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,</span><br><span class="line">				getValidationModeForResource(resource), isNamespaceAware());</span><br></pre></td></tr></table></figure>
<p>documentLoader属性的默认实现是DefaultDocumentLoader；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Load the &#123;@link Document&#125; at the supplied &#123;@link InputSource&#125; using the standard JAXP-configured</span><br><span class="line">* XML parser.</span><br><span class="line">*</span><br><span class="line">* 使用标准JAXP配置XML解析器加载InputSource的Document对象</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,</span><br><span class="line">                             ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建文档构建器工厂对象，并初始化一些属性</span><br><span class="line">    &#x2F;&#x2F;如果验证模式为XSD，那么强制支持XML名称空间，并加上schema属性</span><br><span class="line">    DocumentBuilderFactory factory &#x3D; createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">    if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建一个JAXP文档构建器</span><br><span class="line">    DocumentBuilder builder &#x3D; createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;按照XML文档解析给定inputSource的内容，然后返回一个新的DOM对象</span><br><span class="line">    return builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步，DocumentBuilder的默认实现是DocumentBuilderImpl，这个是jdk里面的xml解析器了，不再赘述。</p>
<p>至此，我们拿到了Document对象</p>
<h2 id="3-7-准备注册BeanDefinitions"><a href="#3-7-准备注册BeanDefinitions" class="headerlink" title="3.7 准备注册BeanDefinitions"></a>3.7 准备注册BeanDefinitions</h2><p>两个核心方法，看完了doLoadDocument方法，我们再来看registerBeanDefinitions方法，后者负责注册BeanDefinitions，我们分别来分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Register the bean definitions contained in the given DOM document.</span><br><span class="line"> * Called by &#123;@code loadBeanDefinitions&#125;.</span><br><span class="line"> * &lt;p&gt;Creates a new instance of the parser class and invokes</span><br><span class="line"> * &#123;@code registerBeanDefinitions&#125; on it.</span><br><span class="line"> * 注册包含在给定DOM文档中的bean定义。由&#123;@code loadBeanDefinitions&#125;调用。&lt;p&gt;创建解析器类的新实例，并在其上调用&#123;@code registerBeanDefinitions&#125;。</span><br><span class="line"> *</span><br><span class="line"> * 注册包含在给定DOM文档对象中的 bean definition</span><br><span class="line"> * 被loadBeanDefinitions方法所调用</span><br><span class="line"> * 解析class后创建一个新的实例，并调用registerBeanDefinitions方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123;</span><br><span class="line">	&#x2F;&#x2F;其实就是new了一个DefaultBeanDefinitionDocumentReader工具类。</span><br><span class="line">	BeanDefinitionDocumentReader documentReader &#x3D; createBeanDefinitionDocumentReader();</span><br><span class="line">	&#x2F;&#x2F;getRegistry()方法拿的是bean工厂对象，beanDefinition注册在工厂中</span><br><span class="line">	&#x2F;&#x2F;这个方法就是返回已经被注册在工厂中的beanDefinitions数量</span><br><span class="line">	int countBefore &#x3D; getRegistry().getBeanDefinitionCount();</span><br><span class="line">	&#x2F;&#x2F;核心方法</span><br><span class="line">	&#x2F;&#x2F;createReaderContext创建了XmlReaderContext对象</span><br><span class="line">	&#x2F;&#x2F;XmlReaderContext对象是BeanDefinition读取过程中传递的上下文，封装相关的的配置和状态</span><br><span class="line">	documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">	&#x2F;&#x2F;返回上文这个核心方法真正注册在工厂中的beanDefinition数量</span><br><span class="line">	return getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心方法documentReader.registerBeanDefinitions实现在DefaultBeanDefinitionDocumentReader类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 这个方法在刚创建的DefaultBeanDefinitionDocumentReader中</span><br><span class="line">*</span><br><span class="line">* This implementation parses bean definitions according to the &quot;spring-beans&quot; XSD</span><br><span class="line">* (or DTD, historically).</span><br><span class="line">* &lt;p&gt;Opens a DOM Document; then initializes the default settings</span><br><span class="line">* specified at the &#123;@code &lt;beans&#x2F;&gt;&#125; level; then parses the contained bean definitions.</span><br><span class="line">*</span><br><span class="line">* 根据“spring-beans&quot;的XSD（或者DTD）去解析bean definition</span><br><span class="line">* 打开一个DOM文档，然后初始化在&lt;beans&#x2F;&gt;层级上指定的默认设置，然后解析包含在其中的bean definitions</span><br><span class="line">*&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123;</span><br><span class="line">	&#x2F;&#x2F;入参时创建的XmlReaderContext对象</span><br><span class="line">	this.readerContext &#x3D; readerContext;</span><br><span class="line">	logger.debug(&quot;Loading bean definitions&quot;);</span><br><span class="line">	&#x2F;&#x2F;拿到了xml文档对象的根元素</span><br><span class="line">	Element root &#x3D; doc.getDocumentElement();</span><br><span class="line">	&#x2F;&#x2F;进入这个方法进行查看</span><br><span class="line">	doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看DefaultBeanDefinitionDocumentReader类的doRegisterBeanDefinitions方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Register each bean definition within the given root &#123;@code &lt;beans&#x2F;&gt;&#125; element.</span><br><span class="line">*</span><br><span class="line">* 从&lt;beans &#x2F;&gt;配置中注册每一个bean，如果有嵌套的beans，那么递归执行这个方法。</span><br><span class="line">*&#x2F;</span><br><span class="line">protected void doRegisterBeanDefinitions(Element root) &#123;</span><br><span class="line">    &#x2F;&#x2F; Any nested &lt;beans&gt; elements will cause recursion in this method. In</span><br><span class="line">    &#x2F;&#x2F; order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span><br><span class="line">    &#x2F;&#x2F; keep track of the current (parent) delegate, which may be null. Create</span><br><span class="line">    &#x2F;&#x2F; the new (child) delegate with a reference to the parent for fallback purposes,</span><br><span class="line">    &#x2F;&#x2F; then ultimately reset this.delegate back to its original (parent) reference.</span><br><span class="line">    &#x2F;&#x2F; this behavior emulates a stack of delegates without actually necessitating one.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; delegate可以理解为配置参数&#x2F;属性，传递的上下文，封装相关的的配置和状态等信息的集合对象</span><br><span class="line">    &#x2F;&#x2F; 任何被嵌套的&lt;beans&gt;元素都会导致此方法的递归。为了正确的传播和保存delegate内的信息，所以这里需要做delegate交接</span><br><span class="line">    &#x2F;&#x2F; 它可能为null</span><br><span class="line">    &#x2F;&#x2F; 为了能够回退，新的（子）delegate具有父的引用，最终会重置this.delegate回到它的初始（父）引用。</span><br><span class="line">    BeanDefinitionParserDelegate parent &#x3D; this.delegate;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重要方法，创建一个新的代理，继承父delegate，并初始化一些默认值</span><br><span class="line">    this.delegate &#x3D; createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;默认明明空间是&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    if (this.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        String profileSpec &#x3D; root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;如果当前层级的&lt;beans &#x2F;&gt;配置有profile属性，那么处理这个属性。不是很重要不赘述</span><br><span class="line">        if (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            String[] specifiedProfiles &#x3D; StringUtils.tokenizeToStringArray(</span><br><span class="line">                profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +</span><br><span class="line">                                &quot;] not matching: &quot; + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;xml预处理，子类没有重写里面就是空实现</span><br><span class="line">    preProcessXml(root);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重要方法，生成BeanDefinition，并注册在工厂中</span><br><span class="line">    parseBeanDefinitions(root, this.delegate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;xml后处理，子类没有重写里面就是空实现</span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    this.delegate &#x3D; parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好，这里两个核心方法，我们一个一个来</p>
<h2 id="3-8-生成代理和传递基础配置"><a href="#3-8-生成代理和传递基础配置" class="headerlink" title="3.8 生成代理和传递基础配置"></a>3.8 生成代理和传递基础配置</h2><p>先看DefaultBeanDefinitionDocumentReader类的createDelegate方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">protected BeanDefinitionParserDelegate createDelegate(</span><br><span class="line">		XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;生成用来解析XML bean definition的有状态Delegate类，用来被主解析器和其他扩展使用。</span><br><span class="line">	&#x2F;&#x2F;上下文readerContext继承在其内部</span><br><span class="line">	BeanDefinitionParserDelegate delegate &#x3D; new BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">	&#x2F;&#x2F;给新生成的delegate做继承和赋初值</span><br><span class="line">	delegate.initDefaults(root, parentDelegate);</span><br><span class="line">	return delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Initialize the default lazy-init, autowire, dependency check settings,</span><br><span class="line"> * init-method, destroy-method and merge settings. Support nested &#39;beans&#39;</span><br><span class="line"> * element use cases by falling back to the given parent in case the</span><br><span class="line"> * defaults are not explicitly set locally.</span><br><span class="line"> *</span><br><span class="line"> * 用默认的值填充DocumentDefaultsDefinition实例</span><br><span class="line"> * 通过使用parentDefaults（父代理的default属性），来解决嵌套的&#39;beans&#39;元素情况，以防默认值在局部设定不明确</span><br><span class="line"> *&#x2F;</span><br><span class="line"> public void initDefaults(Element root, BeanDefinitionParserDelegate parent) &#123;</span><br><span class="line"></span><br><span class="line">	 &#x2F;&#x2F;重要方法，构造当前delegate的默认配置信息封装类，为其赋初值。</span><br><span class="line">	 &#x2F;&#x2F;this.defaults，也就是当前delegate的默认配置信息封装类，它的类型是DocumentDefaultsDefinition</span><br><span class="line">	 &#x2F;&#x2F;如果有父delegate，也要让新生成的defaults继承父delegate的defaults</span><br><span class="line">	populateDefaults(this.defaults, (parent !&#x3D; null ? parent.defaults : null), root);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;默认没做任何实现</span><br><span class="line">	this.readerContext.fireDefaultsRegistered(this.defaults);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Populate the given DocumentDefaultsDefinition instance with the default lazy-init,</span><br><span class="line"> * autowire, dependency check settings, init-method, destroy-method and merge settings.</span><br><span class="line"> * Support nested &#39;beans&#39; element use cases by falling back to &#123;@code parentDefaults&#125;</span><br><span class="line"> * in case the defaults are not explicitly set locally.</span><br><span class="line"> * 用默认的值填充DocumentDefaultsDefinition实例</span><br><span class="line"> * 通过使用parentDefaults（父代理的default属性），来解决嵌套的&#39;beans&#39;元素情况，以防默认值在局部设定不明确</span><br><span class="line"> * @param defaults the defaults to populate</span><br><span class="line"> * @param parentDefaults the parent BeanDefinitionParserDelegate (if any) defaults to fall back to</span><br><span class="line"> * @param root the root element of the current bean definition document (or nested beans element)</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void populateDefaults(DocumentDefaultsDefinition defaults, @Nullable DocumentDefaultsDefinition parentDefaults, Element root) &#123;</span><br><span class="line">	&#x2F;&#x2F;根元素上如果没有设定值，则返回&quot;default&quot;字符串</span><br><span class="line">	String lazyInit &#x3D; root.getAttribute(DEFAULT_LAZY_INIT_ATTRIBUTE);</span><br><span class="line">	&#x2F;&#x2F;如果为&quot;default&quot;，先看parentDefaults有没有，有用它的，没有用&quot;false&quot;</span><br><span class="line">	if (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to false.</span><br><span class="line">		&#x2F;&#x2F; 可能从外部&lt;beans&gt;继承，否则返回false</span><br><span class="line">		lazyInit &#x3D; (parentDefaults !&#x3D; null ? parentDefaults.getLazyInit() : FALSE_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	defaults.setLazyInit(lazyInit);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;下面的逻辑和lazyInit差不多，即看本级是否有显性配置，没有的话，看父类有没有继承，也没有就设默认值。</span><br><span class="line"></span><br><span class="line">	String merge &#x3D; root.getAttribute(DEFAULT_MERGE_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(merge)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to false.</span><br><span class="line">		merge &#x3D; (parentDefaults !&#x3D; null ? parentDefaults.getMerge() : FALSE_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	defaults.setMerge(merge);</span><br><span class="line"></span><br><span class="line">	String autowire &#x3D; root.getAttribute(DEFAULT_AUTOWIRE_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(autowire)) &#123;</span><br><span class="line">		&#x2F;&#x2F; Potentially inherited from outer &lt;beans&gt; sections, otherwise falling back to &#39;no&#39;.</span><br><span class="line">		autowire &#x3D; (parentDefaults !&#x3D; null ? parentDefaults.getAutowire() : AUTOWIRE_NO_VALUE);</span><br><span class="line">	&#125;</span><br><span class="line">	defaults.setAutowire(autowire);</span><br><span class="line"></span><br><span class="line">	if (root.hasAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE)) &#123;</span><br><span class="line">		defaults.setAutowireCandidates(root.getAttribute(DEFAULT_AUTOWIRE_CANDIDATES_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (parentDefaults !&#x3D; null) &#123;</span><br><span class="line">		defaults.setAutowireCandidates(parentDefaults.getAutowireCandidates());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root.hasAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		defaults.setInitMethod(root.getAttribute(DEFAULT_INIT_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (parentDefaults !&#x3D; null) &#123;</span><br><span class="line">		defaults.setInitMethod(parentDefaults.getInitMethod());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (root.hasAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		defaults.setDestroyMethod(root.getAttribute(DEFAULT_DESTROY_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (parentDefaults !&#x3D; null) &#123;</span><br><span class="line">		defaults.setDestroyMethod(parentDefaults.getDestroyMethod());</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;extractSource方法这里没有做任何实现，默认返回null</span><br><span class="line">	defaults.setSource(this.readerContext.extractSource(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-9-拆解根层级，并根据子标签命名空间做不同处理"><a href="#3-9-拆解根层级，并根据子标签命名空间做不同处理" class="headerlink" title="3.9 拆解根层级，并根据子标签命名空间做不同处理"></a>3.9 拆解根层级，并根据子标签命名空间做不同处理</h2><p>我们再来看另一个核心方法：DefaultBeanDefinitionDocumentReader类的parseBeanDefinitions方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse the elements at the root level in the document:</span><br><span class="line"> * 将文档中&lt;beans&#x2F;&gt;层级下的元素一层层剥开，为子标签的不同命名空间选择不同策略。</span><br><span class="line"> * 主要两种命名空间：beans命名空间 +其他命名空间（context&#x2F;aop等命名空间）</span><br><span class="line"> </span><br><span class="line"> * &quot;import&quot;, &quot;alias&quot;, &quot;bean&quot;等标签都属于beans命名空间</span><br><span class="line"> *</span><br><span class="line"> * 这里判断是否是不同的命名空间，不同命名空间，后续会使用不同解析器来解析。</span><br><span class="line"> *</span><br><span class="line"> * @param root the DOM root element of the document</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;判断默认命名空间是&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">		&#x2F;&#x2F;获取根元素(&lt;beans &#x2F;&gt;)下的子Node，注意，Node不一定是子标签，可能是回车，可能是注释</span><br><span class="line">		NodeList nl &#x3D; root.getChildNodes();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">			Node node &#x3D; nl.item(i);</span><br><span class="line">			if (node instanceof Element) &#123;</span><br><span class="line">				&#x2F;&#x2F;拿到了&lt;beans&gt;下的子标签</span><br><span class="line">				Element ele &#x3D; (Element) node;</span><br><span class="line">				&#x2F;&#x2F;如果该标签属于beans的名称空间，则进入这个方法</span><br><span class="line">				&#x2F;&#x2F;xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">				if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">					parseDefaultElement(ele, delegate);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					&#x2F;&#x2F;如果该标签属于其他的名称空间比如：context,aop等</span><br><span class="line">					&#x2F;&#x2F;xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">					&#x2F;&#x2F;xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">					&#x2F;&#x2F;比如我们使用注解注入的话，会在spring的配置文件加&lt;context:annotation-config&#x2F;&gt;</span><br><span class="line">					&#x2F;&#x2F;这个启用注解的标签，就属于context命名空间</span><br><span class="line">					&#x2F;&#x2F;在接下来的逻辑中，不同命名空间，使用不同处理器来解析</span><br><span class="line">					delegate.parseCustomElement(ele);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		delegate.parseCustomElement(root);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-解析beans命名空间的配置"><a href="#3-10-解析beans命名空间的配置" class="headerlink" title="3.10 解析beans命名空间的配置"></a>3.10 解析beans命名空间的配置</h2><p>前文我们说到，如果该标签属于beans的名称空间，则进入parseDefaultElement(ele, delegate)方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;&lt;import&gt;标签进入这个方法</span><br><span class="line">	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">		importBeanDefinitionResource(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;&lt;alias&gt;标签进入这个方法</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">		processAliasRegistration(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;&lt;bean&gt;标签进入这个方法</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F;核心方法</span><br><span class="line">		processBeanDefinition(ele, delegate);</span><br><span class="line">	&#125;&#x2F;&#x2F;又嵌套一层&lt;beans&gt;标签进入这个方法</span><br><span class="line">	else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F; recurse</span><br><span class="line">		&#x2F;&#x2F; 如果是嵌套的beans，那么就会重新调用doRegisterBeanDefinitions进行递归</span><br><span class="line">		doRegisterBeanDefinitions(ele);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述几个标签中，我们主要来看<code>&lt;bean&gt;</code>标签的解析方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Process the given bean element, parsing the bean definition</span><br><span class="line"> * and registering it with the registry.</span><br><span class="line"> * 处理bean元素，解析成bean definition并注册到工厂中</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;使用delegate的内容（默认配置）来解析bean元素，核心方法</span><br><span class="line">	BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	if (bdHolder !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有要求的话渲染beanDefinition</span><br><span class="line">		bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Register the final decorated instance.</span><br><span class="line">			&#x2F;&#x2F;注册最终被渲染的实例到工厂中</span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +</span><br><span class="line">					bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; Send registration event.</span><br><span class="line">		&#x2F;&#x2F; 发送注册事件</span><br><span class="line">		&#x2F;&#x2F; 这里是空实现</span><br><span class="line">		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-11-解析并生成BeanDefinition实例"><a href="#3-11-解析并生成BeanDefinition实例" class="headerlink" title="3.11 解析并生成BeanDefinition实例"></a>3.11 解析并生成BeanDefinition实例</h2><p>进入BeanDefinitionParserDelegate类的parseBeanDefinitionElement方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Parses the supplied &#123;@code &lt;bean&gt;&#125; element. May return &#123;@code null&#125;</span><br><span class="line">* if there were errors during parse. Errors are reported to the</span><br><span class="line">* &#123;@link org.springframework.beans.factory.parsing.ProblemReporter&#125;.</span><br><span class="line">*</span><br><span class="line">* 解析bean元素。如果解析过程中发生错误则返回空</span><br><span class="line">*&#x2F;</span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123;</span><br><span class="line">    return parseBeanDefinitionElement(ele, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123;</span><br><span class="line">    &#x2F;&#x2F;拿bean标签上的id</span><br><span class="line">    String id &#x3D; ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    &#x2F;&#x2F;拿bean标签上的name属性</span><br><span class="line">    String nameAttr &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    List&lt;String&gt; aliases &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">    &#x2F;&#x2F;有name属性进入</span><br><span class="line">    if (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        &#x2F;&#x2F;name属性对应的name值如果有分隔符&quot;,; &quot;，那么切分成数组</span><br><span class="line">        String[] nameArr &#x3D; StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        &#x2F;&#x2F;这些name值就是别名</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;指定了id就用id值作为bean名称</span><br><span class="line">    String beanName &#x3D; id;</span><br><span class="line">    &#x2F;&#x2F;如果没有id，但是指定了name，就用name值作为bean名称</span><br><span class="line">    if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        &#x2F;&#x2F;拿第一个name值作为bean名称，其余的还是别名</span><br><span class="line">        beanName &#x3D; aliases.remove(0);</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;No XML &#39;id&#39; specified - using &#39;&quot; + beanName +</span><br><span class="line">                         &quot;&#39; as bean name and &quot; + aliases + &quot; as aliases&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (containingBean &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;检查bean名称和别名是否已经被使用了，如果用了就报错</span><br><span class="line">        &#x2F;&#x2F;同时把这个bean的名称和别名加入代理的usedNames属性中</span><br><span class="line">        &#x2F;&#x2F;private final Set&lt;String&gt; usedNames &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;直接进入这个方法</span><br><span class="line">    AbstractBeanDefinition beanDefinition &#x3D; parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    if (beanDefinition !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;既没有指定id，也没有指定name就走这里面</span><br><span class="line">        if (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;前面containingBean传递时为null，这里不走这个方法</span><br><span class="line">                if (containingBean !&#x3D; null) &#123;</span><br><span class="line">                    beanName &#x3D; BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                        beanDefinition, this.readerContext.getRegistry(), true);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    &#x2F;&#x2F;生成一个bean名称，beanName</span><br><span class="line">                    &#x2F;&#x2F;如果这个bean是内部bean，全限定名后加#号再加哈希值</span><br><span class="line">                    &#x2F;&#x2F;如果是顶层bean，那么后面加#号再从0开始加数字，id已被注册数字就增1，直到唯一</span><br><span class="line">                    &#x2F;&#x2F;比如：tk.mybatis.spring.mapper.MapperScannerConfigurer#0</span><br><span class="line">                    beanName &#x3D; this.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    &#x2F;&#x2F; Register an alias for the plain bean class name, if still possible,</span><br><span class="line">                    &#x2F;&#x2F; if the generator returned the class name plus a suffix.</span><br><span class="line">                    &#x2F;&#x2F; This is expected for Spring 1.2&#x2F;2.0 backwards compatibility.</span><br><span class="line">                    &#x2F;&#x2F;如果可能的话，如果生成器返回类名加后缀，则注册一个别名，这个别名就是该类的类名。</span><br><span class="line">                    &#x2F;&#x2F;这是为了向后兼容</span><br><span class="line">                    String beanClassName &#x3D; beanDefinition.getBeanClassName();</span><br><span class="line">                    if (beanClassName !&#x3D; null &amp;&amp;</span><br><span class="line">                        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                        !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果该类名没有被使用，那么注册该类名作为别名，比如：</span><br><span class="line">                        &#x2F;&#x2F;tk.mybatis.spring.mapper.MapperScannerConfigurer作为</span><br><span class="line">                        &#x2F;&#x2F;tk.mybatis.spring.mapper.MapperScannerConfigurer#0的别名</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(&quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &quot; +</span><br><span class="line">                                 &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray &#x3D; StringUtils.toStringArray(aliases);</span><br><span class="line">        &#x2F;&#x2F;返回beanDefinition的持有者</span><br><span class="line">        return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上文中，核心方法是这句话：</p>
<p><code>AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse the bean definition itself, without regard to name or aliases. May return</span><br><span class="line"> * 不关注名称和别名，只解析bean definition自身</span><br><span class="line"> * &#123;@code null&#125; if problems occurred during the parsing of the bean definition.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">		Element ele, String beanName, @Nullable BeanDefinition containingBean) &#123;</span><br><span class="line">	&#x2F;&#x2F;栈结构，解析的时候放入bean标签，解析完成弹出</span><br><span class="line">	&#x2F;&#x2F;如果还嵌套有子标签，则后续放入子标签</span><br><span class="line">	&#x2F;&#x2F;栈结构当然后进先出，所以子标签先弹出</span><br><span class="line">	this.parseState.push(new BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">	String className &#x3D; null;</span><br><span class="line">	if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有指定class属性，则拿到class属性值</span><br><span class="line">		className &#x3D; ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">	&#125;</span><br><span class="line">	String parent &#x3D; null;</span><br><span class="line">	if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有指定parent属性，则拿到parent属性值</span><br><span class="line">		parent &#x3D; ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;创建BeanDefinition并设置两属性，核心方法</span><br><span class="line">		AbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);</span><br><span class="line">		&#x2F;&#x2F;将bean标签上的属性设置到bean definition中，核心方法2</span><br><span class="line">		parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为description，拿到标签中的文本，设置到bean definition中</span><br><span class="line">		bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为meta，拿到他的key和value属性，设置到bean definition中</span><br><span class="line">		parseMetaElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为lookup-method，拿到他的name和bean属性，设置到bean definition中</span><br><span class="line">		parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为replaced-method，设置bean definition </span><br><span class="line">		parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">		&#x2F;&#x2F;如果bean标签下有子标签为constructor-arg，设置bean definition的构造方式</span><br><span class="line">		parseConstructorArgElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;这个标签比较常用，为Property标签</span><br><span class="line">		&#x2F;&#x2F;解析Property的属性设置到bean definition中</span><br><span class="line">		parsePropertyElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;有qualifier子标签才走这个方法</span><br><span class="line">		parseQualifierElements(ele, bd);</span><br><span class="line">		&#x2F;&#x2F;设置资源</span><br><span class="line">		bd.setResource(this.readerContext.getResource());</span><br><span class="line">		&#x2F;&#x2F;这里为null</span><br><span class="line">		bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">		return bd;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (NoClassDefFoundError err) &#123;</span><br><span class="line">		error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Throwable ex) &#123;</span><br><span class="line">		error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		&#x2F;&#x2F;解析的时候放入，解析完成弹出</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个重要的核心方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;创建BeanDefinition并设置两属性，核心方法</span><br><span class="line">AbstractBeanDefinition bd &#x3D; createBeanDefinition(className, parent);</span><br><span class="line">&#x2F;&#x2F;将bean标签上的属性设置到bean definition中，核心方法2</span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F;这个标签比较常用，为Property标签</span><br><span class="line">&#x2F;&#x2F;解析Property的属性设置到bean definition中</span><br><span class="line">parsePropertyElements(ele, bd);</span><br></pre></td></tr></table></figure>

<p>我们依次来看：</p>
<h3 id="3-11-1-创建实例"><a href="#3-11-1-创建实例" class="headerlink" title="3.11.1 创建实例"></a>3.11.1 创建实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Create a bean definition for the given class name and parent name.</span><br><span class="line"> * 通过给定的className和parentName创建beanDefinition</span><br><span class="line"> * </span><br><span class="line"> * @param className the name of the bean class</span><br><span class="line"> * @param parentName the name of the bean&#39;s parent bean</span><br><span class="line"> * @return the newly created bean definition</span><br><span class="line"> * @throws ClassNotFoundException if bean class resolution was attempted but failed</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)</span><br><span class="line">		throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">	return BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">			parentName, className, this.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用BeanDefinitionReaderUtils的静态方法createBeanDefinition():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Create a new GenericBeanDefinition for the given parent name and class name,</span><br><span class="line"> * eagerly loading the bean class if a ClassLoader has been specified.</span><br><span class="line"> </span><br><span class="line"> * 通过给定的parentName和className穿件一个新的GenericBeanDefinition</span><br><span class="line"> * 如果指定了ClassLoader，就提前加载bean class</span><br><span class="line"> </span><br><span class="line"> * @param parentName the name of the parent bean, if any</span><br><span class="line"> * @param className the name of the bean class, if any</span><br><span class="line"> * @param classLoader the ClassLoader to use for loading bean classes</span><br><span class="line"> * (can be &#123;@code null&#125; to just register bean classes by name)</span><br><span class="line"> * @return the bean definition</span><br><span class="line"> * @throws ClassNotFoundException if the bean class could not be loaded</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static AbstractBeanDefinition createBeanDefinition(</span><br><span class="line">		@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader)</span><br><span class="line">		throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">	GenericBeanDefinition bd &#x3D; new GenericBeanDefinition();</span><br><span class="line">	bd.setParentName(parentName);</span><br><span class="line">	if (className !&#x3D; null) &#123;</span><br><span class="line">		if (classLoader !&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F;有classloader，则通过反射，动态加载一个实例返回</span><br><span class="line">			bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F;没有classloader，先存个className</span><br><span class="line">			bd.setBeanClassName(className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-11-2-标签的属性注入"><a href="#3-11-2-标签的属性注入" class="headerlink" title="3.11.2 标签的属性注入"></a>3.11.2 标签的属性注入</h3><p>看完了create，我们再来看parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);方法，该方法会将bean标签的属性值注入到BeanDefinition实例中，也就是给BeanDefinition赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Apply the attributes of the given bean element to the given bean * definition.</span><br><span class="line"> * 将bean标签上的属性设置到bean definition中</span><br><span class="line"> * @param ele bean declaration element</span><br><span class="line"> * @param beanName bean name</span><br><span class="line"> * @param containingBean containing bean definition</span><br><span class="line"> * @return a bean definition initialized according to the bean element attributes</span><br><span class="line"> *&#x2F;</span><br><span class="line">public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,</span><br><span class="line">		@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) &#123;</span><br><span class="line">	&#x2F;&#x2F;bean标签上已经没有singleton属性了，新版用scope代替，所以出现singleton就报错提醒</span><br><span class="line">	if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) &#123;</span><br><span class="line">		error(&quot;Old 1.x &#39;singleton&#39; attribute in use - upgrade to &#39;scope&#39; declaration&quot;, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果设置了scope就拿其值</span><br><span class="line">	else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;此处containingBean为空</span><br><span class="line">	else if (containingBean !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F; Take default from containing bean in case of an inner bean definition.</span><br><span class="line">		&#x2F;&#x2F; 如果bd是一个内部的beanDefinition，用包含它的bean的配置</span><br><span class="line">		bd.setScope(containingBean.getScope());</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;如果设置了abstract就拿其值</span><br><span class="line">	if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;lazyInit如果没有设置则为默认值，默认值用的代理类中defaults属性，</span><br><span class="line">	&#x2F;&#x2F;也就是this.defaults</span><br><span class="line">	String lazyInit &#x3D; ele.getAttribute(LAZY_INIT_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(lazyInit)) &#123;</span><br><span class="line">		lazyInit &#x3D; this.defaults.getLazyInit();</span><br><span class="line">	&#125;</span><br><span class="line">	bd.setLazyInit(TRUE_VALUE.equals(lazyInit));</span><br><span class="line">	&#x2F;&#x2F;拿autowire配置，无则用默认值，默认值用的代理类中defaults属性，即不进行autowire</span><br><span class="line">	String autowire &#x3D; ele.getAttribute(AUTOWIRE_ATTRIBUTE);</span><br><span class="line">	bd.setAutowireMode(getAutowireMode(autowire));</span><br><span class="line">	&#x2F;&#x2F;拿depends-on配置</span><br><span class="line">	if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) &#123;</span><br><span class="line">		String dependsOn &#x3D; ele.getAttribute(DEPENDS_ON_ATTRIBUTE);</span><br><span class="line">		bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有autowire-candidate属性，没有或者为默认则不设置</span><br><span class="line">	String autowireCandidate &#x3D; ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);</span><br><span class="line">	if (isDefaultValue(autowireCandidate)) &#123;</span><br><span class="line">		String candidatePattern &#x3D; this.defaults.getAutowireCandidates();</span><br><span class="line">		if (candidatePattern !&#x3D; null) &#123;</span><br><span class="line">			String[] patterns &#x3D; StringUtils.commaDelimitedListToStringArray(candidatePattern);</span><br><span class="line">			bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有primary属性</span><br><span class="line">	if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有init-method属性</span><br><span class="line">	if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		String initMethodName &#x3D; ele.getAttribute(INIT_METHOD_ATTRIBUTE);</span><br><span class="line">		bd.setInitMethodName(initMethodName);</span><br><span class="line">	&#125;&#x2F;&#x2F;没有init-method属性，就拿代理类defaults属性的</span><br><span class="line">	else if (this.defaults.getInitMethod() !&#x3D; null) &#123;</span><br><span class="line">		bd.setInitMethodName(this.defaults.getInitMethod());</span><br><span class="line">		bd.setEnforceInitMethod(false);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有destroy-method属性</span><br><span class="line">	if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		String destroyMethodName &#x3D; ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);</span><br><span class="line">		bd.setDestroyMethodName(destroyMethodName);</span><br><span class="line">	&#125;&#x2F;&#x2F;没有destroy-method属性，就拿代理类defaults属性的</span><br><span class="line">	else if (this.defaults.getDestroyMethod() !&#x3D; null) &#123;</span><br><span class="line">		bd.setDestroyMethodName(this.defaults.getDestroyMethod());</span><br><span class="line">		bd.setEnforceDestroyMethod(false);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有factory-method属性</span><br><span class="line">	if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;是否有factory-bean属性</span><br><span class="line">	if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) &#123;</span><br><span class="line">		bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return bd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，bean标签上的属性也就解析完成了，对其属性的描述不管设置了还是没有设置的，都有相应的值对应到bean definition中。</p>
<h3 id="3-11-3-bean标签下的property注入"><a href="#3-11-3-bean标签下的property注入" class="headerlink" title="3.11.3 bean标签下的property注入"></a>3.11.3 bean标签下的property注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.sgcc.bean.Student&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;无敌&quot;&#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;20&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>如上述配置，我们知道property的存在，parsePropertyElements()负责解析Property的属性设置到beanDefinition中，此方法在BeanDefinitionParserDelegate类中实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Parse property sub-elements of the given bean element.</span><br><span class="line"> * 解析bean标签下property子标签</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void parsePropertyElements(Element beanEle, BeanDefinition bd) &#123;</span><br><span class="line">	NodeList nl &#x3D; beanEle.getChildNodes();</span><br><span class="line">	&#x2F;&#x2F;循环查找元素的子元素，也就是bean标签的子元素</span><br><span class="line">	for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		Node node &#x3D; nl.item(i);</span><br><span class="line">		&#x2F;&#x2F;标签名为property才能进入，进入这个方法</span><br><span class="line">		if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) &#123;</span><br><span class="line">			parsePropertyElement((Element) node, bd);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse a property element.</span><br><span class="line"> * 解析property元素，核心的属性只有name和value</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void parsePropertyElement(Element ele, BeanDefinition bd) &#123;</span><br><span class="line">	&#x2F;&#x2F;拿到property标签的name属性</span><br><span class="line">	String propertyName &#x3D; ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">	if (!StringUtils.hasLength(propertyName)) &#123;</span><br><span class="line">		error(&quot;Tag &#39;property&#39; must have a &#39;name&#39; attribute&quot;, ele);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;解析的时候放入，解析完成弹出，这里放入property标签，</span><br><span class="line">	&#x2F;&#x2F;注意，此时这里还存有bean父标签，子标签解析完成后先弹出</span><br><span class="line">	this.parseState.push(new PropertyEntry(propertyName));</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;bean标签下可以有多个property，但是不能重复name属性，有重复报错</span><br><span class="line">		if (bd.getPropertyValues().contains(propertyName)) &#123;</span><br><span class="line">			error(&quot;Multiple &#39;property&#39; definitions for property &#39;&quot; + propertyName + &quot;&#39;&quot;, ele);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;核心方法，解析property标签属性</span><br><span class="line">		Object val &#x3D; parsePropertyValue(ele, bd, propertyName);</span><br><span class="line">		&#x2F;&#x2F;将name属性和对应的value封装为PropertyValue对象</span><br><span class="line">		PropertyValue pv &#x3D; new PropertyValue(propertyName, val);</span><br><span class="line">		&#x2F;&#x2F;解析property标签的子标签meta，</span><br><span class="line">		&#x2F;&#x2F;拿到meta的key和value属性，设置到PropertyValue中</span><br><span class="line">		parseMetaElements(ele, pv);</span><br><span class="line">		&#x2F;&#x2F;这里没有实现，为null</span><br><span class="line">		pv.setSource(extractSource(ele));</span><br><span class="line">		&#x2F;&#x2F;将PropertyValue添加到bean definition中</span><br><span class="line">		bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		&#x2F;&#x2F;解析的时候放入，解析完成弹出，这里弹出的是property标签</span><br><span class="line">		this.parseState.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Get the value of a property element. May be a list etc.</span><br><span class="line"> * Also used for constructor arguments, &quot;propertyName&quot; being null in this case.</span><br><span class="line"> * 拿到property标签的value值，可能是list</span><br><span class="line"> * 也可能被constructor标签使用，这种情况propertyName为null</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) &#123;</span><br><span class="line">	&#x2F;&#x2F;如果propertyName为null，则ele是constructor-arg标签</span><br><span class="line">	&#x2F;&#x2F;否则为property标签</span><br><span class="line">	String elementName &#x3D; (propertyName !&#x3D; null ?</span><br><span class="line">			&quot;&lt;property&gt; element for property &#39;&quot; + propertyName + &quot;&#39;&quot; :</span><br><span class="line">			&quot;&lt;constructor-arg&gt; element&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Should only have one child element: ref, value, list, etc.</span><br><span class="line">	&#x2F;&#x2F;不管是哪种标签，下面都应该只有一个子标签: ref, value, list等.</span><br><span class="line">	NodeList nl &#x3D; ele.getChildNodes();</span><br><span class="line">	Element subElement &#x3D; null;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">		Node node &#x3D; nl.item(i);</span><br><span class="line">		if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;</span><br><span class="line">				!nodeNameEquals(node, META_ELEMENT)) &#123;</span><br><span class="line">			&#x2F;&#x2F; Child element is what we&#39;re looking for.</span><br><span class="line">			&#x2F;&#x2F;除开description和meta标签，子标签最多只能有一个</span><br><span class="line">			&#x2F;&#x2F;如果该判断为真，说明不止一个除开description和meta的标签</span><br><span class="line">			if (subElement !&#x3D; null) &#123;</span><br><span class="line">				error(elementName + &quot; must not contain more than one sub-element&quot;, ele);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				&#x2F;&#x2F;得到除开description和meta之外的子标签</span><br><span class="line">				&#x2F;&#x2F;比如下面这种配置，那么&lt;value&gt;helloworld&lt;&#x2F;value&gt;就是子元素subElement。</span><br><span class="line">				&#x2F;&#x2F;&lt;property name&#x3D;&quot;Nnnn&quot;&gt;</span><br><span class="line">				&#x2F;&#x2F;	&lt;value&gt;helloworld&lt;&#x2F;value&gt;</span><br><span class="line">				&#x2F;&#x2F;&lt;&#x2F;property&gt;</span><br><span class="line">				subElement &#x3D; (Element) node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;看标签属性用的是value还是ref</span><br><span class="line">	boolean hasRefAttribute &#x3D; ele.hasAttribute(REF_ATTRIBUTE);</span><br><span class="line">	boolean hasValueAttribute &#x3D; ele.hasAttribute(VALUE_ATTRIBUTE);</span><br><span class="line">	&#x2F;&#x2F;value和ref属性不能同时存在，如果有子标签，则value和ref都不能存在，否则报错</span><br><span class="line">	if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||</span><br><span class="line">			((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement !&#x3D; null)) &#123;</span><br><span class="line">		error(elementName +</span><br><span class="line">				&quot; is only allowed to contain either &#39;ref&#39; attribute OR &#39;value&#39; attribute OR sub-element&quot;, ele);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;用的ref的情况，如&lt;property name&#x3D;&quot;name&quot; ref&#x3D;&quot;......&quot;&#x2F;&gt;</span><br><span class="line">	if (hasRefAttribute) &#123;</span><br><span class="line">		&#x2F;&#x2F;拿到ref属性</span><br><span class="line">		String refName &#x3D; ele.getAttribute(REF_ATTRIBUTE);</span><br><span class="line">		if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(elementName + &quot; contains empty &#39;ref&#39; attribute&quot;, ele);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;通过ref属性来构建一个RuntimeBeanReference实例对象</span><br><span class="line">		RuntimeBeanReference ref &#x3D; new RuntimeBeanReference(refName);</span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		return ref;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;用的value的情况，如&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line">	else if (hasValueAttribute) &#123;</span><br><span class="line">		TypedStringValue valueHolder &#x3D; new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));</span><br><span class="line">		valueHolder.setSource(extractSource(ele));</span><br><span class="line">		return valueHolder;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;子标签不为null的情况，比如</span><br><span class="line">	&#x2F;&#x2F;&lt;property name&#x3D;&quot;Nnnn&quot;&gt;</span><br><span class="line">	&#x2F;&#x2F;	&lt;value&gt;helloworld&lt;&#x2F;value&gt;</span><br><span class="line">	&#x2F;&#x2F;&lt;&#x2F;property&gt;</span><br><span class="line">	else if (subElement !&#x3D; null) &#123;</span><br><span class="line">		return parsePropertySubElement(subElement, bd);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F; Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.</span><br><span class="line">		&#x2F;&#x2F;没指定ref或者value或者子标签，返回null</span><br><span class="line">		error(elementName + &quot; must specify a ref or value&quot;, ele);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse a value, ref or collection sub-element of a property or</span><br><span class="line"> * constructor-arg element.</span><br><span class="line"> * 解析property或者constructor-arg标签的子标签，可能为value, ref或者集合</span><br><span class="line"> * @param ele subelement of property element; we don&#39;t know which yet</span><br><span class="line"> * @param bd the current bean definition (if any)</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd) &#123;</span><br><span class="line">	return parsePropertySubElement(ele, bd, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Parse a value, ref or collection sub-element of a property or</span><br><span class="line"> * constructor-arg element.</span><br><span class="line"> * 解析property或者constructor-arg标签的子标签，可能为value, ref或者集合</span><br><span class="line"> * @param ele subelement of property element; we don&#39;t know which yet</span><br><span class="line"> * @param bd the current bean definition (if any)</span><br><span class="line"> * @param defaultValueType the default type (class name) for any</span><br><span class="line"> * &#123;@code &lt;value&gt;&#125; tag that might be created</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Nullable</span><br><span class="line">public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) &#123;</span><br><span class="line">	if (!isDefaultNamespace(ele)) &#123;&#x2F;&#x2F;如果这个子标签不属于beans的名称空间，则走这个方法</span><br><span class="line">		return parseNestedCustomElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是bean子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		BeanDefinitionHolder nestedBd &#x3D; parseBeanDefinitionElement(ele, bd);</span><br><span class="line">		if (nestedBd !&#x3D; null) &#123;</span><br><span class="line">			nestedBd &#x3D; decorateBeanDefinitionIfRequired(ele, nestedBd, bd);</span><br><span class="line">		&#125;</span><br><span class="line">		return nestedBd;</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是ref子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, REF_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F; A generic reference to any name of any bean.</span><br><span class="line">		String refName &#x3D; ele.getAttribute(BEAN_REF_ATTRIBUTE);</span><br><span class="line">		boolean toParent &#x3D; false;</span><br><span class="line">		if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">			&#x2F;&#x2F; A reference to the id of another bean in a parent context.</span><br><span class="line">			refName &#x3D; ele.getAttribute(PARENT_REF_ATTRIBUTE);</span><br><span class="line">			toParent &#x3D; true;</span><br><span class="line">			if (!StringUtils.hasLength(refName)) &#123;</span><br><span class="line">				error(&quot;&#39;bean&#39; or &#39;parent&#39; is required for &lt;ref&gt; element&quot;, ele);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!StringUtils.hasText(refName)) &#123;</span><br><span class="line">			error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		RuntimeBeanReference ref &#x3D; new RuntimeBeanReference(refName, toParent);</span><br><span class="line">		ref.setSource(extractSource(ele));</span><br><span class="line">		return ref;</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是idref子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, IDREF_ELEMENT)) &#123;</span><br><span class="line">		return parseIdRefElement(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是value子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, VALUE_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F;以这个方法作为演示，其他的方法都是大同小异，进入。</span><br><span class="line">		return parseValueElement(ele, defaultValueType);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是null子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, NULL_ELEMENT)) &#123;</span><br><span class="line">		&#x2F;&#x2F; It&#39;s a distinguished null value. Let&#39;s wrap it in a TypedStringValue</span><br><span class="line">		&#x2F;&#x2F; object in order to preserve the source location.</span><br><span class="line">		TypedStringValue nullHolder &#x3D; new TypedStringValue(null);</span><br><span class="line">		nullHolder.setSource(extractSource(ele));</span><br><span class="line">		return nullHolder;</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是array子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, ARRAY_ELEMENT)) &#123;</span><br><span class="line">		return parseArrayElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是list子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, LIST_ELEMENT)) &#123;</span><br><span class="line">		return parseListElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是set子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, SET_ELEMENT)) &#123;</span><br><span class="line">		return parseSetElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是map子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, MAP_ELEMENT)) &#123;</span><br><span class="line">		return parseMapElement(ele, bd);</span><br><span class="line">	&#125;&#x2F;&#x2F;如果是props子标签，则走这个方法</span><br><span class="line">	else if (nodeNameEquals(ele, PROPS_ELEMENT)) &#123;</span><br><span class="line">		return parsePropsElement(ele);</span><br><span class="line">	&#125;&#x2F;&#x2F;否则返回null，报错</span><br><span class="line">	else &#123;</span><br><span class="line">		error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Return a typed String value Object for the given value element.</span><br><span class="line"> * 通过指定的value标签，返回指定的字符串value对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Object parseValueElement(Element ele, @Nullable String defaultTypeName) &#123;</span><br><span class="line">	&#x2F;&#x2F; It&#39;s a literal value.</span><br><span class="line">	&#x2F;&#x2F;拿到value中的文本，包括回车、tab制表符、空格</span><br><span class="line">	String value &#x3D; DomUtils.getTextValue(ele);</span><br><span class="line">	&#x2F;&#x2F;有无type属性</span><br><span class="line">	String specifiedTypeName &#x3D; ele.getAttribute(TYPE_ATTRIBUTE);</span><br><span class="line">	String typeName &#x3D; specifiedTypeName;</span><br><span class="line">	if (!StringUtils.hasText(typeName)) &#123;</span><br><span class="line">		&#x2F;&#x2F;没有就用入参defaultTypeName，其实这里defaultTypeName也是null</span><br><span class="line">		typeName &#x3D; defaultTypeName;</span><br><span class="line">	&#125;</span><br><span class="line">	try &#123;</span><br><span class="line">		&#x2F;&#x2F;构建一个value的封装类。</span><br><span class="line">		TypedStringValue typedValue &#x3D; buildTypedStringValue(value, typeName);</span><br><span class="line">		&#x2F;&#x2F;这里设置为空</span><br><span class="line">		typedValue.setSource(extractSource(ele));</span><br><span class="line">		&#x2F;&#x2F;这里为空字符串</span><br><span class="line">		typedValue.setSpecifiedTypeName(specifiedTypeName);</span><br><span class="line">		&#x2F;&#x2F;返回typedValue</span><br><span class="line">		return typedValue;</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClassNotFoundException ex) &#123;</span><br><span class="line">		error(&quot;Type class [&quot; + typeName + &quot;] not found for &lt;value&gt; element&quot;, ele, ex);</span><br><span class="line">		return value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-12-注册BeanDefinition到工厂中"><a href="#3-12-注册BeanDefinition到工厂中" class="headerlink" title="3.12 注册BeanDefinition到工厂中"></a>3.12 注册BeanDefinition到工厂中</h2><p>好，回到processBeanDefinition方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Process the given bean element, parsing the bean definition</span><br><span class="line"> * and registering it with the registry.</span><br><span class="line"> * 处理bean元素，解析成bean definition并注册到工厂中</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">	&#x2F;&#x2F;使用delegate的内容（默认配置）来解析bean元素，核心方法</span><br><span class="line">	BeanDefinitionHolder bdHolder &#x3D; delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	if (bdHolder !&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F;如果有要求的话渲染beanDefinition，不是很重要</span><br><span class="line">		bdHolder &#x3D; delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Register the final decorated instance.</span><br><span class="line">			&#x2F;&#x2F;注册最终被渲染的实例到工厂中</span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +</span><br><span class="line">					bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; Send registration event.</span><br><span class="line">		&#x2F;&#x2F; 发送注册事件</span><br><span class="line">		&#x2F;&#x2F; 这里是空实现</span><br><span class="line">		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);这一句我们已经在3.11章节中详细介绍了，接下来我们视角继续往下，看下BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Register the given bean definition with the given bean factory.</span><br><span class="line"> * @param definitionHolder the bean definition including name and aliases</span><br><span class="line"> * @param registry the bean factory to register with</span><br><span class="line"> * @throws BeanDefinitionStoreException if registration failed</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void registerBeanDefinition(</span><br><span class="line">		BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Register bean definition under primary name.</span><br><span class="line">	&#x2F;&#x2F; 注册beanDefinition的beanName</span><br><span class="line">	&#x2F;&#x2F; 比如tk.mybatis.spring.mapper.MapperScannerConfigurer#0</span><br><span class="line">	String beanName &#x3D; definitionHolder.getBeanName();</span><br><span class="line">	&#x2F;&#x2F; 核心方法，比较重要，待会儿详解</span><br><span class="line">	registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Register aliases for bean name, if any.</span><br><span class="line">	&#x2F;&#x2F; 如果有别名的话，为bean name注册别名</span><br><span class="line">	String[] aliases &#x3D; definitionHolder.getAliases();</span><br><span class="line">	if (aliases !&#x3D; null) &#123;</span><br><span class="line">		for (String alias : aliases) &#123;</span><br><span class="line">			registry.registerAlias(beanName, alias);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主流程由此进入了registry.registerBeanDefinition中，其中registry实例是DefaultListableBeanFactory的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">		throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">	Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);</span><br><span class="line">	Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);</span><br><span class="line"></span><br><span class="line">	if (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F;做一个验证，静态工厂方法和覆盖方法不能组合使用</span><br><span class="line">			&#x2F;&#x2F;如果bean definition中的beanClass属性不是String类型而是Class类型</span><br><span class="line">			&#x2F;&#x2F;那么就要验证和准备这个bean定义的覆盖方法，检查指定名称的方法是否存在</span><br><span class="line">			((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Validation of bean definition failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;查看beanName是否已经被注册在工厂的beanDefinitionMap属性中</span><br><span class="line">	BeanDefinition existingDefinition &#x3D; this.beanDefinitionMap.get(beanName);</span><br><span class="line">	&#x2F;&#x2F;已经被注册的情况走这个方法，覆盖或者抛异常</span><br><span class="line">	if (existingDefinition !&#x3D; null) &#123;</span><br><span class="line">		if (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">			throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">					&quot;Cannot register bean definition [&quot; + beanDefinition + &quot;] for bean &#39;&quot; + beanName +</span><br><span class="line">					&quot;&#39;: There is already [&quot; + existingDefinition + &quot;] bound.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">			&#x2F;&#x2F; e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span><br><span class="line">			if (logger.isWarnEnabled()) &#123;</span><br><span class="line">				logger.warn(&quot;Overriding user-defined bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">						&quot;&#39; with a framework-generated bean definition: replacing [&quot; +</span><br><span class="line">						existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">			if (logger.isInfoEnabled()) &#123;</span><br><span class="line">				logger.info(&quot;Overriding bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">						&quot;&#39; with a different definition: replacing [&quot; + existingDefinition +</span><br><span class="line">						&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + beanName +</span><br><span class="line">						&quot;&#39; with an equivalent definition: replacing [&quot; + existingDefinition +</span><br><span class="line">						&quot;] with [&quot; + beanDefinition + &quot;]&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;这场景表示beanName还没有被注册</span><br><span class="line">		&#x2F;&#x2F;然后根据阶段不同又有一层判断</span><br><span class="line">		if (hasBeanCreationStarted()) &#123;</span><br><span class="line">			&#x2F;&#x2F; Cannot modify startup-time collection elements anymore (for stable iteration)</span><br><span class="line">			&#x2F;&#x2F;这个阶段是bean已经开始创建，启动阶段不会进入这里</span><br><span class="line">			&#x2F;&#x2F;如果在非启动阶段注册beanDefinition，那么要加锁后才能操作beanDefinitionMap、beanDefinitionNames</span><br><span class="line">			&#x2F;&#x2F;和manualSingletonNames</span><br><span class="line">			synchronized (this.beanDefinitionMap) &#123;</span><br><span class="line">				this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">				List&lt;String&gt; updatedDefinitions &#x3D; new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);</span><br><span class="line">				updatedDefinitions.addAll(this.beanDefinitionNames);</span><br><span class="line">				updatedDefinitions.add(beanName);</span><br><span class="line">				this.beanDefinitionNames &#x3D; updatedDefinitions;</span><br><span class="line">				if (this.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">					Set&lt;String&gt; updatedSingletons &#x3D; new LinkedHashSet&lt;&gt;(this.manualSingletonNames);</span><br><span class="line">					updatedSingletons.remove(beanName);</span><br><span class="line">					this.manualSingletonNames &#x3D; updatedSingletons;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F; 仍然处于启动时的注册阶段</span><br><span class="line">			&#x2F;&#x2F; 所以这里走这个方法</span><br><span class="line">			&#x2F;&#x2F; beanDefinitionMap是工厂的一个属性，ConcurrentHashMap类型</span><br><span class="line">			&#x2F;&#x2F;他保存所有解析好的bean Definition的名称和实例的映射</span><br><span class="line">			&#x2F;&#x2F; Still in startup registration phase</span><br><span class="line">			this.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">			&#x2F;&#x2F;beanName也单独使用了一个ArrayList来保存，方便遍历</span><br><span class="line">			this.beanDefinitionNames.add(beanName);</span><br><span class="line">			&#x2F;&#x2F;如果该beanDefinition是手动注册的，还要从manualSingletonNames中移除beanDefinition的beanName</span><br><span class="line">			&#x2F;&#x2F;manualSingletonNames是LinkedHashSet</span><br><span class="line">			this.manualSingletonNames.remove(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		this.frozenBeanDefinitionNames &#x3D; null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (existingDefinition !&#x3D; null || containsSingleton(beanName)) &#123;</span><br><span class="line">		resetBeanDefinition(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (isConfigurationFrozen()) &#123;</span><br><span class="line">		clearByTypeCache();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看别名的注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void registerAlias(String name, String alias) &#123;</span><br><span class="line">	Assert.hasText(name, &quot;&#39;name&#39; must not be empty&quot;);</span><br><span class="line">	Assert.hasText(alias, &quot;&#39;alias&#39; must not be empty&quot;);</span><br><span class="line">	synchronized (this.aliasMap) &#123;</span><br><span class="line">		if (alias.equals(name)) &#123;</span><br><span class="line">			&#x2F;&#x2F;移除别名中的beanName</span><br><span class="line">			&#x2F;&#x2F;aliasMap是ConcurrentHashMap类型，保存别名和beanName的映射</span><br><span class="line">			this.aliasMap.remove(alias);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Alias definition &#39;&quot; + alias + &quot;&#39; ignored since it points to same name&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			String registeredName &#x3D; this.aliasMap.get(alias);</span><br><span class="line">			&#x2F;&#x2F;如果别名对应beanName已经被注册，则不需要再注册一次</span><br><span class="line">			&#x2F;&#x2F;别名不允许被覆盖</span><br><span class="line">			if (registeredName !&#x3D; null) &#123;</span><br><span class="line">				if (registeredName.equals(name)) &#123;</span><br><span class="line">					&#x2F;&#x2F; An existing alias - no need to re-register</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				if (!allowAliasOverriding()) &#123;</span><br><span class="line">					throw new IllegalStateException(&quot;Cannot define alias &#39;&quot; + alias + &quot;&#39; for name &#39;&quot; +</span><br><span class="line">							name + &quot;&#39;: It is already registered for name &#39;&quot; + registeredName + &quot;&#39;.&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				if (logger.isInfoEnabled()) &#123;</span><br><span class="line">					logger.info(&quot;Overriding alias &#39;&quot; + alias + &quot;&#39; definition for registered name &#39;&quot; +</span><br><span class="line">							registeredName + &quot;&#39; with new target name &#39;&quot; + name + &quot;&#39;&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;再检查一遍，aliasMap中不能已经存在name和alias</span><br><span class="line">			checkForAliasCircle(name, alias);</span><br><span class="line">			&#x2F;&#x2F;工厂的aliasMap属性保存别名，那么alias已被注册</span><br><span class="line">			this.aliasMap.put(alias, name);</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Alias definition &#39;&quot; + alias + &quot;&#39; registered for name &#39;&quot; + name + &quot;&#39;&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-13-加载xml文件beanDefinition流程图"><a href="#3-13-加载xml文件beanDefinition流程图" class="headerlink" title="3.13 加载xml文件beanDefinition流程图"></a>3.13 加载xml文件beanDefinition流程图</h2><p><img src="https://oscimg.oschina.net/oscnet/up-0a652bfc13671b2b64650cd88b8b2aec238.png" alt=""></p>
<h1 id="4-加载注解配置的beanDefinition"><a href="#4-加载注解配置的beanDefinition" class="headerlink" title="4 加载注解配置的beanDefinition"></a>4 加载注解配置的beanDefinition</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/" itemprop="url">Spring Resource资源文件体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-29T22:58:12+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/06/29/Spring-Resource资源文件体系/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Resource接口"><a href="#1-Resource接口" class="headerlink" title="1. Resource接口"></a>1. Resource接口</h1><p>Spring对于资源加载有着一套自己的框架——Resource，Resource继承自InputStream。<br>下面的是Resource的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public interface Resource extends InputStreamSource &#123;</span><br><span class="line">    boolean exists();&#x2F;&#x2F;判断资源是否存在</span><br><span class="line">    default boolean isReadable() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断资源是否打开</span><br><span class="line">    default boolean isOpen() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;判断资源是否是一个文件</span><br><span class="line">    default boolean isFile() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取资源文件的URL</span><br><span class="line">    URL getURL() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;获取资源文件的URI</span><br><span class="line">    URI getURI() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;获取资源文件的File对象</span><br><span class="line">    File getFile() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;这个方法接口中有默认实现，返回的是ReadableByteChannel，这个类属于Java的NIO中的管道。</span><br><span class="line">    default ReadableByteChannel readableChannel() throws IOException &#123;</span><br><span class="line">        return Channels.newChannel(getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;获取内容的长度，这个方法返回一个long，因为文件内容可能很长。</span><br><span class="line">    long contentLength() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;这个方法返回的是最后修改时间，虽然也返回的是long，但是这个数字是一个时间戳。</span><br><span class="line">    long lastModified() throws IOException;</span><br><span class="line">    &#x2F;&#x2F;这个方法根据relativePath相对路径返回一个相对与该Resource的Resource。</span><br><span class="line">    Resource createRelative(String relativePath) throws IOException;</span><br><span class="line">    @Nullable</span><br><span class="line">    &#x2F;&#x2F;获取文件的名字。</span><br><span class="line">    String getFilename();</span><br><span class="line">    &#x2F;&#x2F;获取一个对该资源的一个描述。</span><br><span class="line">    String getDescription();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-Resource实现类"><a href="#2-Resource实现类" class="headerlink" title="2. Resource实现类"></a>2. Resource实现类</h1><p>你可以理解为，Resource就是一个增强版的InputStreamSource，Resource 接口是Spring资源访问策略的抽象，它本身并不提供任何资源访问实现，具体的资源访问由该接口的实现类完成——每个实现类代表一种资源访问策略（策略模式）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-14643860b1762106730a60406986062587a.png" alt=""></p>
<ul>
<li>UrlResource:<ul>
<li>UrlResource封装了java.net.URL，可用于访问通常可通过url访问的任何对象，如文件、HTTP目标、FTP目标和其他对象。所有URL可以使用一个标准化前缀来表示一个URL类型。例如： file：用于访问文件系统路径。 http：用于通过HTTP协议访问资源。 ftp：用于通过FTP访问资源。</li>
</ul>
</li>
<li>ClassPathResource:<ul>
<li>表示从类路径加载资源。如果资源路径带上前缀ClassPath:，那么会隐式的解析为ClassPathResource。注意，如果类资源文件是在文件系统中，则该资源实现会被解析为java.io.File， 如果是在Jar包中，则会使用java.net.URL来解析。</li>
</ul>
</li>
<li>FileSystemResource:<ul>
<li>他是java.io.File和java.nio.file.Path的Resource实现，支持解析为File或者URL。如D:/aaa/vvv.java</li>
</ul>
</li>
<li>ServletContextResource:<ul>
<li>这是ServletContext的Resource实现，用于解释相关Web应用程序根目录中的相对路径。访问Web容器上下文中的资源而设计的类，负责对于Web应用根目录的路径加载资源。它支持以流和URL的方式访问，在WAR解包的情况下，也可以通过File方式访问。该类还可以直接从JAR包中访问资源。</li>
</ul>
</li>
<li>InputStreamResource:<ul>
<li>InputStreamResource 是InputStream 的Resource实现。只有在其他Resource实现不可用的时候才考虑使用它。和其他的Resource实现相反，它是一个already-opened resource的描述器，所以isOpen()会返回true。 如果你想保存资源描述器或者多次读取一个stream， 那么不要使用它。</li>
</ul>
</li>
<li>ByteArrayResource:<ul>
<li>是byte array的Resource实现， 它创建了ByteArrayInputStream。它对于从任何给定的字节数组加载内容都很有用，而不必求助于单次使用的InputStreamResource。</li>
</ul>
</li>
<li>PathResource:<ul>
<li>Spring4.0提供的读取资源文件的新类。Path封装了java.net.URL、java.nio.Path、文件系统资源，它使用户能够访问任何可以通过URL、Path、系统文件路径表示的资源，如文件系统的资源，HTTP资源、FTP资源等。</li>
</ul>
</li>
</ul>
<h1 id="3-使用示例"><a href="#3-使用示例" class="headerlink" title="3. 使用示例"></a>3. 使用示例</h1><p>使用示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testResource() throws IOException &#123;</span><br><span class="line">    String filePath &#x3D; &quot;E:\\源码\\Spring源码阅读\\testSpring\\src\\test\\resources\\spring.txt&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 1. 使用系统的文件路径方式加载文件</span><br><span class="line">    WritableResource resource1 &#x3D; new PathResource(filePath);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 2. 使用类路径方式加载文件</span><br><span class="line">    Resource resource2 &#x3D; new ClassPathResource(&quot;spring.txt&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 3. 使用WritableResource接口写资源文件</span><br><span class="line">    OutputStream os &#x3D; resource1.getOutputStream();</span><br><span class="line">    os.write(&quot;Spring是一套非常优秀的框架&quot;.getBytes());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 4. 使用Resource接口读文件</span><br><span class="line">    InputStream in1 &#x3D; resource1.getInputStream();</span><br><span class="line">    InputStream in2 &#x3D; resource1.getInputStream();</span><br><span class="line">    BufferedInputStream bis &#x3D; new BufferedInputStream(in1);</span><br><span class="line">    byte[] bytes &#x3D; new byte[1024];</span><br><span class="line">    bis.read(bytes);</span><br><span class="line">    System.out.println(new String(bytes));</span><br><span class="line">    System.out.println(&quot;resource1: &quot; + resource1.getFilename());</span><br><span class="line">    System.out.println(&quot;resource2: &quot; + resource2.getFilename());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-资源路径通配符。"><a href="#4-资源路径通配符。" class="headerlink" title="4. 资源路径通配符。"></a>4. 资源路径通配符。</h1><p>Resource解析各种资源路径，依靠资源路径通配符可以带来很多方便。</p>
<h2 id="4-1-Ant-style-Patterns"><a href="#4-1-Ant-style-Patterns" class="headerlink" title="4.1 Ant-style Patterns"></a>4.1 Ant-style Patterns</h2><p>定义资源路径可以是用Ant风格的通配符，下面是 Ant-style patterns 的路径例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;WEB-INF&#x2F;*-context.xml</span><br><span class="line">com&#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml</span><br><span class="line">file:C:&#x2F;some&#x2F;path&#x2F;*-cont?xt.xml</span><br><span class="line">classpath:com&#x2F;mycompany&#x2F;**&#x2F;applicationContext.xml</span><br></pre></td></tr></table></figure>

<p>Ant风格的资源地址支持三种通配符：</p>
<ul>
<li>?:匹配文件名中的一个字符</li>
<li>*：匹配文件名中的多个字符</li>
<li>**:匹配多层路径。</li>
</ul>
<h2 id="4-2-classpath-前缀"><a href="#4-2-classpath-前缀" class="headerlink" title="4.2 classpath*:前缀"></a>4.2 classpath*:前缀</h2><p>构造基于XML的ApplicationContext，路径地址可以使用classpath*: 前缀，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx &#x3D;</span><br><span class="line">    new ClassPathXmlApplicationContext(&quot;classpath*:conf&#x2F;appContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>classpath* 和 classpath 的区别是：classpath* 会去查找所有匹配的classpath， 而classpath 只会找到第一个匹配的资源。</p>
</blockquote>
<h1 id="5-ResourceLoader"><a href="#5-ResourceLoader" class="headerlink" title="5. ResourceLoader"></a>5. ResourceLoader</h1><p>不过有个问题随之而来，那就是Resource的选择，这么多的Resource如何知道选择使用哪一个？Spring提供了一个强大的资源加载机制，他可以通过前缀标识加载资源，如：classpath:, file:,ftp:等，同时还支持使用Ant风格的通配符。</p>
<p>ResourceLoader用来返回Resource实例，下面是其定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ResourceLoader &#123;</span><br><span class="line">    Resource getResource(String location);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>前缀</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>classpath:</td>
<td>classpath:com/myapp/config.xml</td>
<td>使用ClassPathResource从classpath中加载。</td>
</tr>
<tr>
<td>file:</td>
<td>file:/data/config.xml</td>
<td>作为 URL 加载。使用UrlResource从文件系统目录中装载资源</td>
</tr>
<tr>
<td>http:</td>
<td><a href="http://myserver/logo.png" target="_blank" rel="noopener">http://myserver/logo.png</a></td>
<td>作为 URL 加载。使用UrlResource从Web服务器中装载资源</td>
</tr>
<tr>
<td>ftp:</td>
<td><a href="ftp://www.mcwebsite.top/bean.xml">ftp://www.mcwebsite.top/bean.xml</a></td>
<td>作为 URL 加载。使用UrlResource从ftp服务器中装载资源</td>
</tr>
<tr>
<td>(none)</td>
<td>/data/config.xml</td>
<td>根据ApplicationContext的具体实现选择对应类型的Resource</td>
</tr>
</tbody></table>
<p>上表中最后一种情况，需要说明下：</p>
<p>所有的<strong>ApplicationContext</strong>都实现了ResourceLoader类。因此所有的ApplicationContext都可以用来获取Resource。</p>
<p>当在特定的应用程序上下文上调用getResource（），并且指定的位置路径没有特定的前缀时，将返回适合该特定应用程序上下文的资源类型。</p>
<p>例如，假设对ClassPathXmlApplicationContext实例执行了以下代码片段：</p>
<p><code>Resource template = ctx.getResource(&quot;some/resource/path/myTemplate.txt&quot;);</code></p>
<p>在ClassPathXmlApplicationContext中，这个方法返回ClassPathResource。</p>
<p>以此类推，在FileSystemXmlApplicationContext中，方法返回FileSystemResource。在WebApplicationContext， 方法返回ServletContextResource。</p>
<p>当然，就像我们表中说的，我们可以强制使用ClassPathResource，而不管ApplicationContext到底是什么。这样做的话，我们需要添加classpath:前缀。如下：</p>
<p><code>Resource template = ctx.getResource(&quot;classpath:some/resource/path/myTemplate.txt&quot;);</code></p>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath*:applicationContext.xmlclasspath*:applicationContext-shiro.xml</span><br><span class="line">        &lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>

<p>同样的，你可以强制使用UrlResource通过添加标准的java.net.URL前缀(context-param配置的话同理):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Resource template &#x3D; ctx.getResource(&quot;file:&#x2F;&#x2F;&#x2F;some&#x2F;resource&#x2F;path&#x2F;myTemplate.txt&quot;);</span><br><span class="line"></span><br><span class="line">Resource template &#x3D; ctx.getResource(&quot;https:&#x2F;&#x2F;myhost.com&#x2F;resource&#x2F;path&#x2F;myTemplate.txt&quot;);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/" itemprop="url">Spring IoC概念分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T22:55:51+08:00">
                2020-05-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index">
                    <span itemprop="name">框架</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/25/Spring-IoC概念分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  13k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  50
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-IoC概念简介"><a href="#1-IoC概念简介" class="headerlink" title="1. IoC概念简介"></a>1. IoC概念简介</h1><p>IoC是随着近年来轻量级容器（Lightweight Container)的兴起而逐渐被很多人提起的一个名词，它的全称为Inversion of Control，中文通常翻译为“控制反转”。好莱坞原则“Don’t call us, we will call you.”恰如其分地表达了“反转”的意味，是用来形容IoC最多的一句话。</p>
<p>它不是什么技术，而是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</p>
<ul>
<li>正控：若要使用某个对象，需要自己去负责对象的创建</li>
<li>反控：若要使用某个对象，只需要从Spring容器中获取需要使用的对象，不关心对象的创建过程，也就是把创建对象的控制权反转给了Spring框架</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-38d5b7469789631b0fa0fbc1e04e2dfb312.png" alt=""></p>
<h1 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2. 依赖注入"></a>2. 依赖注入</h1><p>依赖注入（Dependency Injection，简称DI），2004年，Martin Fowler探讨了一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“<strong>获得依赖对象的过程被反转了</strong>”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IoC容器主动注入。</p>
<p>于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IoC的方法：<strong>注入</strong>——所谓依赖注入，就是由IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p>
<p>所以，依赖注入(DI)和控制反转(IoC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p>
<p><strong>或者说，IoC是一种思想，是一种目标，而DI这时一种手段，一种过程</strong>。</p>
<h2 id="2-1-理论上的依赖注入方式"><a href="#2-1-理论上的依赖注入方式" class="headerlink" title="2.1 理论上的依赖注入方式"></a>2.1 理论上的依赖注入方式</h2><p>在学术理论上，依赖注入有三种实现方式：</p>
<h3 id="2-1-1-三种注入的方式"><a href="#2-1-1-三种注入的方式" class="headerlink" title="2.1.1 三种注入的方式"></a>2.1.1 三种注入的方式</h3><p>当你来到酒吧，想要喝杯啤酒的时候，通常会直接招呼服务生，让他为你送来一杯清凉的啤酒。同样地，作为被注入对象，要想让IoC容器为其提供服务，并将所需要的被依赖对象送过来，也需要通过某种方式通知对方。</p>
<p>这里就牵涉到了三种依赖注入的方式：</p>
<ol>
<li><strong>构造方法注入</strong><ul>
<li>顾名思义，构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表，让外部（通常是IoC容器）知道它需要哪些依赖对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public FXNewsProvider(IFXNewsListener newsListner,IFXNewsPersister newsPersister) &#123;</span><br><span class="line">	this.newsListener &#x3D; newsListner;</span><br><span class="line">	this.newPersistener &#x3D; newsPersister;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>IoC Service Provider会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。同一个对象是不可能被构造两次的，因此，被注入对象的构造乃至其整个生命周期，应该是由IoC Service Provider来管理的。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</li>
<li><blockquote>
<p>这就好比你刚进酒吧的门，服务生已经将你喜欢的啤酒摆上了桌面一样。坐下就可马上享受一份清凉与惬意。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>setter 方法注入</strong><ul>
<li>对于JavaBean对象来说，通常会通过setXXX()和getXXX()方法来访问对应属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FXNewsProvider&#123;</span><br><span class="line">	private IFXNewsListener newsListener;</span><br><span class="line"></span><br><span class="line">	public IFXNewsListener getNewsListener() &#123;</span><br><span class="line">	return newsListener;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setNewsListener(IFXNewsListener newsListener) &#123;</span><br><span class="line">	this.newsListener &#x3D; newsListener;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样，外界就可以通过调用setNewsListener方法为FXNewsProvider对象注入所依赖的对象了。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再注入。</li>
<li><blockquote>
<p>这就好比你可以到酒吧坐下后再决定要点什么啤酒，可以要百威，也可以要青岛，随意性比较强。如果你不急着喝，这种方式当然是最适合你的。</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>接口注入</strong><ul>
<li><strong>首先注意，因为代码侵入性高，所以这种方式Spring框架不支持，只要了解即可。</strong></li>
<li>相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service  Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。</li>
<li>FXNewsProvider为了让IoC Service Provider为其注入所依赖的IFXNewsListener，首先需要实现IFXNewsListenerCallable接口，这个接口会声明一个injectNewsListner方法（方法名随意），该方法的参数，就是所依赖对象的类型。这样，InjectionServiceContainer对象，即对应的IoC Service Provider就可以通过这个接口方法将依赖对象注入到被注入对象FXNewsProvider当中。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-cbadc8320845789e72095140547d4c456b4.png" alt=""></li>
<li>接口注入方式最早并且使用最多的是在一个叫做Avalon的项目中，相对于前两种依赖注入方式，接口注入比较死板和烦琐。如果需要注入依赖对象，被注入对象就必须声明和实现另外的接口。</li>
<li><blockquote>
<p>这就好像你同样在酒吧点啤酒，为了让服务生理解你的意思，你就必须戴上一顶啤酒杯式的帽子<img src="https://oscimg.oschina.net/oscnet/up-020c50b28bcf338955887894a8dccdd5b1e.png" alt=""></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-三种注入方式的比较"><a href="#2-1-2-三种注入方式的比较" class="headerlink" title="2.1.2 三种注入方式的比较"></a>2.1.2 三种注入方式的比较</h3><ol>
<li>接口注入：<ul>
<li>从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter方法注入则不需要如此。</li>
</ul>
</li>
<li>构造方法注入：<ul>
<li>这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以马上使用。</li>
<li>缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。</li>
</ul>
</li>
<li>setter方法注入：<ul>
<li>因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。另外，setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。</li>
<li>缺点当然就是对象无法在构造完成后马上进入就绪状态。</li>
</ul>
</li>
</ol>
<p>综上所述，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式；而接口注入因为侵入性较强，近年来已经不流行了。</p>
<h2 id="2-2-Spring的依赖注入方式"><a href="#2-2-Spring的依赖注入方式" class="headerlink" title="2.2 Spring的依赖注入方式"></a>2.2 Spring的依赖注入方式</h2><p>因为代码侵入性高的问题，接口注入的方式，spring框架并不支持。Spring的依赖注入方式只有构造方法注入和setter方法注入：</p>
<ol>
<li>构造方法<ul>
<li>开箱即用，适合用于注入实例必须的初始值时使用，但是当参数列表较长时难以维护和使用。构造方法无法被继承，也无法设置默认值。适合较固定的对象使用。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"login"</span> <span class="attr">class</span>=<span class="string">"com.spring.test.di.LoginImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.spring.test.di.LoginAction"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructorarg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">ref</span>=<span class="string">"login"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor­arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>setter方法<ul>
<li>适合依赖对象多，且组成对象灵活多变的场景，是目前最为常见的注入方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;login&quot; class&#x3D;&quot;com.spring.test.di.LoginImpl&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;loginAction&quot; class&#x3D;&quot;com.spring.test.di.LoginAction&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;login&quot; ref&#x3D;&quot;login&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h1 id="3-IoC-Service-Provider"><a href="#3-IoC-Service-Provider" class="headerlink" title="3. IoC Service Provider"></a>3. IoC Service Provider</h1><p>了解了IoC和DI的概念中，我们可以知道，在DI的过程中，IoC Service Provider是一个非常重要的概念——业务对象可以通过IoC方式声明相应的依赖，但是最终仍然需要通过某种角色或者服务将这些相互依赖的对象绑定到一起，IoC Service Provider就是这样一个角色。</p>
<p>IoC Service Provider在这里是一个抽象出来的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。它可以是一段代码，也可以是一组相关的类，甚至可以是比较通用的IoC框架或者IoC容器实现。Spring的IoC容器就是一个提供依赖注入服务的IoC Service Provider。</p>
<h2 id="3-1-IoC-Service-Provider的职责"><a href="#3-1-IoC-Service-Provider的职责" class="headerlink" title="3.1 IoC Service Provider的职责"></a>3.1 IoC Service Provider的职责</h2><p>IoC Service Provider的职责相对来说比较简单，主要有两个：</p>
<ol>
<li>业务对象的注册管理。<ul>
<li>在IoC场景中，业务对象无需关心所依赖的对象如何构建如何取得，但这部分工作始终需要有人来做。所以，IoC Service Provider需要识别这部分需要管理的对象，并且将这些对象的构建逻辑从客户端对象那里剥离出来，以免这部分逻辑污染业务对象的实现。</li>
</ul>
</li>
<li>业务对象间的依赖绑定。<ul>
<li>IoC Service Provider通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状态。</li>
</ul>
</li>
</ol>
<h2 id="3-2-常见IoC-Service-Provider依赖注册方式"><a href="#3-2-常见IoC-Service-Provider依赖注册方式" class="headerlink" title="3.2 常见IoC Service Provider依赖注册方式"></a>3.2 常见IoC Service Provider依赖注册方式</h2><p>那么，对于IoC Service Provider来说，如何知道哪些对象是被其他对象依赖（即需要它管理起来的）的呢？又是如何知道某个管理的对象，具体要注入到哪一个具体的其他对象中呢？就像一个资深的酒吧服务员，客人点了哪些酒，且每一杯酒分别是被哪个客人点的，他都要了然于心，这时如何做到的呢？</p>
<p>很显然，我们需要记录下来这些的“服务信息”(在Spring的术语中，把BeanFactory需要使用的对象注册和依赖绑定信息称为<strong>Configuration Metadata</strong>)，当前流行的IoC Service Provider产品使用的Configuration Metadata的方式主要有以下几种：</p>
<ol>
<li><strong>直接编码方式</strong><ul>
<li>当前大部分的IoC容器都应该支持直接编码方式，比如PicoContainer、Spring、Avalon等。在容器启动之前，我们就可以通过程序编码的方式将被注入对象和依赖对象注册到容器中，并明确它们相互之间的依赖注入关系。</li>
</ul>
</li>
<li><strong>配置文件方式</strong><ul>
<li>这是一种较为普遍的依赖注入关系管理方式。像普通文本文件、properties文件、XML文件等，都可以成为管理依赖注入关系的载体。不过，最为常见的，还是通过XML文件来管理对象注册和对象间依赖关系，比如Spring IoC容器和在PicoContainer基础上扩展的NanoContainer，都是采用XML文件来管理和保存依赖注入信息的。</li>
</ul>
</li>
<li><strong>元数据方式（注解）</strong><ul>
<li>这种方式的代表实现是Google Guice，这是Bob Lee在Java 5的注解和Generic的基础上开发的一套IoC框架。我们可以直接在类中使用元数据信息来标注各个对象之间的依赖关系，然后由Guice框架根据这些注解所提供的信息将这些对象组装后，交给客户端对象使用。</li>
</ul>
</li>
</ol>
<h2 id="3-3-Spring-IoC-Service-Provider依赖注册方式"><a href="#3-3-Spring-IoC-Service-Provider依赖注册方式" class="headerlink" title="3.3 Spring IoC Service Provider依赖注册方式"></a>3.3 Spring IoC Service Provider依赖注册方式</h2><p>Spring IoC Service Provider的注册依赖方式同样是三种，也就是说，其他IoC Service Provider支持的主流的三种依赖注册方式，Spring都支持。</p>
<ol>
<li><strong>直接编码方式</strong><ul>
<li>使用<code>@Configuration</code>注解可以将java的类文件声明成spring的配置类，使用<code>@Bean</code>来声明方法的返回对象要注册为spring的bean对象。</li>
<li>而当bean中需要注入其他参数或者引用时，将其作为方法的参数即可，Spring会帮你注入这些引用。</li>
<li>默认情况下，方法名即为id名，当然也可以为bean指定名称，通过其<code>@Bean</code>注解的name属性。</li>
<li>同时<code>@Bean</code>注解的initMethod属性和destroyMethod属性，可以指定初始化和销毁时的生命周期回调函数。</li>
<li>而<code>@Scope</code>和<code>@Description</code>注解，则可以给bean设置Scope和Description<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用@Configuration注解可以将java的类文件声明成spring的配置类</span><br><span class="line">@Configuration</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line"></span><br><span class="line">	@Bean &#x2F;&#x2F;你可以理解为定义一个String类型的bean，值是&quot;test&quot;，做依赖注入用。</span><br><span class="line">	public String username()&#123;</span><br><span class="line">		return &quot;test&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public List&lt;String&gt; tags()&#123;</span><br><span class="line">		List&lt;String&gt; tags &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">		tags.add(&quot;cool&quot;);</span><br><span class="line">		tags.add(&quot;nice&quot;);</span><br><span class="line">		return tags;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;使用@Bean 注解表明myBean需要交给Spring进行管理</span><br><span class="line">	&#x2F;&#x2F;如果未指定bean的id，默认采用的是 &quot;方法名&quot; + &quot;首字母小写&quot;的配置方式</span><br><span class="line">	&#x2F;&#x2F;name属性可以定义bean的id ; initMethod和destroyMethod属性指定初始化和销毁时的生命周期回调函数。</span><br><span class="line">	@Bean(name &#x3D; &quot;userInterfaceIml&quot; , initMethod &#x3D; &quot;init&quot; , destroyMethod &#x3D; &quot;cleanup&quot;)</span><br><span class="line">	@Scope(&quot;prototype&quot;) &#x2F;&#x2F;指定该bean的scope</span><br><span class="line">	@Description(&quot;Provides a basic example of a bean&quot;) &#x2F;&#x2F;指定该bean的description</span><br><span class="line">	public UserInterface userInterface()&#123;</span><br><span class="line">		return new UserInterfaceImpl();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	&#x2F;&#x2F;通过参数列表，将bean的依赖注入</span><br><span class="line">	public UserCall userCall(UserInterface userInterface, String username, List&lt;String&gt; tags)&#123;</span><br><span class="line">		UserCall uc &#x3D; new UserCall();</span><br><span class="line">		uc.setUi(userInterface);</span><br><span class="line">		uc.setUsername(username);</span><br><span class="line">		uc.setTags(tags);</span><br><span class="line">		return uc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>配置文件方式</strong><ul>
<li>Spring使用XML文件来管理和保存依赖注入信息，配置组件bean的话只需要使用<code>&lt;bean&gt;</code>标签即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userInterface&quot; class&#x3D;&quot;com.springbean.impl.UserInterfaceImpl&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用构造器注入。使用构造器注入的时候必须在类中存在对应的构造方法才能有效</span><br><span class="line">&lt;util:list id&#x3D;&quot;tagsList&quot;&gt;</span><br><span class="line">	&lt;value&gt;cool&lt;&#x2F;value&gt;</span><br><span class="line">	&lt;value&gt;nice&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;util:list&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;userCall&quot; class&#x3D;&quot;com.springbean.UserCall&quot;&gt;</span><br><span class="line">	&lt;constructor-arg name&#x3D;&quot;ui&quot; ref&#x3D;&quot;userInterface&quot;&#x2F;&gt;</span><br><span class="line">	&lt;constructor-arg name&#x3D;&quot;username&quot; value&#x3D;&quot;test&quot;&#x2F;&gt;</span><br><span class="line">	&lt;constructor-arg name&#x3D;&quot;tags&quot; ref&#x3D;&quot;tagsList&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用属性注入</span><br><span class="line">&lt;bean id&#x3D;&quot;userCall&quot; class&#x3D;&quot;com.springbean.UserCall&quot;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;ui&quot; ref&#x3D;&quot;userInterface&quot; &#x2F;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;test&quot; &#x2F;&gt;</span><br><span class="line">	&lt;property name&#x3D;&quot;tags&quot; value&#x3D;&quot;tagsList&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>元数据方式（注解）</strong><ul>
<li>spring支持通过注解方式管理依赖，但是需要指定spring扫描注解的包，指定扫描的包有两种方式<ol>
<li>可以在Spring的xml文件中配置（前提是引入了Spring context的命名空间），使用<code>&lt;context:component-scan base-package=&quot;com.springbean.*&quot;/&gt;</code></li>
<li>注解@ComponentScan指定了spring将扫描这个配置类所在的包及其子包下面的所有类。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan</span><br><span class="line">public class SpringConfig &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>有了组件扫描后，所有被注解@Component或者它衍生的注解标记类都将被识别为组件类，他们完善了spring通过注解来注册依赖的功能：<ul>
<li>@Component: 自动被comonent扫描。 表示被注解的类会自动被component扫描</li>
<li>@Repository: 用于持久层，主要是数据库存储库。</li>
<li>@Service: 表示被注解的类是位于业务层的业务component。</li>
<li>@Controller:表明被注解的类是控制component，主要用于展现层 。</li>
</ul>
</li>
<li>除此之外，spring使用注解<code>@Autowired</code>等完成依赖装配：<ul>
<li>@Autowired：支持按类型自动转配</li>
<li>@Qualifier：根据byName的方式自动装配，其中@Qualifier不能单独使用。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	@Autowired</span><br><span class="line">	@Qualifier(value&#x3D;&quot;carXXX&quot;)</span><br><span class="line">	private Cat cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>@Resource（这个注解属于J2EE的）：<strong>如果同时指定了name和type</strong>，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常;<strong>如果指定了name</strong>，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常;如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常;<strong>如果既没有指定name，又没有指定type</strong>，则自动按照byName方式(字段名)进行装配；<strong>如果没有匹配</strong>，则回退为一个原始类型进行匹配，如果匹配则自动装配；  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	@Resource</span><br><span class="line">	private Cat cat;</span><br><span class="line">	@Resource(name&#x3D;&quot;dogXXX&quot;)</span><br><span class="line">	private Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="4-Spring的IoC容器"><a href="#4-Spring的IoC容器" class="headerlink" title="4. Spring的IoC容器"></a>4. Spring的IoC容器</h1><p>上文中，我们从浅到深，从思想到概念，了解了DI过程中的一个重要的角色——IoC Service Provider。</p>
<p><strong>IoC Service Provider只是一个概念，不同的框架，对IoC Service Provider的具体的实现也是五花八门，接下来我们了解一个完成度高，重要性高且知名度极高的IoC Service Provider实现产品——Spring IoC容器</strong>。</p>
<p>Spring的IoC容器是一个IoC Service Provider，但不止是一个IoC Service Provider，作为轻量级容器，Spring的IoC容器还提供了IoC之外的支持。如在Spring的IoC容器之上，Spring还提供了相应的AOP框架支持、企业级服务集成等服务。Spring的IoC容器和IoC Service Provider所提供的服务之间存在一定的交集，二者的关系如图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-632d868bd3dc83060bd4dea30a7839f43c3.png" alt=""></p>
<h2 id="4-1-Spring-IoC容器类型"><a href="#4-1-Spring-IoC容器类型" class="headerlink" title="4.1 Spring IoC容器类型"></a>4.1 Spring IoC容器类型</h2><p>Spring提供了两种容器类型：BeanFactory和ApplicationContext。</p>
<ol>
<li><strong>BeanFactory</strong>。<ul>
<li>基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，<strong>默认采用延迟初始化策略（lazy-load）</strong>。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</li>
</ul>
</li>
<li><strong>ApplicationContext</strong>。<ul>
<li>ApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如<strong>事件发布</strong>、<strong>国际化信息支持</strong>等，这些会在后面详述。ApplicationContext所管理的对象，在该类型容器启动之后，<strong>默认全部初始化并绑定完成</strong>。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</li>
</ul>
</li>
</ol>
<blockquote>
<p>ApplicationContext包含BeanFactory的所有功能，<strong>几乎所有的应用系统都选择ApplicationContext而不是BeanFactory</strong>。只有在资源很少的情况下，才会考虑采用BeanFactory，如在移动设备上等。</p>
</blockquote>
<p>通过下图，我们可以对BeanFactory和ApplicationContext之间的关系有一个更清晰的认识：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dfda2270ce6b3b965c4c3f1ffd5420d98c6.png" alt=""></p>
<h3 id="4-1-1-BeanFactory"><a href="#4-1-1-BeanFactory" class="headerlink" title="4.1.1 BeanFactory"></a>4.1.1 BeanFactory</h3><blockquote>
<p>在没有特殊指明的情况下，以BeanFactory为中心所讲述的内容同样适用于ApplicationContext，这一点需要明确一下，二者有差别的地方会在合适的位置给出解释。</p>
</blockquote>
<p>BeanFactory，顾名思义，就是生产Bean的工厂。BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零件送入这个汽车生产厂，最后，只需要从生产线的终点取得成品汽车就可以了。至于业务对象如何组装，你不需要关心。</p>
<p>BeanFactory只是个interface，它核心实现，在DefaultListableBeanFactory实现类中。BeanFactory声明了如下的方法：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7bfb551900305838e32ce2559d6ad2b3c9d.png" alt=""></p>
<p>通过方法名我们也能大概了解每个方法的作用，基本上都是查询相关的方法，例如，取得某个对象的方法（getBean）、查询<br>某个对象是否存在于容器中的方法（containsBean），或者取得某个bean的状态或者类型的方法等。</p>
<p>这些api使得我们可以非常方便的从容器中获取特定类型的bean。那么，BeanFactory如何知道它需要管理和生成哪些bean呢？被托管的bean又是如何注册的呢？后文我们会就bean的注册/绑定/注入做深入介绍。</p>
<h3 id="4-1-2-ApplicationContext"><a href="#4-1-2-ApplicationContext" class="headerlink" title="4.1.2 ApplicationContext"></a>4.1.2 ApplicationContext</h3><p>作为Spring提供的较之BeanFactory更为先进的IoC容器实现，<strong>ApplicationContext是BeanFactory的子类，故而ApplicationContext拥有BeanFactory支持的所有功能</strong>，但除此之外，还进一步扩展了基本容器的功能，如：更易与Spring AOP集成，容器启动后bean实例的自动初始化、国际化的信息支持、容器内事件发布等；</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-def463323553c42f7902c8107e524f8cea7.png" alt=""></p>
<h2 id="4-2-spring-bean和bean定义"><a href="#4-2-spring-bean和bean定义" class="headerlink" title="4.2 spring bean和bean定义"></a>4.2 spring bean和bean定义</h2><p>java bean对我们来说十分熟悉，我们把符合下面四点的java对象叫做java bean。</p>
<ol>
<li>所有属性为private</li>
<li>提供默认构造方法</li>
<li>提供getter和setter</li>
<li>实现serializable接口</li>
</ol>
<h3 id="4-2-1-spring中的bean"><a href="#4-2-1-spring中的bean" class="headerlink" title="4.2.1 spring中的bean"></a>4.2.1 spring中的bean</h3><p>spring中的bean是基于java bean概念的延伸，但为了更好的实现bean的注册/绑定/注入，spring bean的定义显然不能止步于此，为了更好的管理bean，spring在bean上做了许多拓展，不仅对bean本身的属性做纵向拓展，在横向的种类上，也按照不同的职责划分，定义了许多“专业”的，有特点功能的bean。</p>
<blockquote>
<p>注意，特殊的bean也是基于普通bean的拓展，普通bean拥有的特点，特殊bean都有。</p>
</blockquote>
<h4 id="4-2-1-1-普通的spring-bean"><a href="#4-2-1-1-普通的spring-bean" class="headerlink" title="4.2.1.1 普通的spring bean"></a>4.2.1.1 普通的spring bean</h4><p>为了应对许多不同的场景，我们在配置spring bean的Configuration Metadata的时候，需要定义bean的许多属性来达到不同的目的，故而我们有必要了解spring为bean定义了哪些属性可用。</p>
<ol>
<li><p>id属性</p>
<ul>
<li>通常，每个注册到容器的对象都需要一个唯一标志来将其与“同处一室”的“兄弟们”区分开来，就好像我们每一个人都有一个身份证号一样（重号的话就比较麻烦）。通过id属性来指定当前注册对象的beanName是什么。</li>
<li><code>&lt;bean id=&quot;djNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt;</code></li>
</ul>
</li>
<li><p>name属性</p>
<ul>
<li>除了可以使用id来指定<code>&lt;bean&gt;</code>在容器中的标志，还可以使用name属性来指定<code>&lt;bean&gt;</code>的别名（alias）</li>
<li>与id属性相比，name属性的灵活之处在于，name可以使用id不能使用的一些字符，比如/。而且还可以通过逗号、空格或者冒号分割指定多个name。</li>
<li><code>&lt;bean id=&quot;djNewsListener&quot; name=&quot;/news/djNewsListener,dowJonesNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt;</code></li>
</ul>
</li>
<li><p>class属性</p>
<ul>
<li>每个注册到容器的对象都需要通过<code>&lt;bean&gt;</code>元素的class属性指定其类型，否则，容器可不知道这个对象到底是何方神圣。</li>
<li>在大部分情况下，该属性是必须的。仅在少数情况下不需要指定，如后面将提到的在使用抽象配置模板的情况下。</li>
<li><code>&lt;bean id=&quot;djNewsListener&quot; class=&quot;..impl.DowJonesNewsListener&quot;&gt; &lt;/bean&gt;</code></li>
</ul>
</li>
<li><p>scope属性</p>
<ul>
<li>scope用来声明容器中的对象所应该处的限定场景或者说该对象的存活时间，即容器在对象进入其相应的scope之前，生成并装配这些对象，在该对象不再处于这些scope的限定之后，容器通常会销毁这些对象。</li>
<li>Spring容器最初提供了两种bean的scope类型：singleton和prototype，但发布2.0之后，又引入了另外三种scope类型，即request、session和global session类型。不过这三种类型有所限制，只能在Web应用中使用。</li>
<li><code>&lt;bean id=&quot;mockObject2&quot; class=&quot;...MockBusinessObject&quot; scope=&quot;prototype&quot;/&gt;</code><ol>
<li><strong>singleton</strong>：单例的意思。即标记为拥有singleton scope的对象定义，在Spring的IoC容器中只存在一个实例，所有对该对象的引用将共享这个实例。该实例从容器启动，并因为第一次被请求而初始化之后，将一直存活到容器退出。</li>
<li><strong>prototype</strong>：容器在接到该类型对象的请求的时候，会每次都重新生成一个新的对象实例给请求方。虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不再拥有当前返回对象的引用，请求方需要自己负责当前返回对象的后继生命周期的管理工作，包括该对象的销毁。</li>
<li><strong>request、session和global session</strong>：这三个scope类型是Spirng 2.0之后新增加的，它们不像之前的singleton和prototype那么“通用”，因为它们只适用于Web应用程序，通常是与XmlWebApplicationContext共同使用。三者的作用域顾名思义，分别对应web应用的request、session和global session。</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="4-2-1-2-FactoryBean"><a href="#4-2-1-2-FactoryBean" class="headerlink" title="4.2.1.2 FactoryBean"></a>4.2.1.2 FactoryBean</h4><p>FactoryBean是我们接触到的第一个特殊bean，首先它是一个Bean（这表示spring bean的定义它都有），但又不仅仅是一个Bean（它有特殊功能）。<strong>它是一个能生产或修饰对象生成的工厂Bean，类似于设计模式中的工厂模式和装饰器模式</strong>。它能在需要的时候“改装”一个对象，且不仅仅限于它自身，它能返回任何Bean的实例。</p>
<blockquote>
<p>简而言之，factoryBean是一个bean，一个拥有简单bean工厂职能的bean。</p>
</blockquote>
<p>FactoryBean是一个接口，它只定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个方法最核心的 getObject()方法，其他两个方法都服务于它。</p>
<p>那么FactoryBean有什么作用呢？？</p>
<p>我们知道，在spring Ioc容器中getBean的时候，底层是通过java的反射机制调用bean的构造器来new一个对象返回，如果我希望从容器中返回的对象不是新new出来的对象，而是某个我指定的对象呢？？</p>
<p>比如我们需要从容器中获取一辆车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Car&#123;</span><br><span class="line">	private String color;</span><br><span class="line">	public Car() &#123;</span><br><span class="line">		this.color &#x3D; &quot;黑色&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	...   &#x2F;&#x2F;set&#x2F;get方法省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为反射都是调用无参构造器来new对象，所以我们只能得到一辆黑色的车，那我如果想要一辆白色的车呢？</p>
<p>我们现有的beanFactory只支持生产默认的黑色的车，那为了得到白色的车，我们得拥有指定想要哪台车的能力，如何指定呢？</p>
<p>我们知道，在对象的概念中，A extends B表示的是A是B； A implements B表示的是A有B提供的能力。我们希望我们在提车时可以自己选择自己想要的车，而FactoryBean就提供了这种能力。</p>
<p>Car类实现了FactoryBean，就表示告诉spring IoC：当beanFactory按照Car类的图纸（beanDefinition，下文将详细描述）来生产Car的实例的时候，如果发现我的图纸上有注明要指定我想要的汽车（即实现FactoryBean接口），那么beanFactory就得按照我的要求来生产我制定的汽车。</p>
<p>这时候，我们的“图纸”可以这么定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class Car implements FactoryBean&lt;Car&gt;&#123;</span><br><span class="line">	private String color;</span><br><span class="line">	public Car() &#123;</span><br><span class="line">		this.color &#x3D; &quot;黑色&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	...   &#x2F;&#x2F;set&#x2F;get方法省略</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;这座新工厂，要生产白色的车</span><br><span class="line">	@Override</span><br><span class="line">	public Car getObject() throws Exception &#123;</span><br><span class="line">		Car car&#x3D;new Car();</span><br><span class="line">		car.setColor(&quot;白色&quot;);</span><br><span class="line">		return car;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		return Car.class;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;表示我要的白车，在全局中单例</span><br><span class="line">	@Override</span><br><span class="line">	public boolean isSingleton() &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候你从容器中取出来的Car类型的实例，都会是白车了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(classes &#x3D; TestApplication.class)</span><br><span class="line">public class FactoryBeanTest &#123;</span><br><span class="line">	@Autowired</span><br><span class="line">	private ApplicationContext context;</span><br><span class="line">	@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		Car car1 &#x3D; (Car) context.getBean(&quot;car&quot;);</span><br><span class="line">		System.out.println(&quot;car1 &#x3D; &quot; + car1.getColor());</span><br><span class="line">		如果要获取Car非定制的实例，那么需要在名称前面加上&#39;&amp;&#39;符号。</span><br><span class="line">		 Car car2 &#x3D; (Car) context.getBean(&quot;&amp;car&quot;);</span><br><span class="line">		System.out.println(&quot;car2 &#x3D; &quot; + car2.getColor());</span><br><span class="line">		System.out.println(&quot;car1.equals(car2) &#x3D; &quot; + car1.equals(car2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<blockquote>
<p>car1 = 白色<br>car2 = 黑色<br>car1.equals(car2) = false</p>
</blockquote>
<p>说了这么多，为什么要有FactoryBean这个东西呢，有什么具体的作用吗？</p>
<p>其实FactoryBean在Spring中最为典型的一个应用就是用来创建AOP的代理对象。</p>
<p>我们知道AOP实际上是Spring在运行时创建了一个代理对象，也就是说这个对象，是我们在运行时创建的，而不是一开始就定义好的，这很符合工厂方法模式。更形象地说，AOP代理对象通过Java的反射机制，在运行时指定了一个定制的代理对象，在代理对象的目标方法中根据业务要求织入了相应的方法。这个对象在Spring中就是——ProxyFactoryBean。</p>
<p>所以，FactoryBean为我们实例化Bean提供了一个更为灵活的方式，我们可以通过FactoryBean创建出更为复杂的Bean实例。</p>
<h3 id="4-2-2-BeanDefinition"><a href="#4-2-2-BeanDefinition" class="headerlink" title="4.2.2 BeanDefinition"></a>4.2.2 BeanDefinition</h3><p>在Java中，一切皆对象。在JDK中使用java.lang.Class来描述类这个对象。</p>
<p>在Spring中，存在bean这样一个概念，那Spring又是怎么抽象bean这个概念，用什么类来描述bean这个对象呢？<strong>Spring使用BeanDefinition来描述bean</strong>。</p>
<p>顾名思义，BeanDefinition就是Spring对bean的定义对象，spring从Configuration Metadata中读取bean的配置，包括它的beanName，是否是单例，具体指向哪个类，是否是懒加载，有哪些依赖等等信息，都存在BeanDefinition对象中，<strong>BeanDefinition就是beanFactory生产bean的图纸</strong>。</p>
<p>将bean定义成BeanDefinition后，spring对bean的操作就可以改为对BeanDefinition进行，比如拿到某个BeanDefinition后，可以根据里面的类名、构造函数、构造函数参数，使用反射进行对象创建。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-607d2dbaeff31870bdaf8d3404790f1302a.png" alt=""></p>
<p>BeanDefinition实现了AttributeAccessor和BeanMetadataElement接口。在Spring中充斥着大量的各种接口，每种接口都拥有不同的能力，某个类实现了某个接口，也就相应的拥有了某种能力:</p>
<ol>
<li>AttributeAccessor：顾名思义，这是一个属性访问者，它提供了对外访问属性的能力。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-1e6fbda257ebbc736e6475307b00b438cd9.png" alt=""></li>
</ul>
</li>
<li>BeanMetadataElement：提供了获取元数据元素的配置源对象的能力。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-81004107878dac4a14374dfc66dd2ac4b44.png" alt=""></li>
</ul>
</li>
</ol>
<p>BeanDefinition的属性和方法如下图所示，大部分方法/属性的作用都能简单从名字区分出来，部分方法的作用，我们下面来简单介绍。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-06c3268fc33840829f3be778fd91baf5fef.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于描述一个具体bean实例</span><br><span class="line">public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line">    &#x2F;&#x2F;scope值，单例</span><br><span class="line">    String SCOPE_SINGLETON &#x3D; ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;scope值，非单例</span><br><span class="line">    String SCOPE_PROTOTYPE &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Bean角色：</span><br><span class="line">    &#x2F;&#x2F;用户</span><br><span class="line">    int ROLE_APPLICATION &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;某些复杂的配置</span><br><span class="line">    int ROLE_SUPPORT &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F;完全内部使用</span><br><span class="line">    int ROLE_INFRASTRUCTURE &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回此bean定义的父bean定义的名称，如果有的话 &lt;bean parent&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String getParentName();</span><br><span class="line">    void setParentName(String parentName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取bean对象className &lt;bean class&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String getBeanClassName();</span><br><span class="line">    void setBeanClassName(String beanClassName);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义创建该Bean对象的工厂类  &lt;bean factory-bean&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    &#x2F;&#x2F;如果该 Bean 采用工厂方法生成，指定工厂名称。</span><br><span class="line">    String getFactoryBeanName();</span><br><span class="line">    void setFactoryBeanName(String factoryBeanName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义创建该Bean对象的工厂方法 &lt;bean factory-method&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String getFactoryMethodName();</span><br><span class="line">    void setFactoryMethodName(String factoryMethodName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&lt;bean scope&#x3D;&quot;singleton&#x2F;prototype&quot;&gt;</span><br><span class="line">    String getScope();</span><br><span class="line">    void setScope(String scope);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;懒加载 &lt;bean lazy-init&#x3D;&quot;true&#x2F;false&quot;&gt;</span><br><span class="line">    boolean isLazyInit();</span><br><span class="line">    void setLazyInit(boolean lazyInit);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;依赖对象  &lt;bean depends-on&#x3D;&quot;xxx&quot;&gt;</span><br><span class="line">    String[] getDependsOn();</span><br><span class="line">    void setDependsOn(String[] dependsOn);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否为被自动装配 &lt;bean autowire-candidate&#x3D;&quot;true&#x2F;false&quot;&gt;</span><br><span class="line">    boolean isAutowireCandidate();</span><br><span class="line">    void setAutowireCandidate(boolean autowireCandidate);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否为主候选bean    使用注解：@Primary。</span><br><span class="line">    &#x2F;&#x2F;同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span><br><span class="line">    boolean isPrimary();</span><br><span class="line">    void setPrimary(boolean primary);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回此bean的构造函数参数值。</span><br><span class="line">    ConstructorArgumentValues getConstructorArgumentValues();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取普通属性集合</span><br><span class="line">    MutablePropertyValues getPropertyValues();</span><br><span class="line">    &#x2F;&#x2F;是否为单例</span><br><span class="line">    boolean isSingleton();</span><br><span class="line">    &#x2F;&#x2F;是否为原型</span><br><span class="line">    boolean isPrototype();</span><br><span class="line">    &#x2F;&#x2F;是否为抽象类</span><br><span class="line">    &#x2F;&#x2F; 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span><br><span class="line">   &#x2F;&#x2F; 常用于作为 父bean 用于继承，其实也很少用......</span><br><span class="line">    boolean isAbstract();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取这个bean的应用</span><br><span class="line">    int getRole();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回对bean定义的可读描述。</span><br><span class="line">    String getDescription();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;返回该bean定义来自的资源的描述（用于在出现错误时显示上下文）</span><br><span class="line">    String getResourceDescription();</span><br><span class="line"></span><br><span class="line">    BeanDefinition getOriginatingBeanDefinition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinition接口有诸多的实现类，不同的实现类，使用的场景也不尽相同：<br><img src="https://oscimg.oschina.net/oscnet/up-721e187dbcf42aebbc3aca0d339e18062e8.png" alt=""></p>
<ol>
<li>AbstractBeanDefinition，是BeanDefinition的主要实现类，也是所有bean定义的父类。</li>
<li>RootBeanDefinition，是在XML配置时代，注册bean定义时用的类。</li>
<li>ChildBeanDefinition，是在XML配置时代，注册bean定义时用的类，必须在配置时指定一个父bean定义。</li>
<li>GenericBeanDefinition，在注解配置时代，推荐使用的bean定义类，可以在运行时动态指定一个父bean定义，也可以不指定。</li>
<li>AnnotatedGenericBeanDefinition，在注解配置时代，通过编程方式注册bean定义时用的类，继承了GenericBeanDefinition。</li>
<li>ScannedGenericBeanDefinition，在注解配置时代，通过扫描jar包中.class文件的方式注册bean定义时用的类，继承了GenericBeanDefinition。</li>
</ol>
<h2 id="4-3-Spring-IoC容器流程"><a href="#4-3-Spring-IoC容器流程" class="headerlink" title="4.3 Spring IoC容器流程"></a>4.3 Spring IoC容器流程</h2><p>Spring的IoC容器所起的作用，就像下图所展示的那样，它会以某种方式加载Configuration Metadata（通常也就是XML格式的配置信息），然后根据这些信息绑定整个系统的对象，最终组装成一个可用的基于轻量级容器的应用系统。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-53938a98292785a01ef1731f32901f4f490.png" alt=""></p>
<p>Spring的IoC容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即容器启动阶段和Bean实例化阶段</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f7c9a513d97f0f4e5abcb2e1f809d42d016.png" alt=""></p>
<h3 id="4-3-1-容器启动阶段"><a href="#4-3-1-容器启动阶段" class="headerlink" title="4.3.1 容器启动阶段"></a>4.3.1 容器启动阶段</h3><ol>
<li><p>容器启动伊始，首先会通过某种途径加载Configuration MetaData。除了代码方式比较直接，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的Configuration MetaData。</p>
</li>
<li><p>对Configuration MetaData进行解析和分析，并将分析后的信息编组为相应的BeanDefinition，最后把这些保存了bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-2c47772c36c20bcf748015c48f8c12fbccb.png" alt=""></p>
<blockquote>
<p>总地来说，该阶段所做的工作可以认为是准备性的，重点更加侧重于对象管理信息的收集。</p>
</blockquote>
<h3 id="4-3-2-Bean实例化阶段"><a href="#4-3-2-Bean实例化阶段" class="headerlink" title="4.3.2 Bean实例化阶段"></a>4.3.2 Bean实例化阶段</h3><p>经过第一阶段，现在所有的bean定义信息都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中。当某个请求方通过容器的getBean方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用getBean方法时，就会触发第二阶段的活动。</p>
<ol>
<li><p>容器会首先检查所请求的对象之前是否已经实例化和初始化。如果没有，则会根据注册的BeanDefinition所提供的信息<strong>实例化</strong>被请求对象，并为其<strong>注入依赖</strong>，然后<strong>初始化</strong>。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。</p>
</li>
<li><p>当该对象装配完毕之后，容器会立即将其返回请求方使用。</p>
</li>
</ol>
<blockquote>
<p>如果说第一阶段只是根据图纸装配生产线的话，那么第二阶段就是使用装配好的生产线来生产具体的产品了</p>
</blockquote>
<blockquote>
<p>注意，我们上面提高的bean的实例化，注入依赖（或者叫依赖装配），初始化，是三个递进的不同阶段，注意区分。</p>
</blockquote>
<h2 id="4-4-spring-bean的生命周期"><a href="#4-4-spring-bean的生命周期" class="headerlink" title="4.4 spring bean的生命周期"></a>4.4 spring bean的生命周期</h2><p>确的了解Spring Bean的生命周期是非常必要的。我们通常使用ApplicationContext作为Spring容器。这里，我们讲的也是 ApplicationContext中Bean的生命周期。而实际上BeanFactory也是差不多的，只不过处理器需要手动注册。</p>
<p>开门见山，我们先直接给出一张总图，然后再分别描述：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-336e2eddd6c632b56f4784f9efa0937cd05.png" alt=""></p>
<p>可以看到，Bean的完整生命周期经历了各种方法调用，这些方法可以划分为以下几类：</p>
<ol>
<li><p>Bean自身的方法：这个包括了Bean本身调用的方法（如构造器，依赖注入的set方法等）和通过配置文件中<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>指定的方法。</p>
</li>
<li><p>Bean级生命周期接口方法：这个包括了Aware接口的相关实现类（如BeanNameAware、BeanFactoryAware）以及InitializingBean、DiposableBean这些接口的方法。</p>
</li>
<li><p>容器级生命周期接口方法：</p>
<ol>
<li><strong>Bean后处理器</strong>接口方法：所有实现了BeanPostProcessor这个接口的实现类，一般称它们为“后处理器”，或者“bean后处理器”。主要作用是对容器中的bean进行后处理，也就是额外的加强。（注意，它的作用对象是它所注册的容器中的所有收管bean）</li>
<li><strong>工厂后处理器</strong>接口方法：所有实现了BeanFactoryPostProcessor这个接口的实现类，一般称它们为“工厂后处理器”，或者“容器后处理器”。主要作用是对IoC容器进行后处理，增强容器功能。（注意，它的作用对象是它所注册的容器的对象）</li>
</ol>
</li>
</ol>
<p>这些类或接口叫做Hook类/接口，这些接口/类的存在，使得Spring Framework具有非常高的扩展性，<strong>使得我们可以在bean的生命周期的关键节点介入，得到一些我们需要的信息，或者做一些对bean的“改装”</strong>。</p>
<p>第一类，Bean自身的方法，这个不再赘述，我们从bean的生命周期中各类的调用顺序，来依次介绍二三类的这些接口方法：</p>
<h3 id="4-4-1-Bean级生命周期接口方法"><a href="#4-4-1-Bean级生命周期接口方法" class="headerlink" title="4.4.1  Bean级生命周期接口方法"></a>4.4.1  Bean级生命周期接口方法</h3><h4 id="4-4-1-1-InitializingBean-DisposableBean接口方法"><a href="#4-4-1-1-InitializingBean-DisposableBean接口方法" class="headerlink" title="4.4.1.1 InitializingBean/DisposableBean接口方法"></a>4.4.1.1 InitializingBean/DisposableBean接口方法</h4><p>InitializingBean和DisposableBean接口十分的简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface InitializingBean &#123;</span><br><span class="line">	void afterPropertiesSet() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface DisposableBean &#123;</span><br><span class="line">	void destroy() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能也十分简单：如果想在bean的 创建/销毁 过程中做一些骚操作的话，就实现这两个接口中对应的接口方法，将骚操作逻辑定义在里面。</p>
<p>Spring在创建/销毁bean的过程中，会判断bean是否实现了这二者的接口方法，如果实现了，就在适当的时机调用它。</p>
<p>具体逻辑见AbstractAutowireCapableBeanFactory#initializeBean()和AbstractAutowireCapableBeanFactory#invokeInitMethods()</p>
<h4 id="4-4-1-2-Aware接口方法"><a href="#4-4-1-2-Aware接口方法" class="headerlink" title="4.4.1.2 Aware接口方法"></a>4.4.1.2 Aware接口方法</h4><p>Spring中有很多继承于aware接口的类，如下图，那么这些类到底是做什么用到的呢？？</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ea8fe95bed3c58c5c737e7d70d67fe22138.png" alt=""></p>
<p>有些时候，我们需要在bean的实例化过程中，获取bean的某些信息来做一些工作，这些信息包括bean的beanName，构造这个bean的ApplicationContext，加载这个bean类的beanClassLoader等等。</p>
<p>假设我们有一个Car类，我们希望在bean的初始化过程中能够有机会获取到bean的beanName，以便我们把beanName赋值给carName，让每辆car的carName和beanName一致，那么我们可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements BeanNameAware&#123;  &#x2F;&#x2F;让Car实现BeanNameAware</span><br><span class="line">	private String carName;</span><br><span class="line">	public void setBeanName(String beanName) &#123;</span><br><span class="line">		&#x2F;&#x2F;ID保存BeanName的值</span><br><span class="line">		carName&#x3D;beanName;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们在Configuration MetaData中定义两个Car类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;benchi&quot;  class&#x3D;&quot;balabala.Car&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;baoma&quot;  class&#x3D;&quot;balabala.Car&quot;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;benchi&quot;)</span><br><span class="line">private Car benchi;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;baoma&quot;)</span><br><span class="line">private Car baoma;</span><br></pre></td></tr></table></figure>
<p>那么可以得到结果：<code>benchi.carName=“benchi”，baoma.carName=“baoma”；</code></p>
<p>aware，翻译过来是知道的，已感知的，意识到的，所以，这些接口从字面意思是能感知到所有Aware前缀值的含义。</p>
<p>实际上，这些接口也确实提供了可实现的方法，在bean的实例化过程中，将各个Aware想要获取的信息通过参数的方式传到实现的方法中来，给开发者一个获取到相关信息值的机会。</p>
<p>如上例的<code>Car implements BeanNameAware</code>，BeanNameAware定义的setBeanName(String beanName)方法，就会在实例化过程中把beanName信息传进方法中来让开发者使用，得意于此，我们才能得到beanName，并将其赋值给carName。</p>
<p>至于其他的Aware实现类，他们获取的信息不同，但逻辑也都是一样的。</p>
<ul>
<li><p>BeanNameAware接口是为了让自身Bean能够感知到，获取到自身在Spring容器中的id（也就是beanName）属性。</p>
</li>
<li><p>实现了ApplicationContextAware接口的类，能够获取到ApplicationContext</p>
</li>
<li><p>实现了BeanFactoryAware接口的类，能够获取到BeanFactory对象。</p>
</li>
<li><p>…</p>
</li>
</ul>
<p>在实例化过程中，将相关信息传进接口方法中以供使用，spring怎么做到这一点的呢？？</p>
<p>其实非常简单，bean在初始化前会调用一次ApplicationContextAwareProcessor类的postProcessBeforeInitialization方法，如果bean实现了Aware接口，那么会继续判断bean实现了具体的什么接口，执行对应接口的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private void invokeAwareInterfaces(Object bean) &#123;</span><br><span class="line">		if (bean instanceof Aware) &#123;</span><br><span class="line">			if (bean instanceof EnvironmentAware) &#123;</span><br><span class="line">				((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof EmbeddedValueResolverAware) &#123;</span><br><span class="line">				((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof ResourceLoaderAware) &#123;</span><br><span class="line">				((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof ApplicationEventPublisherAware) &#123;</span><br><span class="line">				((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof MessageSourceAware) &#123;</span><br><span class="line">				((MessageSourceAware) bean).setMessageSource(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">			if (bean instanceof ApplicationContextAware) &#123;</span><br><span class="line">				((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-容器级生命周期接口方法"><a href="#4-4-2-容器级生命周期接口方法" class="headerlink" title="4.4.2  容器级生命周期接口方法"></a>4.4.2  容器级生命周期接口方法</h3><p>容器级生命周期接口方法主要分为<strong>Bean后处理器</strong>接口方法和<strong>工厂后处理器</strong>接口方法。前者可以对容器中的bean进行增强，后者对容器进行增强，二者我们依次介绍</p>
<h4 id="4-4-2-1-Bean后处理器"><a href="#4-4-2-1-Bean后处理器" class="headerlink" title="4.4.2.1 Bean后处理器"></a>4.4.2.1 Bean后处理器</h4><p><strong>BeanPostProcessor接口是所有Bean后处理器的顶层接口</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;参数：arg1：被增强的bean对象；arg2：被增强的bean对象的id</span><br><span class="line">	@Nullable</span><br><span class="line">	default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;参数：arg1：被增强的bean对象；arg2：被增强的bean对象的id</span><br><span class="line">	@Nullable</span><br><span class="line">	default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，postProcessBeforeInitialization和postProcessAfterInitialization，在接口上就已经有默认实现了，所以其他的Bean后处理器实现类，不一定要重写这两个方法。</p>
</blockquote>
<p>可以看到postProcessBeforeInitialization和postProcessAfterInitialization是一组对称的方法，一个后缀是BeforeInitialization，一个后缀是AfterInitialization。注意，Initialization，初始化的意思，故而一个在初始化前，一个在初始化后。</p>
<p>spring bean的初始化（注意，初始化不是实例化）包含：</p>
<ol>
<li>调用InitializingBean接口的afterPropertiesSet方法（如果有实现的话）。</li>
<li>Configuration Metadata中的init方法，如xml配置的init-method属性指定方法，或@Bean注解注册bean定义时，设置注解initMethod属性指定的方法等。</li>
<li>使用java的注解@PostConstruct，把它标在bean的一个方法上。</li>
</ol>
<p>而postProcessBeforeInitialization和postProcessAfterInitialization方法的调用位置就是：</p>
<p><strong>bean的实例化-&gt; bean的依赖装配 -&gt; BeforeInitialization接口方法（初始化前） -&gt; bean的初始化方法 -&gt; AfterInitialization接口方法（初始化后）</strong></p>
<p>那么bean后处理器如何使用呢？来，我们来自定义一个bean后处理器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyBeanProcessor implements BeanPostProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object arg0, String arg1)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;bean:&quot; + arg1 + &quot; after&quot;);</span><br><span class="line">        return arg0;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessBeforeInitialization(Object arg0, String arg1)</span><br><span class="line">        throws BeansException &#123;</span><br><span class="line">        System.out.println(&quot;bean:&quot; + arg1 + &quot; before&quot;);</span><br><span class="line">        return arg0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring在初始化bean的过程中，会优先初始化那些实现了像BeanPostProcessor这类特殊接口的bean，<strong>如果容器发现初始化的bean实现了BeanPostProcessor 接口，将会将其注册为bean后处理器</strong>。</p>
<p><strong>一经注册，它对它注册的spring容器下的所有bean起作用，任何bean在初始化过程都会通过bean后处理器做额外增强操作</strong>。</p>
<p>作为开发者，我们可以通过实现BeanPostProcessor接口方法，来自定义后处理器类，也可以使用现成，spring为我们准备好的一些后处理器，下面我们简单介绍一些重要的bean后处理器。</p>
<h5 id="4-4-2-1-1-InstantiationAwareBeanPostProcessor"><a href="#4-4-2-1-1-InstantiationAwareBeanPostProcessor" class="headerlink" title="4.4.2.1.1 InstantiationAwareBeanPostProcessor"></a>4.4.2.1.1 InstantiationAwareBeanPostProcessor</h5><p>InstantiationAwareBeanPostProcessor也是一个接口，注意，InstantiationAwareBeanPostProcessor的一对before和after接口方法，不是重写的BeanPostProcessor的postProcessBeforeInitialization和postProcessAfterInitialization。</p>
<p>Instantiation和Initialization，还是不一样的，前者是实例化，后者是初始化，要注意区分。</p>
<p>InstantiationAwareBeanPostProcessor实现BeanPostProcessor接口，更多意义上是为了将自己归类进bean后处理器中，好让容器识别自己的“身份”。它的逻辑载体（即三个方法），都是自实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;注意！！！这个方法是InstantiationAwareBeanPostProcessor自己定义的</span><br><span class="line">	&#x2F;&#x2F;不是重写BeanPostProcessor的postProcessBeforeInitialization，两个方法名很像，但不一样</span><br><span class="line">	&#x2F;&#x2F;在bean实例化前调用，如果返回一个非null对象，则Spring就使用这个对象了，不再进行实例化了。</span><br><span class="line">	&#x2F;&#x2F;所以这里可以返回一个目标bean的代理，来压制（延迟）目标bean的实例化。</span><br><span class="line">	&#x2F;&#x2F;这个方法的参数是bean的类型，因为此时还没有bean实例呢。</span><br><span class="line">	@Nullable</span><br><span class="line">	default Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;注意！！！这个方法是InstantiationAwareBeanPostProcessor自己定义的</span><br><span class="line">	&#x2F;&#x2F;不是重写BeanPostProcessor的postProcessAfterInitialization，两个方法名很像，但不一样</span><br><span class="line">	&#x2F;&#x2F;这是一个理想的地方用来执行自定义字段注入，因为此时Spring的自动装配尚未到来。</span><br><span class="line">	&#x2F;&#x2F;通常方法返回true，如果返回false，后续的属性设置将被跳过。</span><br><span class="line">	default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;在bean属性设置前调用，可以用来定制即将为bean实例设置的属性。</span><br><span class="line">	&#x2F;&#x2F;方法pvs是传进来的已有属性。方法默认返回null。表示不对属性进行操作。</span><br><span class="line">	@Nullable</span><br><span class="line">	default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	@Deprecated</span><br><span class="line">	@Nullable</span><br><span class="line">	default PropertyValues postProcessPropertyValues(</span><br><span class="line">			PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		return pvs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InstantiationAwareBeanPostProcessor的名字中有Instantiation（实例化），说明和BeanPostProcessor只能介入初始化的前后不一样，InstantiationAwareBeanPostProcessor可以介入到bean的实例化的前后，所以它的执行时机是：</p>
<p><strong>bean的实例化准备阶段 -&gt; BeforeInstantiation接口方法（实例化前）-&gt; bean的实例化 -&gt; AfterInstantiation接口方法（实例化后） -&gt; PropertyValues接口方法（定制bean所需的属性值） -&gt; bean的属性设置</strong></p>
<h5 id="4-4-2-1-2-DestructionAwareBeanPostProcessor"><a href="#4-4-2-1-2-DestructionAwareBeanPostProcessor" class="headerlink" title="4.4.2.1.2 DestructionAwareBeanPostProcessor"></a>4.4.2.1.2 DestructionAwareBeanPostProcessor</h5><p>DestructionAwareBeanPostProcessor接口和InstantiationAwareBeanPostProcessor对应，后者负责实例化前后的增强，后者负责销毁前后的增强。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface DestructionAwareBeanPostProcessor extends BeanPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;在bean实例销毁前会被调用，来执行一些定制的销毁代码。</span><br><span class="line">	void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException;</span><br><span class="line">	&#x2F;&#x2F;决定是否要为bean实例调用第一个方法来执行一些销毁代码。返回true表示需要，false表示不需要调用。</span><br><span class="line">	default boolean requiresDestruction(Object bean) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spring bean的销毁包含：</p>
<ol>
<li>调用DisposableBean接口的destroy方法（如果有实现的话）。</li>
<li>Configuration Metadata中的init方法，如xml配置的destroy-method属性指定方法，或@Bean注解注册bean定义时，设置注解destroyMethod属性指定的方法等。</li>
<li>使用java的注解@PreDestroy，把它标在bean的一个方法上。</li>
</ol>
<p>执行时机就在销毁前后，不再细述。</p>
<h5 id="4-4-2-1-3-SmartInstantiationAwareBeanPostProcessor"><a href="#4-4-2-1-3-SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="4.4.2.1.3 SmartInstantiationAwareBeanPostProcessor"></a>4.4.2.1.3 SmartInstantiationAwareBeanPostProcessor</h5><p>占位，知道有这么一个后处理器，可以用来修改bean类型，定制构造方法，还有获取一个早期（初始化还没执行）bean实例的引用，典型的用法是可以用来解决循环引用。</p>
<h5 id="4-4-2-1-4-MergedBeanDefinitionPostProcessor"><a href="#4-4-2-1-4-MergedBeanDefinitionPostProcessor" class="headerlink" title="4.4.2.1.4 MergedBeanDefinitionPostProcessor"></a>4.4.2.1.4 MergedBeanDefinitionPostProcessor</h5><p>占位，知道有这么一个后处理器，这个接口的主要目的不是用来修改合并后的bean定义的，虽然也可以进行一些修改。<br>它主要用来进行一些自省操作，如一些检测，或在处理bean实例之前缓存一些相关的元数据。<br>这些作用都在第一个方法里实现。</p>
<h4 id="4-4-2-2-Bean工厂后处理器"><a href="#4-4-2-2-Bean工厂后处理器" class="headerlink" title="4.4.2.2 Bean工厂后处理器"></a>4.4.2.2 Bean工厂后处理器</h4><p>和Bean后处理器一样，Bean工厂后处理器是一种特殊的Bean，这种Bean并不对外提供服务，它甚至可以无需id属性，它主要负责对容器本身进行某些特殊的处理和增强。</p>
<p>BeanFactoryPostProcessor是所有工厂后处理器的顶层接口，在spring容器实例化bean的逻辑中，spring正是通过<code>instanceof BeanFactoryPostProcessor</code>这一判断语句来确定一个bean是不是工厂后处理器。</p>
<p>如下图所示，spring提供的BeanFactoryPostProcessor实现类有很多，一些常见的功能，我们可以直接选择合适的工厂后处理器来继承或者实现，以免重复造轮子，其中BeanDefinitionRegistryPostProcessor是BeanFactoryPostProcessor最重要的一个实现类。<br><img src="https://oscimg.oschina.net/oscnet/up-026c8508b80dc53ed001a173d88f0b207f4.png" alt=""></p>
<p>Spring中有两类工厂后处理器，<strong>BeanDefinitionRegistryPostProcessor和其他</strong>。其中其他里面又分为spring源生的，和我们自定义的。</p>
<blockquote>
<p>BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，设计它的目的是为了使用它向容器注册额外的bean的配置信息——BeanDefinition对象。</p>
</blockquote>
<h5 id="4-4-2-2-1-自定义BeanFactoryPostProcessor"><a href="#4-4-2-2-1-自定义BeanFactoryPostProcessor" class="headerlink" title="4.4.2.2.1 自定义BeanFactoryPostProcessor"></a>4.4.2.2.1 自定义BeanFactoryPostProcessor</h5><p>我们把spring提供的源生的Bean工厂后处理器之外的，我们自己通过实现BeanFactoryPostProcessor顶层接口的工厂后处理器称为<strong>普通工厂后处理器，或者自定义BeanFactoryPostProcessor</strong>；</p>
<p>我们先来看下BeanFactoryPostProcessor接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;postProcessBeanFactory方法，它的执行的时机是，所有的bean定义都已经注册完毕，不可能再增多了</span><br><span class="line">	&#x2F;&#x2F;该方法允许去修改bean定义的一些属性。</span><br><span class="line">	&#x2F;&#x2F;它允许覆盖或者设置bean的属性值，甚至是立即实例化bean，比如实例化bean后处理器对象。</span><br><span class="line">	void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactoryPostProcessor能改变bean在实例化之前的一些原配置值，比如Scope，lazy，Primary，DependsOn，Role，Description等等。</p>
<p>比如我们有个单例的bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">public class Teacher&#123;</span><br><span class="line">	public Teacher()&#123;</span><br><span class="line">		System.out.println(&quot;Construct&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义实现BeanFactoryPostProcessor的处理器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">		BeanDefinition beanDefinition &#x3D; beanFactory.getBeanDefinition(&quot;teacher&quot;);</span><br><span class="line">		beanDefinition.setScope(&quot;prototype&quot;);</span><br><span class="line">		System.out.println(&quot;Scope:&quot;+beanDefinition.getScope());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就完成了对于bean的作用域的变化。</p>
<h5 id="4-4-2-2-2-BeanDefinitionRegistryPostProcessor"><a href="#4-4-2-2-2-BeanDefinitionRegistryPostProcessor" class="headerlink" title="4.4.2.2.2 BeanDefinitionRegistryPostProcessor"></a>4.4.2.2.2 BeanDefinitionRegistryPostProcessor</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;bean定义注册后处理器，就是用来向容器中注册bean定义的，造成的结果就是beanDefinition的数目变多。</span><br><span class="line">public interface BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor &#123;</span><br><span class="line">	&#x2F;&#x2F;它的接口方法执行的时机是，所有的“常规bean定义”都已注册完毕，该方法允许添加进一步的bean定义注册到容器中。</span><br><span class="line">	void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多说无益，我们来看demo：</p>
<p>首先我们创建一个类并实现BeanDefinitionRegistryPostProcessor接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;</span><br><span class="line">		System.out.println(&quot;TestBeanDefinitionRegistryPostProcessor...postProcessBeanDefinitionRegistry&quot;);</span><br><span class="line">		System.out.println(registry.getBeanDefinitionCount());</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;这里添加一个Dog.class的BeanDefinition进入容器</span><br><span class="line">		&#x2F;&#x2F;RootBeanDefinition beanDefinition &#x3D; new RootBeanDefinition(Dog.class);  作用同下行</span><br><span class="line">		AbstractBeanDefinition beanDefinition &#x3D; BeanDefinitionBuilder.rootBeanDefinition(Dog.class).getBeanDefinition();</span><br><span class="line">		registry.registerBeanDefinition(&quot;dog&quot;,beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">		System.out.println(&quot;TestBeanDefinitionRegistryPostProcessor...postProcessBeanFactory&quot;);</span><br><span class="line">		System.out.println(beanFactory.getBeanDefinitionCount());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就完成了往容器中添加BeanDefinition的操作。</p>
<h5 id="4-4-2-2-3-源生工厂后处理器之ConfigurationClassPostProcessor"><a href="#4-4-2-2-3-源生工厂后处理器之ConfigurationClassPostProcessor" class="headerlink" title="4.4.2.2.3 源生工厂后处理器之ConfigurationClassPostProcessor"></a>4.4.2.2.3 源生工厂后处理器之ConfigurationClassPostProcessor</h5><p>ConfigurationClassPostProcessor是Spring中非常重要的工厂后处理器，它的主要功能是参与BeanFactory的建造，在这个类中，会解析加了@Configuration的配置类，还会解析@ComponentScan、@ComponentScans注解扫描的包，以及解析@Import等注解。</p>
<p>ConfigurationClassPostProcessor 实现了 BeanDefinitionRegistryPostProcessor 接口，而 BeanDefinitionRegistryPostProcessor 接口继承了 BeanFactoryPostProcessor 接口，所以 ConfigurationClassPostProcessor 中需要重写 postProcessBeanDefinitionRegistry() 方法和 postProcessBeanFactory() 方法。而ConfigurationClassPostProcessor类的作用就是通过这两个方法去实现的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4230db35c74bd0b4acc1f353f7129eab984.png" alt=""></p>
<p>具体代码逻辑，可以见该文：<a href="https://blog.csdn.net/qq_34436819/article/details/100944204" target="_blank" rel="noopener" title="ConfigurationClassPostProcessor源码解析">ConfigurationClassPostProcessor源码解析</a>，介绍的非常的详细。</p>
<pre><code>- </code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/" itemprop="url">JVM学习总结之『一个类的前世今生』</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-07T22:11:44+08:00">
                2020-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA-JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/07/JVM学习总结之『一个类的前世今生』/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  26
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-我乃中山靖王之后"><a href="#1-我乃中山靖王之后" class="headerlink" title="1 我乃中山靖王之后"></a>1 我乃中山靖王之后</h1><p>大家好，我叫李大锤，是一名不入流的演员，我即将参演一部名叫《三国演义》的舞台剧，导演是棺材板按不住的罗贯中老先生。而我，即将扮演三位主角之一的刘皇叔，嘿嘿，想想还有点小激动呢！</p>
<p>按照剧本，我是一名出生低微的屌丝，被嘲笑为“织席贩履”之辈，所以一开始，我长这个B样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，我开局就会收关张两位挂逼做小弟，于是，我变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">	int zhangFei&#x3D;123;&#x2F;&#x2F;张飞</span><br><span class="line">	Object guanYu&#x3D;new Object();&#x2F;&#x2F;关羽 为了嫌麻烦，就不给他们定制特定的类了，就int &amp; Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算了，就不追求麾下武将如云谋士如雨了，人太多写的也累，有二弟和三弟出场就够了。</p>
<p>当然，作为未来的汉昭烈帝，我开局还会一些特殊技能，不亏是主角之一，这技能真是别具一格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void shuaiErZi() &#123;&#x2F;&#x2F;摔儿子</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shouMaiRenXin() &#123;&#x2F;&#x2F;收买人心</span><br><span class="line">	shuaiErZi();</span><br><span class="line">&#125;</span><br><span class="line">public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">	System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">	guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，身残志坚，躺在棺材里还在coding的著名程序员罗贯中先生，已经通过他精湛的代码功底，为我编写了一个详（jian）细（lou）的开局设定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">    int zhangFei&#x3D;123;&#x2F;&#x2F;张飞</span><br><span class="line">    Object guanYu&#x3D;new Object();&#x2F;&#x2F;关羽 为了嫌麻烦，就不给他们定制特定的类了，就int &amp; Object</span><br><span class="line">    public void shuaiErZi() &#123;&#x2F;&#x2F;摔儿子</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shouMaiRenXin() &#123;&#x2F;&#x2F;收买人心</span><br><span class="line">        shuaiErZi();</span><br><span class="line">    &#125;</span><br><span class="line">    public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">        System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">        guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们去为舞台剧做一下准备吧！</p>
<h1 id="2-新手村"><a href="#2-新手村" class="headerlink" title="2 新手村"></a>2 新手村</h1><p>舞台剧开演在即，来，摄影机往前，我们先来俯瞰一下整个会场的布局吧（详细介绍见：<a href="https://cherish-ls.github.io/2019/10/23/JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener" title="JAVA内存结构和内存管理">JAVA内存结构和内存管理</a>）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b6cfe993d5877ce9f6a9bcbe30fa1eb5055.png" alt=""></p>
<p>首先，面积最为广大的，就是我们舞台的后台，我们唤作<strong>堆</strong>，所有有名有幸的三国豪杰们（对象们），都会在后台齐聚，各自准备。</p>
<p>然后，我们可以看到一块巨大的显示屏，我们唤作<strong>方法区</strong>，上面是本剧的台本，上面写着：</p>
<ul>
<li>各个英雄豪杰的设定/经历（类信息）等信息<ul>
<li>刘备会遇到关张，然后还会摔儿子技能（属性，方法）</li>
<li>曹操麾下有曹仁曹纯夏侯兄弟等挂逼，还有好人妻这个技能。（属性，方法）</li>
<li>….</li>
</ul>
</li>
<li>一些人尽皆知的信息（常量）<ul>
<li>比如现在是东汉末年，嗯，比如东汉末年是个常量。</li>
<li>…</li>
</ul>
</li>
<li>某位英雄广为人知的设定（类的静态变量）。<ul>
<li>刘备：说织席贩履的给老子滚出来啊魂淡！！</li>
<li>曹操：梦中杀伦什么的，我真不是故意的。</li>
<li>孙权：就不能不提合肥，不提孙十万吗。。</li>
</ul>
</li>
</ul>
<p>舞台之上，我们看到了有三束聚光灯各自照亮舞台一隅，这是以我们三位主角曹孙刘为视角的三个<strong>线程</strong>，然后被聚光灯照亮的三块方寸之地，主要是<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，还有一个小的牌子，叫做<strong>程序计数器</strong>，用来标记此间主角演到剧情的何处了。</p>
<h1 id="3-英雄要问出身"><a href="#3-英雄要问出身" class="headerlink" title="3 英雄要问出身"></a>3 英雄要问出身</h1><p>逛完了舞台以后，我得去看看我的台本，虽然我在接戏之前已经知道了罗贯中老先生为我量身定做的草稿：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class LiuBei &#123;</span><br><span class="line">    int zhangFei&#x3D;123;&#x2F;&#x2F;张飞</span><br><span class="line">    Object guanYu&#x3D;new Object();&#x2F;&#x2F;关羽 为了嫌麻烦，就不给他们定制特定的类了，就int &amp; Object</span><br><span class="line">    public void shuaiErZi() &#123;&#x2F;&#x2F;摔儿子</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shouMaiRenXin() &#123;&#x2F;&#x2F;收买人心</span><br><span class="line">        shuaiErZi();</span><br><span class="line">    &#125;</span><br><span class="line">    public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">        System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">        guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但草稿只是草稿，正经的舞台剧，肯定不能用这么简陋的东西来演出，不说别的，看草稿我只知道我有关张两个小弟，但演出时，我至少得知道关张是谁来演，我到底和谁撘对手戏吧？是胡歌还是霍建华？</p>
<p>所以，还需要把草稿再加工，变成真正的台本，这个过程，叫做<strong>编译</strong>，这时，java文件会编译成class文件。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4ba7398c95ae3265cf9332d9761b6160b9a.png" alt=""></p>
<p>class文件的内容我们不再赘述，详情在<a href="https://cherish-ls.github.io/2019/12/03/Class%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener" title="JAVA Class文件和类加载机制">JAVA Class文件和类加载机制</a>一文中可见。我们只要记得几个核心要素：</p>
<ul>
<li><p>类型信息包含魔数，主次版本号等。</p>
</li>
<li><p>常量池里面存放着字面量和符号引用。</p>
<ul>
<li>常量池中每一项常量都是一个表，在JDK1.7之后共有14种表结构，这14种常量类型各自有自己的结构，下面列出每个常量项的结构及含义</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-49edc6b667c3b7b848c539852736ab72b9c.png" alt=""></li>
<li>字面量可以理解为就是字符文本，class文件中的其他信息要用到字符文本的时候，都是“引用”他，比如字段表中，刘备有关羽这个小弟，那“关羽”这个名字的文本就存放于常量池中。</li>
<li>符号引用包含下面三类：<ul>
<li>全限定名：就是类名全称,例如:org/xxx/class/testClass</li>
<li>简单名称：即没有类型和参数修饰的字段或者方法名称，例如方法test()的简单名称就是test，m字段的简单名称就是m。</li>
<li>描述符：描述符的作用是描述字段的数据类型、方法的参数列表（包括数量、类型及顺序）和返回值。根据描述符的规则，基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名表示<ul>
<li>如“viod main(String[] args)” 的描述符为“([Ljava/lang/String;)V</li>
<li>如“String[][]”,会被记录为”[[Ljava/lang/String”</li>
<li>“int[]”被记录为“[I”。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字段表集合，记录这个类的字段信息，比如我们刘备拥有关张两个小弟做对象，</p>
<ul>
<li>这里我们会记录关张的字段名称，如关羽的名称的值就是常量池中“关羽”常量的引用</li>
<li>记录描述符（descriptor_index中记录），描述这个字段的类型，我们这里是Object类型，那么这个值就是指向常量池中的“Ljava/lang/Object”常量的引用。</li>
<li>以及各种修饰符：类似于：汉寿亭侯·美髯公·武圣·刮骨疗法临床实验者·季汉扛把子·关羽=public transient volatile Object guanYu。</li>
</ul>
</li>
<li><p>方法表集合，记录这个类的方法信息，比如我们刘备拥有摔儿子和收买人心方法。</p>
<ul>
<li>这里我们会记录方法的名称，同样引用常量池。</li>
<li>记录描述符（descriptor_index中记录），描述这个方法的描述符，我们这里是void shuaiErZi()，那么这个值就是指向常量池中的“()V”常量的引用。（注意这里的V是指void，描述符不包括方法名称）</li>
<li>以及各种修饰符：类似于：作用全场的·效果拔群的·刘备角色固有的·摔儿子=public volatile static shuaiErZi</li>
<li>方法体里面有代码的，都会有一个code属性（引用属性表集合），里面有摔儿子说明文本长度（属性长度），操作数栈最大深度等，还有摔儿子的具体操作步骤（代码的字节码指令）。</li>
</ul>
</li>
</ul>
<p>来，我们使用javap工具</p>
<p><code>javap -c -v -p -l -constants /home/lisheng/IdeaProjects/learning/out/production/learning/com/company/LiuBei.class</code></p>
<p>将public class LiuBei的class文件反解析出来，如下，这就是刘备这个角色经过编译后的舞台剧脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;home&#x2F;lisheng&#x2F;IdeaProjects&#x2F;learning&#x2F;out&#x2F;production&#x2F;learning&#x2F;com&#x2F;company&#x2F;LiuBei.class</span><br><span class="line">  Last modified 2019-12-10; size 1018 bytes</span><br><span class="line">  MD5 checksum 7133ac0c7e83a62e1081db1945bc6cf9</span><br><span class="line">  Compiled from &quot;LiuBei.java&quot;</span><br><span class="line">public class com.company.LiuBei</span><br><span class="line">  minor version: 0 &#x2F;&#x2F;次版本</span><br><span class="line">  major version: 52 &#x2F;&#x2F;主版本</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER &#x2F;&#x2F;LiuBei类的修饰符</span><br><span class="line">Constant pool: &#x2F;&#x2F;类的常量池</span><br><span class="line">   #1 &#x3D; Methodref          #3.#32         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V </span><br><span class="line">   &#x2F;&#x2F;#1表示常量池index，此处是一个Methodref类型的常量。</span><br><span class="line">   &#x2F;&#x2F;《JAVA Class文件和类加载机制》一文我们知道Methodref类型内有两个index字段，又引用了两个常量。分别表示方法所属类全限定名，以及方法描述符。</span><br><span class="line">   &#x2F;&#x2F;所以#3.#32 即为#1 &#x3D; Methodref引用了index&#x3D;3和index&#x3D;32的常量。</span><br><span class="line">   &#x2F;&#x2F;我们知道#3是Class类型，引用了#34&#x3D; java&#x2F;lang&#x2F;Object，所以其实#3就是 java&#x2F;lang&#x2F;Object的类常量。这表示#1代表的方法是 java&#x2F;lang&#x2F;Object类的方法。</span><br><span class="line">   &#x2F;&#x2F;我们知道#32是NameAndType类型常量，又引用了 #20&#x3D;&lt;init&gt;，#21&#x3D;()V，合起来就是#32存储了#1代表的方法的方法描述符。</span><br><span class="line">&#x2F;&#x2F;如此，我们得到了一个完整的Methodref，其内容记录了方法所在类的全限定名以及方法描述符。</span><br><span class="line">&#x2F;&#x2F;下面以此类推，不再赘述</span><br><span class="line"></span><br><span class="line">   #2 &#x3D; Fieldref           #15.#33        &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei.zhangFei:I</span><br><span class="line">   #3 &#x3D; Class              #34            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #4 &#x3D; Fieldref           #15.#35        &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei.guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">   #5 &#x3D; Methodref          #15.#36        &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei.shuaiErZi:()V</span><br><span class="line">   #6 &#x3D; Fieldref           #37.#38        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #7 &#x3D; Class              #39            &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">   #8 &#x3D; Methodref          #7.#32         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #9 &#x3D; Methodref          #7.#40         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #10 &#x3D; String             #41            &#x2F;&#x2F;</span><br><span class="line">  #11 &#x3D; Methodref          #7.#42         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #12 &#x3D; Methodref          #7.#43         &#x2F;&#x2F; java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #13 &#x3D; Methodref          #44.#45        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #14 &#x3D; Methodref          #3.#43         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #15 &#x3D; Class              #46            &#x2F;&#x2F; com&#x2F;company&#x2F;LiuBei</span><br><span class="line">  #16 &#x3D; Utf8               zhangFei</span><br><span class="line">  #17 &#x3D; Utf8               I</span><br><span class="line">  #18 &#x3D; Utf8               guanYu</span><br><span class="line">  #19 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">  #20 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">  #21 &#x3D; Utf8               ()V</span><br><span class="line">  #22 &#x3D; Utf8               Code</span><br><span class="line">  #23 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #24 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">  #25 &#x3D; Utf8               this</span><br><span class="line">  #26 &#x3D; Utf8               Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line">  #27 &#x3D; Utf8               shuaiErZi</span><br><span class="line">  #28 &#x3D; Utf8               shouMaiRenXin</span><br><span class="line">  #29 &#x3D; Utf8               geiWoShang</span><br><span class="line">  #30 &#x3D; Utf8               SourceFile</span><br><span class="line">  #31 &#x3D; Utf8               LiuBei.java</span><br><span class="line">  #32 &#x3D; NameAndType        #20:#21        &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #33 &#x3D; NameAndType        #16:#17        &#x2F;&#x2F; zhangFei:I</span><br><span class="line">  #34 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #35 &#x3D; NameAndType        #18:#19        &#x2F;&#x2F; guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">  #36 &#x3D; NameAndType        #27:#21        &#x2F;&#x2F; shuaiErZi:()V</span><br><span class="line">  #37 &#x3D; Class              #47            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #38 &#x3D; NameAndType        #48:#49        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #39 &#x3D; Utf8               java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">  #40 &#x3D; NameAndType        #50:#51        &#x2F;&#x2F; append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #41 &#x3D; Utf8</span><br><span class="line">  #42 &#x3D; NameAndType        #50:#52        &#x2F;&#x2F; append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #43 &#x3D; NameAndType        #53:#54        &#x2F;&#x2F; toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #44 &#x3D; Class              #55            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #45 &#x3D; NameAndType        #56:#57        &#x2F;&#x2F; printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #46 &#x3D; Utf8               com&#x2F;company&#x2F;LiuBei</span><br><span class="line">  #47 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #48 &#x3D; Utf8               out</span><br><span class="line">  #49 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #50 &#x3D; Utf8               append</span><br><span class="line">  #51 &#x3D; Utf8               (I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #52 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">  #53 &#x3D; Utf8               toString</span><br><span class="line">  #54 &#x3D; Utf8               ()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">  #55 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #56 &#x3D; Utf8               printf</span><br><span class="line">  #57 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">&#123;</span><br><span class="line">  int zhangFei;&#x2F;&#x2F;字段表，张飞这个字段，name_index指向的是常量池的#16&#x3D;zhangFei</span><br><span class="line">    descriptor: I&#x2F;&#x2F;descriptor_index指向的是常量池的#17&#x3D;I，表示类型是int</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  java.lang.Object guanYu;&#x2F;&#x2F;字段表，关羽这个字段，name_index指向的是常量池的#18&#x3D;guanYu</span><br><span class="line">    descriptor: Ljava&#x2F;lang&#x2F;Object;&#x2F;&#x2F;descriptor_index指向的是常量池的  #19&#x3D;Ljava&#x2F;lang&#x2F;Object;，表示类型是object类</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  public com.company.LiuBei();&#x2F;&#x2F;这里开始是方法表，LiuBei()是LiuBei类的默认构造器。name_index指向常量池LiuBei字面量。</span><br><span class="line">    descriptor: ()V&#x2F;&#x2F;descriptor_index指向常量池的#21 &#x3D; Utf8               ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:&#x2F;&#x2F;code属性，存储着构造器的字节码指令</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1&#x2F;&#x2F;</span><br><span class="line">         0: aload_0 </span><br><span class="line">		 &#x2F;&#x2F;从本地变量表中加载索引为0的变量的值，也即this的引用，压入栈</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">		 &#x2F;&#x2F;出栈，invokespecial表示调用方法，调用哪个方法呢，调用#1代表的java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V 方法初始化对象，就是this指定的对象的init()方法完成初始化</span><br><span class="line">         4: aload_0</span><br><span class="line">		 &#x2F;&#x2F;再一次从本地变量表中加载索引为0的变量的值，也即this的引用，压入栈</span><br><span class="line">         5: bipush        123</span><br><span class="line">		 &#x2F;&#x2F;将123常量压入栈，当int取值-128~127时,JVM采用bipush指令将常量压入操作数栈中。</span><br><span class="line">         7: putfield      #2                  &#x2F;&#x2F; Field zhangFei:I</span><br><span class="line">		 &#x2F;&#x2F; 将123赋值给zhangFei</span><br><span class="line">		 &#x2F;&#x2F;下面同理，new一个Object对象，再执行Object的&lt;init&gt;方法，然后赋值给guanyu，返回。</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: new           #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">        14: dup</span><br><span class="line">        15: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        18: putfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">        21: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">	  &#x2F;&#x2F;指令与代码行数的偏移对应关系，每一行第一个数字对应代码行数，第二个数字对应前面code中指令前面的数字</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 4</span><br><span class="line">        line 5: 10</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">	  &#x2F;&#x2F;局部变量表，start+length表示这个变量在字节码中的生命周期起始和结束的偏移位置</span><br><span class="line">	  &#x2F;&#x2F;slot就是这个变量在局部变量表中的槽位（槽位可复用），name就是变量名称，Signatur局部变量类型描述</span><br><span class="line"></span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      22     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line">&#x2F;&#x2F;下面同理，不再赘述</span><br><span class="line">  public void shuaiErZi();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;0, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       1     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line"></span><br><span class="line">  public void shouMaiRenXin();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokevirtual #5                  &#x2F;&#x2F; Method shuaiErZi:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 10: 0</span><br><span class="line">        line 11: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line"></span><br><span class="line">  public void geiWoShang();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #6                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: new           #7                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: getfield      #2                  &#x2F;&#x2F; Field zhangFei:I</span><br><span class="line">        14: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        17: ldc           #10                 &#x2F;&#x2F; String</span><br><span class="line">        19: invokevirtual #11                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        22: invokevirtual #12                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        25: iconst_0</span><br><span class="line">        26: anewarray     #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">        29: invokevirtual #13                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        32: pop</span><br><span class="line">        33: aload_0</span><br><span class="line">        34: getfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">        37: invokevirtual #14                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        40: pop</span><br><span class="line">        41: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 14: 33</span><br><span class="line">        line 15: 41</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      42     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;LiuBei.java&quot;</span><br></pre></td></tr></table></figure>

<p>看完了上面的反解析内容，我们要明白：方法表和常量池里面Methodref的区别：</p>
<ul>
<li>前者包含包括代码在内的全部方法信息，而后者充其量翻译出来，只包含了方法名+方法描述符+所在类限定名。</li>
<li>Methodref顾名思义，只是一个引用，是作为字节码的参数而存在的，如<code>invokespecial #1</code>，#1就是一个Methodref。<ul>
<li>所以我们可以看到常量池中存在Methodref=com/company/LiuBei.shuaiErZi:()V，却不存在Methodref=com/company/LiuBei.shouMaiRenXin:()V，因为shouMaiRenXin方法在刘备类的代码中没有被调用，所以它不需要一个包含它基本信息的Methodref</li>
</ul>
</li>
<li>再通俗一点比喻，刘备有技能收买人心，而收买人心技能的发动步骤中包含“大声喊出’摔儿子’三个字，同时发动自己的摔儿子技能”，所以刘备需要像记口诀一样记住“摔儿子”这三个字（即需要在常量池里有这个ref），而因为自己根本不会有喊出“收买人心”四个字的机会，所以常量池里没有必要有“收买人心”的ref。</li>
</ul>
<h1 id="4-争天下也要排练"><a href="#4-争天下也要排练" class="headerlink" title="4 争天下也要排练"></a>4 争天下也要排练</h1><p>上面终于搞懂了我们的台本（类信息）的内容，我也终于理解了罗贯中老导演写的代码到底是什么意思了。舞台剧快开始了，大家赶紧排练（类加载）吧。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>排练的第一步，我们每个演员总得拿到我们各自的台本（类信息）吧？</p>
<p>加载的过程，就是将台本纸稿（class文件）的内容导入到<strong>方法区</strong>大屏幕上的过程，这样我们每个人在排练的时候就可以像看提词器一样，偷瞄我们的设定。</p>
<p> 通过一个台本（类）的名称（全限定名），将所有需要的台本文稿（class文件）内容导入到大屏幕，可以使用的导入方式有：</p>
<ul>
<li>目前可以从zip包获取，即jar，ear，war格式的基础。</li>
<li>从网络获取，即applet实现。</li>
<li>运行时计算生成，典型如动态代理。</li>
<li>由其他文件生成，典型如JSP应用，即为JSP文件生成的class类。</li>
<li>从数据库中读取，这种较少见。</li>
</ul>
<blockquote>
<p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。并没有明确存放于要在堆中，实际上它虽然是对象，但是HotSpot虚拟机仍将其存放在方法区中。</p>
</blockquote>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是为了确保台本信息符合这个舞台剧的需求（确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全），一场三国的舞台剧，你不可以乱入一个李逵吧！</p>
<p>验证会检查格式，规范，引用的验证。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><strong>方法区</strong>大屏幕上已经显示出我们导入的台本内容了，我们可以看到上面写着刘备的一些信息，假设他有个“织席贩履”的设定（类变量），即 static String sheDing=“织席贩履”。那么我们要把这四个字摆到显眼的地方去，因为他是人尽皆知的设定（类变量），表演中被引用到的概率还是很高的。（实例变量不会在此时分配内存）</p>
<p>所以在<strong>方法区</strong>大屏幕找一个地方（分配内存），但是注意，只是留了一块空间给它，但是还没有将“织席贩履<br>四个字给写上去，所以它还只是初始值。</p>
<p>基本数据类型的初始值有这些</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7830ff0655c4438bf1d68d3ef786f834dcd.png" alt=""></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>我们之前介绍过，在台本里面存储的很多都是符号引用（全限定名，简单名称，描述符），比如我们只知道张飞和关羽这两个人的名字，类型而已，并不知道具体对应到哪一个演员。</p>
<p>解析就是将台本上的符号引用，跟真正的演员对应起来的过程。（虚拟机将常量池内的符号引用替换为直接引用的过程）</p>
<p>我们来分析一下刘备的解析过程：</p>
<p>首先，类加载器加载LiuBei这个类的信息。</p>
<p>然后，我们根据台本，知道刘备有“给我上”这个技能（真实解析顺序并非如此，但这里只是示例，逻辑是相通的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void geiWoShang()&#123;&#x2F;&#x2F;给我上</span><br><span class="line">		System.out.printf(zhangFei+&quot;&quot;);</span><br><span class="line">		guanYu.toString();&#x2F;&#x2F;嘛，就让关张二人随便丢了个技能,Object类嘛，就toString一下。</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>geiWoShang方法的完整信息，存在方法表集合中（记录了各种修饰符，字段类型，和字段名称，以及各种属性）。</p>
<blockquote>
<p>我们看上文的反编译信息可以看到，常量池中存在shuaiErZi方法的Methodref，那么同样是刘备的方法，为什么常量池中没有geiWoShang方法的Methodref呢？我们要记住，只有作为字节码参数的目标（方法，或者字段），才有必要在常量池中放置他们的引用。shuaiErZi方法被shouMaiRenXin方法引用，所以有shuaiErZi方法的Methodref。</p>
</blockquote>
<p>方法表长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void geiWoShang();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;3, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #6                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: new           #7                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">         6: dup</span><br><span class="line">         7: invokespecial #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        10: aload_0</span><br><span class="line">        11: getfield      #2                  &#x2F;&#x2F; Field zhangFei:I</span><br><span class="line">        14: invokevirtual #9                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(I)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        17: ldc           #10                 &#x2F;&#x2F; String</span><br><span class="line">        19: invokevirtual #11                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        22: invokevirtual #12                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        25: iconst_0</span><br><span class="line">        26: anewarray     #3                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Object</span><br><span class="line">        29: invokevirtual #13                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.printf:(Ljava&#x2F;lang&#x2F;String;[Ljava&#x2F;lang&#x2F;Object;)Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">        32: pop</span><br><span class="line">        33: aload_0</span><br><span class="line">        34: getfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">        37: invokevirtual #14                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">        40: pop</span><br><span class="line">        41: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 14: 33</span><br><span class="line">        line 15: 41</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      42     0  this   Lcom&#x2F;company&#x2F;LiuBei;</span><br></pre></td></tr></table></figure>

<p>其中有一个属性叫做code，里面的内容就是方法体代码的字节码，它长这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ...</span><br><span class="line">33: aload_0</span><br><span class="line">34: getfield      #4                  &#x2F;&#x2F; Field guanYu:Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">37: invokevirtual #14                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.toString:()Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">40: pop</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>是的，我们忽略其他，只看调用了<code>guanYu.toString();</code>来作为例子。</p>
<p><code>getfield      #4</code>表示将常量池第四项压入栈。好，常量池第4项还没被解析，那么我们要向解析geiWoShang方法的code，就得先解析常量池第四项。</p>
<p>常量池第四项是啥呢，是个Fieldref，对，是关羽这个字段的Fieldref。</p>
<p>结构抽象后大概是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Fieldref&#123;</span><br><span class="line">	Class&#123;</span><br><span class="line">		index&#x3D;&quot;com&#x2F;company&#x2F;LiuBei&quot;;index指向的是常量池的  #15&#x3D;com&#x2F;company&#x2F;LiuBei;，表示关羽字段是属于LiuBei类的字段。</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameAndType&#123;</span><br><span class="line">		name_index&#x3D;&quot;guanYu&quot;;&#x2F;&#x2F;字段表，关羽这个字段，指向的是常量池的#18&#x3D;guanYu</span><br><span class="line">		descriptor_index&#x3D;&quot;Ljava&#x2F;lang&#x2F;Object&quot;;&#x2F;&#x2F;descriptor_index指向的是常量池的  #19&#x3D;Ljava&#x2F;lang&#x2F;Object;，表示关羽字段的类型是object类</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析字段，前提是它所属的类要被加载，我们根据Fieldref的Class_info知道他所属的类是LiuBei，这个已经加载过了，那忽略。（否则，就进入了别的类的加载过程，即用刘备类的加载器区加载别的类。）</p>
<p>然后根据Fieldref的name_index和descriptor_index得到该字段的名称和描述符，去所属类LiuBei的字段表中寻找名称和描述符完全一致的字段。好，找到了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object guanYu;&#x2F;&#x2F;字段表，关羽这个字段，name_index指向的是常量池的#18&#x3D;guanYu</span><br><span class="line">  descriptor: Ljava&#x2F;lang&#x2F;Object;&#x2F;&#x2F;descriptor_index指向的是常量池的  #19&#x3D;Ljava&#x2F;lang&#x2F;Object;，表示类型是object类</span><br><span class="line">  flags:</span><br></pre></td></tr></table></figure>

<p><strong>那么把关羽这个字段表在刘备类中的偏移量当做直接引用，覆盖常量池的第四项，即#4=关羽这个字段表在刘备类中的偏移量</strong>，关羽字段解析完毕，做个标记，解析完成。</p>
<p>这样下次执行<code>getfield      #4</code>时，#4直接指向了关羽字段表的直接引用。</p>
<p>同理，我们接下来解析<code>invokevirtual #14</code>，表示调用#14指向的示例方法。</p>
<p>常量池中#14 = Methodref长这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Methodref&#123;</span><br><span class="line">	Class&#123;</span><br><span class="line">		index&#x3D;&quot;java&#x2F;lang&#x2F;Object&quot;;index指向的是常量池的  #3&#x3D;java&#x2F;lang&#x2F;Object;，表示该方法是Object的方法。</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	NameAndType&#123;</span><br><span class="line">		name_index&#x3D;&quot; toString&quot;;&#x2F;&#x2F;指向的是常量池的#53&#x3D;toString，表示名称</span><br><span class="line">		descriptor_index&#x3D;&quot;()Ljava&#x2F;lang&#x2F;String&quot;;&#x2F;&#x2F;descriptor_index指向的是常量池的  #54&#x3D;()Ljava&#x2F;lang&#x2F;String;，表示方法描述符</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，先解析所属的Object类，哦，也加载过了。</p>
<p>那么根据名称和描述符，去Object类的方法表中找到toString方法的偏移量，然后赋值给常量池第十四项。</p>
<p>以此类推，完成所有类的符号引用向直接引用的转变。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。<strong>给类变量赋初值</strong>，此时“织席贩履”可以赋值在之前留出的空间上了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/" itemprop="url">理解sql中的group by和having</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-06T22:22:26+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/" itemprop="url" rel="index">
                    <span itemprop="name">SQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/06/理解sql中的group-by和having/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>group by的可以帮助我们在特定场景下查询到我们需要的数据，但group by的用法一直给人一种“飘忽”感，究其原因，还是对于该关键字缺乏深入理解。</p>
<p>下面通过一个例子，来简单解释group by的原理。</p>
<h1 id="1-GROUP-BY"><a href="#1-GROUP-BY" class="headerlink" title="1. GROUP BY"></a>1. GROUP BY</h1><p>假设我们有表1，表名为test：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f560d6cf443d0db4819d8937d7578ea7c68.png" alt=""></p>
<p>如果我们执行如下SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM test GROUP BY name</span><br></pre></td></tr></table></figure>

<p>我们很容易可以得到运行的结果：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9551ddc4e56b11de88135ebbd526595cc93.png" alt=""></p>
<p>为了能够更好的理解“group by”多个列“和”聚合函数“的应用，这里可以在表1到表2的过程中，引入一个虚构的中间表：虚拟表3。</p>
<p>FROM test Group BY name：该句执行后，我们想象生成了虚拟表3，如下所图所示：</p>
<p>生成过程是这样的：group by name，那么找name那一列，具有相同name值的行，合并成一行，如对于name值为aa的，那么&lt;1 aa 2&gt;与&lt;2 aa 3&gt;两行合并成1行，所有的id值和number值写到一个单元格里面。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-edcd036013105bd3619a93114d35d78963c.png" alt=""></p>
<p>接下来再针对虚拟表3执行Select语句：</p>
<ol>
<li><p>如果执行<code>select *</code>的话，那么返回的结果应该是虚拟表3，可是id和number中有的单元格里面的内容是多个值的，而关系数据库就是基于关系的，单元格中是不允许有多个值的，所以，执行<code>select *</code> 语句是不允许的。</p>
<ul>
<li><blockquote>
<p>为了约束使用者在编写group by时select多值字段，设计DBMS的开发者也是伤透了脑筋。开发者并不知道将来这个数据库会被用来做什么，所以，他不可能从逻辑上来检查你的select上出现的语句是不是分组属性的一个子集。所以，最简单的方法就是看你的select上出现的属性在group by上出现过。出现过，就通过编译，否则不会。</p>
</blockquote>
</li>
<li><blockquote>
<p>mysql对group by 进行了非ANSI标准的扩展，允许select后含有非group by 的列。所以在mysql中，group by时执行<code>select *</code>不会报错 ，但也得不到我们想要的数据，只会select出原表中的第一个数据</p>
</blockquote>
</li>
</ul>
</li>
<li><p>我们再看name列，每个单元格只有一个数据，所以我们select name的话，就没有问题了。为什么name列每个单元格只有一个值呢，因为我们就是用name列来group by的。</p>
</li>
<li><p>那么对于id和number里面的单元格有多个数据的情况怎么办呢？答案就是用聚合函数，聚合函数就用来输入多个数据，输出一个数据的。如cout(id)，sum(number)，而每个聚合函数的输入就是每一个多数据的单元格。</p>
<ul>
<li>例如我们执行select name,sum(number) from test group by name，那么sum就对虚拟表3的number列的每个单元格进行sum操作，例如对name为aa的那一行的number列执行sum操作，即2+3，返回5，最后执行结果如下：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-3f894207fcec5efe321e2b909f0792ae5f8.png" alt=""></li>
</ul>
</li>
<li><p>group by 多个字段该怎么理解呢：如group by name,number，我们可以把name和number 看成一个整体字段，以他们整体来进行分组的。如下图</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-1489c508db4ee297aa099d9397969eb9e95.png" alt=""></li>
<li>接下来就可以配合select和聚合函数进行操作了。如执行select name,sum(id) from test group by name,number，结果如下图：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-6a3e63a11874a6f61681dcc8e09acd69bf2.png" alt="">- </li>
</ul>
</li>
</ol>
<h1 id="2-HAVING"><a href="#2-HAVING" class="headerlink" title="2. HAVING"></a>2. HAVING</h1><blockquote>
<p><strong>首先，不要错误的认为having必须和group by 配合使用。其实having可以单独使用</strong></p>
</blockquote>
<p>having关键字在我们的印象中，貌似和where关键字十分相似，那二者有什么区别呢？</p>
<ol>
<li>含义：<ul>
<li>“Where”是一个约束声明，在查询数据库的结果返回结果之前对数据库中的查询条件进行约束，<strong>即在结果返回之前起作用</strong>，且where后面不能使用“聚合函数”；<ul>
<li>where后面之所以不能使用聚合函数是因为where的执行顺序在聚合函数之前，所以在执行where的时候，还没有结果集，更别说对结果集做聚合了。</li>
</ul>
</li>
<li>Having”是一个过滤声明，所谓过滤是在查询数据库的结果返回之后进行过滤，<strong>即在结果返回之后起作用</strong>，并且having后面可以使用“聚合函数”。<ul>
<li>having既然是对查出来的结果进行过滤，那么就不能对没有select出来的字段使用having，如<code>select  id , name from student having score &gt;90;</code>这句话就是错误的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>where和having，一个是起作用在结果返回前，用来过滤记录；一个是起作用在结果返回后，用来过滤结果。这种场景的典型应用如这句：<code>SELECT region,count(school) FROM T02_Bejing_school WHERE region IN (&#39;海淀&#39; , &#39;西城&#39; , &#39;东城&#39;) GROUP BY region HAVING count(school) &gt; 10;</code>该句sql可以筛选出北京西城、东城、海淀三个区中学校数量超过10所的区及各区学校数量。即先用where把这三个区的中学过滤出来，然后对结果集做group by，得到一张组合后的虚拟表，最后通过having对虚拟表做二次过滤。</p>
</blockquote>
<ol start="2">
<li>使用的场景：<ul>
<li>只有WHERE可以使用的场景：<ul>
<li>除select外，where还可以用于update、delete和insert into values(select * from table where ..)语句中，having则不行。</li>
<li>select语句中，没有select出要被约束的字段的时候，也不可以使用having。就如上文提到的非法语句：<code>select  id , name from student having score &gt;90;</code></li>
</ul>
</li>
<li>只有HAVING可以使用的场景：<ul>
<li>如果要过滤的字段是原生表中不存在的字段，而是经过聚合函数计算后的字段，那么不可以使用where，只能用having。如：<ul>
<li>合法语句：<code>select id , avg(price) as ag from goods group by category having ag &gt; 1000</code><ul>
<li>非法语句：<code>select id , avg(price) as ag from goods where ag group by category &gt; 1000</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>二者都可以使用的场景：<ul>
<li>要约束的字段既是原生表的字段，又是sql中被select出来的字段，这时候where和having等效：<ul>
<li><code>select price , name from goods where price &gt; 100</code></li>
<li><code>select price , name from goods having price &gt; 100</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://blog.csdn.net/hao1066821456/article/details/69556644" target="_blank" rel="noopener" title="理解group by">理解group by</a></li>
<li><a href="https://blog.csdn.net/suliangkuanjiayou/article/details/94337233" target="_blank" rel="noopener" title="Group by的理解">Group by的理解</a></li>
<li><a href="https://blog.csdn.net/yexudengzhidao/article/details/54924471" target="_blank" rel="noopener" title="正确理解MySQL中的where和having的区别">正确理解MySQL中的where和having的区别</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/06/MySQL%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/06/MySQL%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/" itemprop="url">MySQL核心要点汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-06T21:18:34+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/05/06/MySQL%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/05/06/MySQL核心要点汇总/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  11.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  43
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1. 相关概念"></a>1. 相关概念</h1><h2 id="1-1-内-外-全联接"><a href="#1-1-内-外-全联接" class="headerlink" title="1.1 内/外/全联接"></a>1.1 内/外/全联接</h2><p>假设有两张表，一张本校的校友信息表 t1，一张两院院士信息表 t2，使用二者的身份证号码（ID字段）来关联（即<code>t1.ID=t2.ID</code>）。</p>
<ul>
<li>内联接：在两张表进行连接查询时，只保留两张表中完全匹配的结果集。<ul>
<li><code>select .... from t1 inner join t2 on t1.ID=t2.ID</code></li>
<li>结果是只保留既是本校校友，又是两院院士的人的信息。</li>
</ul>
</li>
<li>外联接：分为左联接和右联接两种<ol>
<li>左联接：在两张表进行连接查询时，会返回左表所有的行，即使左表在右表中没有匹配的记录。<ul>
<li><code>select .... from t1 left (outer) join t2 on t1.ID=t2.ID</code></li>
<li>结果是返回全部本校校友的记录，部分校友可能同时是院士，其他大部分校友，t2表的相关字段值都为null。</li>
</ul>
</li>
<li>右联接：在两张表进行连接查询时，会返回右表所有的行，即使右表在左表中没有匹配的记录。<ul>
<li><code>select .... from t1 right (outer) join t2 on t1.ID=t2.ID</code></li>
<li>结果是返回全部两院院士的记录，部分院士可能是我校校友，其他大部分院士，t1表的相关字段值都为null。</li>
</ul>
</li>
</ol>
</li>
<li>全联接：在两张表进行连接查询时，返回左表和右表中所有的行（即便没有匹配）。<ul>
<li><code>select .... from t1 full join t2 on t1.ID=t2.ID</code></li>
<li>结果是返回本校校友+两院院士所有人的记录（当然会去重）。</li>
<li>其实也就是left join和right join的并集。</li>
</ul>
</li>
</ul>
<blockquote>
<p>单纯的<code>select * from a,b</code>是笛卡尔乘积。比如a表有5条数据，b表有3条数据，那么最后的结果有5*3=15条数据。但是如果对两个表进行关联:<code>select * from a,b where a.id = b.id</code>意思就变了，此时就等价于：<code>select * from a inner join b on a.id = b.id</code>。即就是内连接。但是这种写法并不符合规范，可能只对某些数据库管用，如sqlserver。推荐最好不要这样写。最好写成inner join的写法。</p>
</blockquote>
<h2 id="1-2-drop、delete与truncate的区别"><a href="#1-2-drop、delete与truncate的区别" class="headerlink" title="1.2 drop、delete与truncate的区别"></a>1.2 drop、delete与truncate的区别</h2><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p>
<ol>
<li>delete和truncate只删除表的数据不删除表的结构，drop都删除。</li>
<li>一般来说，执行速度方面是 drop&gt; truncate &gt;delete</li>
<li>delete语句是dml，这个操作会放到rollback segement中，事务提交之后才生效; 如果有相应的trigger，执行的时候将被触发。</li>
<li>truncate、drop是ddl，操作立即生效，原数据不放到rollback segment中，不能回滚.。操作不触发trigger.</li>
</ol>
<h2 id="1-3-数据并发问题"><a href="#1-3-数据并发问题" class="headerlink" title="1.3 数据并发问题"></a>1.3 数据并发问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ol>
<li><p><strong>脏读（Dirty read）</strong>:</p>
<ul>
<li>针对同一个字段，一个事务（假设事务A）读到了另一个的事务（假设事务B）提交前的数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。</li>
</ul>
</li>
<li><p><strong>丢失修改（Lost to modify）</strong>:</p>
<ul>
<li>指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 </li>
<li>例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
</ul>
</li>
<li><p><strong>不可重复读（Unrepeatableread）</strong>:</p>
<ul>
<li>一般发生在一个事务要在事务内读取一个字段多次的场景。</li>
<li>事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据和第一次读取的时候不一样了，就是所谓的不可重复读了。</li>
</ul>
</li>
<li><p><strong>幻读（Phantom read）</strong>:</p>
<ul>
<li>幻读与不可重复读类似。也发生在一个事务在事务内部针对某些记录多次查询的情况。</li>
<li>例如在一个事务（A）读取了几行数据，接着另一个并发事务（B）插入并提交了一些数据，并且这些数据符合事务A的where条件时。在第二次的查询中，事务（A）就会发现相比第一次查询，第二次多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
</li>
</ol>
<p>不可重复读和幻读两者有些相似，他们的区别是：<br>|  不可重复读 | 幻读  |<br>| ———— | ———— |<br>| 针对的是update或delete  | 针对的是insert  |<br>| 重点是修改:同样的条件, 你读取过的数据, 再次读取出来发现值不一样了  | 重点在于新增或者删除 (数据条数变化)：同样的条件, 第1次和第2次读出来的记录数不一样  |</p>
<h2 id="1-4-事务隔离级别"><a href="#1-4-事务隔离级别" class="headerlink" title="1.4 事务隔离级别"></a>1.4 事务隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p>
<ol>
<li>READ-UNCOMMITTED(读未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-6c4f27430f3b074f1f7eef3e2f7b7ef121e.png" alt=""></p>
<blockquote>
<p>MySQL InnoDB 存储引擎的默认的隔离级别是 REPEATABLE-READ（可重复读）。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看</p>
</blockquote>
<p>我们知道隔离级别越低，事务请求的锁越少，并发效率越高，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读） 并不会有任何性能损失。</p>
<p>与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是<strong>Next-Key Lock 锁算法</strong>，<strong>因此可以避免幻读的产生</strong>，这与其他数据库系统(如 SQL Server) 是不同的。</p>
<p>所以说InnoDB 存储引擎的默认的隔离级别是 REPEATABLE-READ（可重读） <strong>已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别</strong>。</p>
<h1 id="2-数据库设计的三范式"><a href="#2-数据库设计的三范式" class="headerlink" title="2 数据库设计的三范式"></a>2 数据库设计的三范式</h1><h2 id="2-1-第一范式（1NF）"><a href="#2-1-第一范式（1NF）" class="headerlink" title="2.1 第一范式（1NF）"></a>2.1 第一范式（1NF）</h2><p>1NF是对属性的原子性，要求每一列（或者叫字段，属性）具有原子性，不可再分解；</p>
<p>如</p>
<p><code>学生表（学号，姓名，性别，生日）</code></p>
<p>如果认为最后一列还可以再分成（出生年，出生月，出生日），它就不满足第一范式了；</p>
<h2 id="2-2-第二范式（2NF）"><a href="#2-2-第二范式（2NF）" class="headerlink" title="2.2 第二范式（2NF）"></a>2.2 第二范式（2NF）</h2><blockquote>
<p>第二范式是指在满足第一范式的条件下，除主键外的每一列都完全依赖于主键（主要针对于<strong>联合主键</strong>而言）。</p>
</blockquote>
<p>2NF是对记录的惟一性，要求记录有惟一标识，即实体的惟一性，即不存在部分依赖；</p>
<p>举个反例：</p>
<p><code>表（学号、课程号、姓名、学分） 联合主键为学号和课程号</code></p>
<p>这个表明显涵盖了两个信息主体：</p>
<ol>
<li>学生信息：学号和姓名字段属于学生信息，且姓名依赖于学号（学生信息的唯一标识）</li>
<li>课程信息：课程号和学分字段属于课程信息，学分依赖课程号（课程信息的唯一标识）。</li>
</ol>
<p>姓名由学号即可唯一标识，是对主键的部分依赖；<br>学分由课程号即可唯一标示，是对主键的部分依赖；</p>
<p>由于2NF要求<strong>非主键字段必须完全依赖主键</strong>，所以不符合二范式。<br>可能会存在问题：</p>
<ul>
<li>数据冗余:，每条记录都含有相同信息；</li>
<li>删除异常：删除所有学生成绩，就把课程信息全删除了；</li>
<li>插入异常：学生未选课，无法记录进数据库；</li>
<li>更新异常：调整课程学分，所有行都调整。</li>
</ul>
<p>正确做法:</p>
<ul>
<li>学生表：Student(学号, 姓名)；</li>
<li>课程表：Course(课程号, 学分)；</li>
<li>选课关系表：StudentCourse(学号, 课程号, 成绩)。</li>
</ul>
<h2 id="2-3-第三范式（3NF）"><a href="#2-3-第三范式（3NF）" class="headerlink" title="2.3 第三范式（3NF）"></a>2.3 第三范式（3NF）</h2><blockquote>
<p>  第三范式是指在满足第二范式的基础上，每一条数据不能依赖于其他的非主属性，也就是消除了传递依赖关系。</p>
</blockquote>
<p>3NF是对字段的冗余性，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即不存在传递依赖；</p>
<p>例如</p>
<p><code>表（学号, 姓名, 年龄, 学院名称, 学院电话）</code></p>
<p>因为存在依赖传递: (学号) → (学生)→(所在学院) → (学院电话) 。</p>
<p>可能会存在问题：</p>
<ul>
<li>数据冗余:有重复值；</li>
<li>更新异常：有重复的冗余信息，修改时需要同时修改多条记录，否则会出现数据不一致的情况</li>
</ul>
<p>正确做法：</p>
<ul>
<li>学生：(学号, 姓名, 年龄, 所在学院)；</li>
<li>学院：(学院, 电话)。</li>
</ul>
<h2 id="2-4-反范式化"><a href="#2-4-反范式化" class="headerlink" title="2.4 反范式化"></a>2.4 反范式化</h2><p>一般说来，数据库只需满足第三范式（3NF）就行了。没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。达到以空间换时间的目的。</p>
<p>比如：有一张存放商品的基本表，“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</p>
<h1 id="3-MySql存储引擎简述"><a href="#3-MySql存储引擎简述" class="headerlink" title="3. MySql存储引擎简述"></a>3. MySql存储引擎简述</h1><p>简单来说，存储引擎就是指表的类型以及表在计算机上的存储方式。</p>
<p>存储引擎的概念是MySQL的特点，Oracle中没有专门的存储引擎的概念，Oracle有OLTP和OLAP模式的区分。不同的存储引擎决定了MySQL数据库中的表可以用不同的方式来存储。我们可以根据数据的特点来选择不同的存储引擎。</p>
<p>在MySQL中的存储引擎有很多种，可以通过<code>mysql&gt; show engines;</code>语句来查看。下面重点关注InnoDB、MyISAM、MEMORY这三种。</p>
<h2 id="3-1-InnoDB引擎"><a href="#3-1-InnoDB引擎" class="headerlink" title="3.1 InnoDB引擎"></a>3.1 InnoDB引擎</h2><p>MySQL默认的<strong>事务型</strong>引擎，也是最重要和使用最广泛的存储引擎。在MySQL从3.23.34a版本开始包含InnnoDB。</p>
<p>InnoDB给MySQL的表提供了<strong>事务处理、回滚、崩溃修复能力和多版本并发控制</strong>的事务安全。它是MySQL上<strong>第一个提供外键约束的存储引擎</strong>。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。</p>
<p>InnoDB的性能与<strong>自动崩溃恢复</strong>的特性，使得它在非事务存储需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该<strong>优先考虑InnoDB引擎</strong>。</p>
<h2 id="3-2-MyISAM引擎"><a href="#3-2-MyISAM引擎" class="headerlink" title="3.2 MyISAM引擎"></a>3.2 MyISAM引擎</h2><p>在MySQL 5.1 及之前的版本，MyISAM是默认引擎。MyISAM提供的大量的特性，包括<strong>全文索引</strong>、<strong>压缩</strong>、空间函数（GIS）等，但MyISAM并<strong>不支持事务以及行级锁</strong>，而且一个毫无疑问的缺陷是<strong>崩溃后无法安全恢复</strong>。正是由于MyISAM引擎的缘故，即使MySQL支持事务已经很长时间了，在很多人的概念中MySQL还是非事务型数据库。尽管这样，它并不是一无是处的。对于只读的数据，或者表比较小，可以忍受修复操作，则依然可以使用MyISAM（但请不要默认使用MyISAM，而是应该默认使用InnoDB）</p>
<h2 id="3-3-MEMORY引擎"><a href="#3-3-MEMORY引擎" class="headerlink" title="3.3 MEMORY引擎"></a>3.3 MEMORY引擎</h2><p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且<strong>数据全部放在内存中</strong>。这些特性与前面的两个很不同。</p>
<p>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p>
<p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p>
<p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p>
<h2 id="3-4-如何合适的选择存储引擎"><a href="#3-4-如何合适的选择存储引擎" class="headerlink" title="3.4 如何合适的选择存储引擎"></a>3.4 如何合适的选择存储引擎</h2><p><img src="https://oscimg.oschina.net/oscnet/up-3127dd066a45c9fa1de2c57f273d5d0df6b.png" alt=""></p>
<ul>
<li><p>有以下要求，则适合采用InnoDB：</p>
<ul>
<li>需要对事务的完整性要求比较高（比如银行）</li>
<li>要求实现并发控制（比如售票）</li>
<li>如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 </li>
</ul>
</li>
<li><p>有以下要求，则适合采用MyISAM：</p>
<ul>
<li>如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。</li>
<li>如果应用对数据的完整性、并发性要求比较低，也可以使用。</li>
</ul>
</li>
<li><p>有以下要求，则适合采用MEMORY：</p>
<ul>
<li>如果需要很快的读写速度，对数据的安全性要求较低，且数据量很小时，可以选择MEMOEY。</li>
</ul>
</li>
</ul>
<h2 id="3-5-MyISAM与InnoDB区别"><a href="#3-5-MyISAM与InnoDB区别" class="headerlink" title="3.5 MyISAM与InnoDB区别"></a>3.5 MyISAM与InnoDB区别</h2><table>
<thead>
<tr>
<th>项目</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>存储结构</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</td>
<td>每个MyISAM在磁盘上存储成三个文件。分别为：表定义文件、数据文件、索引文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。</td>
</tr>
<tr>
<td>存储空间</td>
<td>需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</td>
<td>MyISAM支持支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。当表在创建之后并导入数据之后，不会再进行修改操作，可以使用压缩表，极大的减少磁盘的空间占用。</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</td>
<td>数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。</td>
</tr>
<tr>
<td>事务支持</td>
<td>提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</td>
<td>强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</td>
<td>可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。</td>
</tr>
<tr>
<td>锁</td>
<td>支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE中指定主键是有效的，非主键的WHERE都会锁全表的。</td>
<td>只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</td>
</tr>
<tr>
<td>全文索引</td>
<td>原来不支持FULLTEXT类型的全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好。后来从InnoDB1.2.x版本（MySQL 5.6版本）起，InnoDB存储引擎开始支持全文索引</td>
<td>支持 FULLTEXT类型的全文索引</td>
</tr>
<tr>
<td>表主键</td>
<td>如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</td>
<td>允许没有任何索引和主键的表存在，索引都是保存行的地址。</td>
</tr>
<tr>
<td>表的具体行数</td>
<td>没有保存表的总行数，如果使用<code>select count(*) from table；</code>就会遍历整个表，消耗相当大，但是在加了where条件后，myisam和innodb处理的方式都一样。</td>
<td>保存有表的总行数，如果<code>select count(*) from table;</code>会直接取出出该值。</td>
</tr>
<tr>
<td>CRUD操作</td>
<td>如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。</td>
<td>如果执行大量的SELECT，MyISAM是更好的选择。</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h1 id="4-MySql索引"><a href="#4-MySql索引" class="headerlink" title="4. MySql索引"></a>4. MySql索引</h1><p>我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。</p>
<p>在数据之外，数据库系统维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-289e357d2d12e60c93f6e63fcbcc69877e1.png" alt=""></p>
<p>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。</p>
<p>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<blockquote>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p>
</blockquote>
<h2 id="4-1-索引的优缺点"><a href="#4-1-索引的优缺点" class="headerlink" title="4.1 索引的优缺点"></a>4.1 索引的优缺点</h2><p>优点：</p>
<ul>
<li>可以快速检索，减少I/O次数，加快检索速度；</li>
<li>根据索引分组和排序，可以加快分组和排序；</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引本身也是表，因此会占用存储空间，一般来说，索引表占用的空间的数据表的1.5倍；</li>
<li>索引表的维护和创建需要时间成本，这个成本随着数据量增大而增大；</li>
<li>构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；</li>
</ul>
<h2 id="4-2-索引的分类"><a href="#4-2-索引的分类" class="headerlink" title="4.2 索引的分类"></a>4.2 索引的分类</h2><h3 id="4-2-1-按类型分类"><a href="#4-2-1-按类型分类" class="headerlink" title="4.2.1 按类型分类"></a>4.2.1 按类型分类</h3><ol>
<li>聚集索引<ul>
<li>主键索引；<ul>
<li>数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li>
</ul>
</li>
</ul>
</li>
<li>二级索引（又称辅助索引、非聚簇索引）<ul>
<li>唯一索引；<ul>
<li>约束数据列不允许重复，允许为NULL值</li>
<li>一个表允许组合多个列创建唯一索引，这时约束的是：不同记录，被唯一索引约束的这多个列不能让完全相同</li>
</ul>
</li>
<li>普通索引（又叫辅助索引）；<ul>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</li>
<li>会对该列创建索引。</li>
</ul>
</li>
<li>组合索引(又称联合索引，复合索引)；<ul>
<li>即普通索引的多字段版本</li>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</li>
<li>如下图，可以理解成把几个字段拼接起来的一个普通索引</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-c7dcce083913fdfd6536e40ec10b13ade5f.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-2-2-按按数据结构分类"><a href="#4-2-2-按按数据结构分类" class="headerlink" title="4.2.2 按按数据结构分类"></a>4.2.2 按按数据结构分类</h3><ul>
<li>BTree索引<ul>
<li>下文详解</li>
</ul>
</li>
<li>B+Tree索引；<ul>
<li>下文详解</li>
</ul>
</li>
<li>哈希索引；<ul>
<li>只有memory存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存储该值所在行数据的物理位置。</li>
<li>因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</li>
</ul>
</li>
<li>全文索引；<ul>
<li>通过建立倒排索引来实现，查询效率比like有很大提升。</li>
<li>5.6版本前的MySQL自带的全文索引只能用于MyISAM存储引擎，如果是其它数据引擎，那么全文索引不会生效。5.6版本之后InnoDB存储引擎开始支持全文索引</li>
<li>在MySQL中，全文索引支队英文有用，目前对中文还不支持。5.7版本之后通过使用ngram插件开始支持中文。</li>
</ul>
</li>
</ul>
<h3 id="4-2-3-聚簇索引和非聚簇索引的区别（针对InnoDB）"><a href="#4-2-3-聚簇索引和非聚簇索引的区别（针对InnoDB）" class="headerlink" title="4.2.3 聚簇索引和非聚簇索引的区别（针对InnoDB）"></a>4.2.3 聚簇索引和非聚簇索引的区别（针对InnoDB）</h3><p>假设我们有如下表</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b04827a8539b202102f96172b5913a65965.png" alt=""></p>
<p>mysql对ID生成了聚簇索引，我们再对k字段生成普通索引（非聚簇），如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3fcb682ce6c4f03d0698881525f3c32f251.png" alt=""></p>
<blockquote>
<p><strong>其中R代表一整行的记录</strong>。</p>
</blockquote>
<p>从图中不难看出，聚簇索引和非聚簇索引的区别是：非聚簇索引的叶子节点存放的是<strong>主键的值</strong>，而聚簇索引的叶子节点存放的是<strong>整行数据</strong>。</p>
<p>根据这两种结构我们来进行下查询，看看他们在查询上有什么区别。</p>
<ol>
<li><p>如果查询语句是 select * from table where ID = 100，即主键查询的方式，则只需要搜索 ID 这棵 B+树。</p>
</li>
<li><p>如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100，再到ID索引树搜索一次，这个过程也被称为<strong>回表</strong>。</p>
</li>
</ol>
<blockquote>
<p>回表是非常重要的概念，需要敲黑板划重点记住。其过程就如下图所示：<br><img src="https://oscimg.oschina.net/oscnet/up-f8dece791a80588e740e4bad6e8cccc607f.png" alt=""></p>
</blockquote>
<blockquote>
<p>什么非主键索引结构叶子节点存储的是主键值？<br>一是保证一致性，更新数据的时候只需要更新主键索引树，二是节省存储空间。</p>
</blockquote>
<h3 id="4-2-4-为什么建议使用主键自增的索引"><a href="#4-2-4-为什么建议使用主键自增的索引" class="headerlink" title="4.2.4 为什么建议使用主键自增的索引"></a>4.2.4 为什么建议使用主键自增的索引</h3><p>自增的主键，插入到索引的时候，直接在最右边插入就可以了</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d26d47c59b00d24a6bf8efc2fc3cf99d5bd.png" alt=""></p>
<p>但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间，如果刚好 R4 所在的数据页已经满了，需要进行页分裂操作，这样会更加糟糕。</p>
<p>所以使用自增主键，每次插入的 ID 都会比前面的大，那么就可以避免这种情况。</p>
<h2 id="4-3-索引的数据结构"><a href="#4-3-索引的数据结构" class="headerlink" title="4.3 索引的数据结构"></a>4.3 索引的数据结构</h2><p>索引的数据结构，常见的是B树和B+树，MySql的索引使用的是B+树，关于B树一家子的分析，可以详见下文：<a href="https://my.oschina.net/lscherish/blog/4257330" target="_blank" rel="noopener" title="B树/B+树分析">B树/B+树分析</a></p>
<p>不过虽然都是使用B+树来做数据结构，但在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的（不过至少都是B+树）。</p>
<h3 id="4-3-1-MyISAM索引实现"><a href="#4-3-1-MyISAM索引实现" class="headerlink" title="4.3.1 MyISAM索引实现"></a>4.3.1 MyISAM索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，<strong>其主键索引和普通索引在结构上没有区别</strong>，叶节点的data域存放的是数据记录的地址。</p>
<h4 id="4-3-1-1-MyISAM主键索引"><a href="#4-3-1-1-MyISAM主键索引" class="headerlink" title="4.3.1.1 MyISAM主键索引"></a>4.3.1.1 MyISAM主键索引</h4><p>如下图，这时一个针对主键col1字段的索引结构图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-95589fff5abe03cb617fecfdc3bb7ca40e7.png" alt=""></p>
<p>可以看出MyISAM的索引文件仅仅保存数据记录的地址。</p>
<h4 id="4-3-1-2-MyISAM普通索引"><a href="#4-3-1-2-MyISAM普通索引" class="headerlink" title="4.3.1.2 MyISAM普通索引"></a>4.3.1.2 MyISAM普通索引</h4><p>在MyISAM中，主索引和普通索引（Secondary key）在结构上没有任何区别，<strong>只是主索引要求key是唯一的</strong>，而普通索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-cf329acb011c774d082ce93aff5943de24e.png" alt=""></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>发现没有？MyISAM的索引方式，跟我们上文说的非聚簇索引十分相像（一个是存放id，一个是存放地址）。所以MyISAM索引的实现方式是非聚簇索引。</p>
<h3 id="4-3-2-InnoDB索引实现"><a href="#4-3-2-InnoDB索引实现" class="headerlink" title="4.3.2 InnoDB索引实现"></a>4.3.2 InnoDB索引实现</h3><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。对，InnoDB的索引是聚簇式的：<strong>InnoDB的数据文件本身就是索引文件</strong>，树的叶节点data域保存了完整的数据记录。</p>
<h4 id="4-3-2-1-InnoDB主键索引实现"><a href="#4-3-2-1-InnoDB主键索引实现" class="headerlink" title="4.3.2.1 InnoDB主键索引实现"></a>4.3.2.1 InnoDB主键索引实现</h4><p>我们先来看 InnoDB的主键索引，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0febdd2fe5f4a8e1b6fb2682691f1809eef.png" alt=""></p>
<blockquote>
<p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
</blockquote>
<h4 id="4-3-2-2-InnoDB普通索引实现"><a href="#4-3-2-2-InnoDB普通索引实现" class="headerlink" title="4.3.2.2 InnoDB普通索引实现"></a>4.3.2.2 InnoDB普通索引实现</h4><p>在MyISAM中主索引和普通索引（Secondary key）在结构上没有任何区别，但InnoDB中，普通索引和主键索引是不同的，前文我们也介绍过，InnoDB的普通索引是非聚簇式的。</p>
<p>例如，图11为定义在Col3上的一个辅助索引：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e8635aba2790f0fd15594ce95bfb1dc97da.png" alt=""></p>
<p>图中的15,18这些数字，就是col3所对应的<strong>主键值</strong>，普通索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<blockquote>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
</blockquote>
<p>最后来一张图总结一下InnoDB和Mylsam两种不同索引的结构：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-36fd77ae6ff2ce44045e7c313f7c102add4.png" alt=""></p>
<h3 id="4-3-3-联合索引的数据结构"><a href="#4-3-3-联合索引的数据结构" class="headerlink" title="4.3.3 联合索引的数据结构"></a>4.3.3 联合索引的数据结构</h3><p>我们知道了Mysql的索引采用B+树，那么，联合索引的B+树长什么样呢？？</p>
<h4 id="4-3-3-1-MylSAM的联合索引"><a href="#4-3-3-1-MylSAM的联合索引" class="headerlink" title="4.3.3.1  MylSAM的联合索引"></a>4.3.3.1  MylSAM的联合索引</h4><p>假如我们有一张表</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-05ed253aaa6cac66ae76bd4d9c06610ffba.png" alt=""></p>
<p>那么，联合索引的B+树结构是长这样的：</p>
<pre><code>- ![](https://oscimg.oschina.net/oscnet/up-96d55ea6fae1c299fc33c64c57ece2ce911.png)</code></pre><blockquote>
<p>注意，这是MyISAM的联合索引，也就是说，叶子节点的key是索引列b,c,d的组合，value是指向表记录的内存地址。如果是InnoDB的联合索引，那么叶子结点应该key是b,c,d的组合，value是表的pk，也就是a字段。</p>
</blockquote>
<p>即每个元素的key，都是b,c,d三个字段的组合。那么不同元素之间的排序是依照什么规则呢？第一列的值大小吗？</p>
<p>答案是：先判断 b 再判断 c 然后是 d，即优先级为b&gt;c&gt;d。</p>
<h4 id="4-3-3-2-InnoDB的联合索引"><a href="#4-3-3-2-InnoDB的联合索引" class="headerlink" title="4.3.3.2  InnoDB的联合索引"></a>4.3.3.2  InnoDB的联合索引</h4><p>有一张表test，这张表除了主键id外，还有a，b,  c 三列</p>
<p>假设给这三个字段建一个复合索引 index_abc (a, b, c)，那么其B+树的结构如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b049e18954547cf3acdcd6866261f8c81ce.png" alt=""></p>
<p>key的排序同理，先判断 a 再判断 b 然后是 c，即优先级为b&gt;c&gt;d。</p>
<h2 id="4-4-索引生效条件"><a href="#4-4-索引生效条件" class="headerlink" title="4.4 索引生效条件"></a>4.4 索引生效条件</h2><p>我们创建了索引，但很多时候，我们发现我们的查询语句无法使用到索引，基于此，我们首先要了解索引的命中规则。</p>
<p>那么怎么知道我们写的sql语句是否有使用到索引呢，可以使用<code>explain</code>命令，直接在sql语句前加explain执行：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-835f37250d6a7bf6e9409110997e2494d0d.png" alt=""></p>
<p>explain执行结果关注以下几个字段：</p>
<ol>
<li>select_type:<ul>
<li>查询的类型，主要是区别普通查询和联合查询、子查询之类的复杂查询<ul>
<li>SIMPLE：查询中不包含子查询或者UNION</li>
<li>查询中若包含任何复杂的子部分，最外层查询则被标记为：PRIMARY</li>
<li>在SELECT或WHERE列表中包含了子查询，该子查询被标记为：SUBQUERY</li>
</ul>
</li>
</ul>
</li>
<li>possible_keys<ul>
<li>表示查询时可能使用的索引。如果是空的，没有相关的索引。这时要提高性能，可通过检验WHERE子句，看是否引用某些字段，或者检查字段不是适合索引</li>
</ul>
</li>
<li>key<ul>
<li>显示sql执行过程中实际使用的键或索引，如果为null则表示未使用任何索引，必须进行优化。</li>
</ul>
</li>
<li>rows<ul>
<li>rows是指这次查找数据所内循环的次数。</li>
</ul>
</li>
<li>Extra:<ul>
<li>执行情况的说明和描述。包含不适合在其他列中显示但十分重要的额外信息</li>
</ul>
</li>
<li>type<ul>
<li>type意味着类型，这里的type官方全称是“join type”，意思是“连接类型”,这样很容易给人一种错觉觉得必须需要俩个表以上才有连接类型。事实上这里的连接类型并非字面那样的狭隘，</li>
<li>它更确切的说是一种数据库引擎查找表的一种方式，在《高性能mysql》一书中作者更是觉得称呼它为访问类型更贴切一些。</li>
<li>mysql5.7中type的类型达到了14种之多，这里只记录和理解最重要且经常遇见的六种类型，它们分别是<code>all&lt;index&lt;range&lt;ref&lt;eq_ref&lt;const</code>。从左到右，它们的效率依次是增强的。</li>
<li>撇开sql的具体应用环境以及其他因素，你应当尽量优化你的sql语句，使它的type尽量靠右，但实际运用中还是要综合考虑各个方面的。</li>
</ul>
</li>
</ol>
<h3 id="4-4-1-explain的type字段类型"><a href="#4-4-1-explain的type字段类型" class="headerlink" title="4.4.1 explain的type字段类型"></a>4.4.1 explain的type字段类型</h3><ol>
<li><strong>all</strong>：这便是所谓的“全表扫描”，如果是在一个查找数据项的sql中出现了all类型，那通常意味着你的sql语句处于一种最原生的状态，有很大的优化空间。all是一种非常暴力和原始的查找方法，非常的耗时而且低效。</li>
<li><strong>index</strong>：这种连接类型只是另外一种形式的全表扫描，<strong>只不过它的扫描顺序是按照索引的顺序</strong>。这种扫描根据索引然后回表取数据，和all相比，他们都是取得了全表的数据，而且index要先读索引而且要回表随机取数据</li>
<li><strong>range</strong>：range指的是有范围的索引扫描，相对于index的全索引扫描，它有范围限制，因此要优于index。关于range比较容易理解，需要记住的是出现了range，则一定是基于索引的。同时除了显而易见的between，and以及’&gt;’,’&lt;’外，in和or也是索引范围扫描。</li>
<li><strong>ref</strong>：出现该连接类型的条件是： 查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复（使用了普通索引的意思）。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</li>
<li><strong>ref_eq</strong>：ref_eq 与 ref相比牛的地方是，它知道这种类型的查找结果集只有一个。什么情况下结果集只有一个呢！那便是使用了<strong>主键或者唯一性索引</strong>进行查找的情况。比如根据学号查找某一学校的一名同学，在没有查找前我们就知道结果一定只有一个，所以当我们首次查找到这个学号，便立即停止了查询。这种连接类型每次都进行着精确查询，无需过多的扫描，因此查找效率更高，当然列的唯一性是需要根据实际情况决定的。</li>
<li><strong>const</strong>：通常情况下，如果将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量。即直接按主键或唯一键读取。</li>
<li><strong>NULL</strong>：不用访问表或者索引，直接就能得到结果，如select 1 from test where 1</li>
</ol>
<blockquote>
<p>看起来const和ref_eq貌似是一样的啊，都是使用主键或者唯一性索引，其实eq_ref是用于联表查询的情况，按联表的主键或唯一键联合查询。</p>
</blockquote>
<h3 id="4-4-2-索引失效场景"><a href="#4-4-2-索引失效场景" class="headerlink" title="4.4.2 索引失效场景"></a>4.4.2 索引失效场景</h3><p>很多时候，我们在列上建了索引，查询条件也是索引列，但最终执行计划没有走它的索引。那到底哪些场景，会导致索引失效呢？</p>
<ol>
<li><p>列与列对比</p>
<ul>
<li>某个表中，有两列（id和c_id）都建了单独索引，下面这种查询条件不会走索引</li>
<li><code>select * from test where id=c_id;</code></li>
</ul>
</li>
<li><p>存在NULL值条件</p>
<ul>
<li>我们在设计数据库表时，应该尽力避免NULL值出现，如果非要不可避免的要出现NULL值，也要给一个DEFAULT值</li>
<li><code>select * from test where id=c_id;</code></li>
</ul>
</li>
<li><p>NOT条件</p>
<ul>
<li>我们知道建立索引时，给每一个索引列建立一个条目，如果查询条件为等值或范围查询时，索引可以根据查询条件去找对应的条目。反过来当查询条件为非时，索引定位就困难了，执行计划此时可能更倾向于全表扫描，这类的查询条件有：&lt;&gt;、NOT、not exists<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>&lt;&gt;<span class="number">500</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> test_02 <span class="keyword">where</span> test_02.id=test.id);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>LIKE通配符的前匹配</p>
<ul>
<li>当使用模糊搜索时，尽量采用后置的通配符，例如：name%，因为走索引时，其会从前去匹配索引列，这时候是可以找到的，如果采用前匹配，那么查索引就会很麻烦，比如查询所有姓张的人，就可以去搜索’张%’。相反如果你查询所有叫‘明’的人，那么只能是%明。这时候索引如何定位呢？前匹配的情况下，执行计划会更倾向于选择全表扫描。后匹配可以走INDEX RANGE SCAN。</li>
<li><code>select * from test where name like &#39;张%&#39;;</code></li>
</ul>
</li>
<li><p>条件上对列使用函数</p>
<ul>
<li>查询条件上尽量不要对索引列使用函数，比如下面这个SQL——这样是不会走索引的，因为索引在建立时会和计算后可能不同，无法定位到索引。</li>
<li><code>select * from test where upper(name)=&#39;SUNYANG&#39;;</code></li>
<li>但如果查询条件不是对索引列进行计算，那么依然可以走索引。比如</li>
<li><code>select * from test where name=upper(&#39;sunyang&#39;);</code></li>
</ul>
</li>
<li><p>数据类型的转换</p>
<ul>
<li>当查询条件存在隐式转换时，索引会失效。比如在数据库里id存的number类型，但是在查询时，却用了下面的形式：</li>
<li><code>select * from sunyang where id=&#39;123&#39;;</code></li>
</ul>
</li>
<li><p>谓词运算</p>
<ul>
<li>我们在上面说，不能对索引列进行函数运算，这也包括加减乘除的谓词运算，这也会使索引失效。建立一个sunyang表，索引为id，看这个SQL：</li>
<li><code>select * from sunyang where id/2=15;</code></li>
<li>这里很明显对索引列id进行了’/2’除二运算，这时候就会索引失效，这种情况应该改写为：</li>
<li><code>select * from sunyang where id=30;</code></li>
</ul>
</li>
<li><p>or连接中包含非独立索引</p>
<ul>
<li>先看如下这个sql：</li>
<li><code>SELECT * from t WHERE id = 1 or uid = 2;</code></li>
<li>如果id和uid都有单独的索引，那么mySql优化器会采用index merge 技术使其走索引。index merge 技术简单说就是在用OR，AND连接的多个查询条件时，可以分别使用前后查询中的索引，然后将它们各自的结果合并交集或并集。</li>
<li><strong>但如果uid列上没有单独的索引，那么这个sql将不会走索引，即便id上有主键索引。</strong></li>
</ul>
</li>
</ol>
<h3 id="4-4-3-联合索引生效条件（最左前缀原则）"><a href="#4-4-3-联合索引生效条件（最左前缀原则）" class="headerlink" title="4.4.3 联合索引生效条件（最左前缀原则）"></a>4.4.3 联合索引生效条件（最左前缀原则）</h3><p>上文中我们介绍了联合索引的数据结构，对于index(b,c,d)是长这样的：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-96d55ea6fae1c299fc33c64c57ece2ce911.png" alt=""></p>
<p>因为联合索引中的元素key都是一个组合值&lt;b,c,d&gt;，且排序依据的优先级是b&gt;c&gt;d，所以联合索引的生效条件，要满足最左前缀原则。我们看如下sql：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">2</span> <span class="keyword">and</span> d = <span class="number">3</span>; //走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b = <span class="number">1</span> <span class="keyword">and</span> c = <span class="number">2</span>                  //走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b = <span class="number">1</span>                                  //走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> c = <span class="number">2</span> <span class="keyword">and</span> d = <span class="number">3</span>;                 //不走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> d = <span class="number">3</span>;                                 //走索引</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b = <span class="number">1</span> <span class="keyword">and</span> d = <span class="number">3</span>                 //走部分索引，至少会走到b = <span class="number">1</span>的子树上。</span><br><span class="line"></span><br><span class="line">//范围查询</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> t1 <span class="keyword">WHERE</span> b &lt; <span class="number">1</span>;                                  //走索引</span><br><span class="line">SELECT * from t1 WHERE b &lt; 1 and c &lt; 2 and d&gt;3;   //走部分索引，b&lt;1走了索引，后面两个条件无法走索引。（索引最多用于一个范围列）</span><br></pre></td></tr></table></figure>

<p>这就是最左前缀原则，还是比较好理解的，需要注意的是索引最多用于一个范围列（且只能是最左的列）。</p>
<p>不过大多数时候，mySql优化器会按照现有的索引来优化sql语句的where条件顺序，比如<code>SELECT * from t1 WHERE  c = 2 and b = 1</code>就会被优化为<code>SELECT * from t1 WHERE b = 1 and c = 2</code>，使得这条sql可以走索引。</p>
<h2 id="4-5-索引优化"><a href="#4-5-索引优化" class="headerlink" title="4.5 索引优化"></a>4.5 索引优化</h2><h3 id="4-5-1-索引的选择性"><a href="#4-5-1-索引的选择性" class="headerlink" title="4.5.1 索引的选择性"></a>4.5.1 索引的选择性</h3><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<ol>
<li><p>表记录比较少:</p>
<ul>
<li>例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</li>
</ul>
</li>
<li><p>索引的选择性较低。</p>
<ul>
<li>所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</li>
<li><code>Index Selectivity = Cardinality / #T</code></li>
<li>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</li>
<li><code>SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;</code></li>
</ul>
</li>
</ol>
<h3 id="4-5-2-前缀索引"><a href="#4-5-2-前缀索引" class="headerlink" title="4.5.2 前缀索引"></a>4.5.2 前缀索引</h3><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。</p>
<p>下面以employees.employees表为例介绍前缀索引的选择和使用。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1e10e78d3b5a8ab5317c3469f7b21c27edc.png" alt=""></p>
<p>如果我们需要频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(first_name))&#x2F;count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.0042 |</span><br><span class="line">+-------------+</span><br><span class="line">SELECT count(DISTINCT(concat(first_name, last_name)))&#x2F;count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9313 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p><first_name>显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))&#x2F;count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.7879 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))&#x2F;count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9007 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引建上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employees.employees</span><br><span class="line">ADD INDEX &#96;first_name_last_name4&#96; (first_name, last_name(4));</span><br></pre></td></tr></table></figure>

<p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：<a href="https://www.cnblogs.com/mydriverc/p/7086523.html" target="_blank" rel="noopener" title="MYSQL中使用SHOW PROFILE命令分析性能">MYSQL中使用SHOW PROFILE命令分析性能</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                                           |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br><span class="line">|       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39; |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<h3 id="4-5-3-覆盖索引"><a href="#4-5-3-覆盖索引" class="headerlink" title="4.5.3 覆盖索引"></a>4.5.3 覆盖索引</h3><p>我们知道，联合索引的B+树是长这个样子的(InnoDB版本，index_abc为(a,b,c)的联合索引)：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b049e18954547cf3acdcd6866261f8c81ce.png" alt=""></p>
<p>那么假如我们有如下的语句：</p>
<p><code>select a,b,c from test where b&gt;3</code></p>
<p>请问这句话走不走索引呢？</p>
<p>答案是：走索引</p>
<p>where b&gt;3 根据最左前缀原则明明不会命中index_abc啊，为什么这条语句会走索引呢？？</p>
<p>因为这句sql，不用回表，这会极大的提高查询性能。</p>
<p>为什么不用回表？因为对比联合索引的结构图我们可以看到，该句sql select的三个字段，都是联合索引的索引字段，这使得联合索引index_abc的叶子结点上就已经能够得到a,b,c三个字段了，用不着回表就足够把需要的a,b,c数据都查出来。</p>
<p>但where b&gt;3不满足最左前缀原则啊！那么索引是怎么走的呢？</p>
<p>答案是，<strong>遍历B+树上的所有节点</strong>。是的，因为不满足最左前缀，所以该句sql无法很高效的利用索引来将性能达到极致，但是遍历B+树上的所有节点仍然比全表扫描要快得多，因为B+树多叉的特性，其节点数量远远小于表记录的数量。</p>
<p>这种索引叫做<strong>覆盖索引</strong>，即现有的索引能够覆盖select的字段，那么就可以通过遍历索引树节点，且无需回表的方式，来提高查询性能。</p>
<p>理解了覆盖索引的含义，那么举一反三，我们可以知道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select a,b from test where c&gt;3     &#x2F;&#x2F;走索引</span><br><span class="line">select id,a,b from test where c&gt;3  &#x2F;&#x2F;走索引，别忘了联合索引的叶子节点上除了联合索引的索引列，还有主键id</span><br><span class="line">select a,b,d from test where c&gt;3   &#x2F;&#x2F;不走索引，因为d不在index_abc的覆盖范围内</span><br><span class="line">select a,b,c from test where a&gt;3   &#x2F;&#x2F;走索引，且还能满足最左前缀原则，性能最高。</span><br></pre></td></tr></table></figure>

<p>所以在select的字段不多的时候，我们可以考虑创建这几个字段的联合索引，来促使sql走覆盖索引，提高查询性能。</p>
<h3 id="4-5-4-索引下推"><a href="#4-5-4-索引下推" class="headerlink" title="4.5.4 索引下推"></a>4.5.4 索引下推</h3><p>对于user_table表，我们现在有（username,age）联合索引。</p>
<p>如果现在有一个需求，查出名称中以“张”开头且年龄小于等于10的用户信息，语句如下：</p>
<p><code>select * from user_table where username like &#39;张%&#39; and age &gt; 10</code></p>
<p>那么我们可以推测出来，语句有两种执行可能：</p>
<ol>
<li>根据（username,age）联合索引查询出所有满足名称以“张”开头的叶子节点，得到pk，<strong>然后回表查询出相应的全行数据</strong>，然后再在结果中筛选出满足年龄小于等于10的用户数据</li>
<li>根据（username,age）联合索引查询所有满足名称以“张”开头的叶子节点，<strong>然后再对这些叶子节点筛选出年龄小于等于10的叶子节点</strong>，得到pk，之后再回表查询全行数据。</li>
</ol>
<p>明显的，<strong>第二种方式需要回表查询的全行数据比较少</strong>，这就是mysql的索引下推，即<strong>where条件中的字段如果能被某个联合索引覆盖</strong>（和覆盖索引有点像），那么直接在联合索引中完成过滤操作，缩小范围，最后再做回表操作。</p>
<p>mysql默认启用索引下推，我们也可以通过修改系统变量optimizer_switch的index_condition_pushdown标志来控制<br><code>SET optimizer_switch = &#39;index_condition_pushdown=off&#39;;</code></p>
<hr>
<h1 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h1><ol>
<li><a href="https://segmentfault.com/a/1190000013695030" target="_blank" rel="noopener" title="数据库逻辑设计之三大范式通俗理解，一看就懂，书上说的太晦涩">数据库逻辑设计之三大范式通俗理解，一看就懂，书上说的太晦涩</a></li>
<li>《高性能MySQL》</li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener" title="MySQL索引背后的数据结构及算法原理">MySQL索引背后的数据结构及算法原理</a></li>
<li><a href="https://blog.csdn.net/dennis211/article/details/78170079" target="_blank" rel="noopener" title="mysql中explain的type的解释">mysql中explain的type的解释</a></li>
<li><a href="https://www.cnblogs.com/CNYYGJ/p/12677690.html" target="_blank" rel="noopener" title="左匹配原则，聚集索引，回表查询，索引覆盖 你真的懂了吗">左匹配原则，聚集索引，回表查询，索引覆盖 你真的懂了吗</a></li>
<li><a href="https://blog.csdn.net/mccand1234/article/details/95799942" target="_blank" rel="noopener" title="索引下推（5.6版本+）">索引下推（5.6版本+）</a></li>
<li><a href="https://www.jianshu.com/p/35588ecf33c1" target="_blank" rel="noopener" title="mysql的联合索引的B+树到底张什么样子？">mysql的联合索引的B+树到底张什么样子？</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/28/B%E6%A0%91-B-%E6%A0%91%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/28/B%E6%A0%91-B-%E6%A0%91%E5%88%86%E6%9E%90/" itemprop="url">B树/B+树分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-28T22:39:54+08:00">
                2020-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91-%E5%A0%86/" itemprop="url" rel="index">
                    <span itemprop="name">树/堆</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/28/B%E6%A0%91-B-%E6%A0%91%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/04/28/B树-B-树分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  5.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前我们常见的动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树(Red-Black Tree )，这三者是典型的二叉树结构，利用二分法，可以使其查询的时间复杂度为O(log2N)，即与树的深度相关。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0dcba6005c20f21c6a6e966b9f239b7bc91.png" alt=""></p>
<p>但二叉树一个节点中包含有一个元素，和指向两个子节点的指针，在现实生活中，未免有些太“奢侈”了。为了降低树的深度，提高查找效率，我们完全可以采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）来得到一棵更加“矮胖”的树，以适应我们日益增长的数据量和查询性能要求，在这种背景下，B树和他的亲戚们应运而生。</p>
<h1 id="1-B树"><a href="#1-B树" class="headerlink" title="1. B树"></a>1. B树</h1><p>B-tree（B-tree树即B树，B即Balanced，平衡的意思）这棵神奇的树是在Rudolf Bayer, Edward M. McCreight(1970)写的一篇论文《Organization and Maintenance of Large Ordered Indices》中首次提出的（wikipedia中：<a href="http://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener" title="http://en.wikipedia.org/wiki/B-tree">http://en.wikipedia.org/wiki/B-tree</a>，阐述了B-tree名字来源以及相关的开源地址）。</p>
<p>B树属于多叉树，又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构。</p>
<blockquote>
<p>强调一下，有的文章里出现的B-树，就是B树。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是一种一种树。而事实上是，B-tree就是指的B树。</p>
</blockquote>
<p>什么是B树？抛出一大堆概念前，我们先看看他长什么样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4ab23420bac3cd2b0d9278357cf27adb754.png" alt=""></p>
<p>这里面，每个字母，都表示一个键值对<code>[key,value]</code>，在关系型数据库的使用场景中，<strong>key一般是索引值</strong>（如果是主键索引的话，那就是ID字段，如果是普通索引，那就是索引对应的字段值，如果是联合索引，可以简单理解为对应多个字段的拼接），<strong>value一般是指向行数据的指针（聚簇索引是这样）或者主键id（非聚簇索引）</strong>；</p>
<p>结合该图，我们可以归纳出B树的规则：</p>
<ol>
<li>节点容量：每个节点，都可以容纳多个键值对。</li>
<li>排序方式：所有节点键值对是按key递增次序排列，并遵循左小右大原则；</li>
<li>层级结构：所有叶子节点均在同一层</li>
<li>子树指针：节点中每个键值对的两侧，都可以放置指针（不一定都有值，可以是null），如果有值，则左边指向左子树（key都比当前key小），右边指向右子树（key都比当前key大）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-45013c901275cb3600f245d8c75f79590fd.png" alt=""></li>
</ul>
</li>
</ol>
<p>B树种，每个节点最多可以容纳多少个键值对呢？这当然不可能是无限的，在数据结构的定义中，我们引入如下概念来描述：</p>
<ol>
<li>度（degree），在树中，每个节点的子树个数就称为该节点的度。（注意是子树数量，而不是键值对的数量）</li>
<li>阶（order），在树中，一个节点可以拥有的最大子树数量称为阶。（注意是子树数量，而不是键值对的数量）</li>
</ol>
<p>然而上述的规则，只能得到一个B树，却不一定得到一个平衡的B树，极端一点，下图这样的树，它也可以是个B树，但这显然不是我们想要的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-11c5ae696f01bc75d91131d6ffb2a9dfeeb.png" alt=""></p>
<p>对于一个M阶的平衡的B树，除了上述的规则之外，我们还要加上如下的约束：</p>
<ol>
<li>根节点至少有两颗子树</li>
<li>除根节点和叶子结点外，其他节点至少应该有m/2个子树。</li>
<li>每个节点的键值对数量k，应该<code>m-1≥k≥ceil(m/2)-1</code>。</li>
</ol>
<blockquote>
<p>ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2</p>
</blockquote>
<p>如下图，就是一个5阶的平衡B树，4≥k≥2。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bb258827f7c35e85442858c7e596f2e2524.png" alt=""></p>
<p>注意，每个节点中的键值对，value都是指向实际data的指针，像下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1ebfa206ae65baff44ff3be6ad33826a6cb.png" alt=""></p>
<h2 id="1-1-B树的查询"><a href="#1-1-B树的查询" class="headerlink" title="1.1 B树的查询"></a>1.1 B树的查询</h2><p><img src="https://oscimg.oschina.net/oscnet/up-a9ce1d66b48acaafe781167587318d9c0f0.png" alt=""></p>
<p>如上图我要从上图中找到E字母，查找流程如下</p>
<ol>
<li><p>获取根节点的关键字进行比较，当前根节点关键字为M，E&lt;M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；</p>
</li>
<li><p>拿到关键字D和G，D&lt;E&lt;G 所以直接找到D和G中间的节点；</p>
</li>
<li><p>拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；</p>
</li>
</ol>
<h2 id="1-2-B树的插入"><a href="#1-2-B树的插入" class="headerlink" title="1.2 B树的插入"></a>1.2 B树的插入</h2><p>一棵平衡的B树之所以能维持其平衡性，B树的插入和删除算法功不可没，我们先来看下B树如何应对记录的插入。</p>
<p>对于一个m阶的平衡的B树，从上文我们知道，需要保持其每个节点的键值对数量k为：<code>m-1≥k≥ceil(m/2)-1</code>，新的记录一般是插入在叶子节点上，为了保持这个数量和树的平衡性，我们规定：</p>
<ol>
<li>还是按照key递增次序排列，遵循左小右大的原则，在叶子节点上找到新元素的定位。</li>
<li>若插入时，插入的节点元素个数小于m-1，则该元素直接插入。</li>
<li>否则，将该节点的元素分裂。</li>
</ol>
<p>我们下面以5阶B树为例子，在5阶B树中，结点最多有4个键值对，最少有2个键值对。（下面我们把键值对称为元素）</p>
<ol>
<li>插入树的第一批元素，A，C，G，N，因为数量不超过4，所以刚好能放在一个节点里面：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-0af274b789dd1f16f170fc83968f07eb356.png" alt=""></li>
</ul>
</li>
<li>当试着插入H时，节点发现空间不够（4阶B树，一个节点最多放4个元素），以致将其<strong>分裂</strong>成2个节点，移动中间元素G上移到新的根节点中，比G元素小的A和C留在当前节点中，而比G元素大的H和N放置新的其右邻居节点中。如下图：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-cbd8d929ac323b575bf7d75becdfacf44a8.png" alt=""></li>
</ul>
</li>
<li>接下来插入E，K，Q，因为都不触及上界，所以不需要任何分裂操作<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-e9af49d254a060491b461731484c692dc6c.png" alt=""></li>
</ul>
</li>
<li>插入M（在K和N之间）就会导致一次分裂，注意M恰好是中间关键字元素，以致向上移到父节点中<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-a90c8160743bcd04518ca54bb903db6c700.png" alt=""></li>
</ul>
</li>
<li>插入F，W，L，T不需要任何分裂操作<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d0df1d26e4a539e449f182883079b6e000f.png" alt=""></li>
</ul>
</li>
<li>插入Z时，最右的叶子节点空间满了，需要进行分裂操作，中间元素T上移到父节点中。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-c901bb0b11e87bc7ce2f19966758b8f74e2.png" alt=""></li>
</ul>
</li>
<li>插入D时，导致最左边的叶子节点被分裂，D恰好也是中间元素，上移到父节点中，然后字母P，R，X，Y陆续插入不需要任何分裂操作<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-33e4f1cbd03fa5a95705511b5fa003df45c.png" alt=""></li>
</ul>
</li>
<li>最后，当插入S时，含有[N,P,Q,R]的节点需要分裂，把中间元素Q上移到父节点中，但是情况来了，父节点中空间已经满了，无法加入Q了，所以也要进行分裂，将父节点中的中间元素M上移到新形成的根结点中。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-6d015f6544f424661fdc345f7b017b3bbf4.png" alt=""></li>
</ul>
</li>
</ol>
<h2 id="1-3-B树的删除"><a href="#1-3-B树的删除" class="headerlink" title="1.3 B树的删除"></a>1.3 B树的删除</h2><p>B树的删除比插入要更复杂一些，但总体而言，为了保持树的平衡，还是有以下的原则：</p>
<p>分为如下几种情况：</p>
<ol>
<li><p>要删除的记录d在叶子节点上</p>
<ul>
<li><p>1.1  如果该节点删除了该元素d后元素数量k仍然大于等于ceil(m/2)-1</p>
<blockquote>
<p>那么这种情况最简单，直接删除元素d和其对应的指针即可。这种情况，我们称为<strong>元素直删</strong></p>
</blockquote>
</li>
<li><p>1.2 如果该节点删除了元素d后k小于ceil(m/2)-1，那么这时也分两种情况</p>
<ul>
<li><p>1.2.1 与该节点相邻的兄弟节点，有任一节点，其k大于等于ceil(m/2)。（这表示即便k-1，也仍然大于等于ceil(m/2)-1）</p>
<blockquote>
<p>那么这种情况，我们应该向兄弟节点，借一个元素过来，但不是简单的借，因为要保证B树元素从左到右递增的顺序，故而借法是有门道的，我们暂称为<strong>元素租借</strong>。</p>
</blockquote>
</li>
<li><p>1.2.2 与该节点相邻的兄弟节点，都没有多余的元素可以借出去，即其k都等于ceil(m/2)-1</p>
<blockquote>
<p>那么这种情况，删除元素d后，我们应该和兄弟节点合并，这样k1=ceil(m/2)-1-1和k2=ceil(m/2)-1,k1+k2还是小于m，符合B树的平衡约束（这也是为什么k的下限是ceil(m/2)-1的原因），这种情况，我们称为<strong>元素合并</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>要删除的记录d在非叶子节点上</p>
<ul>
<li><blockquote>
<p>那么这种情况，我们应该在d指针指向的子树中找到一个元素f来替代d的位置，同时在子树中删除f（如果f的删除引起了<code>m-1≥k≥ceil(m/2)-1</code>的不满足，那么操作方法按照<code>情况1：要删除的记录d在叶子节点上</code>来处理），这种情况，我们称为<strong>元素顶替</strong></p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>总结之后，我们发现，删除记录的核心操作，就在<strong>元素直删</strong>，<strong>元素租借</strong>，<strong>元素合并</strong>和<strong>元素顶替</strong>这四个操作步骤之间，直删元素比较简单，我们不多说，剩下的，三种操作步骤，我们来理一下：</p>
<p>我们有一个5阶的b树，原始状态长这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dbe6fba9b6d67cc51aa034d00863633519b.png" alt=""></p>
<ol>
<li><strong>元素顶替</strong><ul>
<li>我们先反着来，先删除位于非叶子节点上的记录27</li>
<li>这时候，需要从27的左右指针指向的两棵子树中找元素来置换27，左子树是<code>23,24,26</code>，右子树是<code>28,29</code></li>
<li>为了保证b树从左到右增序的顺序，所以有资格被置换的元素只有26和28。</li>
<li>b树删除的大部分实现，都是采用<strong>后继顶替优先原则</strong>，即27被删除，则拿27的后继28来顶替。</li>
<li>将28元素替到27原来的位置，同时将右子节点中的28删去，如下图：<br><img src="https://oscimg.oschina.net/oscnet/up-85fdbd40c1a754b1940a8c3edf02992f702.png" alt=""></li>
<li><code>28,29</code>节点删去28之后，显然k小于了ceil(m/2)-1=2，这时候，<code>29</code>有两个兄弟节点：<code>23,24,26</code>和<code>31,32</code></li>
<li>如果<code>29</code>向<code>23,24,26</code>求援，就会引发<strong>元素租借</strong>的情况，反之，向<code>31,32</code>求援，就会引发<strong>元素合并</strong>的情况</li>
</ul>
</li>
</ol>
<blockquote>
<p>其实向哪边求援都可以，实现不同，最终最多导致B树的形态会稍不一样，但肯定的是，他们都是平衡的树。</p>
</blockquote>
<ol start="2">
<li><p><strong>元素租借</strong></p>
<ul>
<li>重申一下， <strong>元素顶替</strong>操作结束后，B树长这样</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-85fdbd40c1a754b1940a8c3edf02992f702.png" alt=""></li>
<li>假如<code>29</code>向<code>23,24,26</code>求援，那么<code>23,24,26</code>明显有“余粮”，就会触发租借元素的情况。</li>
<li><code>23,24,26</code>不能直接将任意一个元素放到<code>29</code>中来，<code>23,24,26</code>任意元素都比28元素小，如果放置在28元素的右子节点上，就违背了左小右大的原则。</li>
<li>那怎么借呢？既然两个当事人<code>23,24,26</code>和<code>29</code>分别是28元素的左右子节点，那就让28元素进入<code>29</code>，26元素替代28元素的位置，这样就皆大欢喜了。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-7e820bffda4330e8a49b4f6dcfe7761c2ad.png" alt=""></li>
</ul>
</li>
<li><p><strong>元素合并</strong></p>
<ul>
<li>重申一下， <strong>元素顶替</strong>操作结束后，B树长这样</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-85fdbd40c1a754b1940a8c3edf02992f702.png" alt=""></li>
<li>假如<code>29</code>向<code>31,32</code>求援，那么<code>31,32</code>明显没有“余粮”，那么就会引发<strong>元素合并</strong>的情况。</li>
<li><code>29</code>和<code>31,32</code>不能直接合并，因为30元素还在父节点上，按照左小右大的原则，30元素一定要在29元素和31元素之间</li>
<li>那怎么合并呢？既然两个当事人 <code>29</code>和<code>31,32</code>分别是30元素的左右子节点，那就让30元素与<code>29</code>和<code>31,32</code>一起加入合并，这样就皆大欢喜了。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-ff3953493f06bb17b382e8bc1a3d38adf6a.png" alt=""></li>
</ul>
</li>
</ol>
<hr>
<p>这就结束了么？不是的，大家注意到没有，合并元素操作，其实相当于在父节点中删去了一个元素，如果这一次的删除，导致了父节点的元素数量小于ceil(m/2)-1怎么办？</p>
<p>我们来看这种情况，现在我们的原图长这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ff3953493f06bb17b382e8bc1a3d38adf6a.png" alt=""></p>
<ol>
<li><p>接着删除key为40的记录，删除后结果如下图所示。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-7459240a23aa224c93bbfb382960001664c.png" alt=""></li>
</ul>
</li>
<li><p>删完后就剩39一个元素了，没话说，找个兄弟节点合并呗，合并结果如下，可以看到，对于原来的<code>36,41</code>节点来说，相当于36元素被删除了，导致<code>41</code>节点不符合约束。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-752976b81e53a4afd84139727851c16e5a3.png" alt=""></li>
</ul>
</li>
<li><p>这时候，其实有两种策略</p>
<ul>
<li>一种是采用<strong>元素顶替</strong>操作：删了我的36，那就拿39顶替呗。</li>
<li>还有一种是向兄弟节点<code>22,26</code>求援，这时要根据兄弟节点的“余粮”情况，酌情触发<strong>元素合并</strong>或者<strong>元素租借</strong>。</li>
<li>那到底是采用第一种方案好还是第二种方案好呢？</li>
<li><strong>答案是第二种，因为第二种情况，可能触发元素合并</strong>，只要触发元素合并，就有可能降低树的高度，使得B树不仅平衡，而且更加“矮胖”，使查找效率更高。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-71b65cb9f29444227d3fbb8a8e9b84d9130.png" alt=""></li>
</ul>
</li>
</ol>
<blockquote>
<p>所以总结一句话，因为元素合并导致的父节点元素数量不符合约束，执行策略时，优先向可能触发<strong>元素合并</strong>的方向靠拢，有利于使树的高度降低。</p>
</blockquote>
<h2 id="1-4-B树的优点"><a href="#1-4-B树的优点" class="headerlink" title="1.4 B树的优点"></a>1.4 B树的优点</h2><p>如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</p>
<h1 id="2-B-树"><a href="#2-B-树" class="headerlink" title="2. B+树"></a>2. B+树</h1><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别：</p>
<ol>
<li>B+树的<strong>非叶子节点不保存关键字记录的指针</strong>，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；</li>
<li>B+树<strong>叶子节点保存了父节点的所有关键字记录的指针</strong>，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</li>
<li>B+树<strong>叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针</strong>。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-d16ff524d920d5b2a808b41aedbd6c256b5.png" alt=""></p>
<h2 id="2-1-B-树的插入"><a href="#2-1-B-树的插入" class="headerlink" title="2.1 B+树的插入"></a>2.1 B+树的插入</h2><p>B+树的插入操作和B树的插入操作大同小异，即都满足：</p>
<ol>
<li>还是按照key递增次序排列，遵循左小右大的原则，在叶子节点上找到新元素的定位。</li>
<li>若插入时，插入的节点元素个数小于m-1，则该元素直接插入。</li>
<li>否则，将该节点的元素分裂。</li>
</ol>
<p>但B+树的叶子节点，会包含所有的元素（不像B树，有些元素在叶子节点上，有些元素在非叶子节点上），所以插入操作有一些许的差异。</p>
<p>我们下面还是以5阶B+树为例子，在5阶B+树中，结点最多有4个元素，最少有2个元素。</p>
<ol>
<li><p>空树中插入5：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-533ee1cfa033ba1ce6dd6e4fc9af90c2d7e.png" alt=""></li>
</ul>
</li>
<li><p>依次插入8，10，15：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-dd36b3e0400e00aea397caac07683e5014a.png" alt=""></li>
</ul>
</li>
<li><p>插入16，</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-22a6217fb1ebcb7245d74fb5b4b92659a2e.png" alt=""></li>
<li>这时超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左节点2个记录，右节点3个记录，中间key成为索引结点中的key，分裂后当前节点指向了父节点（根节点）。结果如下图所示：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-f03ece76b29d638675bbc7c937b7b34ee73.png" alt=""></li>
<li><blockquote>
<p>当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。不同实现而已，本质差不多。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>继续插入17</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d0a8d9b2c71ffd1a692dd88fc44ec6bca10.png" alt=""></li>
</ul>
</li>
<li><p>插入18，插入后当前节点的关键字个数大于5，进行分裂。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-0ea3104f7c970ceb6bba681de50de17f63d.png" alt=""></li>
<li>分裂成两个节点，左节点2个记录，右节点3个记录，关键字16进位到父节点（索引类型）中，将当前结点的指针指向父结点。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-f92dccd11f24b2ddbb8200c36386da6375d.png" alt=""></li>
</ul>
</li>
<li><p>插入若干数据后：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-40118bf9f9ac718d72d7512dab23e9e83d7.png" alt=""></li>
</ul>
</li>
<li><p>在上图中插入7，结果如下图所示</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d9bcc83498f32e2b879edfef356dafcaa62.png" alt=""></li>
<li>此时当前节点的关键字个数超过4，需要分裂。左节点2个记录，右节点3个记录。分裂后关键字7进入到父节点中，将当前结点的指针指向父节点</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-24fbbe8a4fa67721cc8a833a73f4d097ec8.png" alt=""></li>
<li>当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-c2532b2da7da86911713593d79715fbc13f.png" alt=""></li>
</ul>
</li>
</ol>
<h2 id="2-2-B-树的删除"><a href="#2-2-B-树的删除" class="headerlink" title="2.2 B+树的删除"></a>2.2 B+树的删除</h2><p>回顾上文的B树的删除，我们知道B树有元素直删，元素租借，元素合并和元素顶替这四个操作场景，B+树与B树大同小异，几乎没有区别。只不过B+树没有元素顶替</p>
<blockquote>
<p>B+树没有元素顶替，是因为B+树的叶子节点，有所有的键值对信息，所以不存在删除的键值对不是叶子节点的情况。</p>
</blockquote>
<p>我们下面还是以5阶B+树为例子，在5阶B+树中，结点最多有4个元素，最少有2个元素。</p>
<p>初始状态如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7a9ce40e582bd61f21ceea7a2c5c425afc3.png" alt=""></p>
<ol>
<li><p><strong>元素直删</strong></p>
<ul>
<li>在上图基础上删除22</li>
<li>删除后叶子结点中key的个数大于等于2，删除结束</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-cab4eaee78777158a52dca0e9a554519d4a.png" alt=""></li>
</ul>
</li>
<li><p><strong>元素租借</strong></p>
<ul>
<li>在元素直删完了之后的基础上，再删除15，得到下图：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-ccdd113bc8eaa609f57b6b27d1f8e094971.png" alt=""></li>
<li>删除后当前结点只有一个元素，不满足条件，而兄弟结点有三个元素（注意，当前节点的兄弟节点只有<code>[7,8,9]</code>），则可以向兄弟节点借一个元素过来。当然，根据排序原则，只能借9。</li>
<li>9元素去到<code>[10]</code>节点之后，那么索引也要相应的更改，否则也不满足排序原则，即原来非叶子节点中的10改为9：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-48d63a5170d2cece2d2e75cdabbd24d0cf9.png" alt=""></li>
</ul>
</li>
<li><p><strong>元素合并</strong></p>
<ul>
<li>在元素租借完了之后，我们再删除7，删除后的结果如下图所示：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-ea526d3b627c7f71a782ceec9b797b1da95.png" alt=""></li>
<li>可以看到，删除完了以后，当前节点元素个数小于2，且左右节点的元素数量都是2，即都没有富余的元素。</li>
<li>这时候我们选择元素合并，可以选择和左兄弟合并，也可以和右兄弟合并，这里我们选择左兄弟。</li>
<li>合并的时候我们前文说过，为了保证顺序，兄弟节点还会将父节点中对应的元素一起纳入合并，即<code>[5,6]</code>、<code>[8]</code>会和父节点中的7一起合并，不过这次删除的是7，所以7不存在了，故而，得到：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-bd7d531937d2ff85149f47b4cfa4abd8e33.png" alt=""></li>
<li>不过注意，因为7索引的删除，导致了父节点只剩下了一个元素9，这显然不符合数量约束。</li>
<li><code>[9]</code>的兄弟节点也没有余粮，则只能拉着父节点的元素16，和右兄弟<code>[18,20]</code>合并。得到下图：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-800c466ff5b23af3ababd1500a297fb1fc2.png" alt=""></li>
</ul>
</li>
</ol>
<blockquote>
<p>其实说是没有元素顶替，但为了便于理解，也可以用元素顶替的思路来看最后这个删除操作：<br>1.因为删除的是7，7也在非叶子节点上，所以7删除了，要从子节点中找一个元素来顶替。<br>2.不论是8顶替上去还是6顶替上去，都会使得有个子节点数量不符合，触发元素合并。<br>3.这时候左右节点的元素+他们关联的父节点的元素合并，得到的结果，还是<code>[5,6,8]</code></p>
</blockquote>
<h2 id="2-3-B-树的优点"><a href="#2-3-B-树的优点" class="headerlink" title="2.3 B+树的优点"></a>2.3 B+树的优点</h2><ol>
<li><p>B+树的层级更少：相较于B树，B+每个非叶子节点存储的元素数更多（因为B+树的非叶子节点不存data，相同容量下可容纳的元素更多），使得B+树相对于B树更加“矮胖”，即B+树的层级更少<strong>所以查询数据更快</strong>；</p>
</li>
<li><p>B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定。不像B树，有时候在非叶子节点上找到，那就相对快，有时候在叶子节点上找到，那就相对慢。</p>
</li>
<li><p>B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p>
</li>
<li><p>B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p>
</li>
</ol>
<h2 id="2-4-为什么B-树比B树更适合做数据库索引？"><a href="#2-4-为什么B-树比B树更适合做数据库索引？" class="headerlink" title="2.4 为什么B+树比B树更适合做数据库索引？"></a>2.4 为什么B+树比B树更适合做数据库索引？</h2><p>其实理由也正是基于上诉的优势而言，不过我们把语义按照数据库索引适配性的角度转化一下：</p>
<ol>
<li><p>B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。</p>
</li>
<li><p>B+树的查询效率更加稳定：由于非叶节点并不是最终指向文件内容的节点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
<li><p>对范围查询的适配性好：在数据库中基于范围的查询是非常频繁的，B树不支持这样的操作或者说效率太低。而B+树只需要去遍历叶子节点的链表，就可以实现整棵树的范围查询。</p>
</li>
<li><p>全节点遍历更快：由于B+树的数据都存储在叶子节点中，分支节点均为索引，方便扫库，只需要扫一遍叶子节点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-hand-o-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-hand-o-right" aria-label="accessibility.next_page"></i></a>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">408.4k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
