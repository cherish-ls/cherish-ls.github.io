<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/08/TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" itemprop="url">TCP协议分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-08T22:01:51+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/08/TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/04/08/TCP协议分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  16.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  59
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-TCP协议概述"><a href="#1-TCP协议概述" class="headerlink" title="1. TCP协议概述"></a>1. TCP协议概述</h1><p>TCP协议，全称Transmission Control Protocol（传输控制协议），是一种<strong>全双工通信</strong>、<strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流的</strong>传输层通信协议。</p>
<ol>
<li><p>全双工通信：即建立TCP连接之后，通信双方都可以发送数据。</p>
</li>
<li><p>面向连接：意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。</p>
<ul>
<li>这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。</li>
</ul>
</li>
<li><p>可靠：IP层并不保证数据报一定被正确地递交到接收方，TCP负责在超时或者传输失败后，重传没有递交成功的数据报。</p>
<ul>
<li>即使被正确递交的数据报，也可能存在错序的问题，这也是TCP的责任，它必须把接收到的数据报重新装配成正确的顺序。</li>
</ul>
</li>
<li><p>基于字节流：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序传来的数据块看成是一连串的无结构的字节流。由TCP传递给IP的信息单位称为报文段或段（segment）</p>
<ul>
<li>TCP有一个缓冲，TCP发送报文时，是将应用层数据写入TCP缓冲区中，然后由TCP协议来控制发送这里面的数据，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</li>
<li>发送的状态是按字节流的方式发送的，跟应用层写下来的报文长度没有任何关系，所以说是流。</li>
</ul>
</li>
</ol>
<blockquote>
<p>面向字节流的概念，打个比方：<br>一个蓄水池，有出水口和进水口，开几次进水口和开几次出水口是没有必然联系的，也就是说你可以只进一次水，然后分10次出完（即一次write，可以分10次read读取）。另外，水池里的水接多少就会少多少；往里面进多少水，就会增加多少水，但是不能超过水池的容量，多出的水会溢出。</p>
</blockquote>
<p>同时，作为网络协议中举足轻重的传输层协议，TCP协议有这些优秀的机制保证其最为重视的数据可靠性：</p>
<ol>
<li>超时重传</li>
<li>拥塞处理</li>
<li>滑动窗口</li>
</ol>
<p>我们将在后面的篇幅中介绍他们。</p>
<h2 id="1-1-TCP和UDP的区别"><a href="#1-1-TCP和UDP的区别" class="headerlink" title="1.1 TCP和UDP的区别"></a>1.1 TCP和UDP的区别</h2><p>和UDP相比，TCP协议有如下差异：</p>
<table>
<thead>
<tr>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>面向连接（如打电话要先拨号建立连接）</td>
<td>无连接（发送数据之前不需要建立连接）</td>
</tr>
<tr>
<td>传输可靠（通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达）</td>
<td>传输不可靠（尽最大努力交付，即不保证可靠交付）</td>
</tr>
<tr>
<td>面向字节流（把数据看成一连串无结构的字节流）</td>
<td>面向报文（无脑传递上下层的报文）</td>
</tr>
<tr>
<td>适合传输大量数据</td>
<td>适合传输少量数据</td>
</tr>
<tr>
<td>全双工的可靠信道</td>
<td>不可靠信道</td>
</tr>
<tr>
<td>首部开销20字节</td>
<td>首部开销8个字节</td>
</tr>
<tr>
<td>连接只能是点到点</td>
<td>支持一对一，一对多，多对一和多对多的交互通信</td>
</tr>
<tr>
<td>速度慢（需要建立连接、发送确认包等））</td>
<td>速度快</td>
</tr>
<tr>
<td>对系统资源的要求较多</td>
<td>对系统资源的要求较少</td>
</tr>
</tbody></table>
<h2 id="1-2-TCP协议应用场景"><a href="#1-2-TCP协议应用场景" class="headerlink" title="1.2 TCP协议应用场景"></a>1.2 TCP协议应用场景</h2><p>TCP协议是运输层协议，其服务对象自然是应用层。</p>
<p>TCP主要应用在：要求通信数据可靠时，即数据要准确无误地传递给对方如：</p>
<ol>
<li>传输文件：HTTP、HTTPS、FTP等协议；</li>
<li>传输邮件：POP、SMTP等协议</li>
<li>万维网：HTTP协议</li>
<li>文件传输：FTP协议</li>
<li>电子邮件：SMTP协议</li>
<li>远程终端接入：TELNET协议</li>
</ol>
<h2 id="1-3-如何保证可靠性"><a href="#1-3-如何保证可靠性" class="headerlink" title="1.3 如何保证可靠性"></a>1.3 如何保证可靠性</h2><p>TCP通过下列方式来提供可靠性：</p>
<ol>
<li><p>缓冲区：基于缓冲区，应用数据被分割成TCP认为最适合发送的数据块。</p>
</li>
<li><p>超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
</li>
<li><p>接收确认：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</p>
</li>
<li><p>校验：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。</p>
</li>
<li><p>重新排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</p>
</li>
<li><p>既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。</p>
</li>
<li><p>TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</p>
</li>
</ol>
<h2 id="1-4-TCP连接的实质"><a href="#1-4-TCP连接的实质" class="headerlink" title="1.4 TCP连接的实质"></a>1.4 TCP连接的实质</h2><p>我们都知道TCP是面向连接的服务，所有要通过TCP进行通信的应用都要先建立连接才能通信，在通信完毕之后要记得关闭连接。但是TCP连接到底是什么东西呢？</p>
<p>这里先说结论，连接实际上是操作系统内核的一种数据结构，称为TCP控制块（TCB），对于linux而言是tcp_sock结构。不光连接，连数据包也是由一个数据结构来控制，linux里面称为sk_buff结构。</p>
<h3 id="1-4-1-为什么要有TCB"><a href="#1-4-1-为什么要有TCB" class="headerlink" title="1.4.1 为什么要有TCB"></a>1.4.1 为什么要有TCB</h3><ul>
<li><p>当应用希望写数据时，</p>
<ul>
<li>不是直接向网卡驱动发数据，而是经过先放入到一个socket发送缓冲区中</li>
<li>然后根据一定算法（达到一定数量或者调用flush之后），缓冲区中的数据就会被网卡从缓冲区中拷贝出来，再层层封装，最后经过物理层传输。</li>
</ul>
</li>
<li><p>当网卡收到数据时</p>
<ul>
<li>会通过DMA直接发送到内存缓冲区中（网卡驱动提前向操作系统申请的一块内存，并且驱动会提前告诉网卡这块内存的地址（注意是物理地址）和大小。如果没有这块内存缓冲区，那么网卡会直接将数据丢掉）</li>
<li>然后给CPU发送一个中断信号，通知操作系统一个数据包到了。</li>
<li>数据包要先经过校验，分用等操作，到了TCP层，处理程序此时根据TCP首部中的端口号选择一个socket，并将其载荷数据拷贝进socket接收缓冲区。</li>
<li>根据TCP首部中的端口号选择一个socket，如何选择呢？这里TCP是利用连接<strong>四元组&lt;源IP地址，源端口号，目标IP地址，目标端口号&gt;</strong>，并以这个四元组为key，查找hash表找到对应的socket的socket结构指针，并利用该指针找到对应socket的接收缓冲区，并将载荷数据拷贝进去。</li>
</ul>
</li>
</ul>
<blockquote>
<p>所以到这里，我们就应该知道，每个socket结构必须要有自己独立的发送缓冲区和接收缓冲区</p>
</blockquote>
<h3 id="1-4-2-什么是Socket"><a href="#1-4-2-什么是Socket" class="headerlink" title="1.4.2 什么是Socket"></a>1.4.2 什么是Socket</h3><p>socket是什么呢，实际上socket是对TCP/IP协议的封装，它的出现只是使得程序员更方便地使用TCP/IP协议栈而已。socket本身并不是协议，它是<strong>应用层与TCP/IP协议族通信的中间软件抽象层，是一组调用接口（TCP/IP网络的API函数）</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-238e16f14108123af496a6e952926908689.png" alt=""></p>
<p>或者换句话说，<strong>socket是TCP/IP协议实现的封装，和暴露给应用层的函数</strong>。他将网络底层复杂的实现统统隐藏，给应用程序方便的使用接口。</p>
<p>在网络通信方面，socket也有很多种，根据不同协议的实现，也有TCP通信的Socket，UDP通信的DatagramSocket，以及与SSL相关JSSE中的SSLSocket，以及这些非阻塞的SocketChannel,DatagramChannel,SSLEngine在安全方面，JCA,JCE,JAAS等等</p>
<h3 id="1-4-3-HTTP短连接和长连接"><a href="#1-4-3-HTTP短连接和长连接" class="headerlink" title="1.4.3 HTTP短连接和长连接"></a>1.4.3 HTTP短连接和长连接</h3><p>对于HTTP 1.0的http标准而言，默认连接是短连接，什么是短连接？就是服务器当发送完最后一个字节的数据之后将关闭连接，也就是回收tcp_sock结构，这样，如果客户端再发送数据给服务器，将直接丢弃。即使此时客户端还有这样的结构，但是我们说连接已经关闭或者已经断了。</p>
<p>HTTP 1.1引入了长连接的概念，并把它搞成了默认的连接方式。什么是长连接？就是当完成一个业务之后，socket结构并不回收。这样，只要在socket结构还存在的时候，客户端发送的任何数据，服务器都可以收到，这就是所谓的长连接。</p>
<h1 id="2-TCP的首部"><a href="#2-TCP的首部" class="headerlink" title="2. TCP的首部"></a>2. TCP的首部</h1><p>TCP数据被封装在一个IP数据报中</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7c3a2ac388604594ca4646e53a3c1dbc488.png" alt=""></p>
<blockquote>
<p>注意：TCP的包是没有IP地址的，那是IP层上的事。TCP只负责源端口和目标端口的维护。</p>
</blockquote>
<h2 id="2-1-源端口和目的端口"><a href="#2-1-源端口和目的端口" class="headerlink" title="2.1 源端口和目的端口"></a>2.1 源端口和目的端口</h2><p><strong>源端口</strong>和<strong>目的端口</strong>：各占16位2个字节，分别存放源端口号和目的端口号。用于寻找发端和收端应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址，能唯一确定一个TCP连接。</p>
<h2 id="2-2-序号"><a href="#2-2-序号" class="headerlink" title="2.2 序号"></a>2.2 序号</h2><p><strong>序号</strong>：简称seq（sequence number），占32位4个字节。序号范围是[0，2^32 - 1]，共2^32 （即4294967296）个序号。序号增加到2^32-1后，下一个序号就又回到0。</p>
<ul>
<li>TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个<strong>字节</strong>都按顺序编号。</li>
<li>TCP会话建立后，会话的<strong>每一端</strong>都自己维护一个32位（bit）的序号，该序号被用来跟踪该端发送的数据量。这个端每发送一个字节的数据，它维护的序号+1；</li>
<li><strong>当一个TCP会话开启时，它两端的初始序号都是随机的，可能是0和2^32 - 1(即4,294,967,295)之间的任意值</strong></li>
<li>TCP会话的某一端在发送报文段时，会将计算出的报文段<strong>数据</strong>的第一个字节的序号写入首部的序号字段中。</li>
<li>首部中的序号字段值则是指的是<strong>本报文段所发送的数据的第一个字节的序号</strong>。</li>
<li>例如，一报文段的序号是301，而数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。<ul>
<li>显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”。</li>
</ul>
</li>
</ul>
<blockquote>
<p>TCP会话建立后，每一端都要各自初始化一个seq，<strong>这个初始的seq称作ISN（Inital Sequence Number）</strong></p>
</blockquote>
<blockquote>
<p>TCP会话的任意端的ISN为什么要是随机的而不是写死的呢？试想：假如连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。</p>
</blockquote>
<blockquote>
<p>RFC793中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – Wikipedia语条），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</p>
</blockquote>
<h2 id="2-3-确认号"><a href="#2-3-确认号" class="headerlink" title="2.3 确认号"></a>2.3 确认号</h2><p><strong>确认号</strong>：简称Ack（acknowledgement number），占32位4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。仅当控制位ACK = 1时确认号字段才有效。</p>
<ul>
<li>例如，B正确收到了A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501~700），这表明B正确收到了A发送的到序号700为止的数据。</li>
<li>因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。注意，现在确认号不是501，也不是700，而是701。</li>
<li>总之：B给A发送的报文确认号为= N，则表明：到序号N-1为止的所有数据B都已正确收到。</li>
</ul>
<blockquote>
<p>确认号（acknowledgement number）简称Ack序号，不要将确认序号Ack与下面即将介绍的控制位中的ACK搞混了。</p>
</blockquote>
<h2 id="2-4-数据偏移"><a href="#2-4-数据偏移" class="headerlink" title="2.4 数据偏移"></a>2.4 数据偏移</h2><p><strong>数据偏移</strong>：占32位4个字节，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP<strong>报文段的首部长度</strong>。</p>
<ul>
<li>由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是32位字（即以4字节的字为计算单位）。</li>
<li>由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大字节（即选项长度不能超过40字节）。<h2 id="2-4-保留"><a href="#2-4-保留" class="headerlink" title="2.4 保留"></a>2.4 保留</h2></li>
</ul>
<p><strong>保留</strong>：占6位，保留为今后使用，但目前应置为0 。</p>
<h2 id="2-6-6个控制位"><a href="#2-6-6个控制位" class="headerlink" title="2.6 6个控制位"></a>2.6 6个控制位</h2><p><strong>6个控制位</strong>：用来说明本报文段的性质。</p>
<ol>
<li><p><strong>紧急URG（URGent）</strong> 当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。</p>
<ul>
<li>例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。</li>
<li>当URG置为1时，发送应用进程就告诉发送方的TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。</li>
</ul>
</li>
<li><p><strong>确认ACK（ACKnowledgment）</strong> 仅当ACK = 1时确认号字段才有效，当ACK = 0时确认号无效。TCP规定，在连接建立后所有的传送的报文段都必须把ACK置为1。</p>
</li>
<li><p><strong>推送 PSH（PuSH）</strong> 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP就可以使用推送（push）操作。这时，发送方TCP把PSH置为1，并立即创建一个报文段发送出去。<strong>接收方TCP收到PSH=1的报文段，就尽快地（即“推送”向前）交付接收应用进程。而不用再等到整个缓存都填满了后再向上交付</strong>。</p>
</li>
<li><p><strong>复位RST（ReSeT）</strong> 当RST=1时，表示TCP连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST置为1还用来拒绝一个非法的报文段或拒绝打开一个连接。</p>
</li>
<li><p><strong>同步SYN（SYNchronization）</strong> 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1，因此SYN置为1就表示这是一个连接请求或连接接受报文。</p>
</li>
<li><p><strong>终止FIN（FINis，意思是“完”“终”）</strong> 用来释放一个连接。当FIN=1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p>
</li>
</ol>
<blockquote>
<p>ACK和SYN将在下节详述。</p>
</blockquote>
<h2 id="2-7-窗口"><a href="#2-7-窗口" class="headerlink" title="2.7 窗口"></a>2.7 窗口</h2><p><strong>窗口</strong>：占16位2字节。窗口值是【0，2^16-1（65535）】之间的整数。<strong>窗口值告诉对方：从本报文段首部中的确认号算起，我目前允许你发送的数据量（以字节为单位）是这个值的量</strong>。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。TCP的流量控制由连接的每一端通过声明的窗口大小来提供。</p>
<h2 id="2-8-检验和"><a href="#2-8-检验和" class="headerlink" title="2.8 检验和"></a>2.8 检验和</h2><p><strong>检验和</strong>：占16位2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部（<strong>具体过程可见《UDP协议分析》一文的校验过程</strong>）。伪首部的格式和UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）；把第5字段中的UDP中的长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用TPv6,则相应的伪首部也要改变。</p>
<h2 id="2-9-紧急指针"><a href="#2-9-紧急指针" class="headerlink" title="2.9 紧急指针"></a>2.9 紧急指针</h2><p><strong>紧急指针</strong>：占16位2字节。紧急指针仅在URG=1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据排在数据的最前面，紧急数据结束后就是普通数据） 。</p>
<ul>
<li>因此，在紧急指针指出了紧急数据的末尾在报文段中的位置（紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。）。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0时也可以发送紧急数据。<h2 id="2-10-选项"><a href="#2-10-选项" class="headerlink" title="2.10 选项"></a>2.10 选项</h2></li>
</ul>
<p><strong>选项</strong>：长度可变，最长可达4字节。当没有使用“选项”时，TCP的首部长度是20字节。</p>
<ol>
<li>TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Szie），在连接建立的时候，即在发送SYN段的时候，同时会将MSS发送给对方（MSS选项只能出现在SYN段中！！！），<strong>告诉对端他期望接收的TCP报文段数据部分最大长度</strong>。<ul>
<li>注意MSS这个名词含义。MSS是每一个TCP报文段中的数据字段的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS并不是整个TCP报文段的最大长度，而是“TCP报文段长度减去TCP首部长度”。</li>
</ul>
</li>
<li>窗口扩大选项：窗口扩大选项是为了扩大窗口。我们知道，TCP首部中窗口字段长度是16位，因此最大的窗口大小为64K字节。虽然这对早期的网络是足够用的，但对于包含卫星信道的网络，传播时延和宽带都很大，要获得高吞吐量需要更大的窗口大小。<ul>
<li>窗口扩大选项占3字节，其中有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位数从16增大到（16+S）。移位值允许使用的最大值是14，相当于窗口最大值增大到2（16+14）-1=230-1。</li>
<li>窗口扩大选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送S=0选项，使窗口大小回到16。</li>
</ul>
</li>
<li>时间戳选项：时间戳选项占10字节，其中最主要的字段是时间戳字段（4字节）和时间戳回送回答字段（4字节）。时间戳选项有以下两个概念：<ul>
<li>用来计算往返时间RTT。发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段复制到时间戳回送回答字段。因此，发送方在收到确认报文后，可以准确地计算出RTT来。</li>
<li>用于处理TCP序号超过2^32 的情况，这又称为防止序号绕回PAWS。我们知道，TCP报文段的序号只有32位，而每增加2 ^32 个序号就会重复使用原来用过的序号。当使用高速网络时，在一次TCP连接的数据传送中序号很可能被重复使用。<ul>
<li>例如，当使用1.5Mbit/s的速度发送报文段时，序号重复要6小时以上。但若用2.5Gbit/s的速率发送报文段，则不到14秒钟序号就会重复。为了使接收方能够把新的报文段和迟到很久的报文段区分开，则可以在报文段中加上这种时间戳。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-7ada90d37ad88cecc0f6abc535d49d3afde.png" alt=""></p>
<p>每个选项的开始是1字节kind字段，说明选项的类型。kind字段为0和1的选项仅占1个字节。其他的选项在kind字节后还有len字节。它说明的长度是指总长度，包括kind字节和len字节。</p>
<h1 id="3-TCP连接的建立与终止"><a href="#3-TCP连接的建立与终止" class="headerlink" title="3. TCP连接的建立与终止"></a>3. TCP连接的建立与终止</h1><p>TCP是一个面向连接的协议。无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。</p>
<blockquote>
<p>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</p>
</blockquote>
<p>前面我们介绍的TCP的首部字段，其中有三个字段，和TCP的连接有密切关系，他们分别是</p>
<ol>
<li><p>序号（sequence number）：Seq序号，前面说过，tcp会话中的端会对它发送的每个字节进行编号，一个报文段的序号值=本报文段所发送的数据的第一个字节的序号。</p>
</li>
<li><p>确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p>
</li>
<li><p>标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。其中重点是：</p>
<ul>
<li>SYN：表示发起一个新连接。</li>
<li>ACK：表示确认序号有效。（其实是用来确认接收到的数据）（注意，这个ACK和确认号Ack不要搞混！！！！）</li>
<li>FIN：表示释放一个连接。</li>
</ul>
</li>
</ol>
<p>下图是Wireshark中截出的一段tcp交互的seq和ack变化过程。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-922d63a4f387ec7844f4e507d0da1728b37.png" alt=""></p>
<blockquote>
<p>Wireshark的seq展示的是相对序号，即以ISN=0为基准的序号相对值。并不是ISN就这么刚好是0</p>
</blockquote>
<h2 id="3-1-TCP连接的建立——三次握手"><a href="#3-1-TCP连接的建立——三次握手" class="headerlink" title="3.1 TCP连接的建立——三次握手"></a>3.1 TCP连接的建立——三次握手</h2><p>所谓的三次握手即TCP连接的建立。这个连接必须是一方主动打开，另一方被动打开的。以下为客户端主动发起连接的图解：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4c580376d1c99db1a4cfbf33fde066cbd49.png" alt=""></p>
<ul>
<li><p>客户端A的TCP向服务端发出连接请求报文段，其首部中的SYN控制位应置为1，并选择序号x（前面说过，一个端的序号初始值是随机的，我们姑且认为它是x），表明传送数据时的第一个数据字节的序号是x。</p>
<ul>
<li>此时客户端进入SYN-SENT状态。</li>
</ul>
</li>
<li><p>服务端B的TCP收到连接请求报文段后，如同意，则发回确认：</p>
<ul>
<li>服务端B在确认报文段中应将SYN置为 1，其确认号ACK置位为x + 1，同时自己这端也会给这个确认报文段写入序号=y。</li>
<li>此时服务端进入SYN-RCVD状态</li>
</ul>
</li>
<li><p>客户端A收到此报文段后，向服务端B给出确认，其确认号置为 y + 1。</p>
<ul>
<li>客户端的TCP通知上层应用进程，连接已经建立。客户端进入ESTABLISHED状态</li>
<li>当运行服务器进程的服务器主机B的TCP收到客户端主机A的确认后，也通知其上层应用进程，连接已经建立。服务端也进入ESTABLISHED状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于客户对报文段进行了编号，它知道哪些序号是期待的，哪些序号是过时的。当客户发现报文段的序号是一个过时的序号时，就会拒绝该报文段，这样就不会造成重复连接。</p>
</blockquote>
<h2 id="3-2-TCP连接的终止——四次分手"><a href="#3-2-TCP连接的终止——四次分手" class="headerlink" title="3.2 TCP连接的终止——四次分手"></a>3.2 TCP连接的终止——四次分手</h2><p>数据传输结束后，通信双方都可以释放连接。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4315377ecfaa3273f699ec6718dbf8e4d5a.png" alt=""></p>
<p>看起来比较简单，说是四次分手，<strong>其实就是FIN-ACK的交互，由主动方和被动方先后各执行了一次而已</strong>。上图已经直观展示的过程我们不再赘述，下面说一些比较值得注意的点：</p>
<h3 id="3-2-1-2MSL等待状态"><a href="#3-2-1-2MSL等待状态" class="headerlink" title="3.2.1 2MSL等待状态"></a>3.2.1 2MSL等待状态</h3><p>TIME_WAIT状态也称为2MSL等待状态。主动关闭的端（即上图中的客户端）在发送最后一个ACK的时候，没有立刻关闭，而是等待了2个MSL的时间才关闭。</p>
<p>MSL（Maximum Segment Lifetime），指的是一个报文段最大的生存时间，即一个报文段被丢弃前在网络内的最长时间。我们知道这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。不过不同的TCP实现由不同的MSL设置，我们不去管他到底是何值，只要知道它控制着报文段在网络中的最长生存时间，<strong>如果超过MSL时间报文段还没到达彼端，那么它将被丢弃</strong>。</p>
<p>之所以A端在发送最后一个ACK后还要等待2MSL的时间才关闭，<strong>是因为假如最后一个ACK丢失了，B端会等待ACK超时，然后再重发一个FIN过来，如果A端立刻关闭，它就可能无法响应到这个重发的FIN。只有等待2MSL后A段没有收到B端重发的FIN，A端才会关闭。</strong></p>
<h3 id="3-2-2-半关闭链接"><a href="#3-2-2-半关闭链接" class="headerlink" title="3.2.2 半关闭链接"></a>3.2.2 半关闭链接</h3><p>TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭。</p>
<p>显示了一个半关闭的典型例子。假设左方的客户端开始半关闭。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3fb926c3cf588c58785d3d3c0eefd7c58bf.png" alt=""></p>
<ul>
<li><p>初始端发出的FIN，接着是另一端对这个FIN的ACK报文段。<strong>因为接收半关闭的一方仍能发送数据（这是半关闭的基础）</strong>。</p>
</li>
<li><p>我们只显示一个数据报文段和一个ACK报文段，但可能发送了许多数据报文段。</p>
</li>
<li><p>当收到半关闭的一端在完成它的数据传送后，将发送一个FIN关闭这个方向的连接，这将传送一个文件结束符给发起这个半关闭的应用进程。当对第二个FIN进行确认后，这个连接便彻底关闭了。</p>
</li>
</ul>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><ul>
<li><p>建连接为什么需要三次握手？</p>
<ul>
<li>因为通信的双方要互相通知对方自己的ISN（也就上图中的 x 和 y）——所以需要两端各发出一个SYN（全称Synchronize Sequence Numbers，顾名思义，就是用来同步对方自己的ISN的）。ISN后续要作为数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序。</li>
<li>而光有SYN还不够，<strong>发端还要确认对端真的收到了我SYN，而不是我发出去SYN就了事</strong>，所以还有最后一个ACK</li>
</ul>
</li>
<li><p>断连接为什么需要四次挥手</p>
<ul>
<li>因为TCP是全双工的，所以，发送方和接收方都需要各一次的Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。</li>
<li>其实仔细看，挥手比起握手之所以多了一次，主要是收到第一个fin包后单独回复了一个ack包，如果能回复fin+ack那么四次挥手也就变成三次了。</li>
<li>之所以被动端没有在收到fin后回复fin+ack，是因为在CLOSE_WAIT状态阶段，被动端需要去通知应用进程，会有一些时间消耗，所以先回发一个ack，等应用进程确定关闭后，再发送一个fin。否则如果应用进程没有关闭，至少还能维持一个半关闭链接。</li>
<li>如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-2d31a376256d1ac00ef996f1dd52e1a1716.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4-TCP数据的交互"><a href="#4-TCP数据的交互" class="headerlink" title="4 TCP数据的交互"></a>4 TCP数据的交互</h1><p>我们已经在前文的叙述中大概知道了TCP的数据传输，是通过数据和ack的相互交替来确认的，TCP连接的任意一端发送数据，都会捎带一个seq（数据的第一个字节的序号），接收端接收到数据后，返回ACK（控制位）=1，Ack（确认号）=seq+len</p>
<blockquote>
<p>注意，Ack=seq+len，表示的不是它要确认的data的最后一个字节的序号，而是它希望下次接收到的第一个序号。<br>比如，seq=90，len=1，那这唯一的1字节的data，它的序号就是90，Ack=90+1=91，表示它希望下次接受的第一个序号是从91开始。</p>
</blockquote>
<p><img src="https://oscimg.oschina.net/oscnet/up-b4dc1e5e539de60fa74de2a09388dc8eed0.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6c51c255feef37912a51dd9cd89563a46fc.png" alt=""></p>
<h2 id="4-1-捎带确认Delay-ACK"><a href="#4-1-捎带确认Delay-ACK" class="headerlink" title="4.1 捎带确认Delay ACK"></a>4.1 捎带确认Delay ACK</h2><p>通常TCP在接收到数据时并不立即发送ACK，相反，它推迟发送，以便将ACK与需要沿该方向发送的数据（<strong>这个数据可以是应用数据，也可以是另外一个同方向的ACK</strong>）一起发送（有时称这种现象为数据捎带确认），这样做的目的是尽量减少发往网络的报文，以提高传输的效率，节省网络资源。</p>
<p>为了防止产生超时重传，绝大多数情况下，这个等待时间为200ms，超过了200ms，如果没有数据要一起发送，就直接发送ACK报文。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-90e28e43ca3cd1c372709181d9faa0e1687.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2af49e8f61011242f212c658fcd97318e78.png" alt=""></p>
<h2 id="4-2-累计确认和Duplicate-ACK"><a href="#4-2-累计确认和Duplicate-ACK" class="headerlink" title="4.2 累计确认和Duplicate ACK"></a>4.2 累计确认和Duplicate ACK</h2><p>在TCP会话中，发送方对段的发送速度有时候非常快，比如发送方发了A,B,C,D四个段；段A含字节0到10，段B含字节11到20，段C含字节21到30，段D包含字节31到40</p>
<p>接受方成功收到段A，段B，段D，只有段C丢失了。那么接受方<strong>发回一个包含确认序号21的ACK</strong>（而不是分别给段A和段B都回复一个ACK，等于是把段A和段B的ACK合并了一样），发送方收到这个合并的ACK，就知道字节0到20(段A，段B)都成功收到。</p>
<p>通过累积确认的方式，在发送方快速发包的场景，一个ACK可以直接确认<strong>接收方接收到的连续序号的好几个段</strong>，这样减少报文段的传输。</p>
<blockquote>
<p>注意，如果段C没有收到，那么段D即便收到了，接收方也不会回复段D的ACK，因为一旦回复段D的ACK，就表示段D以前的数据都收到了，但其实段C还没收到。</p>
</blockquote>
<p>因为段C丢失，之后接收端即便接收到段E，段F等数据，也只会重复回复确认序号21的ACK，这时我们可以看到，因为段C丢失，接收端重复发送了很多次Ack=21，这种ACK我们称之为<strong>冗余ACK（duplicate ACK）</strong>。</p>
<h2 id="4-3-Nagle算法"><a href="#4-3-Nagle算法" class="headerlink" title="4.3 Nagle算法"></a>4.3 Nagle算法</h2><p>在TCP传输数据流中，存在两种类型的TCP报文段，一种包含成块数据（通常是满长度的，利用缓存，使报文一次发送就携带一个报文段最多容纳的字节数），另一种则包含交互数据（通常只有携带几个字节数据）。</p>
<p>对于成块数据的报文段，TCP采用正常的流程发送即可，因为数据利用率很高。而对于交互数据的报文段（也就是ACK），数据利用率就显得很低（因为ACK一般就一个IP头和TCP头），在网络环境不好的情况下容易加重网络负担。所以TCP必须对交互数据单独处理</p>
<p><strong>nagle算法用于处理小报文段（微小分组）的发送问题，其核心思想是允许网络中最多只能有一个小分组被发送，而待发送的其它小分组会被重新分组成一个”较大的”小分组，等收到上一个小分组的应答后再发送</strong>。</p>
<p>比如客户端需要依次向服务器发送大小为1,2,3,1,2字节的5个分组</p>
<p>在没有开启nagle算法的情况下，这些小分组会被依次发送（不需要等待上一个小分组的应答，因为没启动nagle），总共发送的报文段（分组）个数为5</p>
<p>当开启nagle算法时，客户端首先发送大小为1字节的第一个分组，随后其它分组到达发送缓冲区，由于上一个分组的应答还没有收到，所以TCP会先缓存新来的这4个小分组，并将其重新分组，组成一个大小为8(2+3+1+2)字节的”较大的”小分组。当第一个小分组的应答收到后，客户端将这个8字节的分组发送。总共发送的报文段（分组）个数为2。</p>
<blockquote>
<p>将套接字描述符设置TCP_NODELAY选项可以禁止nagle算法</p>
</blockquote>
<h2 id="4-4-超时重传"><a href="#4-4-超时重传" class="headerlink" title="4.4 超时重传"></a>4.4 超时重传</h2><p>TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据。对任何实现而言，关键之处就在于超时和重传的策略，即怎样决定超时间隔和如何确定重传的频率。</p>
<p>下图是一个超时重传的例子：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-09a3bb4827e8903f8b42dacd0385e2d814c.png" alt=""></p>
<ul>
<li>第1、2和3行表示正常的TCP连接建立的过程</li>
<li>第4行是“hello,world”（12个字符加上回车和换行）的传输过程</li>
<li>第5行是其确认。接着我们从svr4拔掉了以太网电缆</li>
<li>第6行表示“andhi”将被发送。第7~18行是这个报文段的12次重传过程，</li>
<li>而第19行则是发送方的TCP最终放弃并发送一个复位信号的过程。</li>
</ul>
<p>连续重传之间不同的时间差，我们整理后发现他们分别为1.5、3、6、12、24、48和多个64秒。这个倍乘关系被称为“指数退避(exponentialbackoff)”。也就是说，每一次超时，等待的时间都会翻倍，直到等待时间为64秒为止。</p>
<p>首次分组传输（第6行，24.480秒）与复位信号传输（第19行，566.488秒）之间的时间差约为9分钟，该时间在目前的TCP实现中，大多数是不可变的。也就是大多数的TCP实现都要尝试9分钟才会放弃。</p>
<h2 id="4-5-选择确认"><a href="#4-5-选择确认" class="headerlink" title="4.5 选择确认"></a>4.5 选择确认</h2><h3 id="4-5-1-SACK"><a href="#4-5-1-SACK" class="headerlink" title="4.5.1 SACK"></a>4.5.1 SACK</h3><p>我们知道累计确认，不会越过接收方未接受到的序号进行确认，如前例中的ABCD四个段，段A含字节0到10，段B含字节11到20，段C含字节21到30，段D包含字节31到40。</p>
<p>段C未收到，那么是不会返回确认号为41的ACK的。即便接收方已经收到了段D。</p>
<p>这种情况下，发送方只接收到了ack=21，那对于发送方而言，它可以有两种理解：</p>
<ol>
<li>段C丢失了</li>
<li>段C和段D都丢失了</li>
</ol>
<p>这时为了保险起见，发送方可能会重传段C和段D，但我们知道其实段D是没有必要重传的。</p>
<p><strong>为了解决这个问题，TCP实现引入了选择确认机制。</strong></p>
<p>选择确认全称叫做Selective Acknowledgment(SACK)，这种方式需要在TCP首部的选项中里加一个SACK的字段，它的工作原理也十分简单，一目了然：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4b6f8eb48e958728610987dacca173647ef.png" alt=""></p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。</p>
<p>选择确认的数据包长这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0374b03864f3bd117915b947228b916fa2c.png" alt=""></p>
<ol>
<li>这个确认包只有tcp首部，没有数据部分</li>
<li>Kind：SACK（5）用来表示这是选择确认（SACK），该字段占用一个字节。</li>
<li>Length表示tcp选项长度，占用一个字节，左边界和右边界各占用4字节，也就是说这里总共用掉了10字节。</li>
<li>其中left edge表示接收方接收到的数据块中的左边界位置（起始字节）</li>
<li>right edge可以理解为接收方接收到的数据块中的结束位置（右边界）</li>
</ol>
<p>也就是说，通过左边界和右边界我们可以指明一个数据块的位置。那么我们可以根据捕获的数据报中的确认号丢失的数据块中的起始字节，也就是要重传的起始字节，再结合接收窗口，左边界和右边界。我们可以推出接收窗口中的已经接收到的数据块，和未接收到的数据块：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-de3184da09ab090ed97fa9c1d071303a2e9.png" alt=""></p>
<p>这样，发送方在进行选择性重传时，会从2336611189字节的位置开始重传。注意：对于已经接收到的字节数据块（2336631881 - 2336693150）是不会被重传的。</p>
<blockquote>
<p>在前面学习TCP首部的时候我们知道，TCP首部中的选项部分最大是40字节，选择确认选项左边界和右边界在指明一个数据块时就用掉了8字节，那么指明4个数据块就用掉了32字节，再加上Kind：SACK（5）和Length两个字段占用的2字节，最终只剩下了6字节，换句话说，TCP选项的选择确认选项最多也就只能指明4个数据块</p>
</blockquote>
<h3 id="4-5-2-Duplicate-SACK"><a href="#4-5-2-Duplicate-SACK" class="headerlink" title="4.5.2 Duplicate SACK"></a>4.5.2 Duplicate SACK</h3><p>Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。</p>
<p>作为对比，SACK是告诉发送方，接受方已经收到了哪些数据，不要混淆。</p>
<p>那什么样的SACK是D-SACK呢？</p>
<p>答案是：</p>
<ol>
<li><p>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</p>
<ul>
<li>假如发送端已经收到了一个ACK报文，内容为：[Ack=4000, SACK=5000-5500, 4500-5500]，Ack=4000表示序号为4000以前的字节都收到了，这时候再看选项中的SACK=3000-3500，那么很显然，SACK框定的字节范围是已经被确认的范围，那么这个SACK是D-SACK，3000-3500也就是被重传的数据段。</li>
</ul>
</li>
<li><p>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</p>
<ul>
<li>假如发送端收到一个[Ack=4000,SACK=5000-5500, 4500-5500]，那么第二个段的区间4500-5500，覆盖了第一个段的区间5000-5500，这表示该SACK是个D-SACK，5000-5499段是重复收到的。</li>
</ul>
</li>
</ol>
<p>D-SACK在如下场景发挥比较积极的作用：</p>
<ol>
<li>ACK丢包<ul>
<li>如果一个发送端发送序号为3000-3999的段，却没收到对应的ACK，那么过一段时间发送端重传该段，紧接着却收到了[Ack=4000,SACK=3000-3999]，那么发送端就知道，之前的那个ACK丢失了。</li>
</ul>
</li>
<li>发送延误<ul>
<li>发送端发送序号为1000-1499的段，这个段因为网络延迟，导致接收端迟迟没有收到。发送端继续发送后面的段，但接收端因为没有收到1000-1499的段，所以只会回复[Ack=1500]</li>
<li>发送端收到3次[Ack=1500]，就会重传这个1000-1499的段，在重传的期间，接收端也收到了姗姗来迟的原来的1000-1499的段，这时面对重传的新段，接收端返回了[Ack=4000, SACK=1000-1499]</li>
<li>发送端通过这个D-SACK，就知道之前发出去的段，是因为网络延迟才迟到的。</li>
</ul>
</li>
</ol>
<p>可见，引入了D-SACK，有这么几个好处：</p>
<ol>
<li><p>可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</p>
</li>
<li><p>是不是自己的timeout太小了，导致重传。</p>
</li>
<li><p>网络上出现了先发的包后到的情况（又称reordering）</p>
</li>
<li><p>网络上是不是把我的数据包给复制了。</p>
</li>
</ol>
<h1 id="5-RTT算法"><a href="#5-RTT算法" class="headerlink" title="5 RTT算法"></a>5 RTT算法</h1><p>从前文的TCP重传机制我们知道Timeout的设置对于重传非常重要：</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。</p>
<p>我们把这里的超时时间命名为RTO（Retransmission TimeOut），为了动态地设置RTO，TCP引入了RTT的概念——Round Trip Time，<strong>也就是一个数据包从发出去到回来的时间</strong>。</p>
<p>听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。但其实没那么简单，这只是一个<strong>采样</strong>，不能代表普遍情况。</p>
<h2 id="5-1-经典算法"><a href="#5-1-经典算法" class="headerlink" title="5.1 经典算法"></a>5.1 经典算法</h2><p>RFC793中定义的经典算法是这样的：</p>
<ol>
<li><p>首先，先<strong>采样</strong>RTT，记下最近好几次的RTT值。</p>
</li>
<li><p>然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）</p>
</li>
</ol>
<p><code>SRTT = ( α * SRTT ) + ((1- α) * RTT)</code></p>
<ol>
<li>开始计算RTO。公式如下：</li>
</ol>
<p><code>RTO = min [UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</code></p>
<pre><code>其中：
UBOUND是最大的timeout时间，上限值
LBOUND是最小的timeout时间，下限值
β 值一般在1.3到2.0之间。</code></pre><h2 id="5-2-Karn-Partridge-算法"><a href="#5-2-Karn-Partridge-算法" class="headerlink" title="5.2 Karn / Partridge 算法"></a>5.2 Karn / Partridge 算法</h2><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p>
<p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li><p>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</p>
</li>
<li><p>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。</p>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-e601aab8b8345e819d0be3da0cee0083ecb.png" alt=""></p>
<p>所以1987年的时候，搞了一个叫Karn / Partridge算法，这个算法的最大特点是——忽略重传，不把重传的RTT做采样（你看，你不需要去解决不存在的问题）。</p>
<p>但是，这样一来，又会引发一个大BUG——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重传所有的包（因为之前的RTO很小，所以很容易就超时），于是，因为重传的不算，所以，RTO就不会被更新，导致包仍非常容易超时，这是一个灾难。 </p>
<p>于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<h2 id="5-3-Jacobson-Karels-算法"><a href="#5-3-Jacobson-Karels-算法" class="headerlink" title="5.3 Jacobson / Karels 算法"></a>5.3 Jacobson / Karels 算法</h2><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看RFC6289）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。</p>
<p>我们每次<strong>采样</strong>，都能得到一个新的RTT，即RTT[新]，除此之外，还引入了</p>
<ol>
<li>SRTT（Smoothed RTT）——平滑 RTT</li>
<li>DevRTT（Deviation RTT）——滑 RTT 和真实的差距</li>
</ol>
<p>这二者的值，每次采样之后都会更新，于是得到公式如下：</p>
<p><code>SRTT[新] = SRTT[旧] + α ( RTT[新] – SRTT[旧] ) —— 计算平滑 RTT</code></p>
<p><code>DevRTT[新] = ( 1-β ) * DevRTT + β * ( | RTT[新] - SRTT[旧]  | ) ——计算平滑 RTT 和真实的差距（加权移动平均）</code></p>
<p><code>RTO= µ * SRTT + ∂ * DevRTT</code></p>
<p>其中：α、β、μ、∂ 是可以调整的参数，在 RFC6298 中给出了对应的参考值，而在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4；</p>
<blockquote>
<p>Jacobson / Karels算法在被用在今天的TCP协议中（Linux的源代码在：tcp_rtt_estimator）。</p>
</blockquote>
<h1 id="6-滑动窗口"><a href="#6-滑动窗口" class="headerlink" title="6 滑动窗口"></a>6 滑动窗口</h1><h2 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h2><p>我们知道TCP正常的交互是这样的：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d7f1cb4dffbb5fa40972503bbaec49f1503.png" alt=""></p>
<p>这带来了一个问题：吞吐量非常的低。我们发完包1，一定要等确认包1.我们才能发送第二个包。</p>
<p>那如何提高吞吐量？我们可不可以连发几个包等他一起确认呢？</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7692e692bb6f30ce6b27ee7c87b04e86023.png" alt=""></p>
<p>这样确实可以提高吞吐量，发送两个包，所花的时间只是原来一个来回的时间。</p>
<p>但是，新的问题又来了，如果我一次把太多的包连发，超过了接收端的处理上限，导致中途一直重传超时的包，即占用了带宽，又提高不了太多的吞吐量，如何制定最优解呢？TCP实现了一种被称为滑动窗口的流控机制</p>
<h2 id="6-2-发送窗口和接受窗口"><a href="#6-2-发送窗口和接受窗口" class="headerlink" title="6.2 发送窗口和接受窗口"></a>6.2 发送窗口和接受窗口</h2><p>滑动窗口解决的是TCP流量控制的问题，即如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。</p>
<p>我们知道TCP是全双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个<strong>发送窗口（本质是一个缓存）</strong> 和一个 <strong>接收窗口（本质是一个缓存）</strong> 。</p>
<ul>
<li>各自的<strong>接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）</strong>。</li>
<li>各自的发送窗口的大小，则取决于<strong>对端</strong>的接收窗口。</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-9679d08b92cf441e4e938245430a4aea2a9.png" alt=""></p>
<p>在TCP的首部中，我们知道有个窗口（Window Size）字段，它是指接收端的窗口大小（单位字节），即接收窗口的大小。用来告知发送端自己所能接收的数据量，从而达到一部分流控的目的。</p>
<p>同时，选项中还有一个窗口扩展选项（Window Scaling)，前文我们也简单介绍过。窗口扩展选项和窗口字段，这二者由接收端通知发送端，最终确定了发送端的发送窗口大小。</p>
<p>因为接受窗口不是恒定的，所以在会话中，接收端可以不断的通知发端改变窗口大小。</p>
<p>假设，我们设定两边的接受窗口为20*MSS（Maxitum Segment Size），那么我们一个窗口，就可以发送20个满数据的段。如下图（方框内的数字为段的编号）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dabdb246da118fbdb57ec82e179ecc68f64.png" alt=""></p>
<p>其中发送端的段可以分成以下四类</p>
<ol>
<li>已发送，已收到ACK</li>
<li><strong>已发送，未收到ACK</strong>（属于发送窗口）</li>
<li><strong>未发送，但允许发送</strong>（属于发送窗口）</li>
<li>未发送，但不允许发送</li>
</ol>
<p>接收端的段可以分成以下三类</p>
<ol>
<li>已接收</li>
<li><strong>未接收但允许接收</strong>（属于接收窗口）</li>
<li>未接收而且不允许接收</li>
</ol>
<h2 id="6-3-滑动机制"><a href="#6-3-滑动机制" class="headerlink" title="6.3 滑动机制"></a>6.3 滑动机制</h2><ol>
<li><p>发送窗口只有收到发送窗口内的段的ACK确认，才会移动发送窗口的左边界。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-946e095931c35d0a80c6c45f6e0cb5ec7d2.png" alt=""></li>
</ul>
</li>
<li><p>接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有段未接收到，但先收到后面段的情况下，窗口不会移动，也不对窗口外的段进行确认。以此确保对端会对这些数据重传。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-4afa13df8020772655f1b44a468790dfda8.png" alt=""></li>
<li>没有收到G的情况下，窗口不会左移，就算收到窗口外的段，也不会进行确认</li>
</ul>
</li>
<li><p>遵循累计确认、选择确认等规则。</p>
</li>
</ol>
<h2 id="6-4-滑动过程"><a href="#6-4-滑动过程" class="headerlink" title="6.4 滑动过程"></a>6.4 滑动过程</h2><p>flash来自一个模拟TCP滑动窗口的动画：<a href="http://www.exa.unicen.edu.ar/catedras/comdat1/material/Filminas3_Practico3.swf" target="_blank" rel="noopener" title="动画地址">动画地址</a></p>
<ol>
<li><p>假定窗口大小为4*MSS，首先发送端发送A,B,C,D四个包，但是A,B丢失，只有C,D到达接收端。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-8109151f2ca10f0c6c5abd0c8774be9c575.png" alt=""></li>
</ul>
</li>
<li><p>接收端没有收到A，所以不回复ACK包。发送端重传的A,B,C,D四个包。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-e2b5a2ab1460977ca81a8e7c2b06a95df45.png" alt=""></li>
</ul>
</li>
<li><p>这次发送端重传的A,B,C,D四个包全都到达了，接收端先获得A，发ACK包A，但是中途丢失；接收端获得B后，根据累计确认的原则，发D的ACK包，然后窗口滑动。再次获得C,D后，连续回复2个D的ACK包，其中C对应的ACK包丢失。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-f1a81ca52edc05a9f46dcb444c3824b9d60.png" alt=""></li>
</ul>
</li>
<li><p>发送端连收2个D的ACK包，说明4个包对方都已收到，窗口滑动，发E,F,G,H包，其中G包丢失。现在整个序列的状态：ABCD是已发送已确认，EFGH是已发送未确认，I~S是不能发送。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-3555fd95fd6e8faeffdeb0ae13375cae18f.png" alt=""></li>
</ul>
</li>
<li><p>收端先收到E，发E的ACK包；收到F后发F的ACK包；未收到G；收到H，还是发F的ACK包。不幸的是，后两个ACK包全都丢失。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-6623f269f126fd0fb5cd19f1baaaf954e8b.png" alt=""></li>
</ul>
</li>
<li><p>送端收到E的ACK包，窗口向右滑动一位，发送I包，然后再发送F,G,H，其中F丢失。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-e8f2ba5ab327822f79d50e6e967fdd25895.png" alt=""></li>
</ul>
</li>
<li><p>接收端获得I，因为没有G，只好回复F的ACK包(不过紧接着这个包丢了)。还好，接收端相继收到G,H包。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-de01d1b06c6fc7422615569cf37c00c7798.png" alt=""></li>
</ul>
</li>
<li><p>接收端根据累计确认，连发两个I包，其中H的ACK丢失。窗口向右滑动。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-dbe0cb2f7a9b9c97322a234015aeeb02c60.png" alt=""></li>
</ul>
</li>
<li><p>发送端接收I的ACK包后，向右滑动四位。发送J,K,L,M四个包，后面不再分析。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-673c5f49f65170fec5d562a36873a83c936.png" alt=""></li>
</ul>
</li>
</ol>
<p>我们之前说过，在会话过程中，窗口大小也是随时可能发生改变的，下图就展示了一次动态的滑动窗口变动过程：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e0a4aec2b9558a73c2e5ad4ca06c6899a3e.png" alt=""></p>
<p>我们可以看到：</p>
<ol>
<li>发送方不必发送一个全窗口大小的数据。</li>
<li>正如从报文段7到报文段8中变化的那样，窗口的大小可以减小，但是窗口的右边沿却不能够向左移动</li>
<li>接收方在发送一个 ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。</li>
</ol>
<h2 id="6-5-零窗口（Zero-Window）"><a href="#6-5-零窗口（Zero-Window）" class="headerlink" title="6.5 零窗口（Zero Window）"></a>6.5 零窗口（Zero Window）</h2><p><img src="https://oscimg.oschina.net/oscnet/up-7a3eaba1fbc9ee71fb59571821a6c77b3f2.png" alt=""></p>
<p>上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第一次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<h2 id="6-6-糊涂窗口综合症（Silly-Window-Syndrome）"><a href="#6-6-糊涂窗口综合症（Silly-Window-Syndrome）" class="headerlink" title="6.6 糊涂窗口综合症（Silly Window Syndrome）"></a>6.6 糊涂窗口综合症（Silly Window Syndrome）</h2><p>我们知道，发送端的发送窗口大小是受馈于接收端通知的接收窗口大小的，如果接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方窗口越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送<strong>这几个字节</strong>。</p>
<p>要知道，我们的TCP+IP头有40个字节，为了<strong>几个字节</strong>，要达上这么大的开销，这太不经济了。糊涂窗口综合症这个现象<strong>就像是你本来可以坐200人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li>如果这个问题是由Receiver端引起的，那么就会使用David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS（以太网MSS为1500字节），或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</li>
<li>如果这个问题是由Sender端引起的，那么就会使用前文介绍的Nagle’s算法。我们知道这个算法的思路也是延时处理，积攒数据，等于一架飞机在等待客人，以便一次能多拉一些人。</li>
</ul>
<h1 id="7-拥塞控制"><a href="#7-拥塞控制" class="headerlink" title="7 拥塞控制"></a>7 拥塞控制</h1><p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。</p>
<p>TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。</p>
<p>试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。这是一个灾难。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了</strong>。</p>
<p>拥塞控制为发送方增加了另一个窗口：<strong>拥塞窗口</strong>(congestionwindow)，记为cwnd。它以字节为单位，和接收方通告发送方的窗口（我们叫做通告窗口）一起，控制发送方的窗口大小——<strong>发送方取拥塞窗口与通告窗口中的最小值作为发送上限</strong>。拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制。</p>
<p>TCP拥塞控制算法发展的过程中出现了如下几种不同的思路：</p>
<ol>
<li>基于丢包的拥塞控制：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如Reno、Cubic等。</li>
<li>基于时延的拥塞控制：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如Vegas、FastTCP等。</li>
<li>基于链路容量的拥塞控制：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如BBR。</li>
<li>基于学习的拥塞控制：没有特定的拥塞信号，而是借助评价函数，基于训练数据，使用机器学习的方法形成一个控制策略，如Remy。</li>
</ol>
<h2 id="7-1-Reno算法"><a href="#7-1-Reno算法" class="headerlink" title="7.1 Reno算法"></a>7.1 Reno算法</h2><p>Reno现有的众多拥塞控制算法的基础，它将拥塞控制的过程分为四个阶段：</p>
<ol>
<li><strong>慢启动</strong></li>
<li><strong>拥塞避免</strong></li>
<li><strong>快速重传</strong></li>
<li><strong>快速恢复</strong></li>
</ol>
<p>这四个阶段的相关算法和处理策略不是一天都搞出来的，这个四阶段算法的发展经历了很多时间，到今天都还在优化中。</p>
<p>Reno算法将收到ACK这一信号作为拥塞窗口增长的依据，在早期低带宽、低时延的网络中能够很好的发挥作用，但是随着网络带宽和延时的增加，Reno的缺点就渐渐体现出来了，发送端从发送报文到收到ACK经历一个RTT，在高带宽延时（High Bandwidth-Delay Product，BDP）网络中，RTT很大，导致拥塞窗口增长很慢，传输速度需要经过很长时间才能达到最大带宽，导致带宽利用率将低。</p>
<p>适用场景：适用于低延时、低带宽的网络。</p>
<h3 id="7-1-1-慢启动（Slow-Start）"><a href="#7-1-1-慢启动（Slow-Start）" class="headerlink" title="7.1.1 慢启动（Slow Start）"></a>7.1.1 慢启动（Slow Start）</h3><p>首先，我们来看一下TCP的慢启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来便无脑向网络发送多个报文段，把现有的传输秩序搞乱。</p>
<p>慢启动的算法如下：</p>
<ol>
<li><p>连接建好的开始先初始化cwnd = 1个MSS，表明可以传一个MSS大小的数据。</p>
</li>
<li><p>每当收到一个ACK，cwnd+1，即相当于每轮次（一个RTT，无拥塞情况下共可收到cwnd个ACK）发送窗口增加一倍，呈指数增长</p>
<ul>
<li><strong>换句话说，一次交互cwnd * 2;</strong></li>
</ul>
</li>
<li><p>还有一个慢启动门限ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（下文介绍）</p>
</li>
</ol>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-48981739b1cce1dabb79d1837b1e0f20583.png" alt=""></p>
<blockquote>
<p>这里需要提一下的是一篇Google的论文《An Argument for Increasing TCP’s Initial Congestion Window》（<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf）" target="_blank" rel="noopener">http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf）</a><br>Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。<br>而Linux 3.0以前，比如2.6，Linux采用了RFC3390，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p>
</blockquote>
<h3 id="7-1-2-拥塞避免"><a href="#7-1-2-拥塞避免" class="headerlink" title="7.1.2 拥塞避免"></a>7.1.2 拥塞避免</h3><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<ul>
<li>收到一个ACK时，cwnd = cwnd + 1/cwnd，即相当于每轮次（一个RTT，无拥塞情况下共可收到cwnd个ACK）发送窗口+1 * MSS，呈线性增长<ul>
<li><strong>换句话说，一次交互cwnd + 1 * MSS ;</strong></li>
</ul>
</li>
</ul>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<p>所以我们可以看到：</p>
<ul>
<li>当cwnd&lt;ssthresh时，使用慢开始算法。</li>
<li>当cwnd&gt;ssthresh时，改用拥塞避免算法。</li>
</ul>
<h3 id="7-1-3快速重传"><a href="#7-1-3快速重传" class="headerlink" title="7.1.3快速重传"></a>7.1.3快速重传</h3><p>在介绍拥塞发生时tcp选择的策略时，我们要先了解快速重传策略。</p>
<h4 id="7-1-3-1-快速重传策略"><a href="#7-1-3-1-快速重传策略" class="headerlink" title="7.1.3.1 快速重传策略"></a>7.1.3.1 快速重传策略</h4><p>现有的超时重传机制，还有一些问题：</p>
<ul>
<li>当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。</li>
<li>当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li>
</ul>
<p>幸运的是，由于TCP采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）。<br>如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7536f9cee4486e13802d9341b33ceb16d0b.png" alt=""></p>
<p>这样，<strong>如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK</strong>（其实是收到4个同样的ACK，第一个是正常的，后三个才是冗余的），发送端便知晓哪个报文段在传输过程中丢失了，于是<strong>重发该报文段，不需要等待超时重传定时器溢出</strong>，大大提高了效率。这便是快速重传机制。</p>
<blockquote>
<p>为什么需要3次冗余ACK才会触发快速重传？因为即使发送端是按序发送，由于TCP包是封装在IP包内，IP包在传输时乱序，意味着TCP包到达接收端也是乱序的，乱序的话也会造成接收端发送冗余ACK。如果阈值设置的过小，那么快速重传机制很容易被乱序引发的冗余ACK干扰。</p>
</blockquote>
<h4 id="7-1-3-2-拥塞发生时的策略选择"><a href="#7-1-3-2-拥塞发生时的策略选择" class="headerlink" title="7.1.3.2 拥塞发生时的策略选择"></a>7.1.3.2 拥塞发生时的策略选择</h4><p>如果慢启动和拥塞避免算法，仍然无法避免TCP连接进入拥塞状态（发生丢包的情况），那么这时，就要采取非常手段了。</p>
<p>对于丢包，我们知道有两种情况会发生：</p>
<ol>
<li>收到3个duplicate ACK</li>
<li>还没收到3个duplicate ACK，就RTO超时</li>
</ol>
<p>这两种情况下，TCP选择的算法也不一样，我们先讲比较严重的情况2，再讲程度稍好的情况1。（情况1还能收到3个ACK，情况2直接连ACK都超时或者丢了，网络拥塞更严重）</p>
<ul>
<li>情况2：还没收到3个duplicate ACK，就RTO超时<ul>
<li>设置sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>如此一来，cwnd必然小于sshthresh，进入慢启动过程</li>
</ul>
</li>
<li>情况1：收到3个duplicate ACK<ul>
<li>那毫无疑问，快速重传继续，重发数据段。</li>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减少一半，然后等cwnd又很快地以指数级增长爬到cwnd=sshthresh这个地方时，就会成慢慢的线性增长。</p>
<p>我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fce15fccd5fb400c4e7c3731a978b75171e.png" alt=""></p>
<h3 id="7-1-4-快速恢复（Fast-Recovery）"><a href="#7-1-4-快速恢复（Fast-Recovery）" class="headerlink" title="7.1.4 快速恢复（Fast Recovery）"></a>7.1.4 快速恢复（Fast Recovery）</h3><p>这个算法定义在RFC5681。快速重传和快速恢复算法一般同时使用（都在情况1中），因为情况1还有ACK能回来，说明了网络还不是那么的糟糕，所以没有必要像RTO超时那么强烈。</p>
<blockquote>
<p>注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：<code>cwnd = cwnd /2</code>以及<code>sshthresh = cwnd</code></p>
</blockquote>
<p>然后，真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包，这时会有两种结果<ul>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
</li>
</ul>
<h2 id="7-2-Vegas算法"><a href="#7-2-Vegas算法" class="headerlink" title="7.2 Vegas算法"></a>7.2 Vegas算法</h2><p>该算法的论文是《<a href="http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf" target="_blank" rel="noopener" title="TCP Vegas: End to End Congestion Avoidance on a Global Internet">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》</p>
<p>Vegas将时延RTT的增加作为网络出现拥塞的信号，RTT增加，拥塞窗口减小，RTT减小，拥塞窗口增加。</p>
<p>具体来说，Vegas通过比较实际吞吐量和期望吞吐量来调节拥塞窗口的大小：</p>
<p>期望吞吐量：<code>Expected  = cwnd /  BaseRTT</code><br>实际吞吐量：<code>Actual = cwnd / RTT，diff = (Expected-Actual) * BaseRTT</code></p>
<p>其中，BaseRTT是所有观测来回响应时间的最小值，一般是建立连接后所发的第一个数据包的RTT，cwnd是目前的拥塞窗口的大小。</p>
<p>Vegas定义了两个阈值a，b，当diff &gt; b时，拥塞窗口减小，当a &lt;= diff &lt;=b时，拥塞窗口不变，当diff &lt; a时，拥塞窗口增加。</p>
<p>Vegas算法采用RTT的改变来判断网络的可用带宽，能精确地测量网络的可用带宽，效率比较好。但是，网络中Vegas与其它算法共存的情况下，基于丢包的拥塞控制算法会尝试填满网络中的缓冲区，导致Vegas计算的RTT增大，进而降低拥塞窗口，使得传输速度越来越慢，因此Vegas未能在Internet上普遍采用。</p>
<p>适用场景：适用于网络中只存在Vegas一种拥塞控制算法，竞争公平的情况。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener" title="TCP 的那些事儿（上）">TCP 的那些事儿（上）</a></li>
<li><a href="http://jm.taobao.org/2017/06/08/20170608/" target="_blank" rel="noopener" title="就是要你懂 TCP">就是要你懂 TCP</a></li>
<li><a href="https://blog.csdn.net/yao5hed/article/details/81046945" target="_blank" rel="noopener" title="解析TCP之滑动窗口(动画演示)">解析TCP之滑动窗口(动画演示)</a></li>
<li><a href="https://blog.csdn.net/qq_35733751/article/details/80157509" target="_blank" rel="noopener" title="tcp可靠传输——选择确认选项（SACK）">tcp可靠传输——选择确认选项（SACK）</a></li>
<li><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener" title="TCP 的那些事儿（下）">TCP 的那些事儿（下）</a></li>
<li><a href="https://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="noopener" title="Congestion Avoidance and Control">Congestion Avoidance and Control</a></li>
<li><a href="https://blog.csdn.net/smilesundream/article/details/71149434" target="_blank" rel="noopener" title="TCP拥塞控制——慢开始与拥塞避免算法">TCP拥塞控制——慢开始与拥塞避免算法</a></li>
<li><a href="https://www.cnblogs.com/lolau/p/9188476.html" target="_blank" rel="noopener" title="浅谈TCP拥塞控制算法">浅谈TCP拥塞控制算法</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/18/UDP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/18/UDP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" itemprop="url">UDP协议分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-18T23:08:31+08:00">
                2020-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/18/UDP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/03/18/UDP协议分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-UDP的概述"><a href="#1-UDP的概述" class="headerlink" title="1. UDP的概述"></a>1. UDP的概述</h1><p>UDP是User Datagram Protocol（用户数据报协议）的缩写，它是传输层的协议，功能即为在IP的数据报服务之上增加了最基本的服务：复用和分用以及差错检测。</p>
<p>UDP提供<strong>不可靠</strong>的服务（它把应用程序传给IP层的数据发送出去，但是并不保证它们能到达目的地。），具有TCP所没有的优势：</p>
<ol>
<li><p>UDP无连接，时间上不存在建立连接需要的时延。空间上，TCP需要在端系统中维护连接状态，需要一定的开销。此连接装入包括接收和发送缓存，拥塞控制参数和序号与确认号的参数。UCP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。</p>
<ul>
<li>举个例子：</li>
<li>DNS如果运行在TCP之上而不是UDP，那么DNS的速度将会慢很多。</li>
<li>HTTP使用TCP而不是UDP，是因为对于基于文本数据的Web网页来说，可靠性很重要。</li>
<li>同一种专用应用服务器在支持UDP时，一定能支持更多的活动客户机。</li>
</ul>
</li>
<li><p>分组首部开销小，TCP首部20字节，UDP首部8字节。</p>
</li>
<li><p>UDP没有拥塞控制，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但是不能允许有较大的时延（比如实时视频，直播等）</p>
</li>
<li><p>UDP提供尽最大努力的交付，不保证可靠交付。所有维护传输可靠性的工作需要用户在应用层来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息</p>
</li>
<li><p>UDP是<strong>面向报文</strong>的，对应用层交下来的报文，添加首部后直接向下交付为IP层，<strong>既不合并，也不拆分，保留这些报文的边界</strong>。对IP层交上来UDP用户数据报，在去除首部后就<strong>原封不动</strong>地交付给上层应用进程，报文不可分割，是UDP数据报处理的最小单位。</p>
<ul>
<li>正是因为这样，UDP显得不够灵活，不能控制读写数据的次数和数量。比如我们要发送100个字节的报文，我们调用一次sendto函数就会发送100字节，对端也需要用recvfrom函数一次性接收100字节，不能使用循环每次获取10个字节，获取十次这样的做法。</li>
</ul>
</li>
</ol>
<blockquote>
<p>UDP常用于一次性传输比较少量数据的网络应用，如DNS，SNMP等，因为对于这些应用，若是采用TCP，为连接的创建，维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话，实时视频会议，流媒体等）数据的可靠传输对他们而言并不重要，TCP的拥塞控制会使他们有较大的延迟，也是不可容忍的</p>
</blockquote>
<h1 id="2-UDP首部格式"><a href="#2-UDP首部格式" class="headerlink" title="2. UDP首部格式"></a>2. UDP首部格式</h1><p>UDP数据报分为首部和用户数据部分，整个UDP数据报作为IP数据报的数据部分封装在IP数据报中，UDP数据报文结构如图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e908c0de675aebde70a8526a34b0a8b28b4.png" alt=""><br><img src="https://oscimg.oschina.net/oscnet/up-e8ab3a0fb55985d612c74f805d60ac2d071.png" alt=""></p>
<p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，</p>
<ol>
<li><strong>源端口</strong>： 源端口号，需要对方回信时选用，不需要时全部置0.</li>
<li><strong>目的端口</strong>：目的端口号，在终点交付报文的时候需要用到。</li>
<li><strong>长度</strong>：记录UDP的数据报的长度（包括首部+数据），单位是字节，其最小值为8（表示只有首部，没有数据）</li>
<li><strong>校验和</strong>：UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间是否发生变动，有则丢弃。UDP中该字段是可选的（TCP是必须的），当源主机不想计算校验和，则直接令该字段全为0。</li>
</ol>
<blockquote>
<p>当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方</p>
</blockquote>
<h1 id="3-UDP校验"><a href="#3-UDP校验" class="headerlink" title="3 UDP校验"></a>3 UDP校验</h1><p>UDP检验和的基本计算方法与IP首部检验和计算方法相类似（16bit字的二进制反码和）。</p>
<p>在计算校验和的时候，<strong>需要在UDP数据报之前增加12字节的伪首部</strong>，伪首部并不是UDP真正的首部。只是在计算校验和，<strong>临时添加在UDP数据报的前面，得到一个临时的UDP数据报</strong>。校验和就是按照这个临时的UDP数据报计算的。<strong>伪首部既不向下传送也不向上递交，而仅仅是为了计算校验和</strong>。这样的校验和，既检查了UDP数据报，又对IP数据报的源IP地址和目的IP地址进行了检验。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0aa926db9d0b0919605e1f1b85dfb9593fc.png" alt=""></p>
<p>校验过程如下：</p>
<ol>
<li><p>发送方首先把全零放入校验和字段并且添加伪首部</p>
</li>
<li><p>把UDP数据报看成是由许多16位的子串连接起来，若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个填充字节(全零字节，此字节不发送）。</p>
</li>
<li><p>按照二进制反码计算出这些16位字的和。</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-ee8f3ba02186185dec3ca2f68ddd542ea22.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/17/TCP-IP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%A7%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/17/TCP-IP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%A7%88/" itemprop="url">TCP/IP协议学习导览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-17T23:04:04+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index">
                    <span itemprop="name">网络协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/17/TCP-IP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%A7%88/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/03/17/TCP-IP协议学习导览/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  7.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  26
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从字面意义上讲，有人可能会认为TCP/IP是指TCP和IP两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用IP进行通信时所必须用到的协议群的统称。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP协议。</p>
<blockquote>
<p>该文章主要为《TCP-IP详解卷1：协议》归纳笔记</p>
</blockquote>
<h1 id="1-网络的分层"><a href="#1-网络的分层" class="headerlink" title="1. 网络的分层"></a>1. 网络的分层</h1><p>网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。一个协议族，比如TCP/IP，是一组不同层次上的多个协议的组合。TCP/IP通常被认为是一个四层的协议系统。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b92eb0a4ab7d64b99b88d4acb7760baed51.png" alt=""></p>
<ol>
<li><p>链路层</p>
<ul>
<li>有时也称作<strong>数据链路层或网络接口层</strong>，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。</li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li>有时也称作互联网层，处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括<strong>IP</strong>协议（网际协议），<strong>ICMP协议</strong>（Internet互联网控制报文协议），以及<strong>IGMP协议</strong>（Internet组管理协议）。</li>
</ul>
</li>
<li><p>运输层</p>
<ul>
<li>主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：<strong>TCP（传输控制协议）和UDP（用户数据报协议）。</strong></li>
<li>TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。</li>
<li>而另一方面，UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。</li>
</ul>
</li>
<li><p>应用层</p>
<ul>
<li>负责处理特定的应用程序细节。几乎各种不同的TCP/IP实现都会提供下面这些通用的应用程序：<ul>
<li>Telnet 远程登录。</li>
<li>FTP 文件传输协议。</li>
<li>SMTP 简单邮件传送协议。</li>
<li>SNMP 简单网络管理协议。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="2-TCP-IP协议的分层"><a href="#2-TCP-IP协议的分层" class="headerlink" title="2. TCP/IP协议的分层"></a>2. TCP/IP协议的分层</h1><p>在TCP/IP协议族中，有很多种协议。如下图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-11d2a0a828cf310ade2987c70bc46b159d1.png" alt=""></p>
<ul>
<li><strong>TCP</strong>和<strong>UDP</strong>是两种最为著名的运输层协议，二者都使用IP作为网络层协议。TCP提供一种可靠的运输层服务，而UDP是不可靠的，它不能保证数据报能安全无误地到达最终目的。</li>
<li><strong>IP</strong>是网络层上的主要协议，同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。</li>
<li><strong>ICMP</strong>是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。</li>
<li><strong>IGMP</strong>是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</li>
<li><strong>ARP</strong>（地址解析协议）和<strong>RARP</strong>（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</li>
</ul>
<h1 id="3-网络基础概念"><a href="#3-网络基础概念" class="headerlink" title="3. 网络基础概念"></a>3. 网络基础概念</h1><h2 id="3-1-IP地址——互联网的地址"><a href="#3-1-IP地址——互联网的地址" class="headerlink" title="3.1 IP地址——互联网的地址"></a>3.1 IP地址——互联网的地址</h2><p>互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）。IP地址长32bit。IP地址具有一定的结构，五类不同的互联网地址格式如图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a3dda773efe24cf65854d9da0a2a76db966.png" alt=""></p>
<p>总体来说，IP地址由<strong>网络号</strong>和<strong>主机号</strong>组成，网络号相当于某个网络的编号，主机号相当于<strong>相同网络内</strong>的主机编号。只有相同网络地址的两台主机才能通信，因此不同网络地址的主机，需要借助路由器转发才能通信。</p>
<p>这些32位的地址通常写成四个十进制的数，其中每个整数对应一个字节。这种表示方法称作“点分十进制表示法（Dotteddecimalnotation）”。例如，140.252.13.33就是一个B类地址。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-35ef928a25d5723986baf23183d9b16a8c7.png" alt=""></p>
<h3 id="3-1-1-子网寻址"><a href="#3-1-1-子网寻址" class="headerlink" title="3.1.1 子网寻址"></a>3.1.1 子网寻址</h3><p>现在所有的主机都要求支持子网编址。不是把IP地址看成由单纯的一个网络号和一个主机号组成，<strong>而是把主机号再分成一个子网号和一个主机号</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6fd30a8d60771bbc85cffb0224c664c47ae.png" alt=""></p>
<p>子网的出现是基于以下原因：</p>
<ul>
<li>因为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为2^24-2和2^16-2。事实上，在一个网络中人们并不安排这么多的主机</li>
<li>随着互联的发展IPV4地址资源可能会耗尽，如果不划分子网直接将一个C类地址分给一个企业，C类地址可容纳256台主机，但是可能该企业只有20台计算机，这就造成极大浪费</li>
<li>减少网络流量，优化网络性能：隔离数据在整个网络内广播，提高信息传输速率。</li>
</ul>
<h3 id="3-1-2-子网掩码"><a href="#3-1-2-子网掩码" class="headerlink" title="3.1.2 子网掩码"></a>3.1.2 子网掩码</h3><p>子网掩码又叫网络掩码，我们现在把主机号拆分成子网号和主机号了，那拆分后，<strong>IP地址的哪些位是表示子网号，哪些位是表示主机号呢</strong>？我们需要有一种方式来标识它。这就是子网掩码。</p>
<p>子网掩码是一个32bit的值，其中值为1的比特用来标识网络号和子网号，为0的比特用来标识主机号。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4a592bcafbb0ae0fe4df866829865ce0b03.png" alt=""></p>
<h2 id="3-2-域名"><a href="#3-2-域名" class="headerlink" title="3.2 域名"></a>3.2 域名</h2><p>尽管通过IP地址可以识别主机上的网络接口，进而访问主机，但是人们最喜欢使用的还是主机名。在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。</p>
<h2 id="3-3-封装"><a href="#3-3-封装" class="headerlink" title="3.3 封装"></a>3.3 封装</h2><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b91718c00fef8cde14bf35da7006952d67a.png" alt=""></p>
<blockquote>
<p>TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP segment）。IP传给链路层的数据单元称作IP数据报(IP datagram)。通过以太网传输的比特流称作帧(Frame)。</p>
</blockquote>
<h2 id="3-4分用"><a href="#3-4分用" class="headerlink" title="3.4分用"></a>3.4分用</h2><p>当目的主机收到一个以太网数据帧时，<strong>数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部</strong>。每层协议盒都要去<strong>检查报文首部中的协议标识，以确定接收数据的上层协议</strong>。这个过程称作分用（Demultiplexing）。如下图</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2d7f05206f7e8ce1ac051eaf8449c9df6dc.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-990eeeb4d3a2545ae5170522df23b2dc87f.png" alt=""></p>
<h2 id="3-5-端口"><a href="#3-5-端口" class="headerlink" title="3.5 端口"></a>3.5 端口</h2><p>正常情况下，IP能锁定一台物理机器，对应着一张网卡，外界发来的数据包网卡都会接收。网卡给程序提供了接口，你监听一下我，要是有消息来了，我就转发给你。这样应用程序就能收到数据了。</p>
<p>紧接着问题来了，一台物理机器上有无数个程序，每个程序都需要监听网卡接发数据，如果网卡把接收到的数据都转发给所有的程序，那么程序将会被大量本不是发送给自己的数据淹没。</p>
<p>为了隔离不同程序的数据，我们添加了一个标识：端口，来作为区分。如果程序A的端口是8080，那么我收到有8080标识的数据，就只会转发给程序A，以此类推。</p>
<h2 id="3-6-MTU"><a href="#3-6-MTU" class="headerlink" title="3.6 MTU"></a>3.6 MTU</h2><p>最大传输单元（Maximum Transmission Unit，MTU）是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。</p>
<p>如果在IP层要传输一个数据报比链路层的MTU还大，那么IP层就会对这个数据报进行分片。一个数据报会被分为若干片，每个分片的大小都小于或者等于链路层的MTU值。</p>
<p>当同一网络上的主机互相进行通信时，该网络的MTU对通信双方非常重要。但当主机间要通过很多网络才能通信时，对通信双方最重要的是通信路径中最小的MTU，因为在通信路径上不同网络的链路层MTU不同。<strong>通信路径中最小的MTU被称为路径MTU</strong>(木桶原理)。</p>
<p>网络中一些常见链路层协议MTU的缺省数值如下：</p>
<ul>
<li>FDDI协议：4352字节</li>
<li>以太网（Ethernet）协议：1500字节</li>
<li>PPPoE（ADSL）协议：1492字节</li>
<li>X.25协议（Dial Up/Modem）：576字节</li>
<li>Point-to-Point：4470字节</li>
</ul>
<h2 id="3-7-IP分片"><a href="#3-7-IP分片" class="headerlink" title="3.7 IP分片"></a>3.7 IP分片</h2><p>因为有MTU的存在，我们要对长度大于MTU的IP数据报进行分片。</p>
<p>任何时候<strong>IP层</strong>接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</p>
<p>把一份IP数据报分片以后，只有到达目的地才进行重新组装。重新组装由<strong>目的端的IP层</strong>来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的。</p>
<p>IP首部中，有如下这些字段和分片操作有关：</p>
<ol>
<li><p>标识字段：标识字段是IP数据报的唯一主键，同一个数据报分出来的分片，拥有相同的标识字段。在重新组装的时候，通过这个字段，目的端IP层可以知道哪些分片原来是一体的。</p>
</li>
<li><p>片偏移字段：该字段指的是该片的数据在原始数据报中，离开始处的偏移量。通过它，在组装时，可以确定各个分片的次序。</p>
</li>
<li><p>标志字段“不分片”位：还是标志字段中有一个比特称作“不分片”位。如果将这一比特置1，IP将不对数据报进行分片。这时如果遇到IP数据报长度大于MTU的场景，则会把数据报丢弃并发送一个ICMP差错报文给起始端。</p>
</li>
</ol>
<h1 id="4-链路层协议"><a href="#4-链路层协议" class="headerlink" title="4. 链路层协议"></a>4. 链路层协议</h1><p>在TCP/IP协议族中，链路层主要有三个目的：</p>
<ol>
<li>为IP模块发送和接收IP数据报；</li>
<li>为ARP模块发送ARP请求和接收ARP应答；</li>
<li>为RARP发送RARP请求和接收RARP应答。</li>
</ol>
<p>TCP/IP支持多种不同的链路层协议，这取决于网络所使用的硬件，如以太网、令牌环网、FDDI（光纤分布式数据接口）及RS-232串行线路</p>
<p>链路层的协议数据单元是<strong>帧</strong>——IP层（网络层）的数据报添加首部和尾部，即可封装成帧。</p>
<p>帧主要有两种封装格式IEEE 802封装和以太网封装，其中<strong>以太网封装格式是目前的主流</strong>。除此之外，还有SLIP（Serial Line IP）封装和PPP（点对点协议）封装。</p>
<h2 id="4-1-IEEE-802封装和以太网封装"><a href="#4-1-IEEE-802封装和以太网封装" class="headerlink" title="4.1 IEEE 802封装和以太网封装"></a>4.1 IEEE 802封装和以太网封装</h2><p><img src="https://oscimg.oschina.net/oscnet/up-0f5eeeb15e0ff49992da35f360f7eb1838f.png" alt=""></p>
<ul>
<li><p><strong>IEEE802.2/802.3封装协议</strong></p>
<ol>
<li>两个<strong>6字节</strong>的<strong>目的地址和源地址</strong>，这个地址指的是物理地址，也就是MAC地址(48bit)。ARP和RARP协议对32bit的IP地址和48bit的硬件地址进行映射。</li>
<li><strong>2字节</strong>的<strong>长度字段</strong>，值为后续数据的字节长度，但不包括CRC检验码。</li>
<li>3字节的802.2LLC，<ol>
<li><strong>目的服务访问点</strong>（DestinationServiceAccessPoint,DSAP）和<strong>源服务访问点</strong>（SourceServiceAccessPoint,SSAP）的值都设为0xaa。</li>
<li><strong>Ctrl字段</strong>的值设为3。</li>
</ol>
</li>
<li>一共5字节的802.2SNAP。<ol>
<li>3个字节<strong>orgcode字段</strong>都置为0。</li>
<li>2字节的<strong>类型字段</strong>，和以太网帧格式一样，其比较常见的类型字段为：0X0800（IP帧），0X0806（ARP请求/应答帧），0X8035（PARP请求/应答帧），0X8137（NovellIPX），0X809b（AppleTalk）。</li>
</ol>
</li>
<li>数据</li>
<li>CRC，<strong>CRC字段</strong>用于帧内后续字节差错的循环冗余码检验（检验和）（它也被称为FCS或帧检验序列）。</li>
</ol>
</li>
<li><p><strong>以太网封装协议（RFC 894）</strong></p>
<ol>
<li>两个<strong>6字节</strong>的<strong>目的地址和源地址</strong>，这个地址指的是物理地址，也就是MAC地址(48bit)。ARP和RARP协议对32bit的IP地址和48bit的硬件地址进行映射。</li>
<li>2字节的<strong>类型字段</strong>，其比较常见的类型字段为：0X0800（IP帧），0X0806（ARP请求/应答帧），0X8035（PARP请求/应答帧），0X8137（NovellIPX），0X809b（AppleTalk）。</li>
<li>数据</li>
<li>CRC，<strong>CRC字段</strong>用于帧内后续字节差错的循环冗余码检验（检验和）（它也被称为FCS或帧检验序列）。</li>
</ol>
</li>
</ul>
<h2 id="4-2-SLIP：串行线路IP封装协议"><a href="#4-2-SLIP：串行线路IP封装协议" class="headerlink" title="4.2 SLIP：串行线路IP封装协议"></a>4.2 SLIP：串行线路IP封装协议</h2><p>SLIP的全称是Serial Line IP。它是一种在串行线路上对IP数据报进行封装的简单形式，在RFC1055中有详细描述。SLIP适用于家庭中每台计算机几乎都有的RS-232串行端口和高速调制解调器接入Internet。</p>
<p>其封装规则十分简单，一图道尽：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5edf018ce466031e243f2c0ec1c5dd6c485.png" alt=""></p>
<ol>
<li>给IP数据报的前后端都加上一个称作END（0xc0）的特殊字符。</li>
<li>END（0xc0）SLIP协议中是特殊字符，所以如果IP报文中某个字符为END（0xc0），那么就要连续传输两个字节0xdb和0xdc来取代它。</li>
<li>0xdb这个特殊字符被称作SLIP的ESC字符，如果IP报文中某个字符为SLIP的ESC字符，那么就要连续传输两个字节0xdb和0xdd来取代它。</li>
</ol>
<p>SLIP是一种简单的帧封装方法，还有一些值得一提的<strong>缺陷</strong>：</p>
<ol>
<li>因为缺少源地址字段，SLIP没有办法把本端的IP地址通知给另一端，所以每一端必须知道对方的IP地址。。</li>
<li>数据帧中没有类型字段，如果一条串行线路用于SLIP，那么它不能同时使用其他协议。</li>
<li>SLIP没有在数据帧中加上检验和（类似于以太网中的CRC字段）。如果SLIP传输的报文被线路噪声影响而发生错误，只能通过上层协议来发现</li>
</ol>
<h2 id="4-3-PPP：点对点封装协议"><a href="#4-3-PPP：点对点封装协议" class="headerlink" title="4.3 PPP：点对点封装协议"></a>4.3 PPP：点对点封装协议</h2><p>同样作为常用于低速的串行链路的封装协议，PPP（Point to Point Protocol）点对点协议修改了SLIP协议中的所有缺陷。如图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-292e5ecec943da43f8c798b1558e0f3f64e.png" alt=""></p>
<ol>
<li>每一帧都以<strong>标志字符</strong>0x7e开始和结束。</li>
<li>一个字节的<strong>地址字段</strong>，值始终是0xff。</li>
<li>一个字节的<strong>控制字段</strong>，值始终是0x03。</li>
<li><strong>协议字段</strong>，类似于以太网中类型字段的功能。<ul>
<li>值为0x0021时，表示信息字段是一个IP数据报；</li>
<li>值为0xc021时，表示信息字段是链路控制数据；</li>
<li>值为0x8021时，表示信息字段是网络控制数据。</li>
</ul>
</li>
<li>数据</li>
<li><strong>CRC字段</strong>（或FCS，帧检验序列）是一个循环冗余检验码，以检测数据帧中的错误。</li>
</ol>
<p>PPP比SLIP具有下面这些优点：</p>
<ol>
<li>PPP支持在单根串行线路上运行多种协议，不只是IP协议；</li>
<li>每一帧都有循环冗余检验；</li>
<li>通信双方可以进行IP地址的动态协商(使用IP网络控制协议)；</li>
<li>与CSLIP类似，对TCP和IP报文首部进行压缩；</li>
<li>链路控制协议可以对多个数据链路选项进行设置。为这些优点付出的代价是在每一帧的首部增加3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</li>
</ol>
<h1 id="5-网络层协议"><a href="#5-网络层协议" class="headerlink" title="5. 网络层协议"></a>5. 网络层协议</h1><h2 id="5-1-IP协议"><a href="#5-1-IP协议" class="headerlink" title="5.1 IP协议"></a>5.1 IP协议</h2><p>IP是TCP/IP协议族中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输。</p>
<p>IP提供<strong>不可靠</strong>、<strong>无连接</strong>的数据报传送服务</p>
<ul>
<li>不可靠（unreliable）的意思是它<strong>不能保证IP数据报能成功地到达目的地</strong>。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。</li>
<li>无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息。<strong>每个数据报的处理是相互独立的</strong>。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此B可能在A到达之前先到达。</li>
</ul>
<h3 id="5-1-1-IP首部"><a href="#5-1-1-IP首部" class="headerlink" title="5.1.1 IP首部"></a>5.1.1 IP首部</h3><p>IP数据报的格式如下图所示。普通的IP首部长为20个字节，即160位（不包含选项字段）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b5c16d7c7963e9a676df4af41971b566f1e.png" alt=""></p>
<ol>
<li><strong>版本号</strong>，目前是4或者6，我们平常看到的IPv4和IPv6由此区分。</li>
<li><strong>首部长度</strong>，指的是首部（包括任何选项）有多少个4字节（32bit）的数目（也就是首部总位数/32）。由于它每个bit位代表4个字节，且是一个4bit字段，因此首部最长为60个字节。</li>
<li><strong>服务类型</strong>，共8bit，其中：<ul>
<li>3bit优先权字段(现在已被忽略)，默认值是000</li>
<li>4bit的TOS子字段，其值分布和含义如下：<ul>
<li>1000 – minimize delay #<strong>最小延迟</strong>：对应于对延迟敏感的应用，如telnet和人login</li>
<li>0100 – maximize throughput #<strong>最大吞吐量</strong>：对应于对吞吐量要求比较高的应用，如FTP文件应用，对文件传输吞吐量有比较高的要求。</li>
<li>0010 – maximize reliability #<strong>最高可靠性</strong>：对网络传输可靠性要求高的应用，如使用SNMP的应用、路由协议等等。</li>
<li>0001 – minimize monetary cost #<strong>最小费用</strong>：如NNTP这种用户网络新闻等。</li>
<li>0000 – normal service #一般服务</li>
</ul>
</li>
<li>1bit未用位，但必须置0。</li>
</ul>
</li>
<li><strong>总长度字段</strong>，16bit，是指整个IP数据报的长度，以字节为单位。</li>
<li><strong>标识字段</strong>，16bit，唯一地标识主机发送的每一份数据报，也就是主机发送报文的id，通常每发送一份报文它的值就会加1。如果IP报文在数据链路层被分片了，那么每一个片里面的这个id字段相同。</li>
<li><strong>标志字段</strong>，3bit，第一位保留，第二位置为1，标识禁止分片，这时候如果IP报文大于MTU，IP模块就会丢弃报文；第3位表示更多分片，如果分片了的话，最后一个分片置为1，其他都是0，类似于一个结束标记</li>
<li><strong>分片偏移字段</strong>，是分片相对于原始IP报文开始处的偏移，单位是bit，故而实际偏移的字节数为该值 * 8，因此，除了最后一个报文之外，其它的报文长度必须是8的整数倍，否则报文不连续。</li>
<li><strong>TTL（time-to-live）生存时间字段</strong>，表示数据报可以经过最多多少个路由器。其初始值由源主机设置（通常为32或64），每经过一个路由器，值减1。值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。该字段是为了防止出现路由循环而设。</li>
<li><strong>协议字段</strong>，指在上层（TCP/IP的传输层）使用的协议，可能的协议有UDP、TCP、ICMP、IGMP、IGP等。TCP协议为6，UDP协议为17，ICMP为1。</li>
<li><strong>首部校验和</strong>，用于检验IP报文头部在传播的过程中是否出错，主要校验报文头中是否有某一个或几个bit被污染或修改了。<ul>
<li>首先把检验和字段置为0。以抓包得到的该首部为例：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-56ae92b4a4735c455e500848f2c66430fa7.png" alt=""></li>
</ul>
</li>
<li>然后，对首部中<strong>每16bit</strong>进行二进制反码求和，结果存在检验和字段中。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d28dd4972d26fdd4772ad77b4f0c83e1f1b.png" alt=""></li>
</ul>
</li>
<li>当收到一份IP数据报后，同样对首部中每个16bit进行二进制反码的求和。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d9b94b7a21ca5204a4aa50bf7a468a6d61f.png" alt=""></li>
</ul>
</li>
<li>由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1（也就是0xffff）。如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。</li>
<li>ICMP、IGMP、UDP和TCP都采用相同的检验和算法</li>
</ul>
</li>
<li><strong>源IP地址</strong>，32位，4个字节，每一个字节为0～255之间的整数</li>
<li><strong>目的IP地址</strong>，32位，4个字节，每一个字节为0～255之间的整数</li>
<li><strong>选项</strong>，是数据报中的一个可变长的可选信息。选项可用于：<ul>
<li>安全和处理限制（用于军事领域）</li>
<li>记录路径（让每个路由器都记下它的IP地址）</li>
<li>时间戳（让每个路由器都记下它的IP地址和时间）</li>
<li>宽松的源站选路（为数据报指定一系列必须经过的IP地址）</li>
<li>严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能经过其他的地址）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>选项字段很少被使用，并非所有的主机和路由器都支持这些选项。选项字段一直都是以32bit作为界限，在必要的时候插入值为0的填充字节。这样就保证IP首部始终是32bit的整数倍（这是首部长度字段所要求的）。</p>
</blockquote>
<h2 id="5-2-ARP协议和RARP协议"><a href="#5-2-ARP协议和RARP协议" class="headerlink" title="5.2 ARP协议和RARP协议"></a>5.2 ARP协议和RARP协议</h2><p>ARP协议是“Address Resolution Protocol”（地址解析协议）的缩写。在以太网环境中，数据的传输所依懒的是MAC地址而非IP地址，ARP协议的作用是<strong>将已知的IP地址转换为MAC地址</strong>。</p>
<p>RARP协议是“Reverse Address Resolution Protocol”（反向地址转换协议）的缩写。具有本地磁盘的系统引导时，一般是从磁盘上的配置文件中读取 IP地址。但是无盘机，如X终端或无盘工作站，则需要采用其他方法来获得IP地址。RARP协议的作用就是<strong>将已知的MAC地址转换为IP地址</strong></p>
<h3 id="5-2-1-协议原理"><a href="#5-2-1-协议原理" class="headerlink" title="5.2.1 协议原理"></a>5.2.1 协议原理</h3><h4 id="5-2-1-1-APR原理"><a href="#5-2-1-1-APR原理" class="headerlink" title="5.2.1.1 APR原理"></a>5.2.1.1 APR原理</h4><p>ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机。这个过程称作广播，如下图的虚线所示。ARP请求数据帧中包含目的主机的IP地址（假设主机名为bsdi），其意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址。”</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-18c73d5a678a5c9fff90572f89992f48f5f.png" alt=""></p>
<p>目的主机的ARP层收到这份广播报文后，识别出这是发送端在寻问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。收到ARP应答后，使ARP进行请求—应答交换的IP数据报现在就可以传送了。</p>
<h4 id="5-2-1-2-RAPR原理"><a href="#5-2-1-2-RAPR原理" class="headerlink" title="5.2.1.2 RAPR原理"></a>5.2.1.2 RAPR原理</h4><p>同理：</p>
<p>网络上的每个系统都具有唯一的硬件地址，它是由网络接口生产厂家配置的。无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响应这个无盘系统的IP地址（在RARP应答中）。从而得到这个MAC地址对应的IP地址</p>
<h3 id="5-2-2-ARP高速缓存"><a href="#5-2-2-ARP高速缓存" class="headerlink" title="5.2.2 ARP高速缓存"></a>5.2.2 ARP高速缓存</h3><p>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录，从中直接读取，缓解链路压力。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起</p>
<p>我们可以用arp命令来检查ARP高速缓存。参数-a的意思是显示高速缓存中所有的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ arp -a</span><br><span class="line">&gt; sun (140.252.13.33) at 8:0:20:3:f6:42</span><br><span class="line">&gt; svr4 (140.252.13.34) at 0:0:c0:c2:9b:26</span><br></pre></td></tr></table></figure>

<p><img src="https://oscimg.oschina.net/oscnet/up-a74affe098a2b2dcb35b0974ea9fdfdb920.png" alt=""></p>
<h3 id="5-2-3-ARP-RARP的分组格式"><a href="#5-2-3-ARP-RARP的分组格式" class="headerlink" title="5.2.3 ARP/RARP的分组格式"></a>5.2.3 ARP/RARP的分组格式</h3><p>在以太网上解析IP地址时，ARP/RARP请求和应答分组的格式如图所示</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-83112c312c9096d76aaca2d6f38bf459b20.png" alt=""></p>
<ol>
<li><strong>目标mac地址</strong>：ARP请求的目的以太网地址，全1时，代表广播地址。</li>
<li><strong>源mac地址</strong>：发送ARP请求的以太网地址。</li>
<li><strong>帧类型</strong>：以太网帧类型表示后面的数据类型，ARP请求和ARP应答此字段为：0x0806。</li>
<li><strong>硬件类型</strong>：硬件类型字段表示硬件地址的类型。它的值为1即表示以太网地址。</li>
<li><strong>协议类型</strong>：表示要映射的协议地址类型。它的值为0x0800即表示IP地址。它的值与包含IP数据报的以太网数据帧中的类型字段的值相同，这是有意设计的</li>
<li><strong>硬件地址长度、协议地址长度</strong>：表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节。</li>
<li><strong>操作类型</strong>：值为1，表示进行ARP请求；值为2，表示进行ARP应答；值为3，表示进行RARP请求；值为4，表示进行RARP应答。</li>
<li><strong>发送端以太网地址和协议地址</strong>：发送端的硬件地址（在本例中是以太网地址）和协议地址（IP地址）</li>
<li><strong>目的端的硬件地址和目的端的协议地址</strong>：目的端的硬件地址（在本例中是以太网地址）和协议地址（IP地址）。（这是重复数据，在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址。）</li>
</ol>
<blockquote>
<p>对于一个ARP/RARP请求来说，除<strong>目的端硬件地址</strong>外的所有其他的字段，都已经有填充值。当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后把它发送回去。</p>
</blockquote>
<blockquote>
<p>ARP/RARP二者的分组格式，除了操作类型字段以外，其他字段都一样</p>
</blockquote>
<h2 id="5-3-ICMP协议"><a href="#5-3-ICMP协议" class="headerlink" title="5.3 ICMP协议"></a>5.3 ICMP协议</h2><p>ICMP协议，全称是Internet Control Message Protocol，意思是Internet控制消息协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息（可以理解为回来报信的信鸽）。<strong>控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息</strong>。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p>
<p>ICMP 的内容是放在IP数据包的数据部分里来互相交流的。也就是，从ICMP的报文格式来说，ICMP 是IP 的上层协议。但是，正如RFC所记载的，ICMP是分担了IP的一部分功能。所以，被认为是与IP 同层的协议。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c77afda8e8ee65a9872da5f221ef6696631.png" alt=""></p>
<h3 id="5-3-1-ICMP的分类"><a href="#5-3-1-ICMP的分类" class="headerlink" title="5.3.1 ICMP的分类"></a>5.3.1 ICMP的分类</h3><p>在RFC，将ICMP 大致分成两种功能：</p>
<ol>
<li>差错报文：在IP数据包被对方的计算机处理的过程中，发生了某些错误时被使用。不仅传送发生了错误这个事实，也传送错误原因等消息。</li>
<li>查询报文：是在送信方的计算机向对方计算机询问信息时被使用。被询问内容的种类非常丰富，如：目标IP地址的机器是否存在，调查自己网络的子网掩码，取得对方机器的时间信息等。</li>
</ol>
<h3 id="5-3-2-ICMP的报文"><a href="#5-3-2-ICMP的报文" class="headerlink" title="5.3.2 ICMP的报文"></a>5.3.2 ICMP的报文</h3><p><img src="https://oscimg.oschina.net/oscnet/up-de1e6079bd0c3c227e27a4f1d830e2219fe.png" alt=""></p>
<p>如上图，我们将完整的IP首部+ICMP报文都展示了出来，IP首部各字段，前文已经有过描述。</p>
<p>用来传送ICMP报文的IP数据包上实际上有不少字段。但是实际上与ICMP协议相关的只有7个子段。</p>
<ol>
<li>协议：ICMP协议的IP数据包，该字段为1；</li>
<li>源IP 地址：顾名思义，不再赘述。</li>
<li>目的IP 地址：顾名思义，不再赘述。</li>
<li>生存时间：TTL，不再赘述。</li>
</ol>
<p>上述这四个包含在IP 首部的字段。</p>
<ol start="5">
<li>类型；</li>
<li>代码；</li>
<li>选项数据；</li>
</ol>
<p>上述这三个包含在ICMP数据部分的字段。</p>
<p>其中<strong>类型</strong>和<strong>代码</strong>字段是ICMP报文的核心，这两个字段的组合，可以用来标识ICMP的差错报文和查询报文的大多数场景，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-80196ab227699291306a266fcf45c9b7c36.png" alt=""></p>
<p>至于选项数据字段，当ICMP需要传送额外数据时，则放置在选项数据字段中。</p>
<h1 id="6-运输层协议"><a href="#6-运输层协议" class="headerlink" title="6. 运输层协议"></a>6. 运输层协议</h1><h2 id="6-1-TCP协议"><a href="#6-1-TCP协议" class="headerlink" title="6.1 TCP协议"></a>6.1 TCP协议</h2><p>详见文章《TCP协议分析》</p>
<h2 id="6-2-UDP协议"><a href="#6-2-UDP协议" class="headerlink" title="6.2 UDP协议"></a>6.2 UDP协议</h2><p>详见文章《UDP协议分析》</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.51cto.com/art/201906/597961.htm" target="_blank" rel="noopener" title="太厉害了，终于有人能把TCP/IP协议讲的明明白白了！">太厉害了，终于有人能把TCP/IP协议讲的明明白白了！</a></p>
<p><a href="https://blog.csdn.net/sj349781478/article/details/74058939" target="_blank" rel="noopener" title="以太网协议封装格式">以太网协议封装格式</a></p>
<p><a href="https://www.cnblogs.com/iiiiher/p/8513748.html" target="_blank" rel="noopener" title="完全理解icmp协议">完全理解icmp协议</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/20/ElasticSearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3%EF%BC%88index-type-doc-node-shard-replica-segment%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/20/ElasticSearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3%EF%BC%88index-type-doc-node-shard-replica-segment%EF%BC%89/" itemprop="url">ElasticSearch核心概念详解（index/type/doc/node/shard/replica/segment）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-20T23:01:01+08:00">
                2020-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">ElasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/20/ElasticSearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3%EF%BC%88index-type-doc-node-shard-replica-segment%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/02/20/ElasticSearch核心概念详解（index-type-doc-node-shard-replica-segment）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  9.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  34
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ElasticSearch，简称ES，是一个基于Lucene的搜索服务器。要想了解ES，必须先了解Lucene。</p>
<h2 id="数据和搜索"><a href="#数据和搜索" class="headerlink" title="数据和搜索"></a>数据和搜索</h2><p>我们知道，生活中我们有两类的数据：</p>
<ol>
<li><strong>结构化数据</strong>：也称作行数据，是由二维表结构来逻辑表达和实现的数据，严格地遵循数据格式与长度规范，主要通过关系型数据库进行存储和管理。指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li><strong>非结构化数据</strong>：又可称为全文数据，不定长或无固定格式，不适于由数据库二维表来表现，包括所有格式的办公文档、XML、HTML、word文档，邮件，各类报表、图片和咅频、视频信息等。</li>
</ol>
<p>根据两种数据分类，搜索也相应的分为两种：<strong>结构化数据搜索</strong>和<strong>非结构化数据搜索</strong>。对于结构化数据，因为它们具有特定的结构，所以我们一般都是可以通过关系型数据库（mysql，oracle等）的二维表（table）的方式存储和搜索，也可以建立索引。</p>
<p>对于非结构化数据，也即对全文数据的搜索主要有两种方法：<strong>顺序扫描法</strong>，<strong>全文检索</strong>。</p>
<ol>
<li><strong>顺序扫描</strong>：通过文字名称也可了解到它的大概搜索方式，即按照顺序扫描的方式查询特定的关键字。例如给你一张报纸，让你找到该报纸中“平安”的文字在哪些地方出现过。你肯定需要从头到尾把报纸阅读扫描一遍然后标记出关键字在哪些版块出现过以及它的出现位置。</li>
</ol>
<p>这种方式无疑是最耗时的最低效的，如果报纸排版字体小，而且版块较多甚至有多份报纸，等你扫描完你的眼睛也差不多了。</p>
<ol start="2">
<li><strong>全文搜索</strong>：对非结构化数据顺序扫描很慢，我们是否可以进行优化？把我们的非结构化数据想办法弄得有一定结构不就行了吗？将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</li>
</ol>
<p>这种方式就构成了全文检索的基本思路。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之<strong>索引</strong>。这种方式的主要工作量在前期索引的创建，但是对于后期搜索却是快速高效的。</p>
<h2 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h2><p>通过对生活中数据的类型作了一个简短了解之后，我们知道关系型数据库的SQL检索是处理不了这种非结构化数据的。这种非结构化数据的处理需要依赖全文搜索，而目前市场上开放源代码的最好全文检索引擎工具包就属于 apache 的 Lucene了。</p>
<p>但是 Lucene 只是一个工具包，它不是一个完整的全文检索引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。</p>
<p>目前以 Lucene 为基础建立的开源可用全文搜索引擎主要是 Solr 和 Elasticsearch。</p>
<p>Solr 和 Elasticsearch 都是比较成熟的全文搜索引擎，能完成的功能和性能也基本一样。但是 ES 本身就具有分布式的特性和易安装使用的特点，而Solr的分布式需要借助第三方来实现，例如通过使用ZooKeeper来达到分布式协调管理。</p>
<p>不管是 Solr 还是 Elasticsearch 底层都是依赖于 Lucene，而 Lucene 能实现全文搜索主要是因为它实现了<strong>倒排索引</strong>的查询结构。（稍后展开）</p>
<h1 id="1-ES基本概念详解"><a href="#1-ES基本概念详解" class="headerlink" title="1. ES基本概念详解"></a>1. ES基本概念详解</h1><p>ElasticSearch提供了一个分布式多用户能力的<strong>全文搜索引擎</strong>，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。</p>
<p>ElasticSearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。其官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。</p>
<p>不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：</p>
<ul>
<li>分布式的实时文件存储，每个字段都被索引并可被搜索</li>
<li>分布式的实时分析搜索引擎</li>
<li>可以扩展到上百台服务器，处理PB级结构化或非结构化数据</li>
</ul>
<p>es和lucene，solr一样，都是无模式的基于列式的存储格式，这和大多数的NoSQL数据库是一样的，非常灵活，下面我们通过一张图，来看下关系型数据库映射到es里面，对应的名词关系</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6d546ac1f5a76da02b2d7b943ca778010e9.png" alt=""></p>
<h2 id="1-1-Index"><a href="#1-1-Index" class="headerlink" title="1.1 Index"></a>1.1 Index</h2><p>Index，索引，是文档(Document)的容器，是一类文档的集合。</p>
<p>ElasticSearch将它的数据存储在一个或多个索引（index）中。索引就像数据库，可以向索引写入文档或者从索引中读取文档</p>
<p>索引这个词在 ElasticSearch 会有两种意思:</p>
<ol>
<li><p>索引(名词)</p>
<ul>
<li>类比传统的关系型数据库领域来说，<strong>索引相当于SQL中的一个数据库(Database)</strong>。索引由其名称(<strong>必须为全小写字符</strong>)进行标识。</li>
</ul>
</li>
<li><p>索引(动词)</p>
<ul>
<li><strong>保存一个文档到索引(名词)的过程</strong>。这非常类似于SQL语句中的 INSERT关键词。如果该文档已存在时那就相当于数据库的UPDATE。</li>
</ul>
</li>
</ol>
<h2 id="1-2-Type"><a href="#1-2-Type" class="headerlink" title="1.2 Type"></a>1.2 Type</h2><p>Type，类型，可以理解成关系数据库中Table（虽然不完全一致）。用于区分同一个集合中的不同细分。</p>
<p>但和Table不同的是，不同表中的字段可以同名，但他们还是独立的，比如表A的a字段可以是VARCHAR类型，表B的a字段可以是INT类型。</p>
<p>而不同类型的同名字段，他们其实是同一个字段，所以无法独立，实际上，es在底层，也是将不同type的字段都映射为扁平的模式。而不是为每种type分配单独的映射空间。</p>
<p>这导致了type不适合于描述完全不同类型的数据 ，如type A有a，b，c三个字段，type B有d，e，f三个字段，那么这种情况建议不要使用type。</p>
<p>A { a,b,c}和B{b,c,d}这种情况才适用，即<strong>二者间大部分的数据是相同的</strong>，这种情况下，es的扁平化映射，可以复用这部分重合的数据。</p>
<p>之前的版本中，索引和文档中间还有个类型的概念，每个索引下可以建立多个类型，文档存储时需要指定index和type。从6.0.0开始单个索引中只能有一个类型，</p>
<p>7.0.0以后将将不建议使用，8.0.0 以后完全不支持。</p>
<h3 id="1-2-1弃用该概念的原因："><a href="#1-2-1弃用该概念的原因：" class="headerlink" title="1.2.1弃用该概念的原因："></a>1.2.1弃用该概念的原因：</h3><p>我们虽然可以通俗的去理解Index比作 SQL 的 Database，Type比作SQL的Table。但这并不准确，因为如果在SQL中，Table 之前相互独立，同名的字段在两个表中毫无关系。</p>
<p>但是在ES中，同一个Index 下不同的 Type 如果有同名的字段，他们会被Luecence当作同一个字段 ，并且他们的定义必须相同。所以我觉得Index现在更像一个表，而Type字段则并没有多少意义。</p>
<p>目前Type已经被Deprecated，在7.0开始，一个索引只能建一个Type为<code>_doc</code></p>
<h2 id="1-3-Document"><a href="#1-3-Document" class="headerlink" title="1.3 Document"></a>1.3 Document</h2><p>Document，文档，Index 里面单条的记录称为Document。<strong>等同于关系型数据库表中的行</strong>。</p>
<p>我们来看下一个文档的源数据</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fb0733a15d98fe88fbb22b4ea3898cc37c0.png" alt=""></p>
<ul>
<li><p><code>_index</code>文档所属索引名称。</p>
</li>
<li><p><code>_type</code>文档所属类型名。</p>
</li>
<li><p><code>_id</code>Doc的主键。在写入的时候，可以指定该Doc的ID值，如果不指定，则系统自动生成一个唯一的UUID值。</p>
</li>
<li><p><code>_version</code>文档的版本信息。Elasticsearch通过使用version来保证对文档的变更能以正确的顺序执行，避免乱序造成的数据丢失。</p>
</li>
<li><p><code>_seq_no</code>严格递增的顺序号，每个文档一个，Shard级别严格递增，保证后写入的Doc的<code>_seq_no</code>大于先写入的Doc的_seq_no。</p>
</li>
<li><p><code>primary_term</code>primary_term也和<code>_seq_no</code>一样是一个整数，每当Primary Shard发生重新分配时，比如重启，Primary选举等，_primary_term会递增1</p>
</li>
<li><p><code>found</code>查询的ID正确那么ture, 如果 Id 不正确，就查不到数据，found字段就是false。</p>
</li>
<li><p><code>_source</code>文档的原始JSON数据。</p>
</li>
</ul>
<h1 id="2-ES分布式概念详解"><a href="#2-ES分布式概念详解" class="headerlink" title="2. ES分布式概念详解"></a>2. ES分布式概念详解</h1><h2 id="2-1-集群-cluster"><a href="#2-1-集群-cluster" class="headerlink" title="2.1 集群(cluster)"></a>2.1 集群(cluster)</h2><p>ElasticSearch集群实际上是一个分布式系统，它需要具备两个特性：</p>
<ul>
<li><p>高可用性</p>
<ul>
<li>服务可用性：允许有节点停止服务；</li>
<li>数据可用性：部分节点丢失，不会丢失数据；</li>
</ul>
</li>
<li><p>可扩展性</p>
<ul>
<li>随着请求量的不断提升，数据量的不断增长，系统可以将数据分布到其他节点，实现水平扩展；</li>
</ul>
</li>
</ul>
<p>一个集群中可以有一个或者多个节点；</p>
<p>我们采用集群健康值来衡量一个集群的状态</p>
<ol>
<li><code>green</code>：所有主要分片和复制分片都可用</li>
<li><code>yellow</code>：所有主要分片可用，但不是所有复制分片都可用</li>
<li><code>red</code>：不是所有的主要分片都可用</li>
</ol>
<blockquote>
<p>当集群状态为 red，它仍然正常提供服务，它会在现有存活分片中执行请求，我们需要尽快修复故障分片，防止查询数据的丢失；</p>
</blockquote>
<h2 id="2-2-节点-Node"><a href="#2-2-节点-Node" class="headerlink" title="2.2 节点(Node)"></a>2.2 节点(Node)</h2><p>es集群是通过多台服务器来搭建，它们拥有一个共同的clustername比如叫做“escluster”，每台服务器叫做一个节点，用于存储数据并提供集群的搜索和索引功能。</p>
<p>节点拥有自己的唯一名字，默认在节点启动时会生成一个uuid作为节点名，该名字也可以手动指定。</p>
<p>单个集群可以由任意数量的节点组成。如果只启动了一个节点，则会形成一个单节点的集群。其配置文件如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">集群名称，用于定义哪些<span class="selector-tag">elasticsearch</span>节点属同一个集群。</span><br><span class="line"><span class="selector-tag">cluster</span><span class="selector-class">.name</span>: <span class="selector-tag">bigdata</span></span><br><span class="line">节点名称，用于唯一标识节点，不可重名</span><br><span class="line"><span class="selector-tag">node</span><span class="selector-class">.name</span>: <span class="selector-tag">server3</span></span><br><span class="line">设置索引的分片数,默认为5 </span><br><span class="line"><span class="selector-tag">index</span><span class="selector-class">.number_of_shards</span>: 5 </span><br><span class="line">设置索引的副本数,默认为1: </span><br><span class="line"><span class="selector-tag">index</span><span class="selector-class">.number_of_replicas</span>: 1</span><br></pre></td></tr></table></figure>

<p>节点是一个ElasticSearch的实例，其本质就是一个Java进程；一台机器上可以运行多个ElasticSearch实例，但是建议在生产环境中一台机器上只运行一个ElasticSearch实例；</p>
<h3 id="2-2-1-四种普通节点"><a href="#2-2-1-四种普通节点" class="headerlink" title="2.2.1 四种普通节点"></a>2.2.1 四种普通节点</h3><p>在es节点的yml文件中可以配置节点的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conf&#x2F;elasticsearch.yml:</span><br><span class="line">	node.master: true&#x2F;false</span><br><span class="line">	node.data: true&#x2F;false</span><br></pre></td></tr></table></figure>

<p>其中node.master配置表示节点是否具有成为主节点的资格节点。</p>
<blockquote>
<p>此属性的值为true，并不意味着这个节点就是主节点。因为真正的主节点，是由多个具有主节点资格的节点进行选举产生的。所以，这个属性只是代表这个节点是不是具有主节点选举资格。</p>
</blockquote>
<p>node.data配置表示节点是否存储数据。</p>
<p>node.master和node.data的取值可以有四种情况，表示四种节点类型。</p>
<ul>
<li><p><code>node.master: true</code>并且<code>node.data: true</code></p>
<ul>
<li>这种组合表示这个节点即有成为主节点的资格，又存储数据。这个时候如果某个节点被选举成为了真正的主节点，那么他还要存储数据，这样对于这个节点的压力就比较大了。<strong>elasticsearch默认每个节点都是这样的配置</strong>，在测试环境下这样做没问题。实际工作中建议不要这样设置，这样相当于主节点和数据节点的角色混合到一块了。</li>
</ul>
</li>
<li><p><code>node.master: false</code>并且<code>node.data: true</code></p>
<ul>
<li>这种组合表示这个节点没有成为主节点的资格，也就不参与选举，只会存储数据。这个节点我们称为<strong>data(数据)节点</strong>。在集群中需要单独设置几个这样的节点负责存储数据，后期提供存储和查询服务</li>
</ul>
</li>
<li><p><code>node.master: true</code>并且<code>node.data: false</code></p>
<ul>
<li>这种组合表示这个节点不会存储数据，有成为主节点的资格，可以参与选举，有可能成为真正的主节点。对于master节点而言，这样的配置是最适合的。</li>
</ul>
</li>
<li><p><code>node.master: false</code>并且<code>node.data: false</code></p>
<ul>
<li>这种组合表示这个节点即不会成为主节点，也不会存储数据，这个节点的意义是作为一个<strong>client(客户端)节点</strong>，主要是针对海量请求的时候，这些节点负责处理用户请求，实现请求转发，负载均衡等功能。</li>
</ul>
</li>
</ul>
<h3 id="2-2-2-master节点"><a href="#2-2-2-master节点" class="headerlink" title="2.2.2 master节点"></a>2.2.2 master节点</h3><p>拥有选举成为master节点资格的节点经过选举，成为了master节点，</p>
<p>Elasticsearch中的master并不像mysql、hadoop集群的master那样，它既不是集群数据的唯一流入点，也不是所有元数据的存放点。所以，一般情况下Elasticsearch的Master负载是很低的。</p>
<p>master集群的主要工作有：</p>
<ol>
<li>同步集群状态：集群状态信息，由master节点进行维护，并且同步到集群中所有节点。也就是说集群中的任何节点都存储着集群状态信息（经过master的同步），但只有Master能够改变信息。我们可以通过接口读取它，如：/_cluster/state<ul>
<li>集群状态中包括：<ol>
<li>集群层面的设置</li>
<li>集群内有哪些节点的信息</li>
<li>各索引的设置，映射，分析器和别名等设置</li>
<li>索引内各分片所在的节点位置</li>
</ol>
</li>
</ul>
</li>
<li>集群状态的修改：集群状态的修改通过Master节点完成，比如索引的创建删除，mapping的修改等等。<ul>
<li>我们知道配置项dynamic=true表示对于未mapping的新字段，es会尝试猜测该字段的类型，并mapping它。此时数据节点需要跟Master通信，通知Master修改Mapping。这个时候的index写入是阻塞的。等Master修改了集群状态之后，再同步到所有节点，才可以继续写入。</li>
</ul>
</li>
</ol>
<h3 id="2-2-3-master选举"><a href="#2-2-3-master选举" class="headerlink" title="2.2.3 master选举"></a>2.2.3 master选举</h3><p>详见另一篇文章<a href="https://my.oschina.net/lscherish/blog/3167953" target="_blank" rel="noopener" title="ElasticSearch Master选举机制浅析">ElasticSearch Master选举机制浅析</a></p>
<h2 id="2-3-分片-Shared"><a href="#2-3-分片-Shared" class="headerlink" title="2.3 分片(Shared)"></a>2.3 分片(Shared)</h2><p>分片是什么？简单来讲就是咱们在ES中所有数据的文件块，也是<strong>数据的最小单元块</strong>，整个ES集群的核心就是对所有分片进行分布、索引、负载、路由等操作，来达到惊人的速度。</p>
<p>文档存储在分片中，然后分片分配到集群中的节点上。当集群扩容或缩小，Elasticsearch 将会自动在节点间迁移分片，以使集群保持平衡。</p>
<blockquote>
<p>假设 IndexA 有2个分片，我们向 IndexA 中插入10条数据 (10个文档)，那么这10条数据会尽可能平均的分为5条存储在第一个分片，剩下的5条会存储在另一个分片中。</p>
</blockquote>
<p>一个分片(shard)是一个最小级别“<strong>工作单元(worker unit)</strong>”，大多数情况下，它只是保存了索引中所有数据的<strong>一部分</strong>。</p>
<blockquote>
<p>这类似于 MySql 的分库分表。</p>
</blockquote>
<h3 id="2-3-1-分片的种类"><a href="#2-3-1-分片的种类" class="headerlink" title="2.3.1 分片的种类"></a>2.3.1 分片的种类</h3><p><strong>一个分片就是一个运行的 lucene 实例</strong>，一个节点可以包含多个分片，这些分片可以是：</p>
<ul>
<li><p>主分片（<strong>primary shard</strong>）</p>
<ul>
<li>用于解决数据<strong>水平扩展</strong>的问题，一个索引的所有数据是分布在所有主分片之上的（<strong>每个主分片承担一部分数据</strong>，主分片又分布在不同的节点上）</li>
<li>一个索引的主分片数量只能在创建时指定，<strong>es默认情况下数量为5</strong>，主分片数量一经指定<strong>后期无法修改</strong>，除非对数据进行重新构建索引（reindex操作）。</li>
</ul>
</li>
<li><p>副分片（<strong>replica shard</strong>）</p>
<ul>
<li>用于解决<strong>数据高可用</strong>的问题，一个副本分片即一个主分片的拷贝，其数量可以动态调整，通过增加副本分片也可以实现提升系统<strong>读性能</strong>的作用。</li>
<li>副本分片还可以实现es的<strong>故障转移</strong>，如果持有主分片的节点挂掉了，一个副本分片就会晋升为主分片的角色。<ul>
<li>为了达到故障转移的作用，主分片和其<strong>对应的</strong>副本分片是不会在同一个节点上的。</li>
</ul>
</li>
<li>对文档的新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片。<ul>
<li>为了提高写入的能力，ES这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，ES 通过乐观锁的方式控制，每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功。</li>
</ul>
</li>
<li>es默认情况下为每个主分片创造一个副本</li>
</ul>
</li>
</ul>
<h3 id="2-3-2-分片的优势"><a href="#2-3-2-分片的优势" class="headerlink" title="2.3.2 分片的优势"></a>2.3.2 分片的优势</h3><ol>
<li><strong>突破单节点容量上限</strong>，例如我们有10TB大小的总文档，分成20个分片分布于10台节点上，那么每个节点只需要1T的容量即可。</li>
<li><strong>服务高可用</strong>，由于有副本分片的存在，只要不是存储某个文档的node全挂了，那么这个文档数据就不会丢。副本分片提供了灾备的能力。</li>
<li><strong>故障转移</strong>，当主分片节点故障后，可升级一个副分片为新的主分片来应对节点故障。</li>
<li><strong>扩展性能</strong>，通过在所有replicas上并行搜索来提高读性能.由于replicas上的数据是近实时的(near realtime),因此所有replicas都能提供搜索功能,通过设置合理的replicas数量可以极高的提高搜索吞吐量</li>
</ol>
<h3 id="2-3-3-分片的配置"><a href="#2-3-3-分片的配置" class="headerlink" title="2.3.3 分片的配置"></a>2.3.3 分片的配置</h3><p>创建 IndexName 索引时候，在 Mapping 中可以如下设置分片 (curl)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT indexName</span><br><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;: &#123;</span><br><span class="line">		...</span><br><span class="line">		&quot;number_of_shards&quot;: 5,</span><br><span class="line">		&quot;number_of_replicas&quot;: 1</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Content-Type: application/json" -XPUT localhost:9200/indexName -d '</span><br><span class="line">&#123;</span><br><span class="line">	"settings": &#123;</span><br><span class="line">		...</span><br><span class="line">		"number_of_shards": 5,</span><br><span class="line">		"number_of_replicas": 1</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>

<p>当索引创建完成的时候，主分片的数量就固定了，但是复制分片的数量可以随时调整，根据需求扩大或者缩小规模。如把复制分片的数量从原来的 1 增加到 2 ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -H "Content-Type: application/json" -XPUT localhost:9200/indexName/_settings -d '</span><br><span class="line">&#123;</span><br><span class="line">    "number_of_replicas": 2</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-分片数量"><a href="#2-3-4-分片数量" class="headerlink" title="2.3.4 分片数量"></a>2.3.4 分片数量</h3><p>对于生产环境中分片的设定，需要提前做好容量规划，因为主分片数是在索引创建时预先设定的，后续无法修改。</p>
<p>那么分片的数量是否越大越好呢？答案当然是否定的。</p>
<ul>
<li><strong>分片数设置过小</strong><ul>
<li>导致后续无法通过增加节点进行水平扩展。</li>
<li>导致分片的数据量太大，数据在重新分配时耗时；</li>
</ul>
</li>
<li><strong>分片数设置过大</strong><ul>
<li>每个分片都是一个小的lucene索引，会消耗相应的资源;</li>
<li>影响搜索结果的相关性打分，影响统计结果的准确性；</li>
<li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能（每个搜索请求会调度到索引的每个分片中.但当分片位于同一个节点，就会开始竞争相同的硬件资源时, 性能便会逐步下降）；</li>
</ul>
</li>
</ul>
<blockquote>
<p>默认情况下，ES会为每个索引创建5个分片，即使是在单机环境下。这种冗余被称作过度分配（Over Allocation），目前看来这么做完全没有必要，仅在散布文档到分片和处理查询的过程中就增加了更多的复杂性，好在ES的优秀性能掩盖了这一点。但我们要知道在单机环境下配置5个分片是没有必要的。</p>
</blockquote>
<p>分片的数量和大小没有定例，可以参考官方的文档<a href="https://www.elastic.co/cn/blog/how-many-shards-should-i-have-in-my-elasticsearch-cluster" target="_blank" rel="noopener" title="我在 Elasticsearch 集群内应该设置多少个分片？">我在 Elasticsearch 集群内应该设置多少个分片？</a>，提取核心要素就是：</p>
<ol>
<li>“我应该有多少个分片？”<ul>
<li>答： 每个节点的分片数量应该保持在保持在低于每1GB堆内存对应集群的分片在20-25之间。</li>
<li>也就是shared number/node GBs &lt;20 或shared number/node GBs &lt;25，即shared number&lt;20 * node GBs 或 shared number&lt;25 * node GBs</li>
</ul>
</li>
<li>“我的分片应该有多大”？ <ul>
<li>答：分片大小为50GB通常被界定为适用于各种用例的极限，即不应该超过50GB。但实际上，根据经验，小于30GB更为合理</li>
</ul>
</li>
</ol>
<h3 id="2-3-5-分片和副本的分布"><a href="#2-3-5-分片和副本的分布" class="headerlink" title="2.3.5 分片和副本的分布"></a>2.3.5 分片和副本的分布</h3><p>配置一套高可用的集群，我们必须要了解es集群的数据分布和负载原理，我们先来看下es如何分布分片。</p>
<h4 id="2-3-5-1-主分片分布"><a href="#2-3-5-1-主分片分布" class="headerlink" title="2.3.5.1 主分片分布"></a>2.3.5.1 主分片分布</h4><p>假设我们只有三个主分片：</p>
<ul>
<li><strong>单机分片分布：</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-a0972163fdd585eb36a511f6bef04b07db1.png" alt=""></li>
</ul>
</li>
<li><strong>2个节点分片分布：</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-3469208ba209324551593faa0deb7686a3a.png" alt=""></li>
</ul>
</li>
<li><strong>3个节点分片分布：</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-c3b26a1f81c483e827284c297fa003681bd.png" alt=""></li>
</ul>
</li>
<li><strong>9个节点分片分布：</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-b9ed932890be90ea010a491301df5e2f41a.png" alt=""></li>
</ul>
</li>
</ul>
<p>可以看到，<strong>es尽量根据我们指定的分片数来平均分配到各个节点上</strong></p>
<h4 id="2-3-5-2-副本分布"><a href="#2-3-5-2-副本分布" class="headerlink" title="2.3.5.2 副本分布"></a>2.3.5.2 副本分布</h4><p>假设我们有3个节点，3个主分片，和若干个副本（下图边框有粗有细，粗的是主分片，细的是副本分片）</p>
<ul>
<li><strong>1个副本</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-a7dfac0e040e4da5ebefcc631c88dd7d111.png" alt=""></li>
</ul>
</li>
<li><strong>2个副本</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-275de0214674ffdb42ea21c4ef76ab192bf.png" alt=""></li>
</ul>
</li>
<li><strong>3个副本</strong><ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-daf2170fb6ed87cc747bc86c97849c09d42.png" alt=""></li>
</ul>
</li>
</ul>
<p>可以看到，es依旧尽量根据我们指定的主副分片数来平均分配到各个节点上，但是<strong>不会把存着相同数据的主副分片放在同一个节点上</strong>。</p>
<p>如果分片数量太多（如3个副本的情况），由于此时每台机器都已经占满自己的3个分片了，所以此时需要增加新的机器来存放每个主分片的第三个副本，如果没有新的机器。es不会允许同一个节点有多余的分片，所以提示了Unassigned，表示这些分片未指定。</p>
<h4 id="2-3-5-3-多个索引的分片分布"><a href="#2-3-5-3-多个索引的分片分布" class="headerlink" title="2.3.5.3 多个索引的分片分布"></a>2.3.5.3 多个索引的分片分布</h4><p><img src="https://oscimg.oschina.net/oscnet/up-638c00b3e77cfcf2ac50f3213fde5ad0454.png" alt=""></p>
<h3 id="2-3-6-分片分配策略和原理"><a href="#2-3-6-分片分配策略和原理" class="headerlink" title="2.3.6 分片分配策略和原理"></a>2.3.6 分片分配策略和原理</h3><p>详见<a href="https://www.easyice.cn/archives/248#gatewayAllocator" target="_blank" rel="noopener" title="ELASTICSEARCH ALLOCATION 分析">ELASTICSEARCH ALLOCATION 分析</a></p>
<h3 id="2-3-7-读写数据时的分片路由"><a href="#2-3-7-读写数据时的分片路由" class="headerlink" title="2.3.7 读写数据时的分片路由"></a>2.3.7 读写数据时的分片路由</h3><p>加入我们有一个拥有3个节点的集群，共拥有12个分片，其中有4个主分片（S0、S1、S2、S3）和8个副本分片（R0、R1、R2、R3），每个主分片对应两个副本分片，节点1是主节点（Master节点）负责整个集群的状态。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0e2de5975f04452b7f5d9a6192da6db57aa.png" alt=""></p>
<h4 id="2-3-7-1-对特定doc的读写操作"><a href="#2-3-7-1-对特定doc的读写操作" class="headerlink" title="2.3.7.1 对特定doc的读写操作"></a>2.3.7.1 对特定doc的读写操作</h4><p>写数据是只能写在主分片上，然后同步到副本分片。这里有四个主分片，<strong>数据是根据什么规则写到特定分片上的呢？这条索引数据为什么被写到S0上而不写到S1或S2上？那条数据为什么又被写到S3上而不写到S0上了？</strong></p>
<p>首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p>
<p><code>shard = hash(routing) % number_of_primary_shards</code></p>
<p>routing 是一个可变值，默认是文档的 <code>_id</code> ，也可以设置成一个自定义的值。routing 通过 hash 函数生成一个数字，然后这个数字再除以 <code>number_of_primary_shards</code> （主分片的数量）后得到余数 。这个在 0 到 numberofprimary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
<blockquote>
<p><strong>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</strong></p>
</blockquote>
<p>由于在ES集群中每个节点通过上面的计算公式都知道集群中的文档的存放位置，所以每个节点都有处理读写请求的能力。</p>
<p>在一个写请求被发送到某个节点后，该节点即为前面说过的协调节点，协调节点会根据路由公式计算出需要写到哪个分片上，再将请求转发到该分片的主分片节点上。</p>
<p>假如此时数据通过路由计算公式取余后得到的值是 shard = hash(routing) % 4 = 0，则具体流程如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bc10db22d8ebc5cf5d2b6e4d40d25faebc7.png" alt=""></p>
<ol>
<li><p>客户端向ES1节点（协调节点）发送写请求，通过路由计算公式得到值为0，则当前数据应被写到主分片S0上。</p>
</li>
<li><p>ES1节点将请求转发到S0主分片所在的节点ES3，ES3接受请求并写入到磁盘。</p>
</li>
<li><p>并发将数据复制到两个副本分片R0上，其中通过乐观并发控制数据的冲突。一旦所有的副本分片都报告成功，则节点ES3将向协调节点报告成功，协调节点向客户端报告成功。</p>
</li>
</ol>
<h4 id="2-3-7-2-搜索时的读操作"><a href="#2-3-7-2-搜索时的读操作" class="headerlink" title="2.3.7.2 搜索时的读操作"></a>2.3.7.2 搜索时的读操作</h4><p>es最强大的是做全文检索</p>
<ol>
<li><p>客户端发送请求到一个coordinate node。</p>
</li>
<li><p>协调节点将搜索请求转发到所有的shard对应的primary shard 或 replica shard ，都可以。</p>
</li>
<li><p>query phase：每个shard将自己的搜索结果（其实就是一些doc id）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</p>
</li>
<li><p>fetch phase：接着由协调节点根据doc id去各个节点上拉取实际的document数据，最终返回给客户端。</p>
</li>
</ol>
<p>写请求是写入primary shard，然后同步给所有的replica shard</p>
<p>读请求可以从primary shard 或者 replica shard 读取，采用的是随机轮询算法。</p>
<h2 id="2-4-段（segment）"><a href="#2-4-段（segment）" class="headerlink" title="2.4 段（segment）"></a>2.4 段（segment）</h2><p>数据被分配到特定的分片和副本上之后，最终是存储到磁盘上的，这样在断电的时候就不会丢失数据。</p>
<p>具体的存储路径可在配置文件 <code>../config/elasticsearch.yml</code>中进行设置，默认存储在安装目录的data文件夹下。建议不要使用默认值，因为若ES进行了升级，则有可能导致数据全部丢失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.data: &#x2F;path&#x2F;to&#x2F;data  &#x2F;&#x2F;索引数据</span><br><span class="line">path.logs: &#x2F;path&#x2F;to&#x2F;logs  &#x2F;&#x2F;日志记录</span><br></pre></td></tr></table></figure>

<p>segment是实现ES近实时搜索的关键，是数据索引（动词）过程中的重要载体。在说segment前，我们先要了解ES数据的存储和检索原理。</p>
<h3 id="2-4-1-倒排索引"><a href="#2-4-1-倒排索引" class="headerlink" title="2.4.1 倒排索引"></a>2.4.1 倒排索引</h3><p>倒排索引从逻辑结构和基本思路上来讲非常简单。下面我们通过具体实例来进行说明，使得读者能够对倒排索引有一个宏观而直接的感受。</p>
<p>假设文档集合包含五个文档，每个文档内容下图所示，在图中最左端一栏是每个文档对应的文档编号。我们的任务就是对这个文档集合建立倒排索引。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6226373d1d29a8efb8da9b6d7234b0a9604.png" alt=""></p>
<p>中文和英文等语言不同，单词之间没有明确分隔符号，所以首先要用分词系统将文档自动切分成单词序列。这样每个文档就转换为由单词序列构成的数据流，为了系统后续处理方便，需要对每个不同的单词赋予唯一的单词编号，同时记录下哪些文档包含这个单词，在如此处理结束后，我们可以得到最简单的倒排索引：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2175eb8149f1f6b7beb92e77528e463681a.png" alt=""></p>
<blockquote>
<p>“单词ID”一栏记录了每个单词的单词编号，第二栏是对应的单词，第三栏即每个单词对应的倒排列表。比如单词“谷歌”，其单词编号为1，倒排列表为{1,2,3,4,5}，说明文档集合中每个文档都包含了这个单词。</p>
</blockquote>
<p>之所以说上图所示倒排索引是最简单的，是因为这个索引系统只记载了哪些文档包含某个单词，而事实上，索引系统还可以记录除此之外的更多信息：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-94dbc311c56b2b95d1d6a8a19ff0deb91e7.png" alt=""></p>
<ul>
<li>单词ID：记录每个单词的单词编号；</li>
<li>单词：对应的单词；</li>
<li>文档频率：代表文档集合中有多少个文档包含某个单词</li>
<li>倒排列表：包含单词ID及其他必要信息</li>
<li>DocId：单词出现的文档id</li>
<li>TF：单词在某个文档中出现的次数</li>
<li>POS：单词在文档中出现的位置</li>
</ul>
<p>以单词“加盟”为例，其单词编号为6，文档频率为3，代表整个文档集合中有三个文档包含这个单词，对应的倒排列表为{(2;1;&lt;4&gt;),(3;1;&lt;7&gt;),(5;1;&lt;5&gt;)}，含义是在文档2，3，5出现过这个单词，在每个文档的出现过1次，单词“加盟”在第一个文档的POS是4，即文档的第四个单词是“加盟”，其他的类似。</p>
<h3 id="2-4-2-倒排索引的不变性"><a href="#2-4-2-倒排索引的不变性" class="headerlink" title="2.4.2 倒排索引的不变性"></a>2.4.2 倒排索引的不变性</h3><p>写到磁盘的倒序索引是不变的：<strong>写到磁盘后，倒排索引就再也不变</strong>。</p>
<p>这会有很多好处：</p>
<ol>
<li>不需要添加锁。如果你从来不用更新索引，那么你就不用担心多个进程在同一时间改变索引。</li>
<li>因为不变，所以可以很好的做缓存。只要内核有足够的缓存空间，绝大多数的读操作会直接从内存而不需要经过磁盘。这大大提升了性能。</li>
<li>写一个单一的大的倒序索引可以让数据压缩，减少了磁盘I/O的消耗以及缓存索引所需的RAM。</li>
</ol>
<p>然而，索引的不变性也有缺点。<strong>如果你想让新修改过的文档可以被搜索到，你必须重新构建整个索引</strong>。</p>
<p>我们来试想一下这样一个场景：对于一个索引内的所有文档，我们将其分词，建立了一个很大的倒排索引，并将其写入磁盘中。</p>
<p>如果索引有更新，那就需要重新全量创建一个索引来替换原来的索引。这种方式在数据量很大时效率很低，并且由于创建一次索引的成本很高，更无法保证时效性。</p>
<h3 id="2-4-3-分段存储"><a href="#2-4-3-分段存储" class="headerlink" title="2.4.3 分段存储"></a>2.4.3 分段存储</h3><p>如何在不丢失不变形的好处下让倒序索引可以更改？答案是：使用不只一个的索引。 新添额外的索引来反映新的更改来替代重写所有倒序索引的方案。</p>
<p>为了解决这个问题，Lucene引入了段（segment）的概念，简单来说，一个段segment存储着若干个文档，以及这些文档的索引信息（如词频，词向量，域（field）索引等），也就是说，一个segment是一个完整的倒序索引的子集。</p>
<blockquote>
<p>segment文件中存储的内容，可见<a href="https://www.cnblogs.com/buxiangbuliang/p/9275501.html" target="_blank" rel="noopener" title="【Lucene】Lucene 学习之索引文件结构">【Lucene】Lucene 学习之索引文件结构</a></p>
</blockquote>
<p>所以现在index在Lucene中的含义就是多个segments的集合。文档被成功存储的整个过程如下：</p>
<ol>
<li><p><strong>延迟写策略</strong></p>
<ul>
<li>如果每次将数据写入磁盘，磁盘的I/O消耗会严重影响性能。故而Lucene采用延迟写策略，新的文档建立时首先在内存中建立索引buffer：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-155993f01f84b6ca529f6cd82232533cebd.png" alt=""></li>
</ul>
</li>
<li><p><strong>Refresh</strong></p>
<ul>
<li>当达到默认的时间（1秒钟）或者内存的数据达到一定量时，会触发一次刷新（Refresh），将内存中的数据整合，生成到一个新的段。</li>
<li>此时，按理来说，应该将新生成的段刷进磁盘当中，但是将新的segment提交到磁盘需要fsync来保障物理写入。fsync是很耗时的，它不能在每次文档更新时就被调用，否则性能会很低。</li>
<li><strong>在内存和磁盘之间是文件系统缓存</strong>，于是，ES先将新生成的段先写入到内核的文件系统缓存中，这个过程很轻量。</li>
<li>默认情况下每个分片会每秒自动refresh一次。可以通过参数<code>index.refresh_interval</code>来修改这个刷新间隔</li>
<li>我们也可以手动触发 refresh，<ul>
<li><code>POST/_refresh</code> 刷新所有索引。</li>
<li><code>POST/nba/_refresh</code>刷新指定的索引。</li>
</ul>
</li>
<li>在这个阶段，新生成的segment（下图灰色）虽然还未写入磁盘，但已经能够被搜索了，这也是es近实时搜索的原理。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-9d79bd8369c408074f7c5b1d09428f33e0d.png" alt=""></li>
</ul>
</li>
<li><p><strong>Flush</strong></p>
<ul>
<li><strong>新增的段被刷新到磁盘中</strong>。</li>
<li>段被写入到磁盘后会生成一个<strong>提交点</strong>，提交点是一个用来记录所有提交后段信息的文件。</li>
<li>一般Flush的时间间隔会比较久，默认30分钟，或者当translog（后文介绍）达到了一定的大小（超过512M），也会触发flush操作。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-71b2db0e3ad2006e3ddb191c753d5621d81.png" alt=""></li>
</ul>
</li>
</ol>
<blockquote>
<p>这里的<strong>内存使用的是ES的JVM内存</strong>，而<strong>文件缓存系统使用的是操作系统的内存</strong>。</p>
</blockquote>
<blockquote>
<p>新的数据会继续的被写入内存，但内存中的数据并不是以段的形式存储的，因此不能提供检索功能。由内存刷新到文件缓存系统的时候会生成了新的段，并将段打开以供搜索使用，而不需要等到被刷新到磁盘。</p>
</blockquote>
<blockquote>
<p>注意，在内存中的新文档不一定能够被索引，只有生成段后，新文档才可以被索引。</p>
</blockquote>
<p>以上是新增文档操作，删除和更新操作过程有些类似：</p>
<ul>
<li>删除，由于不可修改，所以对于删除操作，不会把文档从旧的段中移除，而是通过新增一个 <code>.del</code>文件，文件中会列出这些被删除文档的段信息。<ul>
<li>这个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。</li>
</ul>
</li>
<li>更新，不能修改旧的段来进行反映文档的更新，其实更新相当于是删除和新增这两个动作组成。<ul>
<li>会将旧的文档在 <code>.del</code>文件中标记删除，然后文档的新版本被索引到一个新的段中。</li>
<li>可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就会被移除。</li>
</ul>
</li>
</ul>
<h3 id="2-4-4-事务日志（Translog）"><a href="#2-4-4-事务日志（Translog）" class="headerlink" title="2.4.4 事务日志（Translog）"></a>2.4.4 事务日志（Translog）</h3><p>虽然通过延时写的策略可以减少数据往磁盘上写的次数，提升了整体的写入能力，但是我们知道文件缓存系统也是内存空间，属于操作系统的内存，只要是内存都存在断电或异常情况下丢失数据的危险。</p>
<p>为了避免丢失数据，Elasticsearch添加了<strong>事务日志（Translog）</strong>，事务日志记录了所有还没有持久化到磁盘的数据。添加了事务日志后整个写索引的流程如下图所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-de73b4c4125c117ac994bf3fba7c249e0d1.png" alt=""></p>
<ul>
<li>一个新文档被索引（动词）之后，先被写入到内存中，但是为了防止数据的丢失，会<strong>追加一份数据到事务日志中</strong>。不断有新的文档被写入到内存，同时也会不断被记录到事务日志中。这时新数据还不能被检索和查询。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-1d8d535fcccc9ffa0ad322e32c2a4126b91.png" alt=""></li>
</ul>
</li>
<li>当达到默认的刷新时间或内存中的数据达到一定量后，<strong>会触发一次refresh</strong>，将内存中的数据以一个新段形式刷新到文件缓存系统中并清空内存。这时虽然新段未被提交到磁盘，但是可以提供文档的检索功能且不能被修改。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-75e39cae236d7e2b714df71c59110211639.png" alt=""></li>
</ul>
</li>
<li>随着新文档索引不断被写入，当日志数据大小超过512M或者时间超过30分钟时，<strong>会触发一次flush</strong>。内存中的数据被写入到一个新段同时被写入到文件缓存系统，文件系统缓存中数据通过 fsync 刷新到磁盘中，生成提交点，日志文件被删除，创建一个空的新日志。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-67cd1c2287040e1cb59cc4051dc2b56b6f0.png" alt=""><h3 id="2-4-5-es写操作总结"><a href="#2-4-5-es写操作总结" class="headerlink" title="2.4.5 es写操作总结"></a>2.4.5 es写操作总结</h3></li>
</ul>
</li>
</ul>
<ol>
<li>先写入内存buffer，在buffer里的时候数据是搜索不到的；同时将数据写入translog日志文件。</li>
<li>如果buffer快满了，或者到一定时间，就会将内存buffer数据refresh 到一个新的segment file中，但是此时数据不是直接进入segment file磁盘文件，而是先进入os cache。这个过程就是 refresh。</li>
<li>每隔1秒钟，es将buffer中的数据写入一个新的segment file，每秒钟会写入一个新的segment file，这个segment file中就存储最近1秒内 buffer中写入的数据。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-45714517c4af324ce1eba2f227ef81df32f.png" alt=""></p>
<h3 id="2-4-6-段合并"><a href="#2-4-6-段合并" class="headerlink" title="2.4.6 段合并"></a>2.4.6 段合并</h3><p>由于自动刷新流程（refresh）每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦，比如每一个段都会消耗文件句柄、内存和cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段然后合并查询结果，所以段越多，搜索也就越慢。</p>
<p>Elasticsearch通过在后台定期进行<strong>段合并</strong>来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。段合并的时候会将那些<strong>旧的已删除文档从文件系统中清除</strong>。被删除的文档不会被拷贝到新的大段中。合并的过程中不会中断索引和搜索。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3d4c071b8381e9828b93a3036abb886dfed.png" alt=""></p>
<p>段合并在进行索引和搜索时会自动进行，合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中，这些段既可以是未提交的也可以是已提交的。合并结束后老的段会被删除，新的段被 flush 到磁盘，同时写入一个包含新段且排除旧的和较小的段的新提交点，新的段被打开可以用来搜索。</p>
<p>段合并的计算量庞大， 而且还要吃掉大量磁盘 I/O，段合并会拖累写入速率，如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/getting-started.html" target="_blank" rel="noopener" title="Elasticsearch权威指南">Elasticsearch权威指南</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/28d5e38e3ca7" target="_blank" rel="noopener" title="elasticsearch5.x集群HA原理(shards、replicas)">elasticsearch5.x集群HA### 2.3.3 分片和副本的分布</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/qdhxhz/p/11448451.html" target="_blank" rel="noopener" title="Elasticsearch(4)--- 基本概念(Index、Type、Document、集群、节点、分片及副本、倒排索引)">Elasticsearch(4)— 基本概念(Index、Type、Document、集群、节点、分片及副本、倒排索引)</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/cc06f9adbe82" target="_blank" rel="noopener" title="【ES】ElasticSearch 深入分片">【ES】ElasticSearch 深入分片</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_33775582/article/details/91425787" target="_blank" rel="noopener" title="Elasticsearch分片">Elasticsearch分片</a></p>
</li>
<li><p><a href="https://blog.csdn.net/J_bean/article/details/80147277" target="_blank" rel="noopener" title="elasticsearch节点(角色)类型解释：node.master和node.data">elasticsearch节点(角色)类型解释：node.master和node.data</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1488535" target="_blank" rel="noopener" title="全文搜索引擎Elasticsearch，这篇文章给讲透了">全文搜索引擎Elasticsearch，这篇文章给讲透了</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/18/ElasticSearch-Master%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/18/ElasticSearch-Master%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/" itemprop="url">ElasticSearch Master选举机制浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-18T22:59:20+08:00">
                2020-02-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">ElasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/18/ElasticSearch-Master%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/02/18/ElasticSearch-Master选举机制浅析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  8
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在ElasticSearch集群中，master负责处理集群层面配置的变更和同步工作，所有yml文件配置<code>node.master: true</code>的节点都有资格经过选举成为master节点</p>
<p><strong>es集群的master选举采用Bully算法</strong></p>
<h1 id="Bully算法"><a href="#Bully算法" class="headerlink" title="Bully算法"></a>Bully算法</h1><p>Leader选举的基本算法之一。</p>
<p>它假定所有节点都有一个惟一的ID，该ID对节点进行排序。 任何时候的当前Leader都是参与集群的最高id节点。</p>
<p>具体来说，Bully算法要求每个节点都投票给ID最高的那个节点，通过这一强制性的条件，让集群非常简单的协调一致。</p>
<p>该算法的优点是易于实现，但是，当拥有最大ID的节点处于不稳定状态的场景下会有问题，例如Master负载过重而假死，集群拥有第二大ID的节点被选为新主，这时原来的Master恢复，再次被选为新主，然后又假死…</p>
<p>而且该算法会有脑裂的问题。</p>
<p>elasticsearch通过<strong>控制触发时机来解决反复去世的问题，即当前的Master失效才会触发选举。</strong></p>
<p>同时es又<strong>要求法定得票人数过半</strong>才能选出master，以此来解决脑裂。</p>
<blockquote>
<p>es实际上是从具有master资格的节点中选id最小的节点作为master，而不是id最大的节点</p>
</blockquote>
<h1 id="选举触发时机"><a href="#选举触发时机" class="headerlink" title="选举触发时机"></a>选举触发时机</h1><ol>
<li>集群启动：<ul>
<li>后台启动线程去ping集群中的节点，按照上述策略从具有master资格的节点中选举出master</li>
</ul>
</li>
<li>Master失效<ul>
<li>非Master节点运行的MasterFaultDetection检测到Master失效，在其注册的listener中执行handleMasterGone，执行rejoin操作，重新选主。注意，即使一个节点认为Master失效，也会进入选主流程。</li>
</ul>
</li>
</ol>
<p>我们需要在候选集群中的节点的配置文件中设置参数 <code>discovery.zen.munimum_master_nodes</code>的值，这个参数表示<strong>在选举主节点时需要参与选举的候选主节点的节点数</strong>，默认值是1，官方建议取值 <code>(master_eligibel_nodes/2)+1</code>，其中 <code>master_eligibel_nodes</code>为候选主节点的个数。</p>
<p>这样做既能防止脑裂现象的发生，也能最大限度地提升集群的高可用性，因为只要不少于discovery.zen.munimum_master_nodes个候选节点存活，选举工作就能正常进行。当小于这个值的时候，无法触发选举行为，集群无法使用，不会造成分片混乱的情况。</p>
<h1 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h1><p>Master选举主要逻辑在<code>ZenDiscovery.findMaster（基于es 5.2版本）</code>中：</p>
<ol>
<li><p><strong>开始</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DiscoveryNode <span class="title">findMaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	logger.trace(<span class="string">"starting to ping"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>每个节点ping集群下的其他节点，等待所有节点的返回。</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pingAndWait用于获取其他节点的状态，这里只介绍下大致实现，不再展开具体源码：</span></span><br><span class="line"><span class="comment">//pingAndWait主要是使用上面介绍的ZenPing去ping配置中的所有host</span></span><br><span class="line"><span class="comment">//通过函数名称可以知道这是个同步调用，同步的具体实现和ElasticSearch大部分需要等待</span></span><br><span class="line"><span class="comment">//远程通信返回的行为类似，采用计数器记录发送的请求个数，每次有请求响应时递减计数器，</span></span><br><span class="line"><span class="comment">//当计数器递减为0时表示所有请求都得到了响应。</span></span><br><span class="line">List&lt;ZenPing.PingResponse&gt; fullPingResponses = pingAndWait(pingTimeout).toList();</span><br><span class="line"><span class="keyword">if</span> (fullPingResponses == <span class="keyword">null</span>) &#123;</span><br><span class="line">	logger.trace(<span class="string">"No full ping responses"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">if</span> (fullPingResponses.size() == <span class="number">0</span>) &#123;</span><br><span class="line">		sb.append(<span class="string">" &#123;none&#125;"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (ZenPing.PingResponse pingResponse : fullPingResponses) &#123;</span><br><span class="line">			sb.append(<span class="string">"\n\t--&gt; "</span>).append(pingResponse);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	logger.trace(<span class="string">"full ping responses:&#123;&#125;"</span>, sb);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">final</span> DiscoveryNode localNode = clusterService.localNode();</span><br><span class="line">	</span><br><span class="line"><span class="comment">// add our selves</span></span><br><span class="line"><span class="keyword">assert</span> fullPingResponses.stream().map(ZenPing.PingResponse::node)</span><br><span class="line">	.filter(n -&gt; n.equals(localNode)).findAny().isPresent() == <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//在获取的装填集中加入当前节点自己的状态，因为自己也需要加入选举，也可能被选举为主节点</span></span><br><span class="line">fullPingResponses.add(<span class="keyword">new</span> ZenPing.PingResponse(localNode, <span class="keyword">null</span>, clusterService.state()));</span><br></pre></td></tr></table></figure></li>
<li><p><strong>根据其他节点的返回，过滤掉没有资格参加选举的节点</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter responses</span></span><br><span class="line"><span class="comment">// 过滤PingResponse, 排除掉client节点，单纯的data节点</span></span><br><span class="line"><span class="keyword">final</span> List&lt;ZenPing.PingResponse&gt; pingResponses = filterPingResponses(fullPingResponses, masterElectionIgnoreNonMasters, logger);</span><br></pre></td></tr></table></figure></li>
<li><p><strong>根据反馈，收集当前集群已经存在的master塞入activeMasters</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//activeMasters用来记录当前已经存在的主节点</span></span><br><span class="line">List&lt;DiscoveryNode&gt; activeMasters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (ZenPing.PingResponse pingResponse : pingResponses) &#123;</span><br><span class="line">	<span class="comment">// We can't include the local node in pingMasters list, otherwise we may up electing ourselves without</span></span><br><span class="line">	<span class="comment">// any check / verifications from other nodes in ZenDiscover#innerJoinCluster()</span></span><br><span class="line">	<span class="comment">//如果返回的信息表明自己当前已经是主节点，那么不会把自己加入到activeMasters中去</span></span><br><span class="line">	<span class="keyword">if</span> (pingResponse.master() != <span class="keyword">null</span> &amp;&amp; !localNode.equals(pingResponse.master())) &#123;</span><br><span class="line">		activeMasters.add(pingResponse.master());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>根据反馈，收集当前集群已经存在的具有选举资格的node塞入masterCandidates</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="comment">// nodes discovered during pinging</span></span><br><span class="line"><span class="comment">//masterCandidates用来记录配置为可以成为主节点的候选节点</span></span><br><span class="line">List&lt;ElectMasterService.MasterCandidate&gt; masterCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//这里将返回节点中配置为可以作为主节点的节点加入候选节点中</span></span><br><span class="line"><span class="keyword">for</span> (ZenPing.PingResponse pingResponse : pingResponses) &#123;</span><br><span class="line">	<span class="comment">//这里要注意isMasterNode并不是说明该节点是不是主节点，而是表明该节点能不能成为主节点</span></span><br><span class="line">	<span class="keyword">if</span> (pingResponse.node().isMasterNode()) &#123;</span><br><span class="line">		masterCandidates.add(<span class="keyword">new</span> ElectMasterService.MasterCandidate(pingResponse.node(), pingResponse.getClusterStateVersion()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>如果集群中已经有master，那么加入它，否则，开始选举</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果当前存在的主节点列表activeMasters为空，则从候选节点列表masterCandidates中选取主节点</span></span><br><span class="line"><span class="keyword">if</span> (activeMasters.isEmpty()) &#123;</span><br><span class="line">	<span class="comment">//判断是否有足够的候选节点</span></span><br><span class="line">	<span class="keyword">if</span> (electMaster.hasEnoughCandidates(masterCandidates)) &#123;</span><br><span class="line">		<span class="comment">//进行节点选举</span></span><br><span class="line">		<span class="keyword">final</span> ElectMasterService.MasterCandidate winner = electMaster.electMaster(masterCandidates);</span><br><span class="line">		logger.trace(<span class="string">"candidate &#123;&#125; won election"</span>, winner);</span><br><span class="line">		<span class="keyword">return</span> winner.getNode();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// if we don't have enough master nodes, we bail, because there are not enough master to elect from</span></span><br><span class="line">		logger.trace(<span class="string">"not enough master nodes [&#123;&#125;]"</span>, masterCandidates);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//activeMasters不为空，表示当前集群已经有master了</span></span><br><span class="line">	<span class="keyword">assert</span> !activeMasters.contains(localNode) : <span class="string">"local node should never be elected as master when other nodes indicate an active master"</span>;</span><br><span class="line">	<span class="comment">//如果当前存在的主节点列表activeMasters不为空，则从中选取主节点</span></span><br><span class="line">	<span class="comment">// lets tie break between discovered nodes</span></span><br><span class="line">	<span class="keyword">return</span> electMaster.tieBreakActiveMasters(activeMasters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果集群中现在没有master，那么选出master</strong></p>
<ul>
<li><p>选举主要算法集中在electMaster.electMaster()方法中，我们来看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Elects a new master out of the possible nodes, returning it. Returns &lt;tt&gt;null&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * if no master has been elected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MasterCandidate <span class="title">electMaster</span><span class="params">(Collection&lt;MasterCandidate&gt; candidates)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//保证有足够的候选者，逻辑是判断有资格参选的node数量大于yml配置的minimumMasterNodes</span></span><br><span class="line">	<span class="function"><span class="keyword">assert</span> <span class="title">hasEnoughCandidates</span><span class="params">(candidates)</span></span>;</span><br><span class="line">	List&lt;MasterCandidate&gt; sortedCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;(candidates);</span><br><span class="line">	<span class="comment">//对候选者进行排序，</span></span><br><span class="line">	sortedCandidates.sort(MasterCandidate::compare);</span><br><span class="line">	<span class="comment">//取队首的node即为master</span></span><br><span class="line">	<span class="keyword">return</span> sortedCandidates.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * compares two candidates to indicate which the a better master.</span><br><span class="line"> * A higher cluster state version is better</span><br><span class="line"> *</span><br><span class="line"> * @return -1 if c1 is a batter candidate, 1 if c2.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int compare(MasterCandidate c1, MasterCandidate c2) &#123;</span><br><span class="line">	&#x2F;&#x2F; we explicitly swap c1 and c2 here. the code expects &quot;better&quot; is lower in a sorted</span><br><span class="line">	&#x2F;&#x2F; list, so if c2 has a higher cluster state version, it needs to come first.</span><br><span class="line">	&#x2F;&#x2F;先根据节点的clusterStateVersion比较，clusterStateVersion越大，优先级越高。</span><br><span class="line">	&#x2F;&#x2F;这是为了保证新Master拥有最新的clusterState(即集群的meta)，避免已经commit的meta变更丢失。</span><br><span class="line">	&#x2F;&#x2F;因为Master当选后，就会以这个版本的clusterState为基础进行更新。</span><br><span class="line">	int ret &#x3D; Long.compare(c2.clusterStateVersion, c1.clusterStateVersion);</span><br><span class="line">	if (ret &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		&#x2F;&#x2F;clusterStateVersion相同时，进入compareNodes，其内部按照节点的Id比较(Id为节点第一次启动时随机生成)</span><br><span class="line">		ret &#x3D; compareNodes(c1.getNode(), c2.getNode());</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">&#x2F;** master nodes go before other nodes, with a secondary sort by id **&#x2F;</span><br><span class="line"> private static int compareNodes(DiscoveryNode o1, DiscoveryNode o2) &#123;</span><br><span class="line"> 	&#x2F;&#x2F;isMasterNode方法是判断该节点yml文件是否配置了data.master&#x3D;true，即是否有资格参选</span><br><span class="line">	&#x2F;&#x2F;有资格参选的优先（其实从findMaster进入这里，所有的node都是有资格的）</span><br><span class="line">	if (o1.isMasterNode() &amp;&amp; !o2.isMasterNode()) &#123;</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if (!o1.isMasterNode() &amp;&amp; o2.isMasterNode()) &#123;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;根据id排序升序排序</span><br><span class="line">	return o1.getId().compareTo(o2.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>如果集群中已经有master，找到这个master</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** selects the best active master to join, where multiple are discovered */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DiscoveryNode <span class="title">tieBreakActiveMasters</span><span class="params">(Collection&lt;DiscoveryNode&gt; activeMasters)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//同理，也是默认id最小的node就是master</span></span><br><span class="line">	<span class="keyword">return</span> activeMasters.stream().min(ElectMasterService::compareNodes).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="选举过程简图"><a href="#选举过程简图" class="headerlink" title="选举过程简图"></a>选举过程简图</h1><p><img src="https://oscimg.oschina.net/oscnet/up-47d023a3bf701279690cbff187a131b0e4d.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/21/Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/21/Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" itemprop="url">Raft算法分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-21T22:52:18+08:00">
                2020-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分布式算法&理论</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务和数据一致性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/21/Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/01/21/Raft算法分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在了解Ratf算法前，我们需要了解如下的一些概念名词：</p>
<ol>
<li><p>状态机复制 (State Machine Replication)</p>
<ul>
<li>在分布式系统设计中，需要遵循CAP理论，如果我们要让一个服务具有容错能力，那么会让一个服务的多个副本同时运行在不同的节点上。此时，<strong>状态的改变</strong>就需要在各个副本之间做同步，实现这种同步方法就是所谓的状态机复制（State Machine Replication）。</li>
<li>状态机复制的理论基础是：如果集群里的每一个节点上都运行着相同的确定性状态机S，并且所有的状态机刚开始都处于同样的初始状态s0，那么给予这些状态机相同的输入序列: {i1, i2, i3, i4, i5, i6, …, in}, 这些状态机必然会经过相同的状态转换路径: s0-&gt;s1-&gt;s2-&gt;s3-&gt;…-&gt;sn最终达到相同的状态sn, 同时生成相同的输出序列 {o1(s1), o2(s2), o3(s3), …, on(sn)}。（典型的例子就是Redis的AOF和MySQL集群的binlog）</li>
<li>在执行输入序列I的过程中，根据同步方式的不同，系统就有了强一致性和最终一致性。如果我们要求对于序列I中的每一个in, <strong>都需要所有的服务副本确认执行了in，才能执行in+1</strong>，那么这个系统就是强一致性的系统。如果我们取消掉这个限制，仅仅要求所有的服务副本执行相同的输入序列I，但是完全各自独立执行，而不需要在中间同步，那么就有了最终一致性（各服务都会达到相同的最终状态，但是达到的时间不确定）。</li>
</ul>
</li>
<li><p>拜占庭将军问题</p>
<ul>
<li>问题很简单，拜占庭帝国要攻打一个城池，兵分多路，城池很难攻下，要多路军队同时进攻才能攻下，为了完成目标，各路的将军需要通过信使来约定一个攻打的时间，而信使有可能死亡或者叛变（传递假消息）。</li>
<li>基于以上的问题，我们需要在行动时达成共识。互联网上，每台计算机都是一个个完全相等的节点，只能靠通信来协调，没有权威背书或信任，是一个急需解决的问题。</li>
</ul>
</li>
</ol>
<blockquote>
<p>拜占庭将军问题的本质：如何让众多完全平等的节点针对某一状态达成共识。</p>
</blockquote>
<h1 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h1><p>拜占庭将军问题是分布式领域最复杂、最严格的容错模型。但在日常工作中使用的分布式系统面对的问题不会那么复杂，更多的是计算机故障挂掉了，或者网络通信问题而没法传递信息，这种情况不考虑计算机之间互相发送恶意信息，极大简化了系统对容错的要求，最主要的是达到一致性。</p>
<p>所以将拜占庭将军问题根据常见的工作上的问题进行简化：<strong>假设将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成一致性决定？</strong></p>
<p>对于这个简化后的问题，有许多解决方案，第一个被证明的共识算法是 Paxos，由拜占庭将军问题的作者 Leslie Lamport 在1990年提出，最初以论文难懂而出名，后来这哥们在2001重新发了一篇简单版的论文 <a href="https://link.jianshu.com?t=%255Bhttps%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Fpaxos-simple.pdf%255D%28https%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Fpaxos-simple.pdf%29" target="_blank" rel="noopener">Paxos Made Simple</a>，然而还是挺难懂的。</p>
<p>因为 Paxos 难懂，难实现，所以斯坦福大学的教授在2014年发表了新的分布式协议 Raft。与 Paxos 相比，Raft 有着基本相同运行效率，但是更容易理解，也更容易被用在系统开发上。paxos见我的另一篇文章<a href="https://my.oschina.net/lscherish/blog/3086518" target="_blank" rel="noopener" title="分布式一致性理论和paxos算法">分布式一致性理论和paxos算法</a></p>
<p>Raft算法主要分为如下几个关键步骤：</p>
<ul>
<li><strong>leader选举</strong>：<ul>
<li>Raft开始时在集群中选举出Leader负责日志复制的管理；</li>
</ul>
</li>
<li><strong>日志复制</strong>：<ul>
<li>Leader接受来自客户端的事务请求（日志），并将它们复制给集群的其他节点，然后负责通知集群中其他节点提交日志，Leader负责保证其他节点与他的日志同步。</li>
</ul>
</li>
<li><strong>故障转移</strong>：<ul>
<li>当Leader宕掉后集群其他节点会发起选举选出新的Leader；</li>
</ul>
</li>
</ul>
<p>raft算法有如下特点：</p>
<ul>
<li>强leader语义：<ul>
<li>相比其他一致性算法，Raft使用增强形式的leader语义。举个例子，日志只能由leader复制给其它节点。这简化了日志复制需要的管理工作，使得Raft易于理解。</li>
</ul>
</li>
<li>leader的选择：<ul>
<li>Raft使用随机计时器来选择leader，它的实现只是在心跳机制(任何一致性算法中都必须实现)上多做了一点“文章”，不会增加延迟和复杂性。</li>
</ul>
</li>
<li>关系改变：<ul>
<li>Raft使用了一个新机制joint consensus允许集群动态在线扩容，保障Raft的可持续服务能力。</li>
</ul>
</li>
</ul>
<h2 id="1-Ratf名词速览"><a href="#1-Ratf名词速览" class="headerlink" title="1 Ratf名词速览"></a>1 Ratf名词速览</h2><h3 id="1-1-Raft节点状态"><a href="#1-1-Raft节点状态" class="headerlink" title="1.1 Raft节点状态"></a>1.1 Raft节点状态</h3><p>从拜占庭将军的故事映射到分布式系统上，每个将军相当于一个分布式网络节点，每个节点有<strong>三种状态：Follower（跟随者），Candidate（候选者），Leader（领导者）</strong>，状态之间是互相转换的，可以参考下图，具体的后面说。</p>
<p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2542550312,1610670251&fm=26&gp=0.jpg" alt=""></p>
<h3 id="1-2-term任期"><a href="#1-2-term任期" class="headerlink" title="1.2 term任期"></a>1.2 term任期</h3><p>从上面可以看出，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这和民选社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫<strong>term</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fcbf54411bab45c59179187008e2b0bb6d3.png" alt=""></p>
<p>上图蓝色表示选举期，绿色表示履职期。</p>
<p>每个任期都有一个对应的整数与之关联，称为“任期号”，任期号用单词“Term”表示，这个值是一个严格递增的整数值。</p>
<p>如果一个candidate在一次选举中赢得leader，那么这个节点将在这个任期中担任leader的角色。但并不是每个任期都一定对应有一个leader的，比如上面的t3中，可能在选举超时到来之前都没有产生一个新的leader，那么此时将递增任期号开始一次新的选举。</p>
<h2 id="2-Raft算法流程"><a href="#2-Raft算法流程" class="headerlink" title="2. Raft算法流程"></a>2. Raft算法流程</h2><h3 id="2-1-leader选举"><a href="#2-1-leader选举" class="headerlink" title="2.1 leader选举"></a>2.1 leader选举</h3><h4 id="2-1-1-心跳机制"><a href="#2-1-1-心跳机制" class="headerlink" title="2.1.1 心跳机制"></a>2.1.1 心跳机制</h4><p>raft算法是使用<strong>心跳机制</strong>来触发leader选举的。</p>
<p>在节点刚开始启动时，初始状态是follower状态。一个follower状态的节点，只要一直收到来自leader或者candidate的正确RPC消息的话，将一直保持在follower状态。</p>
<p>leader节点通过周期性的发送心跳请求（一般使用带有空数据的AppendEntries RPC来进行心跳）来维持着leader节点状态。</p>
<h4 id="2-1-2-选举超时（election-timeout）"><a href="#2-1-2-选举超时（election-timeout）" class="headerlink" title="2.1.2 选举超时（election timeout）"></a>2.1.2 选举超时（election timeout）</h4><p>每个follower有一个选举超时（election timeout）定时器，这个定时器的值，对于每个节点都是不同的，<strong>其值在150ms到300ms之前随机</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-016776da4a64b5dd9d1153b7f5092d46aa8.png" alt=""></p>
<p>如果某个节点在这个定时器超时之前都没有收到来自leader的心跳请求，那么该follower将认为当前集群中没有leader了，<strong>它会改变自己的状态为candidate</strong>，如下图Node A。然后开启一个新的term，节点本地的任期号term+1。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3031d5fce27f4dfa56678ec53d1996b1948.png" alt=""></p>
<h4 id="2-1-3-请求投票（RequestVote）"><a href="#2-1-3-请求投票（RequestVote）" class="headerlink" title="2.1.3 请求投票（RequestVote）"></a>2.1.3 请求投票（RequestVote）</h4><p>成为candidate的节点，会先投自己一票，然后并行给其他节点发送请求投票的消息RequestVote RPCs</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-00e140d80ed7a32d3b2c37a2e9f81aee907.png" alt=""></p>
<p>那么一个节点在接收到RequestVote RPCs时，它会遵循以下约束来决定是否将票投给请求的发送者。</p>
<ol>
<li>在任一任期内，单个节点最多只能投一票</li>
<li>候选人知道的信息不能比自己的少（这一部分，后面介绍log replication和safety的时候会详细介绍）</li>
<li>first-come-first-served 先来先得</li>
</ol>
<p>如果一个节点在接收到RequestVote RPCs时，上述约束都满足，<strong>那么他将投发送者一票，重置自己的election timeout，并给予响应。</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-582e3bffc1f4b8d9559d2fc6b91e21bab71.png" alt=""></p>
<h4 id="2-1-4-票仓分布"><a href="#2-1-4-票仓分布" class="headerlink" title="2.1.4 票仓分布"></a>2.1.4 票仓分布</h4><p>对于一个candidate而言，它发出了请求RequestVote RPCs后，就开始等待其他节点的回复，这时可能会有三种结果：</p>
<ol>
<li><p>全局就它一个candidate，其他的节点election timeout还没结束就接到了它的RequestVote RPCs，那么这时，这个candidate无疑会获得大多数票，成为新的leader。</p>
<p> <img src="https://oscimg.oschina.net/oscnet/up-5935fb3ed30c681c368121b30b33d0c37ca.png" alt=""></p>
</li>
<li><p>有多个节点<strong>或先后或同时</strong>成为了candidate，但基于“每个节点一个任期内只能投一票”和“先到先得”的约束，以及请求的通信时间的随机性，还是有一个candidate运气好，获得了超过半数的票。</p>
</li>
</ol>
<ul>
<li>那么这个新的leader胜选后，会广播心跳，其他candidate发现心跳中携带的term信息不低于自己，知道有已经有leader被选举出来了，于是放弃选举，转换成follower。</li>
</ul>
<ol start="3">
<li>有多个节点<strong>或先后或同时</strong>成为了candidate，但票数分布均匀，没有任何节点获得超过半数的票（这种情况称作split vote）。<ul>
<li><img src="https://img2018.cnblogs.com/blog/1089769/201812/1089769-20181216202546810-1327167758.png" alt=""></li>
<li>此时所有的candidate都在等待能使自己选票超过半数的响应，等啊等，直到超时后重新发起选举。</li>
<li>如果出现split vote的情况，那么就延长了系统不可用的时间（没有leader是不能处理客户端写请求的），因此raft才引入randomized election timeouts来尽量避免平票情况。同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现。</li>
</ul>
</li>
</ol>
<h4 id="2-1-5-诞生leader"><a href="#2-1-5-诞生leader" class="headerlink" title="2.1.5 诞生leader"></a>2.1.5 诞生leader</h4><p>一个leader诞生以后，就像我们在前文<em>2.1.1 心跳机制</em>所述的那样，<strong>在这个新的任期内每隔heartBeat timeout时间，不停的向follower发送心跳请求（append entries）</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-737045f80305af36b81c50bfdc6952cd71c.png" alt=""></p>
<p>而每个follower则维持着自己的election timeout计时器，如果election timeout时间内没有收到来自leader的心跳，那么说明leader故障。将自己变成candidate，并开始下次选举。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9c878faedc64dd14284548e3b6b739f6f5e.png" alt=""></p>
<h3 id="2-2-日志复制（Log-Replication）"><a href="#2-2-日志复制（Log-Replication）" class="headerlink" title="2.2 日志复制（Log Replication）"></a>2.2 日志复制（Log Replication）</h3><p>前文我们说过了<strong>状态机复制(State Machine Replication)</strong>，状态机复制有多种实现，在Raft中，也有一套基于Append-Only Log的状态机复制实现。</p>
<p>Raft 是分布式一致性算法，保证的实际上是多台机器上数据的一致性。前面讨论的 leader 选举，其实都是为了保证日志复制的一致性而做的前提。Raft的状态机复制实现，我们称作日志复制（Log Replication）。</p>
<blockquote>
<p>Leader 选举只是为了保证日志相同的辅助工作。实际上，在更为学术的 Paxos 里面，是没有 leader 的概念的（大部分 Paxos 的实现通常会加入 leader 机制提高性能）。</p>
</blockquote>
<p>这里的日志，指的是命令日志，对于客户端发来的命令请求，leader会将其封装成一个Log Entry作为传输的载体。</p>
<p>在 Raft 中，leader会接收客户端的所有需求（follower会将写请求转发给leader），leader会将数据以Log Entry的方式通过AppendEntries RPC同步给所有followers</p>
<p>只要超过半数以上的follower反馈成功（返回ack），这条日志就成功提交了。如果RPC请求超时，leader就不停的进行AppendEntries RPC重试。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3d5c64ec78bb30781abc5d3932c1013c62b.png" alt=""></p>
<p><strong>简单来说，保证复制日志相同，才是分布式一致性算法的最终任务</strong>。</p>
<h4 id="2-2-1-Log和Log-Entry"><a href="#2-2-1-Log和Log-Entry" class="headerlink" title="2.2.1 Log和Log Entry"></a>2.2.1 Log和Log Entry</h4><p>Raft中每个节点，都会维护一个本地Log数组，其数据结构如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bcaab5cd935fc5a5dd0834e80980e3cea12.png" alt=""></p>
<p>其构成有：</p>
<ul>
<li>创建日志时的任期号（用来检查节点日志是否出现不一致的情况）</li>
<li>状态机需要执行的指令（真正的内容）</li>
<li>索引：整数索引，表示日志条目在日志数组中位置</li>
</ul>
<p>上图显示，共有 8 条日志，提交了 7 条。提交的日志都将通过状态机持久化到磁盘中，防止宕机。</p>
<h4 id="2-2-2-一致性校验"><a href="#2-2-2-一致性校验" class="headerlink" title="2.2.2 一致性校验"></a>2.2.2 一致性校验</h4><p>然后谈谈主从日志的一致性问题，这个是分布式一致性算法要解决的根本问题。</p>
<p>Raft 主从日志的一致性，这个最终的目标，可以分解成<strong>一个假设</strong>和一个<strong>充分条件</strong>。</p>
<ul>
<li><p><strong>我们可以假设</strong>：如果在不同的日志中的两个日志条目的<code>任期号</code> 和 <code>索引下标</code> 相同，那么他们的指令就是相同的。</p>
<blockquote>
<p>leader 最多在一个任期里的一个日志索引位置创建一条日志条目，而所有follower的日志来源都是leader，日志条目在日志的位置从来不会改变，所以基本上可以用任期号和索引下标当做Log Entry的主键</p>
</blockquote>
</li>
<li><p><strong>那么，主从日志一致性的充分条件可以是</strong>：如果在不同节点的日志里， 任意2个拥有相同的任期号和索引的日志条目，他们之前的日志项都是相同的，那么这些节点的日志就都是一致的。</p>
</li>
</ul>
<p>达成了上述的这个充分条件，就达成了主从日志一致的最终条件，那如何达成这个充分条件呢？Raft引入了一种<strong>一致性校验</strong>约束。</p>
<p><strong>每次 RPC 发送附加日志时，leader 会把当前这条日志Entry的前一个日志Entry的下标和任期号一起发送给 follower，如果 follower 发现发来前一个日志Entry的下标和任期号和自己队尾的日志Entry不匹配，那么就拒绝接受这条日志，这个称之为一致性校验</strong></p>
<p>如果每一步都严格遵守该校验，就达成了主从日志一致的最终条件。</p>
<h4 id="2-2-3-日志复制过程"><a href="#2-2-3-日志复制过程" class="headerlink" title="2.2.3 日志复制过程"></a>2.2.3 日志复制过程</h4><p>有了这个一致性校验，我们再反过头来看下日志复制的过程。</p>
<p>在Raft协议中有两个主要的消息，一个是在第二节讲到的RequestVote RPC，用于选主投票时leader发出的消息。一个就是AppendEntries RPC，用于心跳和日志复制。对于心跳，只需要发送空内容的AppendEntries RPC就可以了，我们主要关注日志复制的消息，看看Raft是怎么操作的。</p>
<ol>
<li><p>leader接受客户端的操作请求，如“将X赋值为3”。</p>
<ul>
<li>假如leader当前的任期为term1，那么leader就会向自己本地log的最后添加一个entry，比如索引为K，内容为“term1：X赋值为3”。</li>
</ul>
</li>
<li><p>leader向集群中其他follower并行发送AppendEntries RPC消息。这个消息里面包含：</p>
<ol>
<li>这个新的entry和索引，即“term1：X赋值为3”和K。</li>
<li>前一个entry的内容和索引，比如“term1：Y赋值为2”和K-1。</li>
</ol>
</li>
<li><p>当一个follower收到一个AppendEntries RPC消息时，会查看自己本地的log中的K-1位置的entry的内容。（一致性校验）</p>
<ul>
<li><p>假如本地log中K-1位置的entry内容与接收到的来自leader的K-1的entry内容一致（下标和任期号一致），那么就将leader发来的K位置的entry保存在自己的K位置（当然要做并发控制），并返回true，告诉leader保存成功了</p>
</li>
<li><p>假如本地log中K-1位置的entry内容与接收到的来自leader的K-1的entry内容不一致（下标和任期号不一致），那么就返回false，告诉leader不一致。</p>
</li>
</ul>
</li>
<li><p>leader收到消息。</p>
<ul>
<li>如果得到的反馈为true，即某个follower保存成功了，那么这个Log Entry的复制完成。</li>
<li>否则，见下文2.2.4 特殊情况的日志复制过程。</li>
</ul>
</li>
<li><p>leader得到了超过半数的follower反馈的true消息，leader会执行这条Log Entry中的命令，并反馈客户端该命令已经提交，同时向其他follower广播这条Log Entry被commit的消息。</p>
</li>
<li><p>follower接收到Log Entry被commit的消息，执行该Log Entry中的命令。在当前日志被提交的过程中，如果leader先前的某些日志还没有被提交，则将会一同提交。</p>
</li>
</ol>
<blockquote>
<p>在Raft中，一切以leader为主。因此本地日志不是最新的话，就不能成为leader。因此在选主的时候，会进行日志比较。假如在投票阶段，一个follower收到的选主请求中，包含的日志信息比自己的要旧，那么也会拒绝给这个请求投赞成票。如何比较新旧呢？一是看任期term，一是看最后一个entry的索引号。任期大的新，任期相同的索引大的新。</p>
</blockquote>
<h4 id="2-2-4-特殊情况的日志复制过程"><a href="#2-2-4-特殊情况的日志复制过程" class="headerlink" title="2.2.4 特殊情况的日志复制过程"></a>2.2.4 特殊情况的日志复制过程</h4><p>上面说的都是日志在正常情况下的表现，没有考虑到一些异常情况。</p>
<p>即，正常情况下，leader和follower的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。但如果我们将leader或者follower崩溃的情况考虑进来，那么将可能会出现三种情况：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-49a8f26aa515f308e4feaba3cf7109e118a.png" alt=""></p>
<ol>
<li>follower缺失当前leader上存在的日志条目。如a，b</li>
<li>follower存在当前leader不存在的日志条目。如c，d(比如旧的leader仅仅将AppendEntries RPC消息发送到一部分follower就崩溃掉，然后新的当选leader的服务器恰好是没有收到该AppendEntries RPC消息的服务器)</li>
<li>或者follower即缺失当前leader上存在的日志条目，也存在当前leader不存在的日志条目。如e，f</li>
</ol>
<p>这种情况如何处理呢？</p>
<p>Raft 给出了一个方案（补丁）</p>
<blockquote>
<p>强制follower直接复制leader的日志（意味着follower中的和leader冲突的日志将被覆盖）。</p>
</blockquote>
<p>要使得follower的日志和leader进入一致状态，<strong>leader必须找到follower最后一条和leader匹配的日志，然后从这条日志开始，用leader的日志条目，覆盖follower的日志条目</strong></p>
<p>依据这个方案，上图中的 a follower和b follower从队尾直接复制即可。c follower最后一个条目将被覆盖，d follower最后2个任期为7的条目将被覆盖，e最后2个任期为4的条目将被覆盖，f 则比较厉害，需要覆盖下标为3之后的所有条目。</p>
<p>实现逻辑如下：</p>
<ul>
<li><p>leader向集群中的follower发送AppendEntries RPC，内容为最新的Log Entry和其索引K，以及前一个Log Entry及其索引K-1，这里不再赘述。</p>
</li>
<li><p>一致性检验失败，follower向leader反馈false。</p>
</li>
<li><p>leader会将K自减1，然后再次重新发AppendEntries RPC给失败的follower，直到follower返回true。那么此时的K，<strong>就是follower最后一条和leader匹配的日志的下标</strong>。</p>
</li>
</ul>
<blockquote>
<p>最坏的情况是K=0时才得到true回复，这表示follower的Log和leader完全不一致。K=0得到的回复一定是true，因为没有K-1了</p>
</blockquote>
<ul>
<li>此时leader将<strong>匹配的位置和最新的位置中间的内容</strong>都发送给follower，follower会将接收到的内容，并<strong>覆盖</strong>到对应的位置。</li>
</ul>
<blockquote>
<p>实际上leader对每个follower都维护了一个nextIndex字段，来存上述过程中一直递减的K值，描述中我没有引入nextIndex字段的概念，力求精简，以便理解。</p>
</blockquote>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/software444/article/details/89787410" target="_blank" rel="noopener" title="状态机复制 (State Machine Replication)">状态机复制 (State Machine Replication)</a><br><a href="https://www.cnblogs.com/aibabel/p/10973585.html" target="_blank" rel="noopener" title="Raft算法详解">Raft算法详解</a></p>
<p><a href="https://blog.csdn.net/shangsongwww/article/details/90287565" target="_blank" rel="noopener" title="Raft算法原理">Raft算法原理</a><br><a href="https://www.cnblogs.com/cbkj-xd/p/12152222.html" target="_blank" rel="noopener" title="Raft算法之日志复制">Raft算法之日志复制</a></p>
<p><a href="https://blog.csdn.net/snail_ren/article/details/80588370" target="_blank" rel="noopener" title="Raft协议详解（一）前言：子问题分解">Raft协议详解（一）前言：子问题分解</a></p>
<p><a href="https://www.jianshu.com/p/b28e73eefa88" target="_blank" rel="noopener" title="Raft 日志复制 Log replication">Raft 日志复制 Log replication</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/08/Redis%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%9E%8B-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/08/Redis%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%9E%8B-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/" itemprop="url">Redis事件模型/主从复制/哨兵模型/集群模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-08T22:48:41+08:00">
                2020-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/08/Redis%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%9E%8B-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/01/08/Redis事件模型-主从复制-哨兵模型-集群模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  15.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  57
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Redis的事件模型"><a href="#1-Redis的事件模型" class="headerlink" title="1. Redis的事件模型"></a>1. Redis的事件模型</h1><p>Redis服务器需要处理两类事件：文件事件和时间事件。</p>
<h2 id="1-1-文件事件"><a href="#1-1-文件事件" class="headerlink" title="1.1 文件事件"></a>1.1 文件事件</h2><p>Redis服务器通过<strong>套接字</strong>与客户端进行连接，<strong>而文件事件就是服务器对套接字操作的抽象</strong>。</p>
<p>Redis基于Reactor模式开发了网络事件处理器，由四部分组成：<strong>套接字、I/O多路复用程序、文件事件分派器以及事件处理器</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4f1ecfb38834ecc1e56da223851c70253d1.png" alt=""></p>
<ul>
<li><p>套接字：当有一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件（多个套接字就会有多个文件事件产生；</p>
<ul>
<li>事件类型有AE_READABLE和AE_WRITABLE<ul>
<li>如果客户端对套接字执行write或close操作，或者客户端对服务端的监听套接字执行connect操作，那么产生一个AE_READABLE事件。</li>
<li>如果客户端对套接字执行read操作，那么产生一个AE_WRITABLE事件。</li>
<li>如果一个事件既可读又可写，则先处理AE_READABLE事件，再处理AE_WRITABLE事件。</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O多路复用程序：负责监听多个套接字，并向文件事件分派器传送产生事件的套接字。</p>
<ul>
<li>I/O多路复用程序会将产生的所有事件的套接字放在一个队列中，以有序（sequentially）、同步（synchronously）、每次一个的方式向文件事件分派器传送套接字，只有一个套接字的事件处理完成后才会再发下一个：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-63c1d7f685fe82c9b6de8a1db0cf63425b1.png" alt=""></li>
</ul>
</li>
<li>I/O多路复用的功能是<strong>evport、epoll、kqueue和select这些常见的I/O多路复用函数</strong>的包装。Redis会在编译时自动选择系统中性能最高的I/O多路复用函数。<strong>默认实现是epoll</strong>。关于I/O多路复用可见本博客文章《详解IO多路复用和其三种模式——select/poll/epoll》<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-9e0589e377a8ff80d66c0ddef54da95b6d9.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>文件事件分派器</p>
<ul>
<li>接收I/O多路复用程序传来的套接字，根据套接字产生的事件类型，调用相应事件处理器</li>
</ul>
</li>
<li><p>文件事件处理器</p>
<ul>
<li>连接应答处理器：acceptTCPhandler<ul>
<li>对连接服务器的各个客户端进行应答</li>
<li>Redis初始化时，将监听套接字的AE_READABLE事件与该处理器关联</li>
<li>客户端连接服务器时，监听套接字产生AE_READABLE事件，触发该处理器执行。</li>
<li>服务器将会创建一个redisClient结构的实例，并添加进自身的RedisServer结构的clients链表中。</li>
<li>处理器对客户端请求进行应答，并创建客户端套接字，将客户端套接字的AE_READABLE事件与命令请求处理器关联。</li>
</ul>
</li>
<li>命令请求处理器：readQueryFromClient<ul>
<li>接收客户端传来的命令请求</li>
<li>客户端成功连接服务器后，连接应答处理器将该客户端套接字的AE_READABLE事件与命令请求处理器关联</li>
<li>客户端向服务器发送命令请求时，客户端套接字产生AE_READABLE事件</li>
<li>命令请求处理器读取命令内容，传给相关程序执行。</li>
</ul>
</li>
<li>命令回复处理器：sendReplyToClient<ul>
<li>向客户端返回命令执行结果</li>
<li>服务器有命令执行结果要传送给客户端时，将客户端套接字的AE_WRITABLE事件始终与该处理器关联</li>
<li>客户端准备好接收命令执行结果时，客户端套接字产生AE_WRITABLE事件，触发命令回复处理器执行。</li>
<li>将全部回复写入套接字后，关联解除</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-e1c7b32c5ca809d372507522a169da2effa.png" alt=""></p>
<h2 id="1-2-时间事件"><a href="#1-2-时间事件" class="headerlink" title="1.2 时间事件"></a>1.2 时间事件</h2><p>一个时间事件包括三要素：</p>
<ul>
<li>id<ul>
<li>时间时间的全局唯一表示，新事件id大于旧事件。</li>
</ul>
</li>
<li>when<ul>
<li>毫秒精度的unix时间戳，记录了时间事件的到达时间。</li>
</ul>
</li>
<li>timeproc（时间事件处理器）<ul>
<li>时间事件处理器，一个函数，时间事件到达时，服务器调用对应处理器来执行。</li>
</ul>
</li>
</ul>
<p>时间事件分为两类：</p>
<ul>
<li><p>定时事件：让一段程序在指定时间后执行一次。</p>
<ul>
<li>定时事件的处理器返回值是固定的数值，存在ae.h/AE_NOMORE中，如果一个事件的返回为该值，那么该事件在到达一次后，就会被删除</li>
</ul>
</li>
<li><p>周期事件：让一段程序每隔一段指定时间就执行一次。</p>
<ul>
<li>周期事件的处理器返回值是非ae.h/AE_NOMORE的值，这时，返回值会覆写when值。让这个时间过一段时间再次到达，以此类推。</li>
</ul>
</li>
</ul>
<p>服务器将时间事件都放在一个无序链表中（不是按时间顺序排序，而是按照ID排序，新产生的时间事件放在链表的表头），每次时间事件执行器运行时，processTimeEvents函数遍历整个链表，查找所有已经到达的时间事件，并调用相应的事件处理器。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a1b2a265b2286571ce9313c80598511599a.png" alt=""></p>
<h3 id="1-2-1-serverCron函数"><a href="#1-2-1-serverCron函数" class="headerlink" title="1.2.1 serverCron函数"></a>1.2.1 serverCron函数</h3><p>时间时间最典型的实例就是serverCron函数，它平均100毫秒执行一次，负责Redis定期对自身资源和状态的调整，包括：</p>
<ul>
<li>更新服务器的统计信息：时间，内存，数据库占用情况</li>
<li>清理过期键值对</li>
<li>关闭失效的连接</li>
<li>尝试进行aof\rdb持久化操作</li>
<li>对从服务器进行定期同步</li>
<li>集群模式下的定期同步，连接测试</li>
</ul>
<h2 id="1-3-事件调度与执行"><a href="#1-3-事件调度与执行" class="headerlink" title="1.3 事件调度与执行"></a>1.3 事件调度与执行</h2><p>aeProcessEvents函数负责何时处理文件事件、何时处理时间事件，以及花费多久的时间<br><img src="https://oscimg.oschina.net/oscnet/up-afd39c7736ceb3cb769fdfd7d588e8943d6.png" alt=""></p>
<p>将aeProcessEvents函数放置在循环中，加上初始化、清理函数，就构成了redis服务器的主函数</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-39f2148ba5785661a77fbdecd5375a765a6.png" alt=""></p>
<blockquote>
<p>文件事件和时间事件是合作关系，服务器会轮流处理这两种事件，并且处理过程中也不会抢占线程。因此时间事件的实际处理时间要比设定的时间晚一些。</p>
</blockquote>
<h1 id="2-Redis主从复制"><a href="#2-Redis主从复制" class="headerlink" title="2. Redis主从复制"></a>2. Redis主从复制</h1><p>关系数据库通常会使用一个主服务器向多个从服务器发送更新，并使用从服务器来处理所有的读请求，Redis采用了同样方法来实现自己的复制特性。</p>
<h2 id="2-1-旧版复制功能"><a href="#2-1-旧版复制功能" class="headerlink" title="2.1 旧版复制功能"></a>2.1 旧版复制功能</h2><p><strong>Redis 2.8以前采用的复制都为旧版复制，主要使用SYNC命令同步复制</strong>，SYNC存在很大的缺陷严重消耗主服务器的资源以及大量的网络连接资源。Redis 2.8之后采用PSYNC命令替代SYNC，解决完善这些缺陷，但在介绍新版复制功能之前，必须先介绍旧版复制过程，这样才能更好地形成对比。</p>
<p>复制功能有两种模式，分为<strong>同步sync</strong>与<strong>命令传播（command propagate）</strong>，两个过程配合执行才能实现Redis复制。</p>
<ul>
<li>SYNC命令同步操作<ul>
<li>通过从服务器发送到SYNC命令给 <em>主服务器</em></li>
<li><em>主服务器</em> 执行BGSAVE命令，在后台生成RDB文件，并从现在开始将所有写命令记录进缓冲区</li>
<li>并发送给 <em>从服务器</em>，同时发送缓冲区保存的所有写命令给 <em>从服务器</em>。</li>
<li><em>从服务器</em> 清空之前数据并执行解释RDB文件，然后执行缓冲区的写命令。</li>
<li>保持数据基本一致（还需要命令传播过程才能保持一致）</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-cfd59b02030b3f463de3d8e6ee7d4fa1e63.png" alt=""></li>
</ul>
</li>
<li>命令传播操作：<ul>
<li>在同步之后，<em>主服务器</em> 仍然在不断的接受写命令，这会导致好不容易一致的主从状态再次不一致。</li>
<li>通过发送让主从服务器不一致的命令（主服务器接收到的新写命令）给从服务器并执行，让主从服务器的数据库重新回到一致状态。</li>
</ul>
</li>
</ul>
<blockquote>
<p>SYNC命令的缺陷：如果因为网络问题，导致主从断开链接一段时间，那么重新同步的时候， SYNC无法做到断点继续，而是仍要清空之前数据，并重新开始复制操作。</p>
</blockquote>
<p>SYNC命令非常消耗资源，原因有三点：</p>
<ol>
<li><p>主服务器执行BGSAVE命令生成RDB文件，这个生成过程会大量消耗主服务器资源（CPU、内存和磁盘I/O资源）</p>
</li>
<li><p>主服务器需要将自己生成的RBD文件发送给从从服务器，这个发送操作会消耗主从服务器大量的网络资源（带宽与流量）</p>
</li>
<li><p>接收到RDB文件你的从服务器需要载入RDB文件，载入期间从服务器会因为阻塞而导致没办法处理命令请求。</p>
</li>
</ol>
<h2 id="2-2-新版复制功能"><a href="#2-2-新版复制功能" class="headerlink" title="2.2 新版复制功能"></a>2.2 新版复制功能</h2><p>为了解决旧版本中断线情况下SYNC低效问题，在Redis 2.8之后使用PSYNC命令代替SYNC命令执行复制同步操作，自然PSYNC具备完整重同步和部分重同步模式</p>
<ul>
<li>完整重同步：跟旧版复制基本是一致的，可以理解为“全量”复制。</li>
<li>部分重同步：在命令传播阶段，<strong>断线重复制</strong>只需要发送主服务器<strong>在断开期间执行的写命令</strong>给从服务器即可，可以理解为“增量”复制。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-6b85f71f0d739997ec61cae37975871ef3b.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="2-3-复制的实现"><a href="#2-3-复制的实现" class="headerlink" title="2.3 复制的实现"></a>2.3 复制的实现</h2><p>Redis不管是旧版还是新版，复制的实现都可以分为七个步骤，流程图如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9844df2ae892d6aa2f0eb9bbfe8e2dc0a94.png" alt=""></p>
<ol>
<li>设置主服务的地址与端口<ul>
<li>当客户端向从服务器发送一下命令时或者在配置文件中配置slaveof选项</li>
<li><code>127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379</code></li>
</ul>
</li>
<li>建立套接字连接<ul>
<li>从服务器根据设置的套接字创建连向主服务器的套接字连接<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-cea89403237d39529cf8fe68b1aac463c01.png" alt=""></li>
</ul>
</li>
<li>主服务器接收从服务器的套接字连接之后，为该套接字创建响应的客户端状态，并将此时的从服务器看做是主服务器的客户端，也就是该从服务器同时具备服务器与客户端两个身份。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-6c6228d79603ed7e8091349805b818b0477.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>发送PING命令<ul>
<li>从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送PING命令。PING命令主要有两种作用：<ol>
<li>虽然建立了套接字连接，但是还未使用过，通过发送PING命令检查套接字的读写状态是否正常</li>
<li>通过发送PING命令检查主服务器能否正常处理命令请求</li>
</ol>
</li>
<li>从服务器在发送PING命令之后将遇到以下三种情况的其中一种：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-d8186e4f60ecb5a5f4a3d94a6953b0c0f69.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>身份验证<ul>
<li>从服务器接收到主服务器返回的“PONG”回复，接下来就需要考虑身份验证的事。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-693b46071c249bb5a9ec8795a47317135ac.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>发送端口信息<ul>
<li>在身份验证步骤之后，从服务器将执行命令<code>REPLCONF listening-port &lt;port&gt;</code>，向主服务器发送从服务器的监听端口号。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-cca80560a551e9d92bb2561bc4beac8b8f7.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>同步<ul>
<li>就是上述所指的同步操作，从服务器向主服务器发送PSYNC命令，执行同步操作，值得注意的是开始只有从服务器是主服务器的客户端，但是执行同步操作之后，主服务器也会成为从服务器的客户端。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-7297be982c2757e9849b1d018d7e14a69a4.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>命令传播<ul>
<li>主从服务器就会进入命令传播阶段，主服务器只要将自己执行的写命令发送给从服务器，而从服务器只要一直执行并接收主服务器发来的写命令（上述已经介绍过，这里不过多介绍）</li>
</ul>
</li>
</ol>
<h1 id="3-Redis哨兵模型"><a href="#3-Redis哨兵模型" class="headerlink" title="3. Redis哨兵模型"></a>3. Redis哨兵模型</h1><p><strong>Sentinel(哨兵、哨岗)是Redis 的高可用性的解决方案</strong>：有一个或多个Sentinel实例组成的Sentinel系统可以<strong>监视任意多个主服务器，以及这些主服务器属下的所有从服务器</strong>，并在被监视的主服务器进入下线状态时，<strong>自动将下线主服务器属下的某个从服务器升级为主服务器</strong>，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-74b74416d8986d2bc2260d9848302bd26c5.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2e8b33cdecf632546ed70b2a91e16901f44.png" alt=""></p>
<blockquote>
<p>在替换了新的主服务器之后，如果之前下线的主服务器上线了，就会被降为新的主服务器的从服务器。</p>
</blockquote>
<h2 id="3-1-Sentinel的启动"><a href="#3-1-Sentinel的启动" class="headerlink" title="3.1 Sentinel的启动"></a>3.1 Sentinel的启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ redis-sentinel &#x2F;path&#x2F;to&#x2F;your&#x2F;sentinel.conf</span><br><span class="line">或者</span><br><span class="line">$ redis-sentinel &#x2F;path&#x2F;to&#x2F;your&#x2F;sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>

<p>这两个命令都能启动Sentinel，效果都是一样的。</p>
<p>Sentinel启动后，会有五个步骤：</p>
<ol>
<li><p><strong>初始化服务器</strong></p>
<ul>
<li><strong>Sentinel的本质是一个运行在特殊模式下的Redis服务器</strong>，因此启动时必须对其进行初始化，但是由于Sentinel与普通的服务器不同，<strong>它的初始化需要执行的操作也不同</strong>。</li>
<li>下表是Sentinel 模式下Redis服务器的主要功能的使用情况</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-d17c827a40ef959aa665c9f24c9b1bbe054.png" alt=""></li>
</ul>
</li>
<li><p><strong>使用Sentinel专用代码</strong></p>
<ul>
<li>启动Sentinel的第二步，就是将普通Redis服务器使用的代码替换成Sentinel专用的代码。</li>
<li>比如 普通Redis服务器使用 redis.h/REDIS_SERVERPORT常量作为服务端口(#define REDIS_SERVERPORT 6379),使用 redis.h/redisCommandTable 作为服务器的命令表。</li>
<li>而Sentinel使用 reids.h/REDIS_SENTINEL_PORT 常量作为服务器端口，默认26379，使用 redis.h/sentinelcmds 作为服务器的命令表</li>
</ul>
</li>
<li><p><strong>初始化Sentinel状态</strong></p>
<ul>
<li>接下来，服务器会初始化一个 sentinel.c/sentinelState 结构(简称“Sentinel状态”)，这个结构保存了服务器所有和Sentinel功能有关的状态，服务器的一般状态仍然由 redis.h/redisServer 结构保存：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct sentinelState&#123;</span><br><span class="line">	&#x2F;&#x2F; 当前纪元，用于实现故障转移</span><br><span class="line">	uint64_t current_epoch;</span><br><span class="line">	&#x2F;&#x2F; 保存了所有被这个 Sentinel监视的主服务器</span><br><span class="line">	&#x2F;&#x2F; 字典的键是主服务器的名字</span><br><span class="line">	&#x2F;&#x2F; 字典的值是一个指向 sentinelRedisInstance 结构的指针</span><br><span class="line">	dict *masters;</span><br><span class="line">	&#x2F;&#x2F; 是否进入了 TILT 模式</span><br><span class="line">	int tilt;</span><br><span class="line">	&#x2F;&#x2F; 目前正在执行的脚本数量</span><br><span class="line">	int running_scripts;</span><br><span class="line">	&#x2F;&#x2F; 进入 TILT 模式的时间</span><br><span class="line">	mstime_t tilt_start_time;</span><br><span class="line">	&#x2F;&#x2F; 最后一次执行事件处理器的时间</span><br><span class="line">	mstime_t previous_time;</span><br><span class="line">	&#x2F;&#x2F; 一个 FIFO 队列，包含了所有需要执行的用户脚本</span><br><span class="line">	list *scripts_queue;</span><br><span class="line">&#125;sentinel;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>初始化Sentinel状态的 masters 属性</strong></p>
<ul>
<li><p>接下来要做的是将sentinel状态的 masters 属性进行初始化，上面已经说过了，masters 里面保存的是所有被监视的主服务器的信息。master属性是字典，键是主服务器的名字，值是一个指向 sentinelRedisInstance 结构的指针。</p>
</li>
<li><p>我们先介绍一下 sentinelRedisInstance 结构(简称“实例结构”)，这个结构代表着一个被Sentinel监视的Redis服务器实例，可以是主服务器、从服务器或者另外一个Sentinel.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">ypedef struct sentinelRedisInstance &#123;</span><br><span class="line">	&#x2F;&#x2F; 标识值，记录了当前Redis实例的类型和状态</span><br><span class="line">	int flags;      &#x2F;* See SRI_... defines *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 实例的名字</span><br><span class="line">	&#x2F;&#x2F; 主节点的名字由用户在配置文件中设置</span><br><span class="line">	&#x2F;&#x2F; 从节点以及Sentinel节点的名字由Sentinel自动设置，格式为：ip:port</span><br><span class="line">	char *name;     &#x2F;* Master name from the point of view of this sentinel. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;实例的运行 ID</span><br><span class="line">	char *runid;    &#x2F;* Run ID of this instance, or unique ID if is a Sentinel.*&#x2F;</span><br><span class="line">	&#x2F;&#x2F;配置纪元，用于实现故障转移</span><br><span class="line">	uint64_t config_epoch;  &#x2F;* Configuration epoch. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;实例的地址:ip和port</span><br><span class="line">	sentinelAddr *addr; &#x2F;* Master host. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;实例的连接，有可能是被Sentinel共享的</span><br><span class="line">	instanceLink *link; &#x2F;* Link to the instance, may be shared for Sentinels. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 最近一次通过 Pub&#x2F;Sub 发送信息的时间</span><br><span class="line">	mstime_t last_pub_time;   &#x2F;* Last time we sent hello via Pub&#x2F;Sub. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 只有被Sentinel实例使用</span><br><span class="line">	&#x2F;&#x2F; 最近一次接收到从Sentinel发送来hello的时间</span><br><span class="line">	mstime_t last_hello_time; &#x2F;* Only used if SRI_SENTINEL is set. Last time</span><br><span class="line">								 we received a hello from this Sentinel</span><br><span class="line">								 via Pub&#x2F;Sub. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 最近一次回复SENTINEL is-master-down的时间                             </span><br><span class="line">	mstime_t last_master_down_reply_time; &#x2F;* Time of last reply to</span><br><span class="line">											 SENTINEL is-master-down command. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 实例被判断为主观下线的时间                                         </span><br><span class="line">	mstime_t s_down_since_time; &#x2F;* Subjectively down since time. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 实例被判断为客观下线的时间</span><br><span class="line">	mstime_t o_down_since_time; &#x2F;* Objectively down since time. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down）</span><br><span class="line">	mstime_t down_after_period; &#x2F;* Consider it down after that period. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 从实例获取INFO命令回复的时间</span><br><span class="line">	mstime_t info_refresh;  &#x2F;* Time at which we received INFO output from it. *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Role and the first time we observed it.</span><br><span class="line">	 * This is useful in order to delay replacing what the instance reports</span><br><span class="line">	 * with our own configuration. We need to always wait some time in order</span><br><span class="line">	 * to give a chance to the leader to report the new configuration before</span><br><span class="line">	 * we do silly things. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 实例的角色 </span><br><span class="line">	int role_reported;</span><br><span class="line">	&#x2F;&#x2F; 角色更新的时间</span><br><span class="line">	mstime_t role_reported_time;</span><br><span class="line">	&#x2F;&#x2F; 最近一次从节点的主节点地址变更的时间</span><br><span class="line">	mstime_t slave_conf_change_time; &#x2F;* Last time slave master addr changed. *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Master specific. *&#x2F;</span><br><span class="line">	 &#x2F;*----------------------------------主节点特有的属性----------------------------------*&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 其他监控相同主节点的Sentinel</span><br><span class="line">	dict *sentinels;    &#x2F;* Other sentinels monitoring the same master. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 如果当前实例是主节点，那么slaves保存着该主节点的所有从节点实例</span><br><span class="line">	&#x2F;&#x2F; 键是从节点命令，值是从节点服务器对应的sentinelRedisInstance</span><br><span class="line">	dict *slaves;       &#x2F;* Slaves for this master instance. *&#x2F;</span><br><span class="line">	  &#x2F;&#x2F; 判定该主节点客观下线（objectively down）的投票数</span><br><span class="line">	&#x2F;&#x2F; 由SENTINEL monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;配置</span><br><span class="line">	unsigned int quorum;&#x2F;* Number of sentinels that need to agree on failure. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; SENTINEL parallel-syncs &lt;master-name&gt; &lt;number&gt; 选项的值</span><br><span class="line">	&#x2F;&#x2F; 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量</span><br><span class="line">	int parallel_syncs; &#x2F;* How many slaves to reconfigure at same time. *&#x2F;</span><br><span class="line">	  &#x2F;&#x2F; 连接主节点和从节点的认证密码</span><br><span class="line">	char *auth_pass;    &#x2F;* Password to use for AUTH against master &amp; slaves. *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Slave specific. *&#x2F;</span><br><span class="line">	&#x2F;*----------------------------------从节点特有的属性----------------------------------*&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 从节点复制操作断开时间</span><br><span class="line">	mstime_t master_link_down_time; &#x2F;* Slave replication link down time. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 按照INFO命令输出的从节点优先级</span><br><span class="line">	int slave_priority; &#x2F;* Slave priority according to its INFO output. *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 故障转移时，从节点发送SLAVEOF &lt;new&gt;命令的时间</span><br><span class="line">	mstime_t slave_reconf_sent_time; &#x2F;* Time at which we sent SLAVE OF &lt;new&gt; *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; 如果当前实例是从节点，那么保存该从节点连接的主节点实例</span><br><span class="line">	struct sentinelRedisInstance *master; &#x2F;* Master instance if it&#39;s slave. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; INFO命令的回复中记录的主节点的IP</span><br><span class="line">	char *slave_master_host;    &#x2F;* Master host as reported by INFO *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; INFO命令的回复中记录的主节点的port</span><br><span class="line">	int slave_master_port;      &#x2F;* Master port as reported by INFO *&#x2F;</span><br><span class="line">	 &#x2F;&#x2F; INFO命令的回复中记录的主从服务器连接的状态</span><br><span class="line">	int slave_master_link_status; &#x2F;* Master link status as reported by INFO *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 从节点复制偏移量</span><br><span class="line">	unsigned long long slave_repl_offset; &#x2F;* Slave replication offset. *&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;* Failover *&#x2F;</span><br><span class="line">	 &#x2F;*----------------------------------故障转移的属性----------------------------------*&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 如果这是一个主节点实例，那么leader保存的是执行故障转移的Sentinel的runid</span><br><span class="line">	&#x2F;&#x2F; 如果这是一个Sentinel实例，那么leader保存的是当前这个Sentinel实例选举出来的领头的runid</span><br><span class="line">	char *leader;       &#x2F;* If this is a master instance, this is the runid of</span><br><span class="line">						   the Sentinel that should perform the failover. If</span><br><span class="line">						   this is a Sentinel, this is the runid of the Sentinel</span><br><span class="line">						   that this Sentinel voted as leader. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; leader字段的纪元                       </span><br><span class="line">	uint64_t leader_epoch; &#x2F;* Epoch of the &#39;leader&#39; field. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 当前执行故障转移的纪元</span><br><span class="line">	uint64_t failover_epoch; &#x2F;* Epoch of the currently started failover. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 故障转移操作的状态</span><br><span class="line">	int failover_state; &#x2F;* See SENTINEL_FAILOVER_STATE_* defines. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 故障转移操作状态改变的时间</span><br><span class="line">	mstime_t failover_state_change_time;</span><br><span class="line">	&#x2F;&#x2F; 最近一次故障转移尝试开始的时间</span><br><span class="line">	mstime_t failover_start_time;   &#x2F;* Last failover attempt start time. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F;  更新故障转移状态的最大超时时间</span><br><span class="line">	mstime_t failover_timeout;      &#x2F;* Max time to refresh failover state. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 记录故障转移延迟的时间</span><br><span class="line">	mstime_t failover_delay_logged; &#x2F;* For what failover_start_time value we</span><br><span class="line">									   logged the failover delay. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 晋升为新主节点的从节点实例                                   </span><br><span class="line">	struct sentinelRedisInstance *promoted_slave; &#x2F;* Promoted slave instance. *&#x2F;</span><br><span class="line">	&#x2F;* Scripts executed to notify admin or reconfigure clients: when they</span><br><span class="line">	 * are set to NULL no script is executed. *&#x2F;</span><br><span class="line">	&#x2F;&#x2F; 通知admin的可执行脚本的地址，如果设置为空，则没有执行的脚本 </span><br><span class="line">	char *notification_script;</span><br><span class="line">	 &#x2F;&#x2F; 通知配置的client的可执行脚本的地址，如果设置为空，则没有执行的脚本</span><br><span class="line">	char *client_reconfig_script;</span><br><span class="line">	&#x2F;&#x2F; 缓存INFO命令的输出 </span><br><span class="line">	sds info; &#x2F;* cached INFO output *&#x2F;</span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure></li>
<li><p>其中的 addr 属性是一个指向 sentinel.c/sentinelAddr 结构的指针，这个结构保存实例的IP地址和端口号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct sentinelAddr&#123;</span><br><span class="line">	char *p;</span><br><span class="line">	int port;</span><br><span class="line">&#125;sentinelAddr;</span><br></pre></td></tr></table></figure></li>
<li><p>对Sentinel 状态的初始化将引发对 masters 字典的初始化,而 masters 字典的初始化是根据被载入的Sentinel配置文件来进行的。<strong>假设我们有master1和master2，由如下图1的配置文件导入</strong>：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-63050f2a3d66283638dc1c17d2f1ec19778.png" alt=""></li>
</ul>
</li>
<li><p>那么我们得到两个sentinelRedisInstance：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-f7d42df36db19bd7fa4c53b9e289381dc62.png" alt=""></li>
<li><img src="https://oscimg.oschina.net/oscnet/up-238ac368f60e323211e08ebaeb8e7308450.png" alt=""></li>
</ul>
</li>
<li><p>最终sentinelRedisInstance为：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-235ef5d9525c74626220b099acbff598f27.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>创建连向主服务器的网络连接</p>
<ul>
<li>这是最后一步啦，这一步是创建连向被监视主服务器的网络连接，<strong>Sentinel将成为主服务器的客户端</strong>，可以向主服务器发送命令，并从命令回复中获取相关的信息。</li>
<li>每个被Sentinel监视的主服务器，Sentinel会创建两个连向主服务器的异步网络连接：<ol>
<li>命令连接，用于向主服务器发送命令，并接收命令回复</li>
<li>订阅连接，用于订阅主服务器的<code>__sentinel__:hello</code>频道</li>
</ol>
</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-4dd23054ec9ad51b2c753001abd3bbe46a5.png" alt=""><h2 id="3-2-Sentinel与服务器的交互"><a href="#3-2-Sentinel与服务器的交互" class="headerlink" title="3.2 Sentinel与服务器的交互"></a>3.2 Sentinel与服务器的交互</h2></li>
</ul>
</li>
</ol>
<p>Sentinel作为一个监视Redis服务器的监控系统，必然需要有如下的权利或者义务：</p>
<ol>
<li><p>要能掌握被自己监视的主服务器和其从服务器的状态信息</p>
<ul>
<li><strong>INFO命令</strong>：每十秒一次，通过<strong>命令链接</strong>向被监视的主服务和从服务器发送<strong>INFO命令</strong>。分析主服务器的应答得到主服务器的状态信息。</li>
</ul>
</li>
<li><p>要有为“与自己监视了相同服务器的其他Sentinel”感知到自己提供便利的义务。</p>
<ul>
<li><strong>广播频道消息</strong>：Sentinel每两秒一次，通过<strong>命令链接</strong>向所有被自己监视的主服务器和从服务器发送<strong>PUBLISH命令</strong>，发布自己的一些状态信息到对应主服务器的<strong>sentinel</strong>:hello频道，以便让其他监视了同一服务器的Sentinel（当然这些Sentinel也订阅了该服务器的<strong>sentinel</strong>:hello频道）感知到自己的存在，宣誓主权。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-5cc7e6782bf95df108607d7a9179b94f625.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p>要能感知到“与自己监视了同一服务器的其他Sentinel”的状态信息。</p>
<ul>
<li><strong>接收频道消息</strong>：Sentinel在与主服务器创建订阅链接后就会通过订阅命令来订阅主服务器的<strong>sentinel</strong>:hello频道。通过<strong>订阅链接</strong>，Sentinel能接收到该频道上其他Sentinel发布的他们各自的状态信息。从而感知到他们的存在。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-5b9e81f3a2d2692d744f2dd17340e377a4a.png" alt=""></li>
</ul>
</li>
<li><strong>创建Sentinel之间的链接</strong>：Sentinel A 感知到另一个Sentinel B 时，如果是第一次感知到，那么A会创建连向B的命令链接。当然B也会有一个发现A的过程，所以对于监视相同服务器的Sentinel来说，他们是这样相互关联的。<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-e15a80cc3eaec80234386903b967ca94f1d.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>归纳完毕，现在我们来一一展开介绍：</p>
<h3 id="3-2-1-INFO命令"><a href="#3-2-1-INFO命令" class="headerlink" title="3.2.1 INFO命令"></a>3.2.1 INFO命令</h3><p>假设有个主服务器和三个从服务器。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-cc3509fe121399c911c2c76c9141eae43f0.png" alt=""></p>
<p>Sentinel 默认每十秒一次，通过命令连接向被监视的主服务器发送 INFO 命令，得到如下信息：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bc6314d42194e83e8c3024d39401f1ba78e.png" alt=""></p>
<ul>
<li>关于服务器本身的信息<ul>
<li>包括 run_id 域记录的服务器运行ID，以及 role 域记录的服务器角色</li>
</ul>
</li>
<li>关于主服务器属下的所有从服务器信息<ul>
<li>每个从服务器都由一个“slave”字符串开头的行记录，每行的 ip= 域记录了从服务器的IP地址, port= 域记录了从服务器的端口号。根据这些IP地址和端口号，Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器。</li>
</ul>
</li>
</ul>
<p>根据 run_id 域和 role 域的信息，Sentinel将对主服务器的实例结构（sentinelRedisInstance）进行更新。而主服务器返回的从服务器信息，将会被用于更新主服务器实例结构（sentinelRedisInstance）的 slaves 字典(记录了属下从服务器的名单，key为ip:port格式，值指向从服务器的sentinelRedisInstance实例)。</p>
<p>Sentinel 分析 INFO 命令中包含的从服务器信息时，会检查这个从服务器实例结构(sentinelRedisInstance）是否已经存在于主服务器的 slaves 字典： 如果存在，就对从服务器的实例结构进行更新，如果不存在(表明这个从服务器是新发现的从服务器)，Sentinel会在 slaves 字典中为这个从服务器创建一个新的实例结构。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-39a3a3f5b3381711f3063c1719f4ab03f89.png" alt=""></p>
<p>当Sentinel发现主服务器有新的服务器出现时，除了会为这个新从服务器创建相应的实例结构之外，<strong>还会创建连接到从服务器的命令连接和订阅连接</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0301ec71756c260aaae4f67a696c939939c.png" alt=""></p>
<p>创建了命令连接之后，每10秒一次向从服务器发送 INFO 命令，依次来维护从服务器的实例结构(sentinelRedisInstance）的状态。</p>
<blockquote>
<p>主服务器实例结构的 flags 值为 SRI_MASTER,从服务器是 SRI_SLAVE</p>
</blockquote>
<h3 id="3-2-2-广播频道消息"><a href="#3-2-2-广播频道消息" class="headerlink" title="3.2.2 广播频道消息"></a>3.2.2 广播频道消息</h3><p>Sentinel会<strong>每两秒一次</strong>，通过<strong>命令连接</strong>向所有被监视的主服务器和从服务器发送以下格式的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,</span><br><span class="line">	&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>这条命令就表示向服务器的 __sentinel__:hello 频道发送一条信息，信息由一下部分组成：</p>
<ul>
<li>以 s_ 开头的参数记录Sentinel本身的信息</li>
<li>以 m_ 开头的参数则是该频道所属的主服务器的信息，当然如果监视的是从服务器，这个信息表示的就是所属的从服务器的信息</li>
<li>具体含义如下图</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-0554962e101651acacc73f8c04897f3d7ef.png" alt=""></li>
</ul>
<h3 id="3-2-3-接收频道消息"><a href="#3-2-3-接收频道消息" class="headerlink" title="3.2.3 接收频道消息"></a>3.2.3 接收频道消息</h3><p>在建立起订阅连接之后，Sentinel会通过这个连接，向服务器发送<code>SUBSCRIBE __sentinel__:hello</code>命令，也就是订阅这个频道，这个订阅关系会一直持续到Sentinel与服务器的连接断开之后。</p>
<p>对于监视同一服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他的Sentinel接收到，并用于更新其他Sentinel对发送信息Sentinel的认知，和被用于更新其他Sentinel对被监视服务器的认知。</p>
<p>假如该<strong>Sentinel A</strong>从其监控的<strong>主服务器M</strong>的 <code>__sentinel__:hello</code>频道中，接收到其他<strong>Sentinel B</strong>发来的<code>&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;</code>格式的信息后，Sentinel A会从信息中分析出以下信息：</p>
<ul>
<li>与Sentinel相关的参数：Sentinel B的IP、port、run_id、配置纪元</li>
<li>与主服务器相关参数：Sentinel B 正在监视的这个主服务器（也就是主服务器M）的名字、IP、port、配置纪元</li>
</ul>
<p>服务器实例结构（sentinelRedisInstance）中除了slave字典外，还有一个sentinels字典，存放着其他共同监控着这个主服务器的sentinels的状态信息。<strong>这个字典的键是Sentinel的名字，格式：ip:port。值是对应Sentinel的实例结构(还是sentinelRedisInstance结构)。</strong></p>
<p>根据之前那些主服务器参数，Sentinel A 会在自己的Sentinel状态（sentinelState）的 masters 字典中查找相应的主服务器实例结构（sentinelRedisInstance），然后根据Sentinel参数，检查主服务器实例结构的 sentinels 字典中，Sentinel B的实例结构是否存在：</p>
<ul>
<li>存在，就对Sentinel B的实例结构进行更新</li>
<li>存在，说明Sentinel B是才开始监视主服务器的新Sentinel，Sentinel A 会为Sentinel B创建一个新的实例结构，并将这个结构添加到 sentinels 字典里面</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-084760de95dd05ca210595633b1328d141f.png" alt=""></p>
<h3 id="3-2-4-创建Sentinel之间的链接"><a href="#3-2-4-创建Sentinel之间的链接" class="headerlink" title="3.2.4 创建Sentinel之间的链接"></a>3.2.4 创建Sentinel之间的链接</h3><p>当Sentinel通过频道信息发现了一个新的Sentinel时，它不仅会为新的Sentinel在 sentinels 字典中创建相应的实例结构，还会创建一个连向新Sentinel的命令连接。</p>
<p>新的Sentinel同样会创建连向这个Sentinel的命令连接，最终监视同一主服务器的多个Sentinel将形成相互连接的网络：SentinelA有连向SentinelB的命令连接，SentinelB也有连向SentinelA的命令连接。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e15a80cc3eaec80234386903b967ca94f1d.png" alt=""></p>
<blockquote>
<p>Sentinel之间不会创建订阅连接</p>
</blockquote>
<h2 id="3-3-监控下线和故障转移"><a href="#3-3-监控下线和故障转移" class="headerlink" title="3.3 监控下线和故障转移"></a>3.3 监控下线和故障转移</h2><p>了解了Sentinel与服务器/其他Sentinel的交互方式后，就可以来着手解决实际问题了，Sentinel的使命主要有两点：</p>
<ul>
<li>监控下线</li>
<li>选举领头sentinel</li>
<li>故障转移</li>
</ul>
<h3 id="3-3-1-监控下线"><a href="#3-3-1-监控下线" class="headerlink" title="3.3.1 监控下线"></a>3.3.1 监控下线</h3><h4 id="3-3-1-1-检测主观下线状态"><a href="#3-3-1-1-检测主观下线状态" class="headerlink" title="3.3.1.1 检测主观下线状态"></a>3.3.1.1 检测主观下线状态</h4><p>主观下线状态，即单个sentinel认为某个<strong>主服务器/从服务器/sentinel</strong>下线了，至于是不是真的已经下线，则不一定。</p>
<ul>
<li>默认情况下，Sentinel会以<strong>每秒一次</strong>的频率向所有与它创建了<strong>命令连接</strong>的实例(包括主服务器、从服务器、其他Sentinel在内)发送 <code>PING</code> 命令，并通过实例返回的 <code>PING</code> 命令回复来判断实例是否在线。</li>
<li>对 <code>PING</code> 命令的回复，Redis只认两种含义：<ul>
<li>有效回复：实例返回 +PONG 、 -LOADING 、-MASTERDOWN 三种其中一种</li>
<li>无效回复，除了上面三种之外的其它回复，或者在指定时限内没有返回任何回复</li>
</ul>
</li>
<li>Sentinel配置文件中的 down-after-millseconds 选项指定了Sentinel判断实例进入主观下线所需的时间长度：如果一个实例在 down-after-millseconds 毫秒内，连续向Sentinel返回无效回复，那么Sentinel会修改这个实例所对应的实例结构，在结构的 flags 属性中打上 <code>SRI_S_DOWN</code> 标识，用于表示这个实例已经进入主观下线状态。（也就是我认为你已经下线了）</li>
</ul>
<blockquote>
<p>主观下线时长选项，即 down-after-millseconds 的值，不仅会被Sentinel用于判断其监控的主服务器的主观下线状态，还会被用于判断该主服务器属下的所有从服务器，以及所有同样监视这个主服务器的其他Sentinel的主观下线状态。</p>
</blockquote>
<blockquote>
<p>多个Sentinel设置的主观下线时长可能不同，对于监视同一个主服务器的多个Sentinel来说，这些Sentinel设置的 down-after-milliseconds 选项的值可能不同，因此，当一个Sentinel将主服务器判断为主观下线时，其它Sentinel可能任然会认为主服务器处于在线状态。</p>
</blockquote>
<h4 id="3-3-1-2-检测客观下线状态"><a href="#3-3-1-2-检测客观下线状态" class="headerlink" title="3.3.1.2 检测客观下线状态"></a>3.3.1.2 检测客观下线状态</h4><p>客观下线状态，即经过确认后，可断定为事实上确实下线了。</p>
<p>当Sentinel将一个主服务器判断为主观下线之后，为确定这个服务器是否真的下线，它会<strong>向同样监视这个主服务器的其它Sentinel进行询问</strong>，当接收到足够数量的已下线判断之后，Sentinel就会将从服务器判定为客观下线，并对主服务器进行故障转移操作。</p>
<ul>
<li>发送 <code>SENTINEL is-master-down-by-addr</code> 命令<ul>
<li>entinel会发送下面的命令询问其它Sentinel是否同意主服务器下线：</li>
<li><code>SENTINEL is-master-down-by-addr &lt;ip&gt; &lt;port&gt; &lt;current_epoch&gt; &lt;runid&gt;</code></li>
<li><img src="https://oscimg.oschina.net/oscnet/up-1bff3ef7742eb8463677f3e0c00fb30240d.png" alt=""></li>
</ul>
</li>
<li>接收 <code>SENTINEL is-master-down-by-addr</code> 命令<ul>
<li>当一个Sentinel(目标Sentinel)接收到另外一个Sentinel(源Sentinel)发来的 <code>SENTINEL is-master-by-addr</code>命令时，目标Sentinel会分析并取出命令请求中包含的各个参数，并根据其中的IP和port，判断主服务器是否已经下线，然后向源Sentinel返回一个包含三个参数的 Multi Bulk 回复作为这个命令的回复。这三个参数分别是：<ol>
<li><strong><down_state></strong>：返回目标Sentinel对主服务器的检查结果，1表示主服务器已下线，0表示主服务器未下线</li>
<li><strong><leader_runid></strong>：可以是 * 符号或者目标Sentinel的局部领头Sentinel的运行ID，*表示命令仅仅用于检测主服务器的下线状态，而局部领头Sentinel的运行ID则用于选举领头Sentinel</li>
<li><strong><leader_epoch></strong>：目标Sentinel的局部领头Sentinel的配置纪元，用于选举领头Sentinel。仅在 leader_runid 值不为 * 时有效，如果其值为 * ,这个参数总为0</li>
</ol>
</li>
</ul>
</li>
<li>接收 <code>SENTINEL is-master-down-by-addr</code> 命令之后<ul>
<li>根据其他Sentinel发回的 <code>SENTINEL is-master-down-by-addr</code>回复，Sentinel会统计反馈了“同意这个主服务器已经下线”这个信息的sentinel数量。</li>
<li>当这个值达到配置指定的判断客观下线所需的数量时(即 quorum 属性的值)，Sentinel会将主服务器实例结构中（sentinelRedisInstance） flags 属性的 SRI_O_DOWN 标识打开，标识主服务器已经进入客观下线状态。</li>
</ul>
</li>
</ul>
<h3 id="3-3-2-选举领头sentinel"><a href="#3-3-2-选举领头sentinel" class="headerlink" title="3.3.2 选举领头sentinel"></a>3.3.2 选举领头sentinel</h3><p>当一个Master服务器客观下线后，<strong>监控这个Master服务器的所有Sentinel</strong>将会选举出一个领头Sentinel。并由领头Sentinel对客观下线的Master进行故障转移。</p>
<p>选举领头Sentinel的规则和方法:</p>
<ol>
<li><p>所有监控客观下线Master的Sentinel都有可能成为领头Sentinel。每次进行领头Sentinel选举之后，不论是否选举成功，<strong>所有Sentinel的配置纪元（configuration epoch）的值都会自动增加一次</strong>。</p>
</li>
<li><p>在一个配置纪元里面，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头Sentinel一旦设置，<strong>在这个配置纪元里面将不能再更改</strong>。</p>
</li>
<li><p>监视Master客观下线的所有在线Sentinel都有要求其它Sentinel将自己设置为局部领头Sentinel的机会。</p>
</li>
<li><p>当一个Sentinel（源Sentinel）向另一个Sentinel（目标Sentinel）发送<code>SENTINEL is-master-down-by-addr</code>命令，<strong>并且命令中的runid参数不是“*”符号而是当前Sentinel的运行ID时，这表示当前Sentinel要求目标Sentinel将自己设置为领头Sentinel</strong>。</p>
</li>
<li><p>Sentinel设置局部领头Sentinel的规则是<strong>先到先得</strong>。即最先向目标Sentinel发送设置要求的Sentinel将会成为局部领头Sentinel，之后<strong>接受到的请求都会被拒绝</strong>。</p>
</li>
<li><p>目标Sentinel接收到SENTINEL is-master-down-by-addr命令后，将向源Sentinel返回一条命令回复，<strong>回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元</strong>。</p>
</li>
<li><p>源Sentinel在接收到目标Sentinel返回的命令回复之后，会检查回复中leader_epoch参数的值和自己的配置纪元是否相同，如果相同的话，那么源Sentinel继续取出回复中的leader_runid参数，如果leader_runid参数的值和源Sentinel的运行ID一直，<strong>那么表示目标Sentinel将源Sentinel设置成了局部领头Sentinel，记录下来</strong>。</p>
</li>
<li><p>记录之后，如果有某个Sentinel发现自己已经被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel就会成为领头Sentinel。</p>
</li>
<li><p>领头Sentinel的产生需要半数以上的Sentinel支持，并且每个Sentinel在每个配置纪元里面只能设置一次局部Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel。</p>
</li>
<li><p>如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后<strong>再次进行选举</strong>，直到选出领头Sentinel为止，（所以建议哨兵设置奇数个，且数量不小于3）。</p>
</li>
</ol>
<h3 id="3-3-3-故障转移"><a href="#3-3-3-故障转移" class="headerlink" title="3.3.3 故障转移"></a>3.3.3 故障转移</h3><p>接收到<code>SENTINEL is-master-down-by-addr</code>命令回复的源Sentinel可以统计出有多少个Sentinel将自己设置成局部领头Sentinel。如果超过半数，则当前Sentinel就会被选为领头Sentinel并进行故障转移。</p>
<p>故障转移包括以下三步：</p>
<ol>
<li>在已下线的Master主机下面挑选一个他的Slave服务器，并将其转换为主服务器。</li>
<li>让<strong>其余</strong>所有Slave服务器复制新的Master服务器。</li>
<li>让已下线的Master服务器变成新的Master服务器的Slave。当已下线的服务器再次上线后将复新的Master的数据。</li>
</ol>
<h4 id="3-3-3-1-选举新的主服务器的过程"><a href="#3-3-3-1-选举新的主服务器的过程" class="headerlink" title="3.3.3.1 选举新的主服务器的过程"></a>3.3.3.1 选举新的主服务器的过程</h4><p>领头Sentinel会在所有Slave中选出新的Master，发送<strong>SLAVEOF no one</strong>命令，将这个服务器确定为主服务器。</p>
<p>领头Sentinel会将已下线Master的所有从服务器保存在一个列表中，按照以下规则，一项一项进行<strong>过滤</strong>。</p>
<ol>
<li><p>删除列表中所有处于下线或者短线状态的Slave。（保证剩下都是在线的）</p>
</li>
<li><p>删除列表中所有最近5s内没有回复过领头Sentinel的INFO命令的Slave。（保证剩下都是近期成功通信过的）</p>
</li>
<li><p>删除所有与<strong>下线Master</strong>连接断开超过down-after-milliseconds * 10毫秒的Slave。（过滤掉过早的和下线Master断开连接的，这样可以保证剩下的Slave，数据都比较新）</p>
</li>
<li><p>领头Sentinel将根据Slave优先级，对列表中剩余的Slave进行排序，并选出其中优先级最高的Slave。</p>
</li>
<li><p>如果有多个具有相同优先级的Slave，那么领头Sentinel将按照Slave复制偏移量，选出其中偏移量最大的Slave。（复制偏移量的slave就是保存的最新数据的slave）</p>
</li>
<li><p>如果有多个优先级最高，偏移量最大的Slave，那么根据运行ID最小原则选出新的Master。</p>
</li>
</ol>
<p>确定新的Master之后，领头Sentinel会以<strong>每秒一次</strong>的频率向新的Master发送INFO命令，当得到确切的回复：role由slave变为master之后，当前服务器顺利升级为Master服务器。</p>
<h4 id="3-3-3-2-修改从服务器的复制目标"><a href="#3-3-3-2-修改从服务器的复制目标" class="headerlink" title="3.3.3.2 修改从服务器的复制目标"></a>3.3.3.2 修改从服务器的复制目标</h4><p>选出新的Master服务器后，领头Sentinel会向<strong>下线Master的剩余Slave</strong>发送SLAVEOF命令，让它们复制新的Master。</p>
<h4 id="3-3-3-3-将旧的Master变成Slave"><a href="#3-3-3-3-将旧的Master变成Slave" class="headerlink" title="3.3.3.3 将旧的Master变成Slave"></a>3.3.3.3 将旧的Master变成Slave</h4><p>当已下线的Master重新上线后，领头Sentinel会向此服务器发送SLAVEOF命令，将当前服务器变成新的Master的Slave。</p>
<h1 id="4-集群模式"><a href="#4-集群模式" class="headerlink" title="4. 集群模式"></a>4. 集群模式</h1><p>Redis集群是Redis的分布式数据库方案，通过分片来进行数据共享，并提供复制和故障转移功能。集群为Redis提供了更加便利的水平拓展能力，是现代企业级Redis实现高吞吐高并发的重要实现。</p>
<ul>
<li>集群模式和主从模式的区别：<ul>
<li>主从模式<ul>
<li>指的是针对多台redis实例时候，只存在一台主服务器master，提供读写的功能，同时存在依附在这台主服务器的从服务器slaver，只提供读服务。</li>
<li>主从作用是：读写分离，分散访问量，提高访问可读性，同时保证数据的冗余和备份。</li>
</ul>
</li>
<li>集群模式<ul>
<li>指的是针对多个redis实例，去中心化，去中间件，集群中的每个节点都是平等的关系，都是对等的。</li>
<li>集群的作用是：实现扩容、分摊压力、无中心配置相对简单。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-1-节点"><a href="#4-1-节点" class="headerlink" title="4.1 节点"></a>4.1 节点</h2><p>节点，<strong>指的就是我们之前说的Redis服务器</strong>。</p>
<p>一个Redis 集群通常由多个节点组成，在刚开始的时候，每个节点都是独立的，只处于只包含自己的集群中（也就是之前我们说到的单机模式），当要组成一个真正可工作的集群时，就需要将这些独立的节点连接起来，构建成一个包含多个节点的集群。</p>
<p>如何连接各个节点？使用<code>CLUSTER MEET</code>命令</p>
<p><code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code></p>
<p>向一个节点发送<code>CLUSTER MEET</code>命令，可以让节点与ip和port所指定的节点进行握手，握手成功，节点就会将ip和port指定的节点添加到当前的集群中。</p>
<blockquote>
<p>节点A向节点B发送<code>CLUSTER MEET</code>命令，那么B将会加入A的集群中。反之，A加入B的集群中。</p>
</blockquote>
<p>在启动时，服务器会根据 <code>cluster-enabled</code> 配置选项来决定是否开启集群模式。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6885d13841ad33d7783816ac2e8c63736dd.png" alt=""></p>
<h3 id="4-2-集群数据结构"><a href="#4-2-集群数据结构" class="headerlink" title="4.2  集群数据结构"></a>4.2  集群数据结构</h3><p>Redis使用clusterNode结构来保存一个节点的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一个节点的当前状态</span><br><span class="line">struct clusterNode&#123;    </span><br><span class="line">    &#x2F;&#x2F; 创建节点的时间    </span><br><span class="line">    mstime_t ctime;    </span><br><span class="line">    &#x2F;&#x2F; 节点的名字，由40个16进制字符组成    </span><br><span class="line">    char name[REDIS_CLUSTER_NAMELEN];    </span><br><span class="line">    &#x2F;&#x2F; 节点标识    </span><br><span class="line">    int flags;    </span><br><span class="line">    &#x2F;&#x2F; 节点当前的配置纪元，用于实现故障转移    </span><br><span class="line">    uint64_t configEpoch;    </span><br><span class="line">    &#x2F;&#x2F; 节点的ip地址    </span><br><span class="line">    char ip[REDIS_IP_STR_LEN];    </span><br><span class="line">    &#x2F;&#x2F; 节点的端口号    </span><br><span class="line">    int port；    </span><br><span class="line">    &#x2F;&#x2F; 保存连接节点所需的有关信息   </span><br><span class="line">    clusterLink *link；    </span><br><span class="line">    &#x2F;&#x2F;……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>clusterNode 结构的 link 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterLink &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 连接的创建时间</span><br><span class="line">    mstime_t ctime;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TCP 套接字描述符</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 输出缓冲区，保存着等待发送给其他节点的消息（message）。</span><br><span class="line">    sds sndbuf;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 输入缓冲区，保存着从其他节点接收到的消息。</span><br><span class="line">    sds rcvbuf;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 与这个连接相关联的节点，如果没有的话就为 NULL</span><br><span class="line">    struct clusterNode *node;</span><br><span class="line"></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>
<p>最后，每个节点都保存着一个clusterState结构，这个结构记录了<strong>在当前节点的视角下集群目前所处的状态</strong>，比如集群是在线还是下线，包含多少个节点，当前的配置纪元等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向当前节点的指针</span><br><span class="line">    clusterNode *myself;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集群当前的配置纪元，用于实现故障转移</span><br><span class="line">    uint64_t currentEpoch;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集群当前的状态：是在线还是下线</span><br><span class="line">    int state;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集群中至少处理着一个槽的节点的数量</span><br><span class="line">    int size;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 集群节点名单（包括 myself 节点）</span><br><span class="line">    &#x2F;&#x2F; 字典的键为节点的名字，字典的值为节点对应的 clusterNode 结构</span><br><span class="line">    dict *nodes;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/up-cb0413dac3d1923097cdf136316e96c8f4f.png" alt=""></p>
<h3 id="4-2-1-CLUSTER-MEET-命令的实现"><a href="#4-2-1-CLUSTER-MEET-命令的实现" class="headerlink" title="4.2.1 CLUSTER MEET 命令的实现"></a>4.2.1 CLUSTER MEET 命令的实现</h3><p>向节点A发送 CLUSTER MEET 命令，能让接收命令的节点A将另一个节点B（ip和port指向的节点）添加到节点A当前所处的集群里。</p>
<p>收到命令的节点A 和节点B进行握手，以此来确认彼此的存在，并为将来的进一步通信打好基础：</p>
<ol>
<li><p>节点A为节点B创建一个clusterNode结构，并将该结构添加到节点A自己的clusterState.nodes字典中。</p>
</li>
<li><p>节点A根据ip和port发送meet消息给节点B。</p>
</li>
<li><p>如果一切顺利，节点B收到meet消息，为节点A创建一个clusterNode结构，并将该结构添加到节点B自己的clusterState.nodes字典中。</p>
</li>
<li><p>如果一切顺利，节点B向节点A发送PONG消息</p>
</li>
<li><p>如果一切顺利，节点A向节点B返回PING消息</p>
</li>
<li><p>如果一切顺利，至此，握手完成</p>
</li>
<li><p>最后节点A会向自己处于的集群内的其他节点发送信息，让其他节点也和B节点握手，最终达到集群内的所有节点都相互认识彼此。至此，B节点加入进集群。</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-40fa2846f5067087ba601c5ba8b0658df00.png" alt=""></p>
<h2 id="4-3-redis负载均衡算法——hash-slot"><a href="#4-3-redis负载均衡算法——hash-slot" class="headerlink" title="4.3 redis负载均衡算法——hash slot"></a>4.3 redis负载均衡算法——hash slot</h2><p>Redis使用分片的方式来保存数据库中的键值对：整个集群被分为16384个槽(slot)，数据库中的每个键都位于这其中的某个槽上，集群中的节点，最少可以处理0个槽，最多可以处理16384个槽。</p>
<p><strong>当数据库中的 16384 个槽都有节点在处理时，集群处于上线状态，否则，处于下线状态。</strong></p>
<p>我们可以使用CLUSTER ADDSLOTS命令来给某个节点指派要处理的槽：</p>
<p><code>CLUSTER ADDSLOTS [slot ...]</code></p>
<p>这个命令接受一个或多个槽的编号作为参数，并将所有输入的槽指派给接收该命令的节点负责。</p>
<p>如<code>CLUSTER ADDSLOTS 0 1 2 3 ... 1000</code></p>
<p>表示将槽0到槽1000指派给接收到命令的整个节点负责。</p>
<h3 id="4-3-1-记录节点的槽指派信息"><a href="#4-3-1-记录节点的槽指派信息" class="headerlink" title="4.3.1 记录节点的槽指派信息"></a>4.3.1 记录节点的槽指派信息</h3><p>clusterNode结构中的slots数组和numslots字段记录了该节点负责处理的槽。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 一个节点的当前状态</span><br><span class="line">struct clusterNode&#123;</span><br><span class="line">    &#x2F;&#x2F;……</span><br><span class="line">    &#x2F;&#x2F; 记录处理那些槽</span><br><span class="line">    &#x2F;&#x2F; 二进制位数组，长度为 2048 个字节，包含 16384 个二进制位</span><br><span class="line">    &#x2F;&#x2F; 如果slots数组在索引i上的二进制位的值为1，那么表示节点负责处理槽i；否则表示节点不负责处理槽i</span><br><span class="line">    unsigned char slots[16384&#x2F;8];</span><br><span class="line">    &#x2F;&#x2F;记录自己负责处理的槽的数量</span><br><span class="line">    int numslots;</span><br><span class="line">    &#x2F;&#x2F;……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>slots数组有16384个二进制位，<strong>第i项上的二进制值如果为1，则表示槽i由自己负责。为0则表示槽i不是由自己负责</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-08c2162c6cae22ff35c3fd9c53e0ec5bf8c.png" alt=""></p>
<p>数组的定位时间复杂度是O(1)，这样的设计可以让节点非常快速的知道某个槽到底是不是由自己负责。</p>
<h3 id="4-3-2-传播节点的槽指派信息"><a href="#4-3-2-传播节点的槽指派信息" class="headerlink" title="4.3.2 传播节点的槽指派信息"></a>4.3.2 传播节点的槽指派信息</h3><p>一个节点除了会将自己负责处理的槽记录在clusterNode结构的slots属性和numslots属性之外，它还会<strong>将自己的slots数组通过消息发送给集群中其他的节点</strong>，以此来告知其他节点自己目前负责处理哪些槽。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4068617fde399f6fe494c764ff1e330620c.png" alt=""></p>
<p>当节点A通过消息从节点B那里接收到节点B的slots数组时，节点A会在<strong>自己的clusterState.nodes字典中</strong>查找<strong>节点B对应的clusterNode结构</strong>，并对该clusterNode结构中的slots数组进行保存或者更新。</p>
<p>每个节点都相互分享自己的槽指派信息，每个节点又在自己的clusterState.nodes字典中保存其他节点的槽指派信息，因此，集群中的每个节点都会知道整个集群数据库的全部槽，都分别被分派给了哪些节点。</p>
<h3 id="4-3-3-记录集群所有槽的指派信息"><a href="#4-3-3-记录集群所有槽的指派信息" class="headerlink" title="4.3.3 记录集群所有槽的指派信息"></a>4.3.3 记录集群所有槽的指派信息</h3><p>我们知道，每个节点都保存着一个clusterState结构，这个结构，<strong>我们可以看做节点自己对整个集群所描绘的详细概念地图</strong>。</p>
<p>节点除了会在clusterState.nodes字典中维护每个节点的槽分派信息外，还会在clusterState结构结构中维护一个clusterNode *slots[16384]数组。</p>
<p>clusterState.slots数组有16384项，每个数组项都是一个指向clusterNode的指针：</p>
<ul>
<li>如果slots[i]指向NULL，那么表示槽i尚未指派给任何节点。</li>
<li>如果slots[i]指向一个clusterNode，那么表示槽i已经指派给了这个clusterNode所对应的节点</li>
</ul>
<p>假设槽被指派给了集群中的三个节点，那么slots数组结构如下图：<br><img src="https://oscimg.oschina.net/oscnet/up-ef32357ce2410db6cf95670fec70e865b75.png" alt=""></p>
<ul>
<li>clusterState.nodes[i].slots<ul>
<li>节点A在自己的clusterState.nodes字典中的某个clusterNode结构（假设对应节点B）中保存的槽分派信息，是以单节点（节点B）为视角的槽分派信息，即——<strong>我这个节点负责如下这些槽</strong>。</li>
</ul>
</li>
<li>clusterState.slots</li>
<li>节点A在自己的clusterState.slots数组中保存的槽分派信息，是以每个槽为视角的槽分派信息。即——<strong>我这个槽被某个节点负责</strong>。</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-d08d4389ea5a796d227eed8522533cc9bf9.png" alt=""></p>
<h2 id="4-4-集群处理命令"><a href="#4-4-集群处理命令" class="headerlink" title="4.4 集群处理命令"></a>4.4 集群处理命令</h2><p>当集群中的所有槽都被指派之后，集群就会进入上线状态，这是客户端就可以向集群中的节点发送命令了。</p>
<p>一张图解释如下过程：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1cfff66398d714cab3142e3825989d4f9d0.png" alt=""></p>
<h3 id="4-4-1-计算键属于哪个槽"><a href="#4-4-1-计算键属于哪个槽" class="headerlink" title="4.4.1 计算键属于哪个槽"></a>4.4.1 计算键属于哪个槽</h3><p>节点用以下算法计算给定键 key 属于哪个槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def slot_number(key):</span><br><span class="line">	return CRC16(key) &amp; 16383 &#x2F;&#x2F;CRC16(key) 计算key的CRC-16校验和，然后和16383与出一个0-16383的序号来。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 用于查看一个给定键属于哪个槽</span><br><span class="line">CLUSTER KETSLOT &lt;key&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-2-判断某个槽是否由当前节点负责"><a href="#4-4-2-判断某个槽是否由当前节点负责" class="headerlink" title="4.4.2 判断某个槽是否由当前节点负责"></a>4.4.2 判断某个槽是否由当前节点负责</h3><p>当节点计算出键所属槽 i 之后，节点会检查自己在 clusterState.slots 数组中的项 i ，判断键所处的槽是否由自己负责：</p>
<ul>
<li>如果 <code>clusterState.slots[i]</code> 等于 <code>clusterState.myself</code> ，那么说明槽 i 由当前节点负责，节点可以执行客户端发送的命令；</li>
<li>否则，槽 i 不由当前节点负责,节点会根据 <code>clusterState.slots[i]</code> 所指向的 clusterNode 结构所记录的节点IP和端口号，向客户端返回 MOVED 错误并指引客户端转向正在处理槽i的节点，格式如下：<ul>
<li><code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code></li>
<li>客户端接收到 MOVED 命令之后，根据其提供的IP和端口，转向负责处理槽 slot 的节点，并向节点<strong>重新发送之前想要执行的命令</strong>。</li>
<li>客户端会和每个节点创建套接字连接，所谓的转向，其实就是换一个套接字来发送命令。</li>
</ul>
</li>
</ul>
<h2 id="4-5-节点数据库的实现"><a href="#4-5-节点数据库的实现" class="headerlink" title="4.5 节点数据库的实现"></a>4.5 节点数据库的实现</h2><p>我们在文章<a href="https://my.oschina.net/lscherish/blog/3147447" target="_blank" rel="noopener" title="Redis数据库结构/键空间/过期字典/事务/锁/持久化">Redis数据库结构/键空间/过期字典/事务/锁/持久化</a>中讨论过Redis服务器的键空间（即如何存储键值对）redisDb结构的dict字典数组，保存了所有的键值对。redisDb结构的expires字典数组，保存了所有的过期字典。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6d3519de440528a8af1eded3347c9337236.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dbb09c36a7db3dcb13c5f538cb3ccc80092.png" alt=""></p>
<p><strong>单机服务器和集群服务器（节点）的保存键值对以及键值对过期时间，实现都是一样的</strong>。只不过节点只能使用 0 号数据库，单机服务器没有限制。</p>
<p>和单机服务器不同的是，除了键值对之外，节点还需要维护<strong>槽和键的关系</strong>，节点会用 clusterState 结构中的 <code>slots_to_keys</code> 跳跃表来保存槽和键之间的关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    zskiolist *slots_to_keys;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p>这个跳跃表每个节点的分值( score )都是一个槽号，节点的成员( member )都是一个数据库键：</p>
<ul>
<li><p>每当节点往数据库中添加一个新的键值对时，节点就会将这个键以及键的槽号关联到 slots_to_key s跳跃表</p>
</li>
<li><p>当节点删除数据库中的某个键值对时，节点就会在slots_to_keys跳跃表解除被删除键与槽号的关联</p>
</li>
</ul>
<p>图例：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0bc955e758a048378d24a0e10ca3a39540a.png" alt=""></p>
<p>该图表示：</p>
<ul>
<li>键”book”所在跳跃表节点的分值为1337.0，这表示键”book”所在的槽为1337</li>
<li>键”date”所在跳跃表节点的分值为2022.0，这表示键”date”所在的槽为2022</li>
<li>键”lst”所在跳跃表节点的分值为3347.0，这表示键”lst”所在的槽为3347</li>
</ul>
<blockquote>
<p>slots_to_keys 的存在是为了使节点可以很方便的对属于某个或者某些槽的所有键做批量操作。例如命令<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令可以返回最多count个属于槽slot的数据库键，而这个命令就是通过遍历 slots_to_keys跳跃表来实现的</p>
</blockquote>
<h2 id="4-6-重新分片"><a href="#4-6-重新分片" class="headerlink" title="4.6 重新分片"></a>4.6 重新分片</h2><p>Redis集群的重新分片操作可以将<strong>任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点，并且相关槽所属的键值对也会从源节点移动到目标节点。</strong> 重新分片可以在线进行，在这过程中，集群不用下线，且源节点和目标节点都可以继续处理命令。</p>
<p>重新分片由Redis的集群管理软件 redis-trib 负责执行，redis-trib 通过向源节点和目标节点发送命令来进行重新分片：</p>
<ul>
<li><p>redis-trib对集群的单个槽 slot 进行重新分片的步骤如下：</p>
<ol>
<li><p>redis-trib 对目标节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code> 命令，让目标节点<strong>准备好</strong>从源节点导入槽 slot 的键值对</p>
</li>
<li><p>redis-trib 对源节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;source_id&gt;</code>命令，让源节点<strong>准备好</strong>将属于槽 slot的键值对迁移至目标节点</p>
</li>
<li><p>redis-trib 对源节点发送 <code>CLUSTER GETKEYSINSLOT&lt;slot&gt; &lt;count&gt;</code> 命令，获得最多 count 个属于槽 slot 的键值对的键名。</p>
</li>
<li><p>对于步骤三获得的每个键名，redis-trib 都向源节点发送一个<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code> 命令，<strong>将被选中的键原子的从源节点迁移至目标节点</strong>。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-ee9006a45f14bd9001e3118803ba0f3e6a8.png" alt=""></li>
</ul>
<ol start="5">
<li>重复步骤3和4，直到源节点保存的所有属于槽slot的键值对都被迁移到目标节点为止。</li>
<li>redis-trib向集群中的任意一个节点发送 <code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code> 命令，将槽slot指派给目标节点的信息发送给整个集群。</li>
</ol>
</li>
</ol>
</li>
<li><p>如果重新分片涉及多个槽，那么 redis-trib 将对<strong>每个给定的槽</strong>  <strong>分别</strong>执行上面给出的步骤。</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-0e420042cc4a84d00d7ef383c8c9a540889.png" alt=""></li>
</ul>
</li>
</ul>
<p>重新分片的实战操作，可以参考该篇文章：<a href="http://weizijun.cn/2016/01/08/redis%20cluster%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7redis-trib-rb%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener" title="redis cluster管理工具redis-trib.rb详解">redis cluster管理工具redis-trib.rb详解</a></p>
<h2 id="4-6-ASK-错误"><a href="#4-6-ASK-错误" class="headerlink" title="4.6 ASK 错误"></a>4.6 ASK 错误</h2><p>在重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种中间状态：属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对保存在目标节点中。</p>
<p>这时候如果客户端向源节点发送了一个key的操作请求，就可能会触发ASK 错误。</p>
<p>当客户端向源节点发送关于键key的命令，源节点先在自己的数据库里查找这个键，如果找到就直接返回执行客户端命令，如果没找到，这个键可能已经被迁移到了目标节点，源节点向客户端返回一个 ASK 错误，指引客户端转向正在导入槽的目标节点，并再次发送之前要执行的命令。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1b3f9629997cc535ef543380112d098d3e0.png" alt=""></p>
<p>接到ASK 错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后向目标节点发送一个 ASKING 命令， 之后再重新发送原本想要执行的命令。</p>
<h3 id="4-6-1-ASKING-命令的实现"><a href="#4-6-1-ASKING-命令的实现" class="headerlink" title="4.6.1 ASKING 命令的实现"></a>4.6.1 ASKING 命令的实现</h3><p>在重新分片过程中，我们对目标节点执行了 <code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，这会使得clusterState状态的importing_slots_from数组会记录当前节点的哪些槽正在从哪些节点导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState&#123;</span><br><span class="line">	&#x2F;&#x2F; ……</span><br><span class="line">    &#x2F;&#x2F; 如果importing_slots_from[i]的值不为NULL，而是指向一个clusterNode结构，表示当前节点正在从</span><br><span class="line">    &#x2F;&#x2F; clusterNode所代表的节点导入槽i</span><br><span class="line">    clusterNode *importing_slots_from[16384];</span><br><span class="line">     &#x2F;&#x2F; ……</span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure>

<p>在重新分片过程中，我们对源节点执行了<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;source_id&gt;</code>命令，这会使得clusterState状态的migrating_slots_to数组会记录当前节点正在迁移至其他节点的槽：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct clusterState&#123;</span><br><span class="line">    &#x2F;&#x2F; ……</span><br><span class="line">    &#x2F;&#x2F; 如果migrating_slots_to[i]的值不为NULL，而是指向一个clusterNode结构，表示当前节点正在将</span><br><span class="line">    &#x2F;&#x2F; 槽i迁移至clusterNode所代表的节点</span><br><span class="line">    clusterNode *migrating_slots_to[16384];</span><br><span class="line">    &#x2F;&#x2F; ……</span><br><span class="line">&#125;clusterState;</span><br></pre></td></tr></table></figure>
<p>接到ASK 错误的客户端会根据错误提供的IP地址和端口号，转向至正在导入槽的目标节点，然后向目标节点发送一个 ASKING 命令， 之后再重新发送原本想要执行的命令。</p>
<p><strong>ASKING命令要做的就是打开发送该命令的客户端的 REDIS_ASKING 标识。</strong></p>
<p>如果该客户端的 REDIS_ASKING 标识未打开，直接发送请求，由于槽的迁移过程还未完成，请求的键还属于源节点，此时直接请求目标节点，目标节点会返回一个MOVED错误。(因为迁移未完成，所以虽然部分的键已经迁移至目标节点了，但这部分键的归属，还是记在源节点上)</p>
<p>但是，如果节点的<code>clusterState.importing_slots_from[i]</code>显示节点正在导入槽 i ,并且发送命令的客户端带有 REDIS_ASKING 标识，<strong>那么节点将破例执行这个关于槽 i 的命令一次</strong>。</p>
<blockquote>
<p>客户端的 REDIS_ASKING 标识是一个一次性标识，当节点执行了一个带有 REDIS_ASKING 标识的客户单发送的命令之后，客户端的这个表示就会被移除。</p>
</blockquote>
<blockquote>
<p>ASK错误和MOVED错误的区别:<br>    MOVED错误代表槽的负责全已经从一个结点转移到了另一个节点<br>    ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施</p>
</blockquote>
<h2 id="4-7-节点的复制与故障转移"><a href="#4-7-节点的复制与故障转移" class="headerlink" title="4.7 节点的复制与故障转移"></a>4.7 节点的复制与故障转移</h2><p>集群中的节点分为主节点和从节点，主节点负责处理槽，而从节点负责复制某个主节点，并在被复制的主节点下线时，替代下线主节点继续处理命令请求。</p>
<h3 id="4-7-1-设置从节点"><a href="#4-7-1-设置从节点" class="headerlink" title="4.7.1 设置从节点"></a>4.7.1 设置从节点</h3><p>向一个节点发送命令：<code>CLUSTER REPLICATE &lt;node_id&gt;</code></p>
<p>这个命令可以让接收命令的节点成为 node_id 所指定的从节点，并开始对主节点进行复制：</p>
<ul>
<li><p>这个节点会先在自己的 clusterState.nodes 字典中找到 node_id 所对应节点的 clusterNode 结构，并将自己的 <code>clusterState.myself.slaveof</code>指针指向这个结构，以此来记录这个节点正在复制的主节点</p>
</li>
<li><p>然后节点修改自己在 clusterState.myself.flags 中的属性，关闭原本的 <code>REDIS_NODE_MASTER</code>标识，打开 <code>REDIS_NODE_SLAVE</code>标识，表示这个节点由原来的主节点变成了从节点</p>
</li>
<li><p>最后，节点调用复制代码，并跟据 clusterState.myself.slaveof 指向的 clusterNode 结构所保存的IP地址和端口号，对主节点进行复制。就是相当于向从节点发送命令 <code>SLAVEOF &lt;master_ip&gt; &lt;maste_port&gt;</code></p>
</li>
</ul>
<p>一个节点开始成为从节点的时候，会向集群广播这一事实，以便集群中的其他节点更新从节点和主节点的关系。</p>
<h3 id="4-7-2-故障检测"><a href="#4-7-2-故障检测" class="headerlink" title="4.7.2 故障检测"></a>4.7.2 故障检测</h3><p>集群中的每个节点都会定期地向集群中的其他节点发送 PING 消息，以此来检测对方是否在线</p>
<p>如果接受 PING 消息的节点没有在规定时间内返回 PONG ，那么发送 PING 的节点就会将该节点标记为<strong>疑似下线</strong>(PFAIL)。</p>
<p>当一个主节点A通过消息得知主节点B认为主节点C进入疑似下线状态，主节点A会在自己的 <code>clusterState.nodes</code> 字典中找到主节点C所对应的 clusterNode 结构，并将主节点B的下线报告添加到这个结构的 fail_reports 链表里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct clusterNode&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;&#x2F; 一个链表，记录了所有其他节点对该节点的下线报告</span><br><span class="line">    list *fail_reports;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个集群里，半数以上负责处理槽的主节点都将某个主节点X报告为疑似下线，那么这个主节点X将被标记为已下线(FAIL)，将主节点X标记为已下线的节点会向集群广播一条关于主节点X的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点X标记为已下线。</p>
<p>比较绕，我们来举例：假设一个集群有ABCD四个节点，A和B节点都认为D节点进入了疑似下线状态，这时刚好半数的主节点认为D疑似下线。然后，C节点通过消息交换，也将D节点标记为疑似下线状态。这时候数量就超过了半数了，于是C节点会将D节点标记为<strong>已下线</strong>，并向整个集群广播一条D节点已下线的消息。这时A和B接到消息，会将D节点标记为<strong>已下线</strong>。</p>
<h3 id="4-7-3-故障转移"><a href="#4-7-3-故障转移" class="headerlink" title="4.7.3 故障转移"></a>4.7.3 故障转移</h3><p>当一个从节点发现自己正在复制的主节点进入了已下线状态，<strong>从节点将开始对下线主节点进行故障转移</strong>:</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个<strong>从节点</strong>被选中</li>
<li>被选中的从节点将执行 slaveof no one 命令，成为新的主节点</li>
<li>新的主节点撤销已下线主节点对指派槽的管理，并将这些槽全部指派给自己</li>
<li>新的主节点向集群广播一条PONG消息，告诉集群中的其他节点自己成为了新的主节点。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
<p>这里面涉及到新的主节点的选举：</p>
<ol>
<li><p>集群的配置纪元是一个自增计数器，初始值为0</p>
</li>
<li><p>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值就会加一</p>
</li>
<li><p>对于每个配置纪元，集群中的每个负责处理槽的主节点都有一次投票机会，而第一个向主节点要求投票的从节点将获得主节点的投票</p>
</li>
<li><p>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条 CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST 消息，要求所有收到这条消息、并具有投票权的主节点向这个从节点投票</p>
</li>
<li><p>如果一个主节点具有投票权(它正在负责处理槽),并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条 CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 消息，表示这个主节点支持从节点成为新的主节点</p>
</li>
<li><p>每个参与选举的从节点都会接受 CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK 消息，并根据自己受到了多少条这种消息来统计自己获得了多少主节点 的支持</p>
</li>
<li><p>如果集群库有N个具有投票权的朱及诶单，那么当一个从节点收集到大于等于N/2+1张支持票，这个从节点当选为新的主节点</p>
</li>
<li><p>因为在每个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个</p>
</li>
<li><p>如果在一个配置纪元里没有从节点能搜集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</p>
</li>
</ol>
<blockquote>
<p>和选举领头sentinel的算法一样，都是基于raft算法。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84-%E9%94%AE%E7%A9%BA%E9%97%B4-%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8-%E4%BA%8B%E5%8A%A1-%E9%94%81-%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84-%E9%94%AE%E7%A9%BA%E9%97%B4-%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8-%E4%BA%8B%E5%8A%A1-%E9%94%81-%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url">Redis数据库结构/键空间/过期字典/事务/锁/持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T22:45:55+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84-%E9%94%AE%E7%A9%BA%E9%97%B4-%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8-%E4%BA%8B%E5%8A%A1-%E9%94%81-%E6%8C%81%E4%B9%85%E5%8C%96/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/12/25/Redis数据库结构-键空间-过期字典-事务-锁-持久化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Redis服务器结构"><a href="#1-Redis服务器结构" class="headerlink" title="1 Redis服务器结构"></a>1 Redis服务器结构</h1><p>Redis服务器将所有数据库都保存在redis.h/redisServer结构中，这里面最重要的一个结构是 <strong>redisDb *db</strong>，这是一个数组，保存着服务器中的所有数据库。<br>在redis初始化的时候，程序会根据dbnum属性来决定创建多少个数据库，这个属性由配置文件里的database选项来决定，默认是16，故而redis服务器默认创建16个数据库。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dd2a29153e71b63cd5bfd49ea2758169ebb.png" alt=""></p>
<h2 id="1-1-目标数据库"><a href="#1-1-目标数据库" class="headerlink" title="1.1 目标数据库"></a>1.1 目标数据库</h2><p>每个redis客户端都有自己的目标数据库，redis的读写操作都是针对目标数据库的。</p>
<p>默认情况下，redis的目标数据库是0号数据库，用户可以使用select命令来切换目标数据库。<code>SELECT 1</code>命令即为使目标数据库为1号数据库。</p>
<p>用来存储客户端状态的redisClient对象中的db属性记录了客户端当前的目标数据库，这个指针指向了redisDb数组的某个节点。</p>
<p>Select就是通过改变db属性的指针而切换目标数据库的。</p>
<h2 id="1-2-数据库键空间"><a href="#1-2-数据库键空间" class="headerlink" title="1.2 数据库键空间"></a>1.2 数据库键空间</h2><p><img src="https://oscimg.oschina.net/oscnet/up-d6e14f11d52889dd33329a8330c815e5b10.png" alt=""></p>
<p>上文说过redisDb结构表示一个数据库，其中的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间。我们对键值对的增删改查，都是对这个键空间的操作。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-edc492565847bfab632cc7203a17fb62736.png" alt=""></p>
<p>使用字典的好处是，随着数据量的增大，定位到某个键值对的时间复杂度并不会增加太厉害。很适合redis数据库的情况。</p>
<h2 id="1-3-过期字典"><a href="#1-3-过期字典" class="headerlink" title="1.3 过期字典"></a>1.3 过期字典</h2><p>要理解过期字典，先知道生存时间这一概念：</p>
<h3 id="1-3-1-设置过期时间"><a href="#1-3-1-设置过期时间" class="headerlink" title="1.3.1 设置过期时间"></a>1.3.1 设置过期时间</h3><p>Redis可以设置键的生存时间或过期时间：</p>
<ul>
<li>expire命令或者pexpire命令，客户端可以以秒（前者）或者毫秒（后者）精度，为数据库中某个键设置生存时间。</li>
</ul>
<blockquote>
<p>expire命令或者pexpire命令为一个key设置生存时间，注意，这个生存时间设置在<strong>key上</strong>，除非是用新的k-v来取代这个k-v，否则，只改变其value（可能是链表，集合，哈希等等）的结构，或者只是重命名这个key，或者对key进行自增自减操作，本质上都不会改变key上的生存时间。</p>
</blockquote>
<ul>
<li>Persist命令可以移除一个键的生存时间设置。</li>
<li>TTL 命令可以查看一个带有生存时间限制的键的剩余时间，以秒为单位，底层实现是以过期时间戳减去当前时间。（PTTL以毫秒为单位）</li>
</ul>
<h3 id="1-3-2-过期字典空间"><a href="#1-3-2-过期字典空间" class="headerlink" title="1.3.2 过期字典空间"></a>1.3.2 过期字典空间</h3><p>回到我们的redisDb结构，我们可以看到一个dict数组叫做expires</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6d3519de440528a8af1eded3347c9337236.png" alt=""></p>
<p>Expires字典保存了数据库中<strong>所有键的过期时间</strong>，这个键就是过期字典。</p>
<ul>
<li><strong>过期字典的键是一个指针，指向了键空间中的某个键对象</strong>（所以才说生存时间是针对key的）</li>
<li><strong>过期字典的值是一个long long 类型的整数</strong>，这个整数保存了键所指向的键对象的过期时间——以毫秒为精度的一个时间戳（所以底层其实都是用PEXPIREAT命令）</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-dbb09c36a7db3dcb13c5f538cb3ccc80092.png" alt=""></p>
<h3 id="1-3-3-过期键删除策略"><a href="#1-3-3-过期键删除策略" class="headerlink" title="1.3.3 过期键删除策略"></a>1.3.3 过期键删除策略</h3><p>Redis使用了<strong>惰性删除（在使用到键时才去判断是否过期以及删除）和定期删除（每隔一段时间删除库中的过期键）两种结合的删除策略</strong></p>
<ul>
<li>db.c/expireIfNeeded函数负责惰性删除，</li>
<li>redis.c/activeExpireCycle函数实现定期删除，它在规定的时间内，分多次遍历服务器中的各个数据库，从过期字典中随机检查一部分键的过期时间，并删除过期键。</li>
</ul>
<h1 id="2-Redis的事务"><a href="#2-Redis的事务" class="headerlink" title="2 Redis的事务"></a>2 Redis的事务</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;我们首先使用MULTI命令告诉Redis：</span><br><span class="line">&#x2F;&#x2F;“下面我发给你的命令属于同一个事务，你先不要执行，而是把它们暂时存起来。”Redis回答：“OK。</span><br><span class="line"></span><br><span class="line">redis &gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;而后我们发送了两个SADD命令来实现关注和被关注操作.</span><br><span class="line">&#x2F;&#x2F;可以看到Redis遵守了承诺，没有执行这些命令，</span><br><span class="line">&#x2F;&#x2F;而是 返回QUEUED表示这两条命令已经进入等待执行的事务队列中了。</span><br><span class="line">redis &gt; 命令1</span><br><span class="line">QUEUED</span><br><span class="line">redis &gt; 命令2</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当把所有要在同一个事务中执行的命令都发给Redis后，</span><br><span class="line">&#x2F;&#x2F;我们 使用EXEC命令告诉Redis将等待执行的事务队列中的所有命令（即刚才所有返回QUEUED的命令）</span><br><span class="line">&#x2F;&#x2F;按照发送顺序依次执行。</span><br><span class="line">&#x2F;&#x2F;EXEC命令的返回值就是这些命令的返回值组成的列表，返回值顺序和命令的顺序相同。</span><br><span class="line"></span><br><span class="line">redis &gt; EXEC</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Redis的事务和其他的事务一样保证最基本的原子性，只要执行exec命令，事务就会执行，执行过程中，一个命令失败，事务中的命令就全部取消。</p>
</blockquote>
<blockquote>
<p>redis没有类似关系型数据库的回滚功能，烂摊子只能自己收拾。</p>
</blockquote>
<h1 id="3-Redis的锁"><a href="#3-Redis的锁" class="headerlink" title="3 Redis的锁"></a>3 Redis的锁</h1><p>Redis的Watch命令具有乐观锁的功能，WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。</p>
<p>监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）</p>
<blockquote>
<p>WATCH只负责  当被监控的键值被修改后 阻止紧随其后的一个事务的执行，而不能保证其他客户端不修改这一键值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; SET key 1</span><br><span class="line">OK</span><br><span class="line">redis &gt; WATCH key</span><br><span class="line">OK</span><br><span class="line">redis &gt; SET key 2</span><br><span class="line">OK</span><br><span class="line">redis &gt; MULTI</span><br><span class="line">OK</span><br><span class="line">redis &gt; SET key 3</span><br><span class="line">QUEUED</span><br><span class="line">redis &gt; EXEC</span><br><span class="line">(nil)</span><br><span class="line">redis &gt; GET key   &#x2F;&#x2F;得到2，说明SET key 3命令没有实现，事务被取消了</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure>

<h1 id="4-Redis的持久化"><a href="#4-Redis的持久化" class="headerlink" title="4 Redis的持久化"></a>4 Redis的持久化</h1><p>为了防止因为突发情况，导致Redis数据库的数据丢失，我们需要对Redis做持久化。Redis如何做持久化呢？有两种方式：</p>
<ul>
<li>RDB（快照）持久化</li>
<li>AOF</li>
</ul>
<h2 id="4-1-RDF"><a href="#4-1-RDF" class="headerlink" title="4.1 RDF"></a>4.1 RDF</h2><p>RDB（快照）持久化：保存某个时间点的全量数据快照，生成RDB文件在磁盘中。RDB文件是一个压缩过的二进制文件，可以还原为Redis的数据。</p>
<h3 id="4-1-1-触发和载入方式"><a href="#4-1-1-触发和载入方式" class="headerlink" title="4.1.1 触发和载入方式"></a>4.1.1 触发和载入方式</h3><ul>
<li><p>手动触发方式</p>
<ul>
<li>SAVE命令：阻塞Redis的服务器进程，直到RDB文件被创建完毕，阻塞期间服务器不能处理任何命令请求。</li>
<li>BGSAVE命令：Fork出一个子进程来创建RDB文件，不阻塞服务器进程。lastsave 指令可以查看最近的备份时间。</li>
</ul>
</li>
<li><p>载入方式</p>
<ul>
<li>Redis没有主动载入RDB文件的命令，RDB文件是在服务器启动时自动载入，只要Redis服务器检测到RDB文件的存在，即会载入。<strong>且载入过程，服务器也会是阻塞状态</strong>。</li>
</ul>
</li>
<li><p><strong>自动触发方式</strong></p>
<ul>
<li><p>根据redis.conf配置里的save m n定时触发（用的是BGSAVE），m表示多少时间内，n表示修改次数。<strong>save可以设置多个条件，任意条件达到即会执行BGSAVE命令</strong>。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1  &#x2F;&#x2F;设置条件1，即服务器在900秒内，对数据库进行了至少1次修改，即会触发BGSAVE</span><br><span class="line">save 300 10 &#x2F;&#x2F;设置条件2，即服务器在300秒内，对数据库进行了至少10次修改，即会触发BGSAVE</span><br><span class="line">save 60 1000  &#x2F;&#x2F;设置条件3，即服务器在0秒内，对数据库进行了至少1000次修改，即会触发BGSAVE</span><br></pre></td></tr></table></figure></li>
<li><p><strong>redis如何保存自动触发方式的save配置呢</strong>？</p>
<ul>
<li>redisServer结构中维护了一个saveParam的数组，数组每个saveParam都存储着一个save条件，如下图：<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-a92236652f39715c887c21cc25185375914.png" alt=""></li>
<li><img src="https://oscimg.oschina.net/oscnet/up-5a64963f2ac3b06d5b7420e21fbee878300.png" alt=""></li>
</ul>
</li>
<li>前文所述三个save，其saveParam的数组将会是下图的样子<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-049e2745bfb3bde016408e3504b8d04e19f.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>自动触发方式如何实现的呢</strong>？</p>
<ul>
<li>redisServer结构维护了一个dirty计数器和lastsave属性。</li>
<li><strong>dirty计数器记录了上次SAVE或者BGSAVE之后，数据库执行了多少次的增删改</strong>，当服务器成功执行一个修改命令后，程序就会对该值+1，（对集合操作n个元素，dirty+n）。SAVE或者BGSAVE命令执行后，dirty计数器清零。</li>
<li>lastsave属性是一个unix时间戳，记录了服务器上次成功执行SAVE或者BGSAVE命令的时间。</li>
<li>Redis服务器有个周期性操作函数serverCron，默认每100毫秒执行一次，它其中一项工作就是检查saveParam保存的条件，并根据dirty和lastsave字段判断是否有哪一条条件已经被满足。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-1-2-RDB文件的结构"><a href="#4-1-2-RDB文件的结构" class="headerlink" title="4.1.2 RDB文件的结构"></a>4.1.2 RDB文件的结构</h3><p><img src="https://oscimg.oschina.net/oscnet/up-bf5e7bf3f501d299a65899d125c4490ea9c.png" alt=""></p>
<p>不加赘述，详见<a href="https://www.cnblogs.com/huangxincheng/p/5074998.html" target="_blank" rel="noopener" title="让你彻底了解RDB存储结构">让你彻底了解RDB存储结构</a></p>
<h2 id="4-2-AOF"><a href="#4-2-AOF" class="headerlink" title="4.2 AOF"></a>4.2 AOF</h2><p>除了RDB持久化以外，Redis还提供了AOF（append only file）持久化功能，和RDB通过保存数据库的键值对来记录状态不同，AOF持久化是通过保存Reids服务器所执行的写命令来记录数据库状态的。</p>
<h3 id="4-2-1-AOF持久化的实现"><a href="#4-2-1-AOF持久化的实现" class="headerlink" title="4.2.1  AOF持久化的实现"></a>4.2.1  AOF持久化的实现</h3><p>AOF持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。</p>
<ul>
<li>命令追加<ul>
<li>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf缓存区的末尾。</li>
</ul>
</li>
<li>AOF文件的写入和同步<ul>
<li>Redis的服务器进程就是一个事件循环。</li>
<li>每次结束一个事件循环之前，都会调用flushAppendOnlyFile函数，考虑是否将缓冲区的内容写入和保存到AOF文件里面。</li>
<li>flushAppendOnlyFile函数根据配置项appendsync的不同选值有不同的同步策略。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-53aa39c4281edee37463b23c40a0ca46eb7.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="4-2-2-AOF文件的载入"><a href="#4-2-2-AOF文件的载入" class="headerlink" title="4.2.2 AOF文件的载入"></a>4.2.2 AOF文件的载入</h3><p>Redis读取AOF文件并还原数据库状态的详细步骤如下：</p>
<ul>
<li>服务器创建一个不带网络连接的伪客户端（fake client）（因为Redis的命令只能在客户端上下文中执行）；</li>
<li>从AOF文件中分析并读取出一条写命令。</li>
<li>从AOF文件中分析并读取出一条写命令。</li>
<li>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</li>
</ul>
<h3 id="4-2-3-AOF重写"><a href="#4-2-3-AOF重写" class="headerlink" title="4.2.3 AOF重写"></a>4.2.3 AOF重写</h3><p>体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。</p>
<p>为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能。</p>
<p>通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。</p>
<p>我们称新的AOF文件为<strong>AOF重写文件</strong>，AOF重写文件不是像AOF一样记录每一条的写命令，也不是对AOF文件的简单复制和压缩。<strong>AOF重写是通过读取当前Redis数据库状态来实现的</strong>。</p>
<p>比如一个animals键，我们有如下操作：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dd5c6d3f849ab2c7e4028ae3b8ae976c920.png" alt=""></p>
<p>在AOF中，我们要保存四条写命令，而在AOF重写文件中，我们使用一条<code>SADD animals &quot;Dog&quot; &quot;Panda&quot; &quot;Tiger&quot; &quot;Lion&quot; &quot;Cat&quot;</code>来替代四条命令。</p>
<blockquote>
<p>从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理。（比如连续6条RPUSH命令会被整合成1条）</p>
</blockquote>
<blockquote>
<p>在实际中，为了避免在执行命令时造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查键所包含的元素数量，如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量(默认为64)的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。例如如果SADD后面加入的元素为90条，那么会分成两天SADD，第一条SADD 64个元素，第二条SADD 36个元素。</p>
</blockquote>
<h3 id="4-2-3-AOF后台重写"><a href="#4-2-3-AOF后台重写" class="headerlink" title="4.2.3 AOF后台重写"></a>4.2.3 AOF后台重写</h3><p>Redis服务器是单线程，如果由服务器发起AOF重写，那么服务器将阻塞。为了防止这个情况，Redis使用子进程进行AOF重写，在这同时主进程仍然在接受并处理客户端的请求。</p>
<p>因为在子线程重写的过程中，主线程也在处理请求导致数据库状态变化，为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用。</p>
<p>在子线程重写的过程中，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给<strong>AOF缓冲区</strong>和<strong>AOF重写缓冲区</strong>。</p>
<p>这样一来可以保证： </p>
<ol>
<li>AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。</li>
<li>从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-6a4615d0c2484006b568327f6ad06b36bfb.png" alt=""></p>
<p>当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：</p>
<ol>
<li><p>将AOF重写缓冲区中的所有内容写入到AOF重写文件中，这时AOF重写文件所保存的数据库状态将和服务器当前的数据库状态一致。</p>
</li>
<li><p>对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。</p>
</li>
</ol>
<p>在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/19/Redis%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/19/Redis%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" itemprop="url">Redis的5种数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-19T22:42:07+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/19/Redis%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/12/19/Redis的5种数据类型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Redis是一个key-value存储系统，由C语言编写。</p>
<p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键(key对象)，另一个对象用作键值对的值(value对象)。</p>
<p>Redis的每种数据类型全都是套用一种结构的对象(redisObject)。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d95d7fe428cfe258965098d3c8425942dba.png" alt=""></p>
<p><strong>Redis支持5种对象类型</strong>，分别是字符串(string)、列表(list)、哈希(hash)、集合(set)、有序集合(zset)，redisObject使用type字段记录自身属于哪种类型。</p>
<p>而每种对象类型至少使用了两种底层数据结构来实现，redisObject使用编码字段（encoding字段）记录了自己使用的是哪种底层数据结构实现。<strong>而*ptr指针则会直接指向这个对应的底层数据结构</strong>。</p>
<p>每个对象会用到的编码以及对应的数据结构详见下表，即共8种底层数据结构：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9e9d4aadc7f129e331c74b52b7db9d6d7d2.png" alt=""></p>
<blockquote>
<p>Redis中的键，都是用字符串对象来存储的，即对于Redis数据库中的键值对来说，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的其中一种。</p>
</blockquote>
<p>Redis的8种数据结构，我们已经在<a href="https://my.oschina.net/lscherish/blog/3145142" target="_blank" rel="noopener" title="Redis的8种底层数据结构">Redis的8种底层数据结构</a>一文中有过介绍，本文我们来讲Redis支持的5种对象类型</p>
<h1 id="统一的对象——redisObject"><a href="#统一的对象——redisObject" class="headerlink" title="统一的对象——redisObject"></a>统一的对象——redisObject</h1><p>Redis的五种数据类型全都是套用一种结构的对象 ：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e3635d29856355ba1d30a58c82b4632d3c0.png" alt=""></p>
<p>redisObject对象实现了基于引用计数技术的内存回收机制和对象共享机制。</p>
<p>因为redis是k-v键值对的缓存数据库，所以每一次我们新建一个k-v键值对时，redis都会创建两个redisObject对象，<strong>键总是字符串对象</strong>。</p>
<p>这几个属性我们拆开一个个讲：</p>
<ul>
<li><p><strong>Type</strong></p>
<ul>
<li>redisObject对象根据type的不同会有五种类型，这个字段就是用来标记<strong>不同类型的对象</strong>的。</li>
<li>命令TYPE keyname 可以得到这个type属性。</li>
<li>具体值见下表：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-9d87b66548de4d735b77d81f7b5e9e12e32.png" alt=""></li>
<li>Redis基于类型的多态就是根据type字段来判断的，如DEL,EXPIRE等命令可以针对任何类型的键操作，而SET/GET只能针对字符串键操作，HDEL,HSET只能针对哈希键操作等，这种针对特定类型的命令实现，其实就是在执行命令前先检查一下这个type值。</li>
</ul>
</li>
<li><p><strong>Ptr内存指针</strong></p>
<ul>
<li>Ptr是一个指针，用来指向对象的底层数据结构。</li>
</ul>
</li>
<li><p><strong>Encoding</strong></p>
<ul>
<li>对象ptr指针指向对象的<strong>底层实现数据结构</strong>，而到底取用哪个数据结构，则在encoding中标记。</li>
<li>后续Redis命令在针对对象进行操作时，也会根据encoding自动选择合适的函数，这是Redis命令的多态。</li>
<li>下面是encoding的字面值和各种数据结构的对应：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-698fd8d4d8dc2a1676a2b8422c71a99ab0d.png" alt=""></li>
<li>上图中值得注意的是 “跳跃表和字典”。其实在redis中，在使用跳跃表时（其实也就用于有序集合），总会辅助一个字典来提升效率的。这时字典的k-v会分别保存一个元素的<strong>成员地址</strong>和<strong>分值地址</strong>。跳跃表和字典的指针共同指向一个数据，这样既不会占用内存，也能利用字典实现 <strong>常数级的</strong> 定位查找。</li>
</ul>
</li>
<li><p><strong>Refcount</strong></p>
<ul>
<li><p>Refcount是redisObject对象的引用计数器，redis的内存回收是引用计数法，规则如下：</p>
<ul>
<li>当一个新对象创建时，refcount被设置为1。</li>
<li>当对象被一个程序引用时，refcount +1</li>
<li>不再被某个对象引用时，refcount – 1</li>
<li>Refcount为0时，对象被释放</li>
</ul>
</li>
<li><p>Refcount的功能为redis的对象共享提供了可能性，为了节约内存，Redis中大量使用了指针，前面就说过，跳跃表和字典的结合中就大量用到了内存共享。他们相互对应的节点中，指针被指向了同一个对象。</p>
</li>
<li><p>比如为键A新创建了一个整数值为100的字符串对象C，如果键B的值也是100，那么value指针就会指向C，C对象的refcount+1</p>
</li>
<li><p>限于cpu时间的限制，redis只对包含整数值的字符串对象进行共享。</p>
</li>
</ul>
</li>
<li><p><strong>Lru</strong></p>
<ul>
<li>Lru属性记录了该对象最后一次被命令访问的时间</li>
<li>通过它，Redis可以得到这个对象的闲置时间，从而在服务器被占用的内存大小超过maxmenmory时，空转时间长的对象会被优先释放。</li>
</ul>
</li>
</ul>
<h2 id="1-字符串对象"><a href="#1-字符串对象" class="headerlink" title="1 字符串对象"></a>1 字符串对象</h2><p>字符串对象的编码可以是int、raw或者embstr。或者说，字符串对象的encoding只能是<strong>REDIS_ENCODING_INT，REDIS_ENCODING_EMBSTR和REDIS_ENCODING_RAW</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-34c77b394832476e0bbeedef031129d1d08.png" alt=""></p>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">prt和encoding的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">如果保存的字符串是整数值，并且这个整数值可以用long类型来表示</td>
<td align="center">Ptr属性中，void*会转化成long，encoding改为REDIS_ENCODING_INT</td>
</tr>
<tr>
<td align="center">保存的字符串不是整数值，且长度<strong>大于39字节</strong>（包含可以用long double 类型保存的浮点数）</td>
<td align="center">Ptr属性中，void*会转化成SDS，encoding为REDIS_ENCODING_RAW</td>
</tr>
<tr>
<td align="center">保存的字符串保存的字符串不是整数值，且长度<strong>小于等于39字节</strong></td>
<td align="center">Ptr属性中，void*会转化成embstr，encoding为REDIS_ENCODING_EMBSTR</td>
</tr>
</tbody></table>
<p>下图展示了一个当ptr指向SDS时的字符串对象的结构：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0f49a84c13fabc614b44f2bb095baef5f9a.png" alt=""></p>
<blockquote>
<p>注意：当字符串改变，直到不满足上述各自条件时，embstr和int会被转换为raw类型。</p>
</blockquote>
<blockquote>
<p>注意：Embstr实际上是只读的，因为redis没有为它编写任何的修改函数，所以对它进行任何操作，它都会先转换为raw，然后再执行命令，且不会变回来。</p>
</blockquote>
<h2 id="2-列表对象"><a href="#2-列表对象" class="headerlink" title="2 列表对象"></a>2 列表对象</h2><p>列表对象的编码可以是压缩链表ziplist或者双端链表linkedlist，encoding取值<strong>REDIS_ENCODING_ZIPLIST或者REDIS_ENCODING_LINKEDLIST</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9bd3b4fd6b03622da176ffcb6dbe8759400.png" alt=""></p>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">prt和encoding的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">当列表保存的<strong>所有</strong>字符串元素的长度<strong>都小于</strong>64字节，且元素的数量<strong>小于512</strong></td>
<td align="center">Ptr指向一个ziplist，encoding改为REDIS_ENCODING_ZIPLIST</td>
</tr>
<tr>
<td align="center">否则</td>
<td align="center">Ptr指向一个linkedlist，encoding改为REDIS_ENCODING_LINKEDLIST</td>
</tr>
</tbody></table>
<blockquote>
<p>当列表对象被改变，使其无法满足上述条件时，ziplist会向linkedlist迁移</p>
</blockquote>
<h3 id="2-1-列表对象中的Ziplist"><a href="#2-1-列表对象中的Ziplist" class="headerlink" title="2.1 列表对象中的Ziplist"></a>2.1 列表对象中的Ziplist</h3><ul>
<li><p>Ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</p>
</li>
<li><p>当列表对象元素不大，每个元素也不大的时候，就采用Ziplist存储。</p>
</li>
<li><p>但当数据量过大时就ziplist就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是O(N)，即每次插入都会重新进行realloc。</p>
</li>
<li><p>如下图所示，对象结构中ptr所指向的就是一个Ziplist。整个Ziplist只需要malloc一次，它们在内存中是一块连续的区域。</p>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-c482fdbc263e1449b8228a94a380c173d1b.png" alt=""></p>
<h3 id="2-2-列表对象中的Linkedlist"><a href="#2-2-列表对象中的Linkedlist" class="headerlink" title="2.2 列表对象中的Linkedlist"></a>2.2 列表对象中的Linkedlist</h3><ul>
<li><p>linkedlist是一种双向链表。它的结构比较简单，节点中存放pre和next两个指针，还有节点相关的信息。</p>
</li>
<li><p>当每增加一个node的时候，就需要重新malloc一块内存。</p>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-9f827f3c5c40fcdf61d8b61cf780f0eeb8d.png" alt=""></p>
<h2 id="3-哈希对象"><a href="#3-哈希对象" class="headerlink" title="3 哈希对象"></a>3 哈希对象</h2><p>哈希对象的底层实现可以是ziplist或者dict。Encoding的值可以是压缩链表REDIS_ENCODING_ZIPLIST或者字典REDIS_ENCODING_HT</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5d9f5a97ffdf3ff8f60580807c38ad7b2b3.png" alt=""><br><img src="https://oscimg.oschina.net/oscnet/up-cc2b0b5bb5247b99b76742c3ebf1ce28ced.png" alt=""></p>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">prt和encoding的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">对象保存的<strong>所有键值对的键和值</strong>的字符串长度<strong>都小于64字节</strong>，且键值对<strong>数量小于512</strong></td>
<td align="center">Ptr指向一个ziplist，encoding改为REDIS_ENCODING_ZIPLIST</td>
</tr>
<tr>
<td align="center">否则</td>
<td align="center">Ptr指向一个dict，encoding改为REDIS_ENCODING_HT</td>
</tr>
</tbody></table>
<h3 id="3-1-哈希对象中的ziplist"><a href="#3-1-哈希对象中的ziplist" class="headerlink" title="3.1 哈希对象中的ziplist"></a>3.1 哈希对象中的ziplist</h3><ul>
<li><p>ziplist中的哈希对象是按照key1,value1,key2,value2这样的顺序存放来存储的。</p>
</li>
<li><p>新的键值插入表尾，先是key节点，紧接着value节点。因此同一键值对的两个节点总是紧挨在一起，key在前，value在后。</p>
</li>
<li><p>先添加的k-v靠近表头，后添加的靠近表尾，当对象数目不多且内容不大时，这种方式效率是很高的。</p>
</li>
</ul>
<h3 id="3-2-哈希对象中的dict"><a href="#3-2-哈希对象中的dict" class="headerlink" title="3.2 哈希对象中的dict"></a>3.2 哈希对象中的dict</h3><p>之前已经介绍过dict了，字典中，dicht[0] 是用于真正存放数据，dicht[1]一般在哈希表元素过多进行rehash的时候用于中转数据。</p>
<p>dictht中的table用于真正存放元素，每个key/value对用一个dictEntry表示，放在dictEntry数组中。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e7e180d88c04aecf2ab4f03230acffcc1e6.png" alt=""></p>
<h2 id="4-集合对象"><a href="#4-集合对象" class="headerlink" title="4 集合对象"></a>4 集合对象</h2><p>集合对象的编码可以是intset或者dict。Encoding可以是整数集合REDIS_ENCODING_INTSET或者字典REDIS_ENCODING_HT。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5d9f5a97ffdf3ff8f60580807c38ad7b2b3.png" alt=""><br><img src="https://oscimg.oschina.net/oscnet/up-43dad25f3a597386f766d258daddc45f7b9.png" alt=""></p>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">prt和encoding的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">当集合对象保存的<strong>所有元素</strong>都是<strong>整数值</strong>，且元素数量<strong>不超过512个</strong></td>
<td align="center">Ptr指向一个intset，encoding改为REDIS_ENCODING_ZIPLIST</td>
</tr>
<tr>
<td align="center">否则</td>
<td align="center">Ptr指向一个dict，encoding改为REDIS_ENCODING_HT</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：当使用哈希表作为集合对象的底层实现时，字典的每一个键都是一个字符串对象，用来保存集合元素，而<strong>字段的值都被设置为null</strong>。联想一下JAVA的keySet，这方式跟set和hashmap的关系是一样的。</p>
</blockquote>
<h2 id="5-有序集合对象"><a href="#5-有序集合对象" class="headerlink" title="5 有序集合对象"></a>5 有序集合对象</h2><p>有序集合的编码可能两种，一种是ziplist，<strong>另一种是skiplist与dict的结合</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-cc2b0b5bb5247b99b76742c3ebf1ce28ced.png" alt=""><br><img src="https://oscimg.oschina.net/oscnet/up-d234e8da671c9d487dd5ca5470753fc75a1.png" alt=""></p>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">prt和encoding的值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">有序集合保存的元素<strong>数量小于128</strong>，且所有成员的长度都<strong>小于64字节</strong></td>
<td align="center">Ptr指向一个ziplist，encoding改为REDIS_ENCODING_ZIPLIST</td>
</tr>
<tr>
<td align="center">否则</td>
<td align="center">Ptr指向一个skiplist和dict的结合体，encoding改为REDIS_ENCODING_SKIPLIST</td>
</tr>
</tbody></table>
<h3 id="4-1-有序集合对象中的ziplist"><a href="#4-1-有序集合对象中的ziplist" class="headerlink" title="4.1 有序集合对象中的ziplist"></a>4.1 有序集合对象中的ziplist</h3><ul>
<li>ziplist作为集合和作为哈希对象是一样的，member和score顺序紧凑的存放。</li>
<li>按照score从小到大顺序排列。它的结构不再复述。</li>
</ul>
<h3 id="4-2-有序集合对象中的跳跃表和字典合用"><a href="#4-2-有序集合对象中的跳跃表和字典合用" class="headerlink" title="4.2 有序集合对象中的跳跃表和字典合用"></a>4.2 有序集合对象中的跳跃表和字典合用</h3><p>前面讲过：<br>在使用跳跃表时（其实也就用于有序集合），总会辅助一个字典来提升效率的。这时字典的k-v会分别保存一个元素的成员地址和分值地址。跳跃表和字典的指针共同指向一个数据，这样既不会占用内存，也能利用字典实现** 常数级的** 定位查找。</p>
<p>例如：</p>
<ul>
<li><p>如果我们只使用字典，那么虽然我们可以以O(1)复杂度查找成员的分值，但是因为字典以无序的方式存储，所以在执行注入zrank之类的范围型命令时，还需要重排序。至少需要O（NlogN）的时间复杂度和O（N）的空间复杂度。</p>
</li>
<li><p>反之，我们查找分值这一操作，将需要O（logN）的复杂度。</p>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-e4c2cc27528e959f2850a4732f53d8b308b.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/19/Redis%E7%9A%848%E7%A7%8D%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/19/Redis%E7%9A%848%E7%A7%8D%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url">Redis的8种底层数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-19T22:38:18+08:00">
                2019-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/19/Redis%E7%9A%848%E7%A7%8D%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/12/19/Redis的8种底层数据结构/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  10.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  40
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li><p>Redis是一个key-value存储系统，由C语言编写。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型），这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
</li>
<li><p>在此基础上，Redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
</li>
</ul>
<ul>
<li><p>Redis 是一个高性能的key-value数据库。 Redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。</p>
</li>
<li><p>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p>
</li>
</ul>
<blockquote>
<p>Redis的作者叫Salvatore Sanfilippo，来自意大利的西西里岛，现在居住在卡塔尼亚。目前供职于Pivotal公司。他使用的网名是antirez。</p>
</blockquote>
<h1 id="Redis的5种对象与8种数据结构"><a href="#Redis的5种对象与8种数据结构" class="headerlink" title="Redis的5种对象与8种数据结构"></a>Redis的5种对象与8种数据结构</h1><p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键(key对象)，另一个对象用作键值对的值(value对象)。</p>
<p>Redis的每种数据类型全都是套用一种结构的对象(redisObject)。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d95d7fe428cfe258965098d3c8425942dba.png" alt=""></p>
<p><strong>Redis支持5种对象类型</strong>，分别是字符串(string)、列表(list)、哈希(hash)、集合(set)、有序集合(zset)，redisObject使用type字段记录自身属于哪种类型。</p>
<p>而每种对象类型至少使用了两种底层数据结构来实现，redisObject使用编码字段（encoding字段）记录了自己使用的是哪种底层数据结构实现。<strong>而*ptr指针则会直接指向这个对应的底层数据结构</strong>。</p>
<p>每个对象会用到的编码以及对应的数据结构详见下表，即共8种底层数据结构：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9e9d4aadc7f129e331c74b52b7db9d6d7d2.png" alt=""></p>
<blockquote>
<p>Redis中的键，都是用字符串对象来存储的，即对于Redis数据库中的键值对来说，键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象中的其中一种。</p>
</blockquote>
<p>那么，我们首先先从底层开始，了解一下Redis的8种数据结构。</p>
<h1 id="Reids的8种底层数据结构"><a href="#Reids的8种底层数据结构" class="headerlink" title="Reids的8种底层数据结构"></a>Reids的8种底层数据结构</h1><h2 id="1-整数"><a href="#1-整数" class="headerlink" title="1 整数"></a>1 整数</h2><p>如果保存的字符串是整数值，并且这个整数值可以用long类型来表示，那么ptr指针的void*则转化为C语言源生的long类型，这个无须多言。</p>
<h2 id="2-简单动态字符串-SDS"><a href="#2-简单动态字符串-SDS" class="headerlink" title="2 简单动态字符串 SDS"></a>2 简单动态字符串 SDS</h2><p>在Redis中，只有在使用到不会被修改的字符串字面量时（比如打印日志），Redis才会采用c语言传统的字符串（以空字符结尾的字符数组），<strong>而在Redis数据库中，所有的字符串在底层都由SDS来实现的</strong>。</p>
<h3 id="2-1-SDS数据结构"><a href="#2-1-SDS数据结构" class="headerlink" title="2.1 SDS数据结构"></a>2.1 SDS数据结构</h3><p>被重新定义过的字符串对象（SDS）是Redis的基本存储类型，一个SDS字符串的完整结构，由在内存地址上前后相邻的<strong>两部分</strong>组成（header和char数组）。如下图，SDS字符串有多种类型，<strong>不同类型的SDS字符串是为了保存不同长度的内容</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5a36209c6053a1edbd5881ba7aeeb0f018e.png" alt=""></p>
<ul>
<li><p>header——我们把上图中非char数组（变量名为buf）的部分都统称为header，其成员有：</p>
<ul>
<li><p>第一个成员变量len记录的是为buf分配的<strong>内存空间已使用的长度，即我们看见的，有效的字符串</strong>；</p>
</li>
<li><p>第二个成员变量alloc记录的是为buf分配的内存空间的<strong>总长度</strong>，alloc – len 就是未使用的空间，当然<strong>这长度不包括SDS字符串头和结尾NULL</strong>。</p>
</li>
<li><p>第三个字符flags只使用了<strong>低三位表示类型</strong>，高五位没有用处，目的是根据字符串的长度的不同选择不同的sds结构体。</p>
<ul>
<li><p><strong><em>为何要定义不同的结构体</em></strong>： 结构体的主要区别是len和alloc的类型（uint8，uint16等等），定义不同的结构体是为了存储不同长度的字符串，根据不同长度定义不同的类型是为了节省一部分空间大小，毕竟在Redis字符串非常多，哪怕一点点优化积累起来都很可观。</p>
</li>
<li><p><strong><em>flags字段的用处</em></strong>：由于SDS字符串结构的设计，在我们需要访问header中成员变量时，需要通过sds指针向前回溯一个头结构体的长度，然后通过这个地址去访问。至于回溯多长，则要视该SDS字符串的类型而定，而这个信息就保存在sds指针前一个unsigned char长度的空间中——即flags。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>char数组</p>
<ul>
<li><p>这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为<strong>柔性数组</strong>（flexible array member），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在分配内存的时候，一开始它并不占用内存空间。</p>
</li>
<li><p>这个字符数组的长度等于最大容量+1。之所以字符数组的长度比最大容量多1个字节，就是为了在字符串长度达到最大容量时仍然<strong>有1个字节NULL结束符</strong>，即ASCII码为0的’\0’字符，这样字符串可以和c语言源生的字符串兼容。</p>
</li>
<li><p>与其他的结构体不同，<strong>sdshdr5没有定义char数组和alloc字段</strong>，他的值存储在flag没有被使用的高五位中，所以sdshdr5对应的SDS_TYPE_5类型字符串只能保存原串长度小于等于2^5 = 32，因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-使用sds结构的优点"><a href="#2-2-使用sds结构的优点" class="headerlink" title="2.2 使用sds结构的优点"></a>2.2 使用sds结构的优点</h3><ul>
<li><p>1.有利于减少内存碎片，提高存储效率</p>
<ul>
<li>在各个header的定义中使用了<strong>attribute</strong> ((packed))，是为了让编译器以<strong>紧凑模式</strong>来分配内存。如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。<strong>这样利于获取header字段，提高性能</strong>。</li>
</ul>
</li>
<li><p>2.常数复杂度获取字符串长度</p>
<ul>
<li>C语言源生的获取字符串长度的方式是遍历整个char数组，因此复杂度为O(N)，SDS采用len字段记录长度，且header和char数组紧凑排列，获取的复杂度为O(1)。设置和更新SDS长度的工作是由SDS的api在执行时<strong>自动完成</strong>的。</li>
</ul>
</li>
<li><p>3.杜绝缓冲区溢出</p>
<ul>
<li>C语言字符串不记录自身长度，也容易造成缓冲区溢出。而当SDS对自身字符串进行修改时，API会先检查SDS的剩余空间是否满足需要（获取alloc减len），如果不满足，则会先拓展空间，再执行API。</li>
</ul>
</li>
<li><p>4.空间预分配</p>
<ul>
<li><p>SDS在重新分配空间的时候，会预分配一些空间来作为冗余。当SDS的len属性长度小于1MB时，Redis会分配和len相同长度的free空间。至于为什么这样分配呢，上次用了len长度的空间，那么下次程序可能也会用len长度的空间，所以Redis就为你预分配这么多的空间。</p>
</li>
<li><p>但是当SDS的len属性长度大于1MB时，程序将多分配1M的未使用空间。这个时候我在根据这种惯性预测来分配的话就有点得不偿失了。所以Redis是将1MB设为一个风险值，没过风险值你用多少我就给你多少，过了的话那这个风险值就是我能给你临界值。</p>
</li>
</ul>
</li>
<li><p>5.惰性空间释放</p>
<ul>
<li>Redis的内存回收采用惰性回收，即你把字符串变短了，那么多余的内存空间也不会立刻还给操作系统，先留着，用header的字段将其记录下来，以防接下来又要被使用呢。</li>
</ul>
</li>
<li><p>6.二进制安全</p>
<ul>
<li>因为’\0’字符串在SDS中没有意义，他作为结束符的任务已经被header字段给替代了，所以与c语言不一样的，SDS是二进制安全的。<h2 id="3-embstr"><a href="#3-embstr" class="headerlink" title="3 embstr"></a>3 embstr</h2></li>
</ul>
</li>
</ul>
<p>embstr编码是专门用来保存短字符串的一种优化编码方式，其实他和raw编码一样，底层都会使用SDS，只不过raw编码是调用两次内存分配函数分别创建redisObject和SDS，而embstr只调用一次内存分配函数来分配一块连续的空间，embstr编码的的redisObject和SDS是紧凑在一起的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2adb57eb7edab3562f560151c3c38894cef.png" alt=""></p>
<p>其优势是：</p>
<ul>
<li><p>embstr的创建只需分配一次内存，而raw为两次（一次为sds分配对象，另一次为objet分配对象，embstr省去了第一次）。</p>
</li>
<li><p>相对地，释放内存的次数也由两次变为一次。</p>
</li>
<li><p>embstr的objet和sds放在一起，更好地利用缓存带来的优势。</p>
</li>
</ul>
<p>不过很显然，紧凑型的方式只适合短字符串，长字符串占用空间太大，就没有优势了。</p>
<blockquote>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。否则采用raw编码的SDS来存储。这在3.0以上版本的Redis出现。</p>
</blockquote>
<blockquote>
<p>至于为什么是39?<br>embstr是一块连续的内存区域，由redisObject和sdshdr组成。其中redisObject占16个字节，当buf内的字符串长度是39时，sdshdr的大小为8+8+39+1=56，那一个字节是’\0’。加起来刚好64。 </p>
</blockquote>
<blockquote>
<p>从2.4版本开始，Redis开始使用jemalloc内存分配器。在这里可以简单理解，jemalloc会分配8，16，32，64等字节的内存。embstr中即便sdshdr的buf为空，最小空间占用也为16+8+8+1=33，所以jemalloc低三档的分配粒度无法满足embstr，最少也要分配64字节。故而当字符数小于39时，都会分配64字节。<strong>默认39就是这么来的</strong>。</p>
</blockquote>
<h2 id="4-双端链表-linkedlist"><a href="#4-双端链表-linkedlist" class="headerlink" title="4 双端链表 linkedlist"></a>4 双端链表 linkedlist</h2><p>C语言中没有内置链表结构，Redis构建了自己的链表实现。list的容量是2的32次方减1个元素，即最多有4294967295个元素数量。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d670404ad3811655092266b0d0c830362ac.png" alt=""></p>
<h3 id="4-1-链表的数据结构"><a href="#4-1-链表的数据结构" class="headerlink" title="4.1 链表的数据结构"></a>4.1 链表的数据结构</h3><p><img src="https://oscimg.oschina.net/oscnet/up-2f435501df72b60b23103eae103efddce78.png" alt=""></p>
<p><strong>列表的节点</strong>（注意不是列表的定义）定义如上，除了双向链表必须的前后指针外，为了实现通用性，支持不同类型数据的存储，Redis将节点类型的数据域定义为void *类型，从而模拟了“泛型”。<br>整个列表定义如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a1fe34a95b7cb4b1ece1b7719b9dd4c1086.png" alt=""></p>
<p>在链表结构中，Redis定义了三个字段和三个函数：</p>
<ul>
<li>字段：<ul>
<li>listNode *head;  // 指向链表的头结点</li>
<li>listNode *tail;    //  指向链表的尾节点</li>
<li>unsigned long len;  //  链表长度</li>
</ul>
</li>
<li>函数：<ul>
<li>void *(*dup)(void *ptr);    //  节点值复制函数，用于复制某个节点的值</li>
<li>void (*free)(void *ptr);    //  节点值释放函数，用于释放某个节点的值</li>
<li>int (*match)(void *ptr, void *key); // 节点值对比函数，用于对比节点的值和另一个输入值是否相等</li>
</ul>
</li>
</ul>
<h2 id="5-字典-dict"><a href="#5-字典-dict" class="headerlink" title="5 字典 dict"></a>5 字典 dict</h2><p>在Redis中，字典的结构可以简单归纳如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3f6ae07f99f50b0510198ece877358ec0d4.png" alt=""></p>
<h3 id="5-1-Dict的数据结构"><a href="#5-1-Dict的数据结构" class="headerlink" title="5.1 Dict的数据结构"></a>5.1 Dict的数据结构</h3><p>Redis定义了dictEntry、dictType、dictht和dict四个结构体来实现哈希表的功能。它们具体定义如下：</p>
<h4 id="5-1-1-dictEntry结构体"><a href="#5-1-1-dictEntry结构体" class="headerlink" title="5.1.1 dictEntry结构体"></a>5.1.1 dictEntry结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 保存键值（key - value）对的结构体，类似于STL的pair。*&#x2F;</span><br><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    &#x2F;&#x2F; 关键字key定义</span><br><span class="line">    void *key;  </span><br><span class="line">    &#x2F;&#x2F; 值value定义，只能存放一个被选中的成员</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;      </span><br><span class="line">        uint64_t u64;   </span><br><span class="line">        int64_t s64;    </span><br><span class="line">        double d;       </span><br><span class="line">    &#125; v;</span><br><span class="line">    &#x2F;&#x2F; 指向下一个键值对节点</span><br><span class="line">    struct dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-2-dictType结构体"><a href="#5-1-2-dictType结构体" class="headerlink" title="5.1.2 dictType结构体"></a>5.1.2 dictType结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 定义了字典操作的公共方法，类似于adlist.h文件中list的定义，将对节点的公共操作方法统一定义。搞不明白为什么要命名为dictType *&#x2F;</span><br><span class="line">typedef struct dictType &#123;</span><br><span class="line">    &#x2F;* hash方法，根据关键字计算哈希值 *&#x2F;</span><br><span class="line">    unsigned int (*hashFunction)(const void *key);</span><br><span class="line">    &#x2F;* 复制key *&#x2F;</span><br><span class="line">    void *(*keyDup)(void *privdata, const void *key);</span><br><span class="line">    &#x2F;* 复制value *&#x2F;</span><br><span class="line">    void *(*valDup)(void *privdata, const void *obj);</span><br><span class="line">    &#x2F;* 关键字比较方法 *&#x2F;</span><br><span class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</span><br><span class="line">    &#x2F;* 销毁key *&#x2F;</span><br><span class="line">    void (*keyDestructor)(void *privdata, void *key);</span><br><span class="line">    &#x2F;* 销毁value *&#x2F;</span><br><span class="line">    void (*valDestructor)(void *privdata, void *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-dictht结构体"><a href="#5-1-3-dictht结构体" class="headerlink" title="5.1.3 dictht结构体"></a>5.1.3 dictht结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 哈希表结构 *&#x2F;</span><br><span class="line">typedef struct dictht &#123;</span><br><span class="line">    &#x2F;&#x2F; 散列数组。</span><br><span class="line">    dictEntry **table;</span><br><span class="line">    &#x2F;&#x2F; 散列数组的长度</span><br><span class="line">    unsigned long size;</span><br><span class="line">    &#x2F;&#x2F; sizemask等于size减1</span><br><span class="line">    unsigned long sizemask;</span><br><span class="line">    &#x2F;&#x2F; 散列数组中已经被使用的节点数量</span><br><span class="line">    unsigned long used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-4-dict结构体"><a href="#5-1-4-dict结构体" class="headerlink" title="5.1.4 dict结构体"></a>5.1.4 dict结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 字典的主操作类，对dictht结构再次包装  *&#x2F;</span><br><span class="line">typedef struct dict &#123;</span><br><span class="line">    &#x2F;&#x2F; 字典类型</span><br><span class="line">    dictType *type;</span><br><span class="line">    &#x2F;&#x2F; 私有数据</span><br><span class="line">    void *privdata;</span><br><span class="line">    &#x2F;&#x2F; 一个字典中有两个哈希表</span><br><span class="line">    dictht ht[2];</span><br><span class="line">    &#x2F;&#x2F;rehash的标记，rehashidx&#x3D;&#x3D;-1，表示没在进行rehash</span><br><span class="line">    long rehashidx; </span><br><span class="line">    &#x2F;&#x2F; 当前正在使用的迭代器的数量</span><br><span class="line">    int iterators; </span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-5-dict结构总结"><a href="#5-1-5-dict结构总结" class="headerlink" title="5.1.5 dict结构总结"></a>5.1.5 dict结构总结</h4><p>上面的结构体如果看得你头昏脑胀，没有关系，下面两张图让你理清他们的关系：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-713ec9ca17f9f0c789e9b94986d7ee907a0.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-53481663c1f1a2a56aebcc0edb1c2aa0daa.png" alt=""></p>
<blockquote>
<p>可以很清楚的看到，通过“拉链法”来解决冲突问题的，dictEntry结构体的*next指针指向了其拉链列表的下一个节点。</p>
</blockquote>
<ul>
<li><p>上图中，dict是字典的包装对象，居于最外层。</p>
</li>
<li><p>ht[2]是包含两个项的哈希表的数组，一般情况下，只使用h[0]，h[1]只有在rehash的时候才会使用</p>
</li>
</ul>
<ul>
<li><p>dictht是哈希表的结构，他除了一个数组table用来存放键值对以外，还有used字段表示目前已有键值对，size表示数组大小，sizemark=size-1，用来hash索引。</p>
</li>
<li><p>dictType是类型特定函数，上图中从上到下，依次是：</p>
<ol>
<li>HashFunction  计算哈希值的函数</li>
<li>KeyDup       复制键的函数</li>
<li>ValDup          复制值的函数</li>
<li>KeyCompare    对比键的函数</li>
<li>KeyDestructor   销毁键的函数</li>
<li>ValDestructor    销毁值的函数</li>
</ol>
</li>
</ul>
<h3 id="5-2-dict的哈希算法"><a href="#5-2-dict的哈希算法" class="headerlink" title="5.2 dict的哈希算法"></a>5.2 dict的哈希算法</h3><p>Redis提供了三种不同的散列函数，分别是：</p>
<ul>
<li>使用Thomas Wang’s 32 bit Mix哈希算法，对一个整型进行哈希，该方法在dictIntHashFunction函数中实现。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned int dictIntHashFunction(unsigned int key)      &#x2F;&#x2F;用于计算int整型哈希值的哈希函数</span><br><span class="line">&#123;</span><br><span class="line">	key +&#x3D; ~(key &lt;&lt; 15);</span><br><span class="line">	key ^&#x3D;  (key &gt;&gt; 10);</span><br><span class="line">	key +&#x3D;  (key &lt;&lt; 3);</span><br><span class="line">	key ^&#x3D;  (key &gt;&gt; 6);</span><br><span class="line">	key +&#x3D; ~(key &lt;&lt; 11);</span><br><span class="line">	key ^&#x3D;  (key &gt;&gt; 16);</span><br><span class="line">	return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用MurmurHash2哈希算法对字符串进行哈希，该方法在dictGenHashFunction函数中实现。(当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis用MurmurHash2算法来计算哈希值，能产生32-bit或64-bit哈希值。)  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">unsigned int dictGenHashFunction(const void *key, int len) &#123;  &#x2F;&#x2F;用于计算字符串的哈希值的哈希函数</span><br><span class="line">	&#x2F;&#x2F;m和r这两个值用于计算哈希值，只是因为效果好。</span><br><span class="line">	uint32_t seed &#x3D; dict_hash_function_seed;</span><br><span class="line">	const uint32_t m &#x3D; 0x5bd1e995;</span><br><span class="line">	const int r &#x3D; 24;</span><br><span class="line">	&#x2F;* Initialize the hash to a &#39;random&#39; value *&#x2F;</span><br><span class="line">	uint32_t h &#x3D; seed ^ len;    &#x2F;&#x2F;初始化</span><br><span class="line">	&#x2F;* Mix 4 bytes at a time into the hash *&#x2F;</span><br><span class="line">	const unsigned char *data &#x3D; (const unsigned char *)key;</span><br><span class="line">	&#x2F;&#x2F;将字符串key每四个一组看成uint32_t类型，进行运算的到h</span><br><span class="line">	while(len &gt;&#x3D; 4) &#123;</span><br><span class="line">		uint32_t k &#x3D; *(uint32_t*)data;</span><br><span class="line">		k *&#x3D; m;</span><br><span class="line">		k ^&#x3D; k &gt;&gt; r;</span><br><span class="line">		k *&#x3D; m;</span><br><span class="line">		h *&#x3D; m;</span><br><span class="line">		h ^&#x3D; k;</span><br><span class="line">		data +&#x3D; 4;</span><br><span class="line">		len -&#x3D; 4;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;* Handle the last few bytes of the input array  *&#x2F;</span><br><span class="line">	switch(len) &#123;</span><br><span class="line">	case 3: h ^&#x3D; data[2] &lt;&lt; 16;</span><br><span class="line">	case 2: h ^&#x3D; data[1] &lt;&lt; 8;</span><br><span class="line">	case 1: h ^&#x3D; data[0]; h *&#x3D; m;</span><br><span class="line">	&#125;;</span><br><span class="line">	&#x2F;* Do a few final mixes of the hash to ensure the last few</span><br><span class="line">	 * bytes are well-incorporated. *&#x2F;</span><br><span class="line">	h ^&#x3D; h &gt;&gt; 13;</span><br><span class="line">	h *&#x3D; m;</span><br><span class="line">	h ^&#x3D; h &gt;&gt; 15;</span><br><span class="line">	return (unsigned int)h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在dictGenCaseHashFunction函数中提供了一种比较简单的djb哈希算法，对字符串进行哈希。（djb哈希算法，算法的思想是利用字符串中的ascii码值与一个随机seed，通过len次变换，得到最后的hash值。）  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) &#123;   &#x2F;&#x2F;用于计算字符串的哈希值的哈希函数</span><br><span class="line">	unsigned int hash &#x3D; (unsigned int)dict_hash_function_seed;</span><br><span class="line"></span><br><span class="line">	while (len--)</span><br><span class="line">		hash &#x3D; ((hash &lt;&lt; 5) + hash) + (tolower(*buf++)); &#x2F;* hash * 33 + c *&#x2F;</span><br><span class="line">	return hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-3-dict的rehash"><a href="#5-3-dict的rehash" class="headerlink" title="5.3 dict的rehash"></a>5.3 dict的rehash</h3><p>当哈希表的大小不能满足需求，就可能会有两个或者以上数量的键被分配到了哈希表数组上的同一个索引上，于是就发生冲突（collision），在Redis中解决冲突的办法我们提到过是拉链法（separate chaining）。</p>
<p>但是我们仍然需要尽可能避免冲突，希望哈希表的负载因子（load factor），维持在一个合理的范围之内，就需要对哈希表进行扩展或收缩。</p>
<p>Rehsh会根据负载因子（load_factor = ht[0].used/ht[0].size）调整，当满足如下任意条件时，哈希表会rehash拓展：</p>
<ol>
<li>在服务器没有执行BGSAVE或BGREWRITEAOF，即没有持久化数据的时候，如果负载因子大于等于1</li>
<li>在服务器正在执行BGSAVE或BGREWRITEAOF时，如果负载因子大于等于5</li>
</ol>
<p>Rehash扩展有三个步骤:</p>
<ol>
<li>扩展备用的ht[1]，将它的容量扩张到<strong>第一个大于ht[0].used*2的 2的n次方</strong></li>
<li>将ht[0]的值重新经过hash索引之后迁移到ht[1]上。</li>
<li>释放ht[0]，将ht[1]设为ht[0]，创建新的空表ht[1]。<blockquote>
<p>注意：当负载因子小于0.1时，进行收缩操作，步骤将上述三步中的<strong>大于</strong>变为<strong>小于</strong>就是</p>
</blockquote>
</li>
</ol>
<h4 id="5-3-1-Rehash是渐进式的"><a href="#5-3-1-Rehash是渐进式的" class="headerlink" title="5.3.1 Rehash是渐进式的"></a>5.3.1 Rehash是渐进式的</h4><p> Rehash不是一步完成的，而是在操作过程中渐进式的。字典维持一个<strong>索引计数器rehashidx</strong>用来记录当前正在操作的索引，从ht[0]的0号索引上开始，<strong>一个项一个项的迁移到ht[1]</strong>，直到完成所有迁移，rehashidx变成-1。</p>
<p> 在rehash期间，所有新增字段添加在ht[1]中，而删除，更新操作会在两个表上同时进行。查找时先找ht[0]，再找ht[1]。</p>
<h2 id="6-跳跃表-skiplist"><a href="#6-跳跃表-skiplist" class="headerlink" title="6 跳跃表 skiplist"></a>6 跳跃表 skiplist</h2><p>跳跃表是有序集合zset的底层实现之一（另一个是压缩列表），当元素数量比较多，或者元素成员是比较长的字符串时，底层实现采用跳跃表。</p>
<p>跳跃表是一种<strong>有序数据结构</strong>，他在一个节点中维持多个指向其他节点的指针</p>
<p>跳跃表的<strong>平均复杂度为O(logN)，最坏为O(N)</strong>，其效率可以和平衡树相媲美，而且跟<strong>平衡树</strong>相比，<strong>实现简单</strong>；</p>
<h3 id="6-1-平衡的跳跃表"><a href="#6-1-平衡的跳跃表" class="headerlink" title="6.1 平衡的跳跃表"></a>6.1 平衡的跳跃表</h3><p><img src="https://oscimg.oschina.net/oscnet/up-417f68c4ab9f1d7ceb35303dee800dc5c89.png" alt=""></p>
<p>如图：<strong>每一个竖列其实是一个节点</strong>。如果能通过在节点中维持多个指向不同节点的指针（比如node4（值为21）就有三个指针，分别指向node5（33），node6（37），node8（55）），那么就会得到一个平衡的跳跃表。</p>
<p>在平衡的跳跃表中是左右对称的，node2两层，node4三层，node8四层。这样查到某一个节点的复杂度都为O(logN)：</p>
<ul>
<li>比如要查46，可以走L4到55，再用55的后退指针得到46。</li>
<li>比如要查37，先走L2层到21，再前进一步得到33。</li>
</ul>
<p>可以看到，上述表中，找到任何一个节点，时间复杂度<strong>不超过两次跳跃</strong>。</p>
<p><strong>但是，跳跃表最难的，就是保持平衡，维持平衡的跳跃表难度要大于维持平衡的二叉树。故而易于实现的，是实现<em>概率平衡<em>，而不是</em>强制平衡</em></strong></p>
<h4 id="6-1-1-跳跃表的查询"><a href="#6-1-1-跳跃表的查询" class="headerlink" title="6.1.1 跳跃表的查询"></a>6.1.1 跳跃表的查询</h4><p>跳跃表的查询是从顶层往下找，那么会先从第顶层开始找，方式就是循环比较，如过顶层节点的下一个节点为空说明到达末尾，会跳到第二层，继续遍历，直到找到对应节点。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f87590f2742d68eabeebbcd26f5c44fe8f8.png" alt=""></p>
<p>例子：查找元素 117</p>
<ol>
<li>比较 21， 比 21 大，且21有后继，向后面找</li>
<li>比较 37, 比 37大，且37节点同层没有后继了，则从 37 的下面一层开始找</li>
<li>比较 71, 比 71 大，且71节点同层没有后继了，则从 71 的下面一层开始找</li>
<li>比较 85， 比 85 大，且85有后继，向后面找</li>
<li>比较 117， 等于 117， 找到了节点。</li>
</ol>
<h4 id="6-1-2-跳表的删除"><a href="#6-1-2-跳表的删除" class="headerlink" title="6.1.2 跳表的删除"></a>6.1.2 跳表的删除</h4><p>使用标准的 delete from list 方法删除该节点。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3b0a0c32dfd79ae06682a776c19c90234d3.png" alt=""></p>
<h3 id="6-2-Redis中的跳跃表的实现"><a href="#6-2-Redis中的跳跃表的实现" class="headerlink" title="6.2 Redis中的跳跃表的实现"></a>6.2 Redis中的跳跃表的实现</h3><p>为了尽可能的维持理想的跳跃表，Redis根据<strong>幂次定律</strong>来使跳跃表尽可能的平衡，我们先看Redis中跳跃表和跳跃表<strong>节点</strong>的结构：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-70e4d2aeab504a37e26ac2fcbe36f60faa1.png" alt=""></p>
<p>我们逐个分析</p>
<ul>
<li><p>zskiplistNode 表示跳跃表节点结构</p>
<ul>
<li>ele是个SDS，是有序集合的值element。</li>
<li>Score是double结构，存储分数值。</li>
<li>Backward，后退指针，指向列表前一个node。</li>
<li>Level [ ]数组，表示一个节点可以有多个层。<ul>
<li>数组里面的项是zskiplistLevel结构，可以看到，每一层都有一个跳跃指针forward。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-4b6dcf80fa31562f83545c064df02e16302.png" alt=""></li>
<li>跨度span，顾名思义，就是用来记录跨度的，相邻的节点跨度为1。</li>
<li>注意：跨度的用处是用来计算某个节点在跳跃表中的排位的，zset的排序按score从小到大排序。比如我查找到node7，通过将沿途的<strong>所有跨度累加</strong>，我们可以得到其排在列表中的序列。</li>
</ul>
</li>
</ul>
</li>
<li><p>zskiplist 表示跳跃表结构</p>
<ul>
<li>zskiplist中有指向整个跳跃表两端的head指针和tail指针</li>
<li>记录跳跃表长度的leng字段。</li>
<li><strong>Int型的level用来记录目前整个跳跃表中最高的层数</strong>。</li>
</ul>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-7aa4b36237430d0296ff16d8d80d656494a.png" alt=""></p>
<h3 id="6-3-一般情况下维持平衡跳跃表的实现"><a href="#6-3-一般情况下维持平衡跳跃表的实现" class="headerlink" title="6.3 一般情况下维持平衡跳跃表的实现"></a>6.3 一般情况下维持平衡跳跃表的实现</h3><ol>
<li>在跳跃表中插入一个新的节点时，程序需要确定两个要素：该节点的位置，以及层数</li>
<li>因为有序集合按照score排序，故而位置可以按照score比出，确定位置。</li>
<li>确定了位置后，再确定node的层数，可以采用抛硬币的方式，一次正面，层数+1，直到反面出现为止。因为抛硬币会使层数L的值满足参数为 p = 1/2 的几何分布，在数量足够大时，可以近似平衡。</li>
<li>用抛硬币的方式，可以使level+1的概率为2分之一，也就是说，k层节点的数量是k+1层的1/2 ，你可以把它看成是一个二叉树。</li>
</ol>
<h3 id="6-4-Redis维持平衡跳跃表的实现"><a href="#6-4-Redis维持平衡跳跃表的实现" class="headerlink" title="6.4 Redis维持平衡跳跃表的实现"></a>6.4 Redis维持平衡跳跃表的实现</h3><p>与上述抛硬币的方式不同，Redis尽可能去掉不确定性，根据幂次定律维持一个尽可能理想的跳跃表（即节点数尽可能大时，整个链表尽可能平衡。）</p>
<h4 id="6-4-1-幂次定律"><a href="#6-4-1-幂次定律" class="headerlink" title="6.4.1 幂次定律"></a>6.4.1 幂次定律</h4><ul>
<li>含义是：如果某件事的发生频率和它的某个属性成幂关系，那么这个频率就可以称之为符合幂次定律。</li>
<li>表现是：少数几个事件的发生频率占了整个发生频率的大部分， 而其余的大多数事件只占整个发生频率的一个小部分。</li>
<li>说人话版：<strong>越大的数，出现的概率越小</strong>。</li>
</ul>
<h4 id="6-4-2-实现算法"><a href="#6-4-2-实现算法" class="headerlink" title="6.4.2 实现算法"></a>6.4.2 实现算法</h4><ul>
<li><p>当Redis在跳跃表中插入一个新的节点时，程序需要确定两个要素：该节点的位置，以及层数</p>
</li>
<li><p>Redis的实现与一般维持平衡跳跃表的实现大同小异，Redis中跳跃表的层数也是在插入的时候确定，按照分数找好位置后，Redis会生成一个1-32的数作为层数。</p>
</li>
<li><p>Redis的level+1的概率是1/4,所以Redis的跳跃表是一个四叉树。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">level &#x3D; zslRandomLevel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面是 zslRandomLevel() 函数的具体实现：</span><br><span class="line">&#x2F;* Returns a random level for the new skiplist node we are going to create.</span><br><span class="line"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span><br><span class="line"> * (both inclusive), with a powerlaw-alike distribution where higher</span><br><span class="line"> * levels are less likely to be returned. *&#x2F;</span><br><span class="line"> &#x2F;&#x2F;这个函数返回一个随机值，范围在：1 到 ZSKIPLIST_MAXLEVEL 之间，最小值为 1。</span><br><span class="line">int zslRandomLevel(void) &#123;</span><br><span class="line">    int level &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;(random()&amp;0xFFFF 得到 &lt;&#x3D; 0xFFFF的随机数，这个随机数比ZSKIPLIST_P * 0xFFFF小的概率为ZSKIPLIST_P。</span><br><span class="line">    while ((random()&amp;0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))</span><br><span class="line">        level +&#x3D; 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;最大不会超过ZSKIPLIST_MAXLEVEL</span><br><span class="line">    return (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;每一次while为true的概率都为ZSKIPLIST_P，换个角度想就是level n的概率为 ZSKIPLIST_P ^ (n-1)。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ZSKIPLIST_P=0.25，所以Redis的跳跃表是一个四叉树。</p>
<h2 id="7-整数集合-intset"><a href="#7-整数集合-intset" class="headerlink" title="7 整数集合 intset"></a>7 整数集合 intset</h2><p>整数集合是set的底层实现之一，当一个集合中只包含整数值，并且元素数量不多时，redis使用整数集合作为set的底层实现。</p>
<h3 id="7-1-数据结构"><a href="#7-1-数据结构" class="headerlink" title="7.1 数据结构"></a>7.1 数据结构</h3><p><img src="https://oscimg.oschina.net/oscnet/up-504f3c5be7d45452af037a4ff1fa3a0087e.png" alt=""></p>
<ul>
<li>Encoding 存储编码方式</li>
<li>Length  inset的长度，即元素数量</li>
<li>Content   Int数组，用来保存元素，各个项在数组中按数值从小到大排序，不包含重复项</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-197396aea88a0d869af62e1fa24fc0b068f.png" alt=""></p>
<blockquote>
<p>注意：虽然content数组的结构是int8_t，但其实他不会存储任何int8_t类型的值，当encoding=INTSET_ENC_INT16，那么他存的就是int16_t。以此类推，还有int32和int64。</p>
</blockquote>
<h3 id="7-2-整数集合的升级"><a href="#7-2-整数集合的升级" class="headerlink" title="7.2 整数集合的升级"></a>7.2 整数集合的升级</h3><p>当在一个int16类型的整数集合中插入一个int32类型的值，整个集合的所有元素都会转换成32类型。<br>整个过程有三步：</p>
<ol>
<li><p>根据新元素的类型（比如int32），扩展整数集合底层数组的空间大小，并为新元素分配空间。</p>
</li>
<li><p>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</p>
</li>
<li><p>最后改变encoding的值，length+1。</p>
</li>
</ol>
<p>举个例子， 假设现在有一个<code>INTSET_ENC_INT16</code>编码的整数集合， 集合中包含三个 int16_t 类型的元素。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-527a9df97126e409ffd78f281302358fe4a.png" alt=""></p>
<p>因为每个元素都占用 16 位空间， 所以整数集合底层数组的大小为 3 * 16 = 48 位， 图 6-4 展示了整数集合的三个元素在这 48 位里的位置。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5337e299b492cee7a39513cf3672b48cd7d.png" alt=""></p>
<p>现在， 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面， 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长， 所以在将 65535 添加到整数集合之前， 程序需要先对整数集合进行升级。</p>
<p>升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。</p>
<p>整数集合目前有三个元素， 再加上新元素 65535 ， 整数集合需要分配四个元素的空间， 因为每个 int32_t 整数值需要占用 32 位空间， 所以在空间重分配之后， 底层数组的大小将是 32 * 4 = 128 位， 如图 6-5 所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d39ad394e9c97feee8c766d2ec7bf53685a.png" alt=""></p>
<p>虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 1 、 2 、 3 仍然是 int16_t 类型， 这些元素还保存在数组的前 48 位里面， 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 3 在 1 、 2 、 3 、 65535 四个元素中排名第三， 所以它将被移动到 contents 数组的索引 2 位置上， 也即是数组 64 位至 95位的空间内。因为元素 2 在 1 、 2 、 3 、 65535 四个元素中排名第二， 所以它将被移动到 contents 数组的索引 1 位置上， 也即是数组的 32 位至 63 位的空间内， 如图 6-7 所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7b54a434071d7d0d42a3e926621cdb02b88.png" alt=""></p>
<p>之后， 因为元素 1 在 1 、 2 、 3 、 65535 四个元素中排名第一， 所以它将被移动到 contents 数组的索引 0 位置上， 也即是数组的 0 位至 31位的空间内， 如图 6-8 所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-726879c870feb95bbdf5ff302348de545a3.png" alt=""></p>
<p>然后， 因为元素 65535 在 1 、 2 、 3 、 65535 四个元素中排名第四， 所以它将被添加到 contents 数组的索引 3 位置上， 也即是数组的 96 位至 127 位的空间内， 如图 6-9 所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dc660d12146cd03ff50fc5c1c6ff08083e6.png" alt=""></p>
<p>最后， 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 ， 并将 length 属性的值从 3 改为 4 ， 设置完成之后的整数集合如图 6-10 所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7b1384f5a3986181d02c59a30c8b1ab2be6.png" alt=""></p>
<blockquote>
<p>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
</blockquote>
<blockquote>
<p>注意，整数集合只支持升级操作，不支持<strong>降级操作</strong></p>
</blockquote>
<blockquote>
<p>升级之后新元素的摆放位置如何确定？因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 0 ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 length-1 ）。</li>
</ul>
</blockquote>
<h2 id="8-压缩列表-ziplist"><a href="#8-压缩列表-ziplist" class="headerlink" title="8 压缩列表 ziplist"></a>8 压缩列表 ziplist</h2><p>压缩列表是list和hash的底层实现之一，当一个列表只包含少量元素，并且每个元素要么就是小整数值，要么就是长度比较短的字符串，那么Redis使用ziplist作为列表实现。</p>
<p>压缩表是为了节约内存而开发的，压缩表可以包含任意个节点，每个节点保存一个字节数组（字符串）或一个整数值。</p>
<h3 id="8-1-压缩表数据结构"><a href="#8-1-压缩表数据结构" class="headerlink" title="8.1 压缩表数据结构"></a>8.1 压缩表数据结构</h3><p><img src="https://oscimg.oschina.net/oscnet/up-dcf94c09f6de184765b374036918756b9e1.png" alt=""></p>
<ul>
<li>Zlbytes 类型：uint32_t   记录整个压缩表占用的内存字节数，对压缩表进行内存重分配和或者计算zlend位置时被使用</li>
<li>Zltail_offset   类型：uint32_t    记录压缩列表尾节点entryN距离压缩列表的起始地址的字节数。用来快速确定表尾节点的地址。</li>
<li>Zllength   类型：uint16_t    若不超过uint16的极值65535，就是<strong>记录着压缩表节点的数量</strong>。否则，真实的节点数量需要遍历压缩表才能得出</li>
<li>Zlend   类型：uint8_t    特殊值0xFF（十进制255），用于标记表的末端。</li>
<li>Entry    char[]或uint     长度不定，节点的长度随保存的内容而改变。</li>
</ul>
<h3 id="8-2-压缩表节点的结构"><a href="#8-2-压缩表节点的结构" class="headerlink" title="8.2 压缩表节点的结构"></a>8.2 压缩表<strong>节点</strong>的结构</h3><p><img src="https://oscimg.oschina.net/oscnet/up-3c3b0793d2b96c8ea61d178eccfe64c1ec8.png" alt=""></p>
<ul>
<li>prevrawlen：前置节点的长度（以字节为单位）</li>
<li>prevrawlensize：存储 prevrawlen 的值所需的字节大小</li>
<li>len：当前节点的长度</li>
<li>lensize：存储 len 的值所需的字节大小</li>
<li>headersize：当前节点 header 的大小，等于 prevrawlensize + lensize</li>
<li>encoding：当前节点值所使用的编码类型</li>
<li>p：指向当前节点的指针</li>
</ul>
<p>虽然定义了这个结构体，但是Redis<strong>根本就没有使用</strong>zlentry结构来作为压缩列表中用来存储数据节点中的结构，这个结构总共在32位机占用了28个字节(32位机)，在64位机占用了32个字节。这不符合压缩列表的设计目的：提高内存的利用率。</p>
<p>ziplist在存储节点信息时，并没有将zlentry数据结构所有属性保存，而是做了简化。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ab3f09a0f2c6679b6087075e4f9ad585ec2.png" alt=""></p>
<p><strong>虽然在压缩列表中使用的是”压缩版”的zlentry结构，但是在对节点操作时，还是要将”压缩版” “翻译”到zlentry结构中，因为我们无法对着一串字符直接进行操作。</strong></p>
<p>因此，就有了下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Return a struct with all information about an entry. *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 将p指向的列表节点信息全部保存到zlentry中，并返回该结构</span><br><span class="line">static zlentry zipEntry(unsigned char *p) &#123;</span><br><span class="line">    zlentry e;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; e.prevrawlensize 保存着编码前一个节点的长度所需的字节数</span><br><span class="line">    &#x2F;&#x2F; prevrawlen 保存着前一个节点的长度</span><br><span class="line">    ZIP_DECODE_PREVLEN(p, e.prevrawlensize, e.prevrawlen);  &#x2F;&#x2F;恢复前驱节点的信息</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; p + e.prevrawlensize将指针移动到当前节点信息的起始地址</span><br><span class="line">    &#x2F;&#x2F; encoding保存当前节点的编码格式</span><br><span class="line">    &#x2F;&#x2F; lensize保存编码节点值长度所需的字节数</span><br><span class="line">    &#x2F;&#x2F; len保存这节点值的长度</span><br><span class="line">    ZIP_DECODE_LENGTH(p + e.prevrawlensize, e.encoding, e.lensize, e.len);  &#x2F;&#x2F;恢复当前节点的信息</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当前节点header的大小 &#x3D; lensize + prevrawlensize</span><br><span class="line">    e.headersize &#x3D; e.prevrawlensize + e.lensize;    </span><br><span class="line">    e.p &#x3D; p;    &#x2F;&#x2F;保存指针</span><br><span class="line">    return e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ZIP_DECODE_PREVLEN和ZIP_DECODE_LENGTH都是定义的两个宏，在ziplist.c文件中</span><br></pre></td></tr></table></figure>


<h4 id="8-2-1-prev-entry-len"><a href="#8-2-1-prev-entry-len" class="headerlink" title="8.2.1 prev_entry_len"></a>8.2.1 prev_entry_len</h4><p>prev_entry_len成员实际上就是zlentry结构中prevrawlensize(记录存储prevrawlen值的所需的字节个数)和prevrawlen(记录着上一个节点的长度)这两个成员的压缩版。</p>
<ul>
<li>如果前一节点的长度小于254（即2^8-1）字节，则pre_entry_len用一个字节记录其长度。</li>
<li>当前驱节点的长度大于等于255（即2^8-1）字节，那么prev_entry_len使用5个字节表示。<ul>
<li>并且用5个字节中的最高8位(最高1个字节)用 0xFE来标志prev_entry_len占用了5个字节，后四个字节才是真正保存前驱节点的长度值。</li>
</ul>
</li>
<li>pre_entry_len最大的用处是用来从后向前遍历，因为前一个节点的指针c = 当前节点指针p –pre_entry_len，可以快速往前上溯。</li>
</ul>
<blockquote>
<p>因为，对于访问的指针都是char 类型，它能访问的范围为1个字节，如果这个字节的大小等于0xFE，那么就会继续向后访问四个字节来获取前驱节点的长度，如果该字节的大小小于0xFE，那么该字节就是要获取的前驱节点的长度。因此这样就使prev_entry_len同时具有了prevrawlen和prevrawlensize的功能，而且更加节约内存。</p>
</blockquote>
<h4 id="8-2-2-encoding"><a href="#8-2-2-encoding" class="headerlink" title="8.2.2 encoding"></a>8.2.2 encoding</h4><p>prev_entry_len一样，encoding成员同样可以看做成zlentry结构中lensize（记录存储 len 所需的字节大小）和len（当前节点的长度）的压缩版。</p>
<p>Encoding记录了节点内容（value）的<strong>类型和长度</strong>。value可存的类型有两种，<strong>整数和字符串（字节数组）</strong>。Redis对字节数组和整数编码提供了一组宏定义，定义在ziplist.c中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Different encoding&#x2F;length possibilities *&#x2F;</span><br><span class="line">#define ZIP_STR_MASK 0xc0               &#x2F;&#x2F;1100 0000     字节数组的掩码</span><br><span class="line">#define ZIP_STR_06B (0 &lt;&lt; 6)            &#x2F;&#x2F;0000 0000</span><br><span class="line">#define ZIP_STR_14B (1 &lt;&lt; 6)            &#x2F;&#x2F;0100 0000</span><br><span class="line">#define ZIP_STR_32B (2 &lt;&lt; 6)            &#x2F;&#x2F;1000 0000</span><br><span class="line"></span><br><span class="line">#define ZIP_INT_MASK 0x30               &#x2F;&#x2F;0011 0000     整数的掩码</span><br><span class="line">#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4)       &#x2F;&#x2F;1100 0000</span><br><span class="line">#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4)       &#x2F;&#x2F;1101 0000</span><br><span class="line">#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4)       &#x2F;&#x2F;1110 0000</span><br><span class="line">#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4)       &#x2F;&#x2F;1111 0000</span><br><span class="line">#define ZIP_INT_8B 0xfe                 &#x2F;&#x2F;1111 1110</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;掩码个功能就是区分一个encoding是字节数组编码还是整数编码</span><br><span class="line">&#x2F;&#x2F;如果这个宏返回 1 就代表该enc是字节数组，如果是 0 就代表是整数的编码</span><br><span class="line">#define ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)</span><br></pre></td></tr></table></figure>

<p>上面这些常量被如下代码使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从ptr中取出节点信息，并将其保存在encoding、lensize和len中</span><br><span class="line">#define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do &#123;                         \</span><br><span class="line">    &#x2F;*从ptr数组中取出节点的编码格式并将其赋值给encoding*&#x2F;                                  \</span><br><span class="line">    ZIP_ENTRY_ENCODING((ptr), (encoding));                                          \</span><br><span class="line">    &#x2F;*如果是字符串编码格式*&#x2F;                                                            \</span><br><span class="line">    if ((encoding) &lt; ZIP_STR_MASK) &#123;                                                 \</span><br><span class="line">        if ((encoding) &#x3D;&#x3D; ZIP_STR_06B) &#123;   &#x2F;*6位字符串编码格式*&#x2F;                        \</span><br><span class="line">            (lensize) &#x3D; 1;                 &#x2F;*编码长度需要1个字节*&#x2F;                      \</span><br><span class="line">            (len) &#x3D; (ptr)[0] &amp; 0x3f;       &#x2F;*当前字节长度保存到len中*&#x2F;                  \</span><br><span class="line">        &#125; else if ((encoding) &#x3D;&#x3D; ZIP_STR_14B) &#123;    &#x2F;*14位字符串编码格式*&#x2F;               \</span><br><span class="line">            (lensize) &#x3D; 2;                 &#x2F;*编码长度需要2个字节*&#x2F;                      \</span><br><span class="line">            (len) &#x3D; (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1]; &#x2F;*当前字节长度保存到len中*&#x2F;    \</span><br><span class="line">        &#125; else if (encoding &#x3D;&#x3D; ZIP_STR_32B) &#123;   &#x2F;*32串编码格式*&#x2F;                       \</span><br><span class="line">            (lensize) &#x3D; 5;                   &#x2F;*编码长度需要5节*&#x2F;                        \</span><br><span class="line">            (len) &#x3D; ((ptr)[1] &lt;&lt; 24) |         &#x2F;*当前字节长度保存到len中*&#x2F;               \</span><br><span class="line">                    ((ptr)[2] &lt;&lt; 16) |                                                \</span><br><span class="line">                    ((ptr)[3] &lt;&lt;  8) |                                                \</span><br><span class="line">                    ((ptr)[4]);                                                       \</span><br><span class="line">        &#125; else &#123;                                                                      \</span><br><span class="line">            assert(NULL);                                                             \</span><br><span class="line">        &#125;                                                                             \</span><br><span class="line">    &#125; else &#123;    &#x2F;*整数编码格式*&#x2F;                                                        \</span><br><span class="line">        (lensize) &#x3D; 1;            &#x2F;*需要1个字节*&#x2F;                                      \</span><br><span class="line">        (len) &#x3D; zipIntSize(encoding);                                                 \</span><br><span class="line">    &#125;                                                                                 \</span><br><span class="line">&#125; while(0);</span><br></pre></td></tr></table></figure>

<p>看不懂没关系，简单归纳就是：</p>
<table>
<thead>
<tr>
<th align="center">编码格式</th>
<th align="center">value类型</th>
<th align="center">encoding长度</th>
<th align="center">value保存的值长度</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00xxxxxx</td>
<td align="center">字节数组</td>
<td align="center">1字节</td>
<td align="center">长度小于等于 2^6−1 字节</td>
<td align="center">encoding长8bit，后6个bit，最多承载数量2^6−1的数字，说明其最多能为长度为2^6−1的字节数组计数</td>
</tr>
<tr>
<td align="center">01xxxxxx xxxxxxxx</td>
<td align="center">字节数组</td>
<td align="center">2字节</td>
<td align="center">长度小于等于2^14−1字节</td>
<td align="center">encoding长16bit，后14个bit，最多承载数量2^14−1的数字，说明其最多能为长度为2^14−1的字节数组计数</td>
</tr>
<tr>
<td align="center">10—— xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx</td>
<td align="center">字节数组</td>
<td align="center">5字节</td>
<td align="center">长度小于等于2^32−1字节</td>
<td align="center">encoding长40bit，前两位bit10表示该encoding5字节，然后6bit留空，最后32个bit，最多承载数量2^32−1的数字，说明其最多能为长度为2^32−1的字节数组计数</td>
</tr>
<tr>
<td align="center">1100 0000</td>
<td align="center">整数</td>
<td align="center">1字节</td>
<td align="center">int16_t类型整数</td>
<td align="center">—–</td>
</tr>
<tr>
<td align="center">1101 0000</td>
<td align="center">整数</td>
<td align="center">1字节</td>
<td align="center">int32_t类型整数</td>
<td align="center">—–</td>
</tr>
<tr>
<td align="center">1110 0000</td>
<td align="center">整数</td>
<td align="center">1字节</td>
<td align="center">int64_t类型整数</td>
<td align="center">—–</td>
</tr>
<tr>
<td align="center">1111 0000</td>
<td align="center">整数</td>
<td align="center">1字节</td>
<td align="center">24 bit 有符号整数</td>
<td align="center">—–</td>
</tr>
<tr>
<td align="center">1111 1110</td>
<td align="center">整数</td>
<td align="center">1字节</td>
<td align="center">8 bit 有符号整数</td>
<td align="center">—–</td>
</tr>
<tr>
<td align="center">1111 xxxx</td>
<td align="center">整数</td>
<td align="center">1字节</td>
<td align="center">4 bit 无符号整数,[0,12]</td>
<td align="center">encoding为该值的节点是没有value的，因为xxxx已经足够存储0-12的值了，<strong>value直接存在encoding中</strong>。xxxx首先最小值应该是0001（0000已经被占用），最大值应该是1101（1110与1111均已经被占用），因此，可被编码的值实际上只能是 1 至 13，由于还需要减1，所以实际只能编码[0,12]，至于减1的理由，我的理解是方便编码0。</td>
</tr>
</tbody></table>
<h4 id="8-2-3-value"><a href="#8-2-3-value" class="headerlink" title="8.2.3 value"></a>8.2.3 value</h4><p>根据encoding来保存字节数组或整数。我们举例说明：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-460ea93659f8a9216f91160daf7b0d2ee92.png" alt=""></p>
<p>假设这是一个压缩列表的头两个节点，因此：</p>
<ul>
<li>第一个节点信息：<ul>
<li>prev_entry_len成员值为0，占1字节空间，因为前驱节点长度为0，小于254。</li>
<li>encoding成员值为0000 0101，最高两位为00，因此encoding占1个字节且可以算出value为字符数组，根据剩下的6位00 0101，可以算出value长度为5字节。</li>
<li>value成员根据encoding成员算出长度为5字节，因此，会读5个字节的字节数组，值为”Redis”。</li>
</ul>
</li>
<li>第二个节点信息：<ul>
<li>prev_entry_len成员值为0x07，占一个字节，因为前驱节点长度为7，小于254。<br>encoding成员编码值为1101 0000，最高两位为11，因此encoding占1个字节且可以算出value为整数，在根据encoding编码可以得出value值为占32位，4个字节int32_t类型的有符号整数。</li>
<li>value成员根据encoding编码，读出4个字节的整数，值为 1234。</li>
</ul>
</li>
<li>压缩列表的表头信息：<ul>
<li>zlbytes为整个压缩列表所占字节数24。</li>
<li>zltail_offset为从压缩列表的首地址到最后一个entry节点的偏移量17。</li>
<li>zlength为节点个数2。</li>
<li>zlend为常数255(0xFF)。</li>
</ul>
</li>
</ul>
<h3 id="8-3-连锁更新"><a href="#8-3-连锁更新" class="headerlink" title="8.3 连锁更新"></a>8.3 连锁更新</h3><p>因为有如下的前提，所以才会出现连锁更新的场景：</p>
<ul>
<li><p>如果前驱节点的长度小于254（2^8-1），那么prev_entry_len成员需要用1字节长度来保存这个长度值。</p>
</li>
<li><p>如果前驱节点的长度大于等于254（2^8-1），那么prev_entry_len成员需要用5字节长度来保存这个长度值。</p>
</li>
</ul>
<p>如果在一个压缩列表中，有<strong>多个连续、长度介于250字节到253字节之间的节点</strong>，因此记录这些节点只需要1个字节的prev_entry_len，如果要插入一个长度<strong>大于等于254的新节点e0</strong>到压缩列表的头部，然而原来的头节点e1的prev_entry_len成员长度仅仅为1个字节，无法保存新节点的长度，这会使得e1的prev_entry_len必须扩容到5个节点。e1的长度本来就在[250,254]之间，一扩容又大于了254，使得e2又要扩容，以此类推，引发连锁扩展。</p>
<p>反之，也会引发连锁收缩。</p>
<blockquote>
<p>因为ziplist是链表，他们节点之间不是紧挨着的，所以重分配的代价并不是特别大。</p>
</blockquote>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhihu.com/question/25624589/answer/61382148" target="_blank" rel="noopener" title="为什么redis小等于39字节的字符串是embstr编码，大于39是raw编码？">为什么redis小等于39字节的字符串是embstr编码，大于39是raw编码？</a></p>
<p><a href="https://blog.csdn.net/xiejingfa/article/details/51018337" target="_blank" rel="noopener" title="【Redis源码剖析】 - Redis内置数据结构之字典dict">【Redis源码剖析】 - Redis内置数据结构之字典dict</a></p>
<p><a href="https://blog.csdn.net/kisimple/article/details/38706729" target="_blank" rel="noopener" title="SkipList 浅析">SkipList 浅析</a></p>
<p><a href="https://www.jianshu.com/p/c21a1d51a33b" target="_blank" rel="noopener" title="整数集合">整数集合</a></p>
<p><a href="http://blog.csdn.net/men_wen/article/details/70176753" target="_blank" rel="noopener" title="Redis源码剖析和注释（六）--- 压缩列表(ziplist)">Redis源码剖析和注释（六）— 压缩列表(ziplist)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-hand-o-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-hand-o-right" aria-label="accessibility.next_page"></i></a>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">93</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">457.2k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
