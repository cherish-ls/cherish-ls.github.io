<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper%E7%AE%80%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper%E7%AE%80%E8%AE%BA/" itemprop="url">分布式协调服务zookeeper简论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-20T21:49:46+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/" itemprop="url" rel="index">
                    <span itemprop="name">ZooKeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper%E7%AE%80%E8%AE%BA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/20/分布式协调服务zookeeper简论/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  5.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  19
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ps.本文为《从Paxos到Zookeeper  分布式一致性原理与实践》笔记之一</p>
<h1 id="1-ZooKeeper"><a href="#1-ZooKeeper" class="headerlink" title="1 ZooKeeper"></a>1 ZooKeeper</h1><ul>
<li><p>ZooKeeper曾是Apache Hadoop的一个子项目，是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、master选举、分布式锁和分布式队列等。</p>
</li>
<li><p>ZooKeeper是Google的Chubby一个开源的实现，由雅虎创建，是Hadoop和Hbase的重要组件。</p>
</li>
<li><p>ZooKeeper没有直接采用paxos算法，而是采用了一种被称为ZAB（Zookeeper Atomic Broadcast）的一致性协议</p>
</li>
<li><p>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>
</li>
</ul>
<h2 id="1-1-ZooKeeper可以保证如下分布式一致性特性"><a href="#1-1-ZooKeeper可以保证如下分布式一致性特性" class="headerlink" title="1.1 ZooKeeper可以保证如下分布式一致性特性"></a>1.1 ZooKeeper可以保证如下分布式一致性特性</h2><ol>
<li><p>顺序一致性：从同一个客户端发起的事务请求，最终将会严格地按照其发起顺序被应用到Zookeeper中；</p>
</li>
<li><p>原子性：所有事务的请求结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么在整个集群中所有机器上都成功应用了某一个事务，要么都没有应用，没有中间状态；</p>
</li>
<li><p>单一视图：无论客户端连接的是哪个Zookeeper服务器，其看到的服务端数据模型都是一致的。</p>
</li>
<li><p>可靠性：一旦服务端成功应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</p>
</li>
<li><p>实时性：Zookeeper仅仅保证在一定的时间内，客户端最终一定能够从服务端上读到最终的数据状态。</p>
</li>
</ol>
<h2 id="1-2-ZooKeeper的四个设计目标"><a href="#1-2-ZooKeeper的四个设计目标" class="headerlink" title="1.2 ZooKeeper的四个设计目标"></a>1.2 ZooKeeper的四个设计目标</h2><p>zk致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力（主要是写操作）的分布式协议，最后者能使得zk能实现一些复杂的同步语义。</p>
<ol>
<li><p>简单的数据模型：能够通过一个共享的、树型结构的名字空间来进行相互协调。这里是树形结构的名字空间是指zk服务器内存中的一个数据结构，由其一系列的ZNode数据节点组成，他们的层级关系就像文件系统的目录结构，不过zk将其全量数据存储在内存中，以达到高吞吐。</p>
</li>
<li><p>可以构建集群：zk集群通常由一组机器组成，集群中的每台机器都会在内存中维护当前的服务器状态，并且每台机器之间都保持着通信。集群中只要超过一半的机器可以正常工作，zk就可以对外提供服务。zk客户端会选择和集群中任意一台机器共同来创建一个tcp链接，如果连接断开，客户端会自动连接到服务机器的其他机器。</p>
</li>
<li><p>顺序访问：对于来自客户端的每个更新请求，Zookeeper都会分配一个全局唯一的递增编号，这个编号反映了所有事务操作的先后顺序。</p>
</li>
<li><p>高性能：Zookeeper将全量数据存储在内存中，并直接服务于客户端的所有非事务请求，因此它尤其适用于以读操作为主的应用场景。</p>
</li>
</ol>
<h1 id="2-ZooKeeper的基本概念"><a href="#2-ZooKeeper的基本概念" class="headerlink" title="2 ZooKeeper的基本概念"></a>2 ZooKeeper的基本概念</h1><h2 id="2-1-集群角色"><a href="#2-1-集群角色" class="headerlink" title="2.1 集群角色"></a>2.1 集群角色</h2><ul>
<li>最典型的集群就是Master/Slave模式（主备模式），此情况下把所有能够处理写操作的机器称为Master机器，把所有通过异步复制方式获取最新数据，并提供读服务的机器为Slave机器。  </li>
<li>Zookeeper不采用主备模式，它引入了Leader、Follower、Observer三种角色，Zookeeper集群中的所有机器通过Leaser选举过程来选定一台被称为Leader的机器，Leader服务器为客户端提供读和写服务，Follower和Observer提供读服务，但是Observer不参与Leader选举过程，不参与写操作的”过半写成功”策略，Observer可以在不影响写性能的情况下提升集群的性能。</li>
</ul>
<p>leader：  是整个集群工作机制中的核心，其主要工作有：</p>
<ol>
<li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性。</li>
<li>集群内部各服务器的调度者。</li>
</ol>
<p>follower：是zookeeper集群状态的跟随者，其主要工作是：</p>
<ol>
<li>处理客户端的非事务请求，转发事务请求给leader服务器。</li>
<li>参与事务请求proposal的投票</li>
<li>参与leader选举投票</li>
</ol>
<p>observer：和follower唯一的区别在于，observer服务器只提供非事务服务，不参与任何形式的投票，包括事务请求proposal的投票和leader选举投票。</p>
<ol>
<li>通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</li>
</ol>
<h2 id="2-2-会话"><a href="#2-2-会话" class="headerlink" title="2.2 会话"></a>2.2 会话</h2><ul>
<li>指客户端会话，一个客户端连接是指客户端和服务端之间的一个TCP长连接，Zookeeper对外的服务端口默认为2181，客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接受来自服务器的Watch事件通知。</li>
</ul>
<h2 id="2-3-数据节点"><a href="#2-3-数据节点" class="headerlink" title="2.3 数据节点"></a>2.3 数据节点</h2><ul>
<li>我们常说的节点指的是集群中的机器节点，zk中节点有两类，第一类指构成集群的机器，称为机器节点，第二类是指数据模型中的数据单元，称为数据节点-Znode，Zookeeper将所有数据存储在内存中，数据模型是一棵树，由斜杠/进行分割的路径，就是一个ZNode，如/foo/path1，每个ZNode都会保存自己的数据内存，同时还会保存一些列属性信息。</li>
<li>ZNode分为持久节点和临时节点两类，持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上，而临时节点的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</li>
<li>另外，Zookeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点后面追加一个整形数字，其是由父节点维护的自增数字。</li>
<li>临时，持久和顺序，如此，数据节点一共有四种类型：<ol>
<li>持久节点（PERSISTENT）<ul>
<li>zk中最常见的一种节点类型。除非主动删除，否则一直保留</li>
</ul>
</li>
<li>持久顺序节点（PERSISTENT_SEQUENTIAL）<ul>
<li>基本和持久节点一致，额外的特性表现在顺序性上。持久顺序节点在创建节点的时候，zk会自动给它的名字加上数字后缀，表示在该父节点下的创建顺序，后缀上线是整型最大值。</li>
</ul>
</li>
<li>临时节点（EPHEMERAL）<ul>
<li>临时节点的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</li>
</ul>
</li>
<li>临时顺序节点（EPHEMERAL_SEQUENTIAL）<ul>
<li>同临时节点，再加上顺序特性。<h2 id="2-4-stat"><a href="#2-4-stat" class="headerlink" title="2.4 stat"></a>2.4 stat</h2></li>
</ul>
</li>
</ol>
</li>
<li>数据节点中除了有数据内容外，还有一个stat对象来记录节点的状态信息：<br>  <img src="https://oscimg.oschina.net/oscnet/d18c5024bebdf96b7546ea05d385eb5ec6e.jpg" alt=""><br>  <img src="https://oscimg.oschina.net/oscnet/40cc46a32f2828bd4c8d995e4015c780691.jpg" alt=""><h2 id="2-5-版本"><a href="#2-5-版本" class="headerlink" title="2.5 版本"></a>2.5 版本</h2></li>
<li>对于每个ZNode，Zookeeper都会为其维护一个叫作Stat的数据结构，Stat记录了这个ZNode的三个数据版本，分别是version（当前ZNode的版本）、cversion（当前ZNode子节点的版本）、aversion（当前ZNode的ACL版本）。</li>
<li>类似于乐观锁和cas，保证原子性操作<h2 id="2-6-事务操作"><a href="#2-6-事务操作" class="headerlink" title="2.6 事务操作"></a>2.6 事务操作</h2></li>
<li>在ZooKeeper中，能改变ZooKeeper服务器状态的操作称为事务操作。一般包括数据节点创建与删除、数据内容更新和客户端会话创建与失效等操作。对应每一个事务请求，ZooKeeper都会为其分配一个全局唯一的事务ID，用ZXID表示，通常是一个64位的数字。每一个ZXID对应一次更新操作，从这些ZXID中可以间接地识别出ZooKeeper处理这些事务操作请求的全局顺序。<h2 id="2-7-watcher"><a href="#2-7-watcher" class="headerlink" title="2.7 watcher"></a>2.7 watcher</h2></li>
<li>watcher是事件监听器，Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，Zookeeper服务端会将事件通知到感兴趣的客户端。该机制是zk实现分布式协调服务的重要特性。</li>
<li>其逻辑如下图：<br>  <img src="https://oscimg.oschina.net/oscnet/a30aeb692c39f7d5b0824afe7befd31a31b.jpg" alt=""></li>
<li>当客户端向服务端注册watcher时，也会将watcher对象存储在客户端的watcherManager中，当服务端出发watcher时间后，向客户端发送通知，客户端从watcherManager中去处watcher对象来执行回调逻辑。<h2 id="2-8-ACL"><a href="#2-8-ACL" class="headerlink" title="2.8 ACL"></a>2.8 ACL</h2>Zookeeper采用ACL（Access Control Lists）策略来进行权限控制，类似于unix文件系统的权限控制，</li>
<li>权限模式<ul>
<li>ip模式<ul>
<li>通过ip地址粒度来进行权限控制。</li>
</ul>
</li>
<li>digest<ul>
<li>类似于username:password形式配置权限标识来控制，</li>
</ul>
</li>
<li>world<ul>
<li>即任何人都可以访问</li>
</ul>
</li>
<li>super<ul>
<li>一种特殊的digest模式，只不过权限是超级用户。</li>
</ul>
</li>
</ul>
</li>
<li>权限：<ul>
<li>CREATE：创建子节点的权限。</li>
<li>READ：获取节点数据和子节点列表的权限。</li>
<li>WRITE：更新节点数据的权限。</li>
<li>DELETE：删除子节点的权限。</li>
<li>ADMIN：设置节点ACL的权限。</li>
</ul>
</li>
<li>值得注意的是，CREATE和READ都是针对子节点的权限控制。</li>
</ul>
<h1 id="3-ZAB协议"><a href="#3-ZAB协议" class="headerlink" title="3 ZAB协议"></a>3 ZAB协议</h1><p>见文章《ZAB协议分析》一文</p>
<h1 id="4-Zookeeper应用场景"><a href="#4-Zookeeper应用场景" class="headerlink" title="4 Zookeeper应用场景"></a>4 Zookeeper应用场景</h1><h2 id="4-1-数据发布-订阅"><a href="#4-1-数据发布-订阅" class="headerlink" title="4.1 数据发布/订阅"></a>4.1 数据发布/订阅</h2><ul>
<li><p>发布订阅系统，即所谓的配置中心，发布者将数据发布到zk的一个或者一系列节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的。</p>
</li>
<li><p>常规的发布订阅系统有push和pull两种模式，在push模式中，服务端主动将数据更新发送给所有订阅的客户端。pull模式中，客户端通常采用盯视轮询拉取的方式发送请求来服务端获取。</p>
</li>
<li><p>zk的发布订阅系统采用推拉结合的模式，客户端向服务端祖册自己需要关注的数据节点，一旦该节点的数据（也就是配置信息）发生变更，服务端会发送watcher时间通知客户端来获取数据。</p>
</li>
</ul>
<h2 id="4-2-负载均衡"><a href="#4-2-负载均衡" class="headerlink" title="4.2 负载均衡"></a>4.2 负载均衡</h2><ul>
<li>这里说的负载均衡是指软负载均衡。在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方都会部署多份，达到对等服务。而消费者就须要在这些对等的服务器中选择一个来执行相关的业务逻辑，其中比较典型的是消息中间件中的生产者，消费者负载均衡。</li>
<li>消息中间件中发布者和订阅者的负载均衡，linkedin开源的KafkaMQ和阿里开源的metaq都是通过zookeeper来做到生产者、消费者的负载均衡。我们以kafka为例子。<h3 id="4-2-1-kafka概念："><a href="#4-2-1-kafka概念：" class="headerlink" title="4.2.1 kafka概念："></a>4.2.1 kafka概念：</h3></li>
<li>消息生产者：producer</li>
<li>消息消费者：consumer</li>
<li>主题：即Topic，由用户定义并配置在Kafka服务端，用于建立生产者和消费者之间的订阅关系：生产者发送消息到指定Topic下，消费者从这个Topic下消费消息。</li>
<li>Broker：即Kafka服务器，用于存储消息，在消息中间件中通常被称为Broker<br>消费者分组：Group</li>
<li>Offset：消息存储在Kafka的Broker上，消费者拉取消息数据的过程中需要知道消息在文件中的偏移量，这个偏移量就是所谓的Offset</li>
<li>ZooKeeper负责管理所有Broker服务器列表，并且建立了对应路径来对其进行管理/brokers/ids<br>每个Broker服务器在启动时，都会到ZooKeeper上进行注册，其节点路径为/broker/ids/[0…N]</li>
<li>Topic注册：Kafka当中，会将同一个Topic的消息分成多个区，分布到多个Broker上，这些分区信息和Broker的对应关系由ZooKeeper来维护<h3 id="4-2-2-ZooKeeper负载均衡实现"><a href="#4-2-2-ZooKeeper负载均衡实现" class="headerlink" title="4.2.2 ZooKeeper负载均衡实现"></a>4.2.2 ZooKeeper负载均衡实现</h3></li>
<li>每当一个Broker启动时，会首先完成Broker注册过程，在ZooKeeper的节点列表里保存Broker。</li>
<li>Kafka的生产者会对ZooKeeper上的“Broker的新增与减少”、“Topic的新增和减少”和“Broker和Topic关联关系的变化”等事件注册Watcher监听</li>
<li>通过ZooKeeper的Watcher通知能够让生产者动态的获取Broker和Topic的变化情况</li>
<li>Kafka有消费者分组的概念，每个消费者分组包含了若干个消费者，每一条消息只会发送给分组内的一个消费者，不同消费者分组消费自己特定的Topic下面的消息，互不干扰</li>
<li>Kafka会为每个消费者分配全局唯一的Consumer ID，采用“Hostname：UUID”形式来表示</li>
<li>每个消费者一旦确定了对一个消息分区的消费权利，ZooKeeper会将其Consumer ID写入到对应消息分区的<strong>临时节点</strong>上</li>
<li>消费进度管理：Kafka需要定时地将分区消息的消费进度，即Offset记录到ZooKeeper上去</li>
</ul>
<h2 id="4-3-命名服务"><a href="#4-3-命名服务" class="headerlink" title="4.3 命名服务"></a>4.3 命名服务</h2><ul>
<li>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li>
<li>其中较为常见的就是一些分布式服务框架中的服务地址列表。通过调用ZK提供的创建节点的API，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。</li>
<li>阿里巴巴集团开源的分布式服务框架Dubbo中使用ZooKeeper来作为其命名服务，维护全局的服务地址列表，在Dubbo实现中<ul>
<li>服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。</li>
<li>服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址， 并向/dubbo/${serviceName} /consumers目录下写入自己的URL地址。</li>
<li>注意，所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。</li>
<li>另外，Dubbo还有针对服务粒度的监控，方法是订阅/dubbo/${serviceName}目录下所有提供者和消费者的信息。<h2 id="4-4-分布式通知-协调"><a href="#4-4-分布式通知-协调" class="headerlink" title="4.4 分布式通知/协调"></a>4.4 分布式通知/协调</h2></li>
</ul>
</li>
<li>ZooKeeper中特有watcher注册与异步通知机制，能够很好的实现分布式环境下不同系统之间的通知与协调，实现对数据变更的实时处理。使用方法通常是不同系统都对ZK上同一个znode进行注册，监听znode的变化（包括znode本身内容及子节点的），其中一个系统update了znode，那么另一个系统能够收到通知，并作出相应处理。<ul>
<li>心跳检测式通知/协调：检测系统和被检测系统之间并不直接关联起来，而是通过zk上某个节点关联，比如两个客户端都在一个节点下创建各自的临时节点，并定时心跳去检测对方节点的存在，达到心跳检测的目的。</li>
<li>系统调度式通知/协调：有控制台和推送系统两部分组成，控制台的职责是控制推送系统进行相应的推送工作。管理人员在控制台作的一些操作，实际上是修改了ZK上某些节点的状态，而ZK就把这些变化通知给他们注册Watcher的客户端，即推送系统，于是，作出相应的推送任务。</li>
<li>工作汇报式通知/协调：一些类似于任务分发系统，子任务启动后，到zk来注册一个临时节点，并且定时将自己的进度进行汇报（将进度写回这个临时节点），这样任务管理者就能够实时知道任务进度。</li>
</ul>
</li>
<li>总之，使用zookeeper来进行分布式通知和协调能够大大降低系统之间的耦合</li>
</ul>
<h2 id="4-5-集群管理"><a href="#4-5-集群管理" class="headerlink" title="4.5 集群管理"></a>4.5 集群管理</h2><ul>
<li>通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题：<ul>
<li>集群中机器有变动的时候，牵连修改的东西比较多。</li>
<li>有一定的延时。</li>
</ul>
</li>
<li>利用ZooKeeper有两个特性，就可以实时另一种集群机器存活性监控系统：<ul>
<li>客户端在节点x上注册一个Watcher，那么如果 x的子节点变化了，会通知该客户端。</li>
<li>创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。</li>
</ul>
</li>
<li>例如，监控系统在 /clusterServers 节点上注册一个Watcher，以后每动态加机器，那么就往 /clusterServers 下创建一个 EPHEMERAL类型的节点：/clusterServers/{hostname}. 这样，监控系统就能够实时知道机器的增减情况，至于后续处理就是监控系统的业务了。<h2 id="4-6-Master选举"><a href="#4-6-Master选举" class="headerlink" title="4.6 Master选举"></a>4.6 Master选举</h2></li>
<li>在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能，于是这个master选举便是这种场景下的碰到的主要问题。</li>
<li>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建同名的如名字为 /currentMaster的节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。<h3 id="4-6-1-动态master选举"><a href="#4-6-1-动态master选举" class="headerlink" title="4.6.1 动态master选举"></a>4.6.1 动态master选举</h3></li>
<li>上述场景演化一下，就是动态Master选举。这就要用到EPHEMERAL_SEQUENTIAL类型节点的特性了。上文中提到，所有客户端创建请求，最终只有一个能够创建成功。在这里稍微变化下，创建EPHEMERAL_SEQUENTIAL节点，于是所有的请求最终在ZK上创建结果的一种可能情况是这样<ul>
<li>/currentMaster/{sessionId}-1 ,/currentMaster/{sessionId}-2 ,/currentMaster/{sessionId}-3</li>
</ul>
</li>
<li>每次选取序列号最小的那个机器作为Master，如果这个机器挂了，由于他创建的节点会马上消失，那么之后最小的那个机器就是Master了。</li>
</ul>
<h2 id="4-7-分布式锁"><a href="#4-7-分布式锁" class="headerlink" title="4.7 分布式锁"></a>4.7 分布式锁</h2><ul>
<li>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强一致性。锁服务可以分为两类，一个是保持独占，另一个是控制时序。<ul>
<li>所谓保持独占，就是所有试图来获取这个锁的客户端，最终只有一个可以成功获得这把锁。通常的做法是把zk上的一个znode看作是一把锁，通过create znode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。</li>
<li>控制时序，就是所有试图来获取这个锁的客户端，最终都是会被安排执行，只是有个全局时序了。做法和上面基本类似，只是这里 /distribute_lock 已经预先存在，客户端在它下面创建临时有序节点（这个可以通过节点的属性控制：CreateMode.EPHEMERAL_SEQUENTIAL来指定）。Zk的父节点（/distribute_lock）维持一份sequence,保证子节点创建的时序性，从而也形成了每个客户端的全局时序。<h2 id="4-8-分布式队列"><a href="#4-8-分布式队列" class="headerlink" title="4.8 分布式队列"></a>4.8 分布式队列</h2></li>
</ul>
</li>
<li>队列方面，简单地讲有两种，一种是常规的先进先出队列，另一种是要等到队列成员聚齐之后的才统一按序执行。对于第一种先进先出队列，和分布式锁服务中的控制时序场景基本原理一致，这里不再赘述。</li>
<li>第二种队列其实是在FIFO队列的基础上作了一个增强。通常可以在 /queue 这个znode下预先建立一个/queue/num 节点，并且赋值为n（或者直接给/queue赋值n），表示队列大小，之后每次有队列成员加入后，就判断下是否已经到达队列大小，决定是否可以开始执行了。</li>
<li>这种用法的典型场景是，分布式环境中，一个大任务Task A，需要在很多子任务完成（或条件就绪）情况下才能进行。这个时候，凡是其中一个子任务完成（就绪），那么就去 /taskList 下建立自己的临时时序节点（CreateMode.EPHEMERAL_SEQUENTIAL），当 /taskList 发现自己下面的子节点满足指定个数，就可以进行下一步按序进行处理了。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/paxos%E7%AE%97%E6%B3%95%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%8E%A8%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/paxos%E7%AE%97%E6%B3%95%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%8E%A8%E5%AF%BC/" itemprop="url">paxos算法论述和推导</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-12T00:34:38+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">分布式算法&理论</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95-%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务和数据一致性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/12/paxos%E7%AE%97%E6%B3%95%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%8E%A8%E5%AF%BC/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/12/paxos算法论述和推导/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  14
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><ul>
<li><p>在HA集群系统中，假设有同一个整体、动作协调的节点A 和节点B，节点A和B之间通过heartBeat来检查对方的存活状态,负责协调保证整个集群服务的可用性。正常情况下，如果节点A通过心跳检测不到B的存在的时候，就会接管B的资源，同理节点B检查不到B的存活状态的时候也会接管A的资源。</p>
</li>
<li><p>如果出现网络故障，就会导致A和B同时检查不到对方的存活状态认为对方出现异常，这个时候就会导致A接管B的资源，B也会接管A的资源。原来被一个节点访问的资源就会出现被多个节点同时访问的情况，这种情况就是脑裂现象。</p>
</li>
<li><p>嗯，这是比较官方的解释，说人话的话，其实就是在一个集群中，有多个“大脑”，即多个master</p>
<h2 id="三态"><a href="#三态" class="headerlink" title="三态"></a>三态</h2></li>
<li><p>在传统的单机系统中，我们调用一个函数，这个函数要么返回成功，要么返回失败，其结果是确定的。可以概括为传统的单机系统调用只存在两态（2-state system）：成功和失败。</p>
</li>
<li><p>然而在分布式系统中，由于系统是分布在不同的机器上，系统之间的请求就相对于单机模式来说复杂度较高了。具体的，节点 A 上的系统通过 RPC (Remote Procedure Call) 方式与节点 B 上的系统进行通信，在这个请求结果存在三态(3-state system)：也就是成功、失败和超时，不要小瞧超时这个状态，因为它几乎是所有分布式系统复杂性的根源。</p>
</li>
</ul>
<h1 id="1-paxos算法"><a href="#1-paxos算法" class="headerlink" title="1 paxos算法"></a>1 paxos算法</h1><ul>
<li>Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。- - Paxos算法及变种算法在分布式系统中应用广泛。基于Paxos算法的变种有：ZAB、Raft。 Zookeeper 中的ZAB协议也是Paxos算法的变种。</li>
<li>Paxos是一个解决共识问题consensus problem的算法，现实中Paxos的实现以及成为一些世界级软件的心脏，如Cassandra, Google的Spanner数据库, 分布式锁服务Chubby。一个被Paxos管理的系统实际上谈论的是值状态和跟踪等问题，其目标是建造更高可用性和强一致性的分布式系统。</li>
<li>Paxos算法解决的问题是在一个可能发生消息可能会延迟、丢失、重复的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。这 个“值”可能是一个数据的某，也可能是一条log日志等；根据不同的应用环境这个“值”也不同。<h2 id="1-1-角色"><a href="#1-1-角色" class="headerlink" title="1.1 角色"></a>1.1 角色</h2></li>
<li>Paxos中有三类角色Proposer、Acceptor及Learner，主要交互过程在Proposer和Acceptor之间。网络中的任意节点，都可能既是Proposer，又是Acceptor。</li>
<li>当某个节点想将分布式系统中进行写操作的，它就是Proposer。除Proposer外，所有接收到请求，被要求对某个值进行更改的其他节点，就是Acceptor。</li>
</ul>
<h2 id="1-2-比喻推导前提"><a href="#1-2-比喻推导前提" class="headerlink" title="1.2 比喻推导前提"></a>1.2 比喻推导前提</h2><ul>
<li><p>举个例子，一个城市为了确定城市未来的发展方针，市长皮皮虾决定集思广益，向全体市民寻求建议。每个人都有建议权，也都有投票权（一个市民在发展方针的时候，他就是proposer，其他人是acceptor，此时，发展方针即表示节点希望推动的值变更或者说值状态，他希望所有节点都接受自己提出的值变更）</p>
</li>
<li><p>在现实环境中我们可以在一个大会堂召集全体市民共同讨论或在微信群中讨论（基于内存共享方式）；但在基于消息传递的分布式环境中每个人只能通过手机短信与其它人沟通。我们要寻求一种机制以解决如何在这种会延迟、丢失的环境中确定一个城市的发展方针。</p>
</li>
<li><p>在讨论之前，我们得制定一些投票规则，以便能够胜利选出呼声最高的发展方针。</p>
<ol>
<li>最终只能确定一个建议</li>
<li>少数服从多数。只要建议被多数人同意即可确定该建议。</li>
</ol>
</li>
<li><p>为了保证投票环节让所有人信服，我们得保证如下几点：</p>
<ol>
<li>只有被提出来的建议才能被大家投票同意。<ul>
<li>也就是大家只能投票给被建议出来的选项。</li>
</ul>
</li>
<li>最终一定要能够得到一个被大多数人同意的建议。</li>
<li>不同人的提议可以重复。</li>
<li>如果某个人认为大家同意了某个建议，那么这个建议必须真的是被大家同意的。<ul>
<li>也就是要让所有市民心服口服，人们认为的众望所归的建议，必须真的是大家众望所归的建议。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="1-3-比喻推导过程"><a href="#1-3-比喻推导过程" class="headerlink" title="1.3 比喻推导过程"></a>1.3 比喻推导过程</h2><p>为了制定行之有效的机制，市长皮皮虾召集了一大批专家团队来规划整个决策机制，在讨论当中，专家们提出了许多未来可能遇到的问题，并尝试完善规则：</p>
<h3 id="1-3-1-情况一"><a href="#1-3-1-情况一" class="headerlink" title="1.3.1 情况一"></a>1.3.1 情况一</h3><p>如果因为宣传不充分，很多人准备也不到位，结果只有一位市民提出了自己的建议，它希望这个小城大力发展纸尿裤行业，希望大家在即将到来的投票中选择自己的提议。这个明显是帮宝适董事长提的傻逼建议，在初步征询阶段就得不到市民的认可，于是情况陷入了僵局，在没有新的建议出来的情况下，大家都不同意，导致决策机制彻底失灵。</p>
<p><strong>解决办法</strong>：为了使得这个表决机制不会陷入这个局面，一根筋的市长皮皮虾决定增加一条硬性规定，<strong>我们称他为P1：不许不投票，每一个人必须同意他收到的第一个建议</strong>。这样即使只有一个建议被提出，也能够被采纳。</p>
<h3 id="1-3-2-情况二"><a href="#1-3-2-情况二" class="headerlink" title="1.3.2 情况二"></a>1.3.2 情况二</h3><p>此时一位专家说：基于情况一，我们要求每一个人必须同意他收到的第一个提议，但因为我们又需要一个提议必须被大多数人同意才能生效，所以一个人必须可以同时同意多个人的建议，即一个人必须可以拥有多次投票权可以投给不同的人，不然发生A同意B，B同意C，C同意D，D同意A的情况，永远也得不出一个超过半数同意的提议。</p>
<p>市长皮皮虾表示这位专家说的很有道理。</p>
<p>但这时又有一位专家提醒，就算我们允许一个人可以投给不同的人，也会遇到类似的僵局，比如A同意B和C的提议，B同意C和D的提议，C同意D和A的提议，D同意A和B的提议，这样每个人的提议都有两票，也会陷入僵局。</p>
<p>要避免出现这种问题，就要求被某个人投票的这些建议者们，他们的提议内容都是一样的。</p>
<p>于是皮皮虾市长规定，<strong>我们称他为P2：市民只能有一个立场，抱定这个立场后，可以投票给不同的但都是提议该立场的建议者，以便选出最后得票最高的建议</strong>。</p>
<h3 id="1-3-3-情况三"><a href="#1-3-3-情况三" class="headerlink" title="1.3.3 情况三"></a>1.3.3 情况三</h3><p>此时一位专家说：如果有五个人甲乙丙丁戊，甲乙丙三个人同意了方案A，方案A成为了主流意见。丁，戊 2人由于之前手机没电，没收到通知，所以他们下线了。当他们2人开机后（注意此时甲乙丙之间的投票已经结束，方案A成为了主流意见），丁和戊以为主流意见尚未选出，刚好丁也有提议没发出去，所以丁给戊发短信提议了方案B，这个提议是戊开机后第一次收到的提议，根据P1原则，他必须同意他接收到的第一个提议，并将其作为自己的立场，所以戊同意方案B。但这样就会导致戊与甲乙丙他们意见不一致。</p>
<p>一个人意见不一致还好，但因为有这样的漏洞，所以可能最后和主流意见不一致的人会非常多，这不利于我们构建和谐且令人心服的讨论。</p>
<p>于是市长皮皮虾对P2进行了补充，<strong>我们称为P2a:一旦一个提议成为了主流的意见，那么之后的人再次投票的提议内容，必须和主流意见内容一致</strong>。</p>
<p>也就是说，戊在开机后同意的第一个提议必须是方案A才不会出现信息不一致的现象。但戊开机后必须得接受第一个提议（P1原则），并且无法干涉提议中的内容（方案A还是方案B）。所以最好的办法通过某种方式让丁的提议中的内容与甲乙丙的提议相同。这样戊同意的第一个提议就是方案A</p>
<p>于是皮皮虾再次对P2a进行补充，<strong>我们称为P2b:一旦一个提议成为主流意见，那么之后的人再次提议，提议中的内容必须跟主流意见一致。</strong></p>
<p>如何让刚开机的戊提议的内容必须与甲乙丙同意的一致呢？要想达到这一点，只要达到另一个条件即可：</p>
<p><strong>我们称为P2c:存在一个提议A，对于大多数市民来说，要么他们中所有人在同意A前没有同意其他提议，要么他们已经同意的所有提议，内容都和A一模一样。</strong></p>
<p>如果能做到P2c这一点，那么P2b自然就达到了，P2c是P2b的充分条件。也是P2的充分条件。</p>
<h2 id="1-4-paxos流程比喻"><a href="#1-4-paxos流程比喻" class="headerlink" title="1.4 paxos流程比喻"></a>1.4 paxos流程比喻</h2><p>也就是说，要想这个表决机制表决出的结果是真的所有人都认同的，那么必须同时满足P1,P2c(P2的充分条件),那如何设计表决的程序，才能使表决满足P1和P2c呢？</p>
<p>而且P2c条件中，有提议的时间先后概念，在一个只能依靠短信沟通的环境中，如何确定一个提议早于另外一个提议被提出呢？毕竟就算某个提议A比提议B早提出，它也不可能永远比B早到达每一个节点。众人觉得应该引入一个全局的编号，每个提议对应一个编号，用这个编号来表示时间维度的早和晚。但具体如何实施呢？</p>
<p>在众人一筹莫展的时候，一个天才专家站了出来，它设计了一个流程，能够使P1和P2c成立。</p>
<p>专家建议，谁的提议最后被选为了最终提议，可以奖励一个巨量的奖金，这样，每一个提议者都会竭尽所能的让自己的提议成为最终提议（模拟真实paxos实现中proposer始终试图让acceptor接受自己提议的场景）</p>
<p>专家还建议，可以引入贿选机制，每个提议者都可以为自己的提议选定一个贿选金额（模拟实际情况中的全局编号），承诺如果自己的提议成为最终提议，每个接受自己的提议的投票人可以得到该金额。贿选金额维护在一个地方，每个提议者在提议之前都知道目前最高的贿选金额是多少了。</p>
<p>为了得到最后的奖金，每个提议者都会一直提高这个贿选金额（这就模拟了实际中一直自增的全局编号，也合理了为什么accept会投票给后来的提议，因为后来的提议给的钱多啊）。</p>
<p>基于上面两个前提，专家提出了最后的流程，这个表决要分两步：</p>
<ul>
<li>准备阶段，大家先内部讨论一下，不急着投票<ol>
<li>proposer选择一个贿选金额，并将信息以<br> <code>[贿选金额，提议内容]</code><br> 的kv形式广播（prepare请求）。</li>
<li>如果收信人收到 [贿选金额，提议内容] 后。<ul>
<li>如果该提议的金额大于它已经回复的所有提议的金额。那么acceptor将会为了钱出卖自己的上家，将自己上次接受的提议内容以及上家给了他多少钱回复给proposer，即<code>[之前最高的贿选金额，我之前同意的提案内容]</code>，并承诺不再接受小于这个金额的提议。</li>
<li>如果该提议的金额不大于它已经接受的那个提议的金额。那么直接无视。（贿选金额没有吸引力，无视）</li>
</ul>
</li>
</ol>
</li>
<li>同意阶段，经过阶段一，proposer们已经通过acceptor们的反馈知道了每个acceptor的投票承诺。（因为prepare是广播形式，所以会受到全部acceptor的返回，即要么得到接受提议的回馈，表示我接受你的提案了，并且将我上家的提案告诉你。要么我就无视你，无视也是一种表态），<ol>
<li>当proposer<strong>收到多数人接受提议的反馈信息后</strong>，就进入同意阶段（<strong>重点，收到大多数的承诺后才会进入同意阶段</strong>）。它要向反馈给它信息的人再次发送一个请同意该提议的请求（accept请求）,内容为<br><code>[第一步的那个贿选金额，收到的反馈中价码最高的那个提议内容]</code><br>（如果proposer接收到的<strong>所有</strong>回复中都没有acceptor已经接受过的提议内容，则proposer可以自由决定提议内容）  </li>
</ol>
  <strong>注意</strong>，对于某些proposer来说，这里再次发出的提议内容，可能已经和自己之前在第一步的提议不一样了。因为如果他通过acceptor们的反馈（里面包含acceptor们接受的提议），知道了自己之前的提议没有成为主流意见，大伙大多数都同意了另一个给钱最壕的proposer的提议，那么为了彰显自己的正确，它也默默的把提议内容改成了大家都同意的提议内容。<ol start="2">
<li>acceptor接收到请求：<ul>
<li>在不违背向其它人承诺的前提下，收到该提议请求后会立即同意该请求，并回馈一个接受的消息。（即一个acceptor只要尚未响应过任何编号大于N的prepare请求，那么它就可以接受这个编号为N的accept请求）</li>
<li>而如果此时acceptor又叛变了，它接受了一个金额更高（编号更高）的提议，那么，他会无视这个accept请求。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><strong>如果一个proposer发出的accept请求没有得到大多数的回应，那么他就会知道大多数acceptor已经叛变了，无奈之下，他只能重新进入准备阶段，重新选择一个更大的金额（编号n），再去冲击一波。（此时他的提案，就是之前他默默改成的大家都同意的提议）</strong></p>
<p>否则，如果一个proposer发出的accept请求得到了大多数的回应，那么流程结束，该proposer的提案胜出，至于算法如何将胜出的提案通知给 Learner，有如下三种方案，各有优劣</p>
<h2 id="1-5-Learner学习被选定的value"><a href="#1-5-Learner学习被选定的value" class="headerlink" title="1.5 Learner学习被选定的value"></a>1.5 Learner学习被选定的value</h2><p>Learner学习（获取）被选定的value有如下三种方案：<br><img src="https://oscimg.oschina.net/oscnet/f9856c18ffd5c2077b95209a2d0cf256e57.jpg" alt=""></p>
<h2 id="1-6-后述"><a href="#1-6-后述" class="headerlink" title="1.6 后述"></a>1.6 后述</h2><p>Leslie Lamport没有用数学描述Paxos，但是他用英文阐述得很清晰。至于Paxos中一直提到的一个全局唯一且递增的proposer number，其如何实现，引用如下</p>
<blockquote>
<p>如何产生唯一的编号呢？在《Paxos made simple》中提到的是让所有的Proposer都从不相交的数据集合中进行选择，例如系统有5个Proposer，则可为每一个Proposer分配一个标识j(0~4)，则每一个proposer每次提出决议的编号可以为5*i + j(i可以用来表示提出议案的次数)</p>
</blockquote>
<p>除此之外，如何保证paxos的活性<br><img src="https://oscimg.oschina.net/oscnet/153639395f419d81e803cf5bbcdec3c0d1a.jpg" alt=""><br>通过选取主Proposer，就可以保证Paxos算法的活性。至此，我们得到一个既能保证安全性，又能保证活性的分布式一致性算法——Paxos算法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/" itemprop="url">常用shell命令导航</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-21T23:46:16+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/Linux%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">Linux相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/07/21/常用shell命令导航/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  25.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  102
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>导航栏位于右侧，只收录常用命令，按字母表排序</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="alias-设置指令的别名"><a href="#alias-设置指令的别名" class="headerlink" title="alias-设置指令的别名"></a>alias-设置指令的别名</h2><ul>
<li><p>简介：</p>
</li>
<li><p>别名就是一种便捷方式，可以为用户省去输入一长串命令序列的麻烦。Linux alias命令用于设置指令的别名。用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.bashrc中设定指令的别名。</p>
</li>
<li><p>语法：</p>
</li>
<li><p><code>alias[别名]=[指令名称]</code></p>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为apt-get install创建别名。</span><br><span class="line">$ alias install&#x3D;&#39;sudo apt-get install&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;alias命令的效果只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。</span><br><span class="line">&#x2F;&#x2F;为了使别名在所有的shell中都可用，可以将其定义放入~&#x2F;.bashrc文件中。</span><br><span class="line">&#x2F;&#x2F;每当一个新的交互式shell进程生成时，都会执行 ~&#x2F;.bashrc中的命令。</span><br><span class="line">$ echo &#39;alias cmd&#x3D;&quot;command seq&quot;&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们可以创建一个别名rm，它能够删除原始文件，同时在backup目录中保留副本。</span><br><span class="line">$ alias rm&#x3D;&#39;cp $@ ~&#x2F;backup &amp;&amp; rm $@&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>alias命令若不加任何参数，则列出目前所有的别名设置。</p>
</blockquote>
<blockquote>
<p> 如果需要删除别名，只需将其对应的定义（如果有的话）从~/.bashrc中删除，或者使用unalias命令。也可以使用alias example=，这会取消别名example。</p>
</blockquote>
<blockquote>
<p>创建别名时，如果已经有同名的别名存在，那么原有的别名设置将被新的<br>设置取代。</p>
</blockquote>
<blockquote>
<p>如果我们遇到别名和原生命令同名的情况，我们可以转义要使用的命令，忽略当前定义的别名：<br>$ \command<br>字符\可以转义命令，从而执行原本的命令。</p>
</blockquote>
<blockquote>
<p>在不可信环境下执行特权命令时，在命令前加上\来忽略可能存在的别名总是一种良好的安全实践。这是因为攻击者可能已经将一些别有用心的命令利用别名伪装成了特权命令，借此来盗取用户输入的重要信息。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="awk——把文件逐行的读入，以分隔符将其切片，再进行处理。"><a href="#awk——把文件逐行的读入，以分隔符将其切片，再进行处理。" class="headerlink" title="awk——把文件逐行的读入，以分隔符将其切片，再进行处理。"></a>awk——把文件逐行的读入，以分隔符将其切片，再进行处理。</h2><ul>
<li><p>简介：</p>
<ul>
<li>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</li>
<li>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</li>
<li>之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>awk [选项参数] &#39;{pattern + action}&#39; {filenames}</code></li>
<li>尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</li>
<li>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</li>
<li>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-F fs or –field-separator fs</strong></p>
<ul>
<li>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式。在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</li>
</ul>
</li>
<li><p><strong>-v var=value or –asign var=value</strong></p>
<ul>
<li>赋值一个用户定义变量。</li>
</ul>
</li>
<li><p><strong>-f scripfile or –file scriptfile</strong></p>
<ul>
<li>从脚本文件中读取awk命令。</li>
</ul>
</li>
<li><p><strong>-mf nnn and -mr nnn</strong></p>
<ul>
<li>对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li>
</ul>
</li>
<li><p><strong>-W compact or –compat, -W traditional or –traditional</strong></p>
<ul>
<li>在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</li>
</ul>
</li>
<li><p><strong>-W copyleft or –copyleft, -W copyright or –copyright</strong></p>
<ul>
<li>打印简短的版权信息。</li>
</ul>
</li>
<li><p><strong>-W help or –help, -W usage or –usage</strong></p>
<ul>
<li>打印全部awk选项和每个选项的简短说明。</li>
</ul>
</li>
<li><p><strong>-W lint or –lint</strong></p>
<ul>
<li>打印不能向传统unix平台移植的结构的警告。</li>
</ul>
</li>
<li><p><strong>-W lint-old or –lint-old</strong></p>
<ul>
<li>打印关于不能向传统unix平台移植的结构的警告。</li>
</ul>
</li>
</ul>
</li>
<li><p>内建变量</p>
<p>  如下变量在awk中具有特定含义。</p>
<ul>
<li>$n    当前记录的第n个字段，字段间由FS分隔</li>
<li>$0    完整的输入记录</li>
<li>ARGC    命令行参数的数目</li>
<li>ARGIND    命令行中当前文件的位置(从0开始算)</li>
<li>ARGV    包含命令行参数的数组</li>
<li>CONVFMT    数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</li>
<li>ERRNO    最后一个系统错误的描述</li>
<li>FIELDWIDTHS    字段宽度列表(用空格键分隔)</li>
<li>FILENAME    当前文件名</li>
<li>FNR    各文件分别计数的行号</li>
<li>IGNORECASE    如果为真，则进行忽略大小写的匹配</li>
<li>NF    一条记录的字段的数目</li>
<li>NR    已经读出的记录数，就是行号，从1开始</li>
<li>OFMT    数字的输出格式(默认值是%.6g)</li>
<li>OFS    输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</li>
<li>ORS    输出记录分隔符(默认值是一个换行符)</li>
<li>RLENGTH    由match函数所匹配的字符串的长度</li>
<li>RS    记录分隔符(默认是一个换行符)</li>
<li>RSTART    由match函数所匹配的字符串的第一个位置</li>
<li>SUBSEP    数组下标分隔符(默认值是/034)</li>
</ul>
</li>
<li><p>代码示例</p>
<blockquote>
<p>awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。</p>
</blockquote>
<ul>
<li><p>action的使用示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假设last -n 5的输出如下</span><br><span class="line">$ last -n 5 &lt;&#x3D;&#x3D;仅取出前五行</span><br><span class="line">&gt; root     pts&#x2F;1   192.168.1.100  Tue Feb 10 11:21   still logged in</span><br><span class="line">&gt; root     pts&#x2F;1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)</span><br><span class="line">&gt; root     pts&#x2F;1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)</span><br><span class="line">&gt; dmtsai   pts&#x2F;1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)</span><br><span class="line">&gt; root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用awk显示最近登录的5个帐号</span><br><span class="line">$ last -n 5 | awk  &#39;&#123;print $1&#125;&#39;</span><br><span class="line">&gt; root</span><br><span class="line">&gt; root</span><br><span class="line">&gt; root</span><br><span class="line">&gt; dmtsai</span><br><span class="line">&gt; root</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果只是显示&#x2F;etc&#x2F;passwd文件中的账户信息</span><br><span class="line">$ awk  -F &#39;:&#39;  &#39;&#123;print $1&#125;&#39;  &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root</span><br><span class="line">&gt; daemon</span><br><span class="line">&gt; bin</span><br><span class="line">&gt; sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示&#x2F;etc&#x2F;passwd文件中的账户和账户对应的shell信息,而账户与shell之间以tab键分割</span><br><span class="line">$ awk  -F &#39;:&#39;  &#39;&#123;print $1&quot;\t&quot;$7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root    &#x2F;bin&#x2F;bash</span><br><span class="line">&gt; daemon  &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; bin     &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; sys     &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;格式化输出</span><br><span class="line">$ awk &#39;&#123;printf &quot;%-8s %-10s\n&quot;,$1,$7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root       &#x2F;bin&#x2F;bash</span><br><span class="line">&gt; daemon     &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; bin        &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; sys        &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示&#x2F;etc&#x2F;passwd的账户和账户对应的shell,而账户与shell之间以逗号分割</span><br><span class="line">&#x2F;&#x2F;而且在所有行添加列名name,shell,在最后一行添加&quot;blue,&#x2F;bin&#x2F;nosh&quot;。</span><br><span class="line">&#x2F;&#x2F; 遇到BEGIN和END关键字，则二者分别在 读取文件之前 和 所有记录读完之后 执行</span><br><span class="line">$ awk  -F &#39;:&#39;  &#39;BEGIN &#123;print &quot;name,shell&quot;&#125;  &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,&#x2F;bin&#x2F;nosh&quot;&#125;&#39; &#x2F;etc&#x2F;passwd </span><br><span class="line">&gt; name,shell</span><br><span class="line">&gt; root,&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; daemon,&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; bin,&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; sys,&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; blue,&#x2F;bin&#x2F;nosh</span><br></pre></td></tr></table></figure></li>
<li><p>pattern使用示例 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 搜索&#x2F;etc&#x2F;passwd有root关键字的所有行,</span><br><span class="line">$ awk -F: &#39;&#x2F;root&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;&#x2F; 匹配了pattern(这里是root)的行才会执行action(本例未指定action，默认输出每行的内容，即$0，下例指定action)。</span><br><span class="line">&#x2F;&#x2F; 搜索支持正则，例如找root开头的: awk -F: &#39;&#x2F;^root&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定action&#123;print $7&#125;。搜索&#x2F;etc&#x2F;passwd有root关键字的所有行，并显示对应的shell</span><br><span class="line">$ awk -F: &#39;&#x2F;root&#x2F;&#123;print $7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列大于2的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1&gt;2&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列等于2的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1&#x3D;2&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列大于2并且第二列等于&#39;Are&#39;的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1&gt;2 &amp;&amp; $2&#x3D;&#x3D;&quot;Are&quot;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列包含 &quot;th&quot;的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1 ~ &#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列包含 &quot;th&quot;的行,忽略大小写(action就不指定了)</span><br><span class="line">$ awk &#39;BEGIN&#123;IGNORECASE&#x3D;1&#125; $1 ~ &#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列不包含 &quot;th&quot;的行,忽略大小写(action就不指定了)</span><br><span class="line">$ awk &#39;BEGIN&#123;IGNORECASE&#x3D;1&#125; $1 !~ &#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤整行不包含 &quot;th&quot;的行,忽略大小写(action就不指定了)</span><br><span class="line">$ awk &#39;BEGIN&#123;IGNORECASE&#x3D;1&#125; !&#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure></li>
<li><p>变量赋值和使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 内建变量赋值。使用BEGIN替代-F,其中FS是awk内建变量</span><br><span class="line">$ awk  &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125; &#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root</span><br><span class="line">&gt; daemon</span><br><span class="line">&gt; bin</span><br><span class="line">&gt; sys</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内建变量使用。使用BEGIN替代-F,其中FS是awk内建变量，并且打印文件名，使用FILENAME内建变量</span><br><span class="line">$ awk  &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125; &#123;print FILENAME,$1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd root</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd daemon</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd bin</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd sys</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-v变量赋值用法</span><br><span class="line">$ awk -F: -va&#x3D;1 -vb&#x3D;s &#39;&#x2F;root&#x2F;&#123;print $7,$7+a,$7b&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;bash 1 &#x2F;bin&#x2F;bashs</span><br><span class="line">&gt; &#x2F;bin&#x2F;false 1 &#x2F;bin&#x2F;falses</span><br><span class="line">&#x2F;&#x2F;BEGIN同理</span><br><span class="line">$ awk -F: &#39;BEGIN &#123;a&#x3D;1;b&#x3D;s&#125; &#x2F;root&#x2F;&#123;print $7,$7+a,$7b&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;bash 1 &#x2F;bin&#x2F;bashs</span><br><span class="line">&gt; &#x2F;bin&#x2F;false 1 &#x2F;bin&#x2F;falses</span><br></pre></td></tr></table></figure></li>
<li><p>其他一些实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;计算文件大小</span><br><span class="line">$ ls -l *.txt | awk &#39;&#123;sum+&#x3D;$6&#125; END &#123;print sum&#125;&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从文件中找出长度大于80的行</span><br><span class="line">$ awk &#39;length&gt;80&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>awk还支持条件语句和循环，使用较少，本文不再展开。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="cat-连接文件或标准输入至标准输出"><a href="#cat-连接文件或标准输入至标准输出" class="headerlink" title="cat-连接文件或标准输入至标准输出"></a>cat-连接文件或标准输入至标准输出</h2><ul>
<li><p>简介：</p>
</li>
<li><p>cat命令是linux下的一个文本输出命令，其功能是连接文件或标准输入至标准输出，常用于显示文件内容 。cat是concatenate(串联)的缩写。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>cat [选项参数] [--help] [--version] fileName</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-n 或 –number</strong></p>
<ul>
<li>由 1 开始对所有输出的行数编号。</li>
</ul>
</li>
<li><p><strong>-b 或 –number-nonblank</strong></p>
<ul>
<li>和 -n 相似，只不过对于空白行不编号。</li>
</ul>
</li>
<li><p><strong>-s 或 –squeeze-blank</strong></p>
<ul>
<li>当遇到有连续两行以上的空白行，就代换为一行的空白行。</li>
</ul>
</li>
<li><p><strong>-v 或 –show-nonprinting</strong></p>
<ul>
<li>以^和M-显示不可打印字符，除LFD与TAB </li>
</ul>
</li>
<li><p><strong>-E 或 –show-ends</strong></p>
<ul>
<li>在每行结束处显示 $。</li>
</ul>
</li>
<li><p><strong>-T 或 –show-tabs</strong></p>
<ul>
<li>将 TAB 字符显示为 ^I。这有助于排查缩进错误。</li>
</ul>
</li>
<li><p><strong>-A, –show-all</strong></p>
<ul>
<li>等价于-vET显示所有，以$结尾。</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
<ul>
<li>在每行行尾添加$,用以标记</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>等价于”-vT”选项；</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//打印多个文件的内容</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat one.txt two.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> This line is from one.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> This line is from two.txt</span></span><br><span class="line"></span><br><span class="line">//将stdin和另一个文件中的数据组合在一起，其中-被作为stdin文本的文件名。</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'Text through stdin'</span> | cat - file.txt</span></span><br><span class="line"></span><br><span class="line">//把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat -n textfile1 &gt; textfile2</span></span><br><span class="line"></span><br><span class="line">//把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat -b textfile1 textfile2 &gt;&gt; textfile3</span></span><br><span class="line"></span><br><span class="line">//有时候，我们只希望抓取文件中感兴趣的关键字</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat fileName | grep keyword</span></span><br><span class="line"></span><br><span class="line">//清空某个文件内容</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /dev/null &gt; /test.txt</span></span><br><span class="line"></span><br><span class="line">//创建文件，并把标准输入输出到filename文件中</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat&gt;filename，</span></span><br><span class="line"></span><br><span class="line">//以EOF作为输入结束，将输入流重定向覆盖filename文件，可用于创建文件，追加使用&gt;&gt;</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat&gt;filename&lt;&lt;EOF</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>现在我们知道cat &lt;&lt; EOF语句表示 打印以EOF输入字符为标准输入结束的流内容，EOF是“end of file”，        表示文本结束符。用在这里起到什么作用？首先必须要说明的是EOF在这里没有特殊的含义，你可以使用FOE或        OOO等（当然也不限制在三个字符或大写字符）可以把EOF替换成其他东西。cat &lt;&lt; OOF的含义即为打印以OOF输入字符为标准输入结束的流内容，代码如下图<br><img src="https://oscimg.oschina.net/oscnet/69fc8c9ccaff98a782091232365f03a9898.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>cat&gt;filename，创建文件，并把标准输入输出到filename文件中，以ctrl+d作为输入结束。</p>
</blockquote>
<blockquote>
<p>cat&gt;filename&lt;&lt;EOF等价于cat&lt;<EOF>filename,执行顺序固定是输入早于输出<br><img src="https://oscimg.oschina.net/oscnet/8cf56f84669c53afd935f5ee1def0b64841.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="cd——切换当前工作目录"><a href="#cd——切换当前工作目录" class="headerlink" title="cd——切换当前工作目录"></a>cd——切换当前工作目录</h2><ul>
<li><p>简介：</p>
<ul>
<li>Linux cd命令用于切换当前工作目录至 dirName(目录参数)。</li>
<li>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</li>
<li>另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录；”-“表示上次所在目录</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>cd [dirName]</code></li>
<li>dirName：要切换的目标目录。</li>
</ul>
</li>
<li><p>选项值：</p>
</li>
</ul>
<ul>
<li>代码示例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;跳到 &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">$ cd &#x2F;usr&#x2F;bin</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳到自己的 home 目录</span><br><span class="line">$ cd ~</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳到目前目录的上层</span><br><span class="line">$ cd ..</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳到目前目录的上上两层</span><br><span class="line">$ cd ..&#x2F;..</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回之前的目录</span><br><span class="line">$ cd -</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="chmod-设置文件权限"><a href="#chmod-设置文件权限" class="headerlink" title="chmod-设置文件权限"></a>chmod-设置文件权限</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux/Unix 的文件调用权限分为三级：用户，用户组，其他用户。利用 chmod 可以藉以控制文件如何被他人所调用。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>chmod [选项参数]  mode filename</code></li>
<li>其中mode为权限设定字串，格式如下<code>[ugoa...][[+-=][rwxX]...][,...]</code><ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个用户组(group)者，o 表示其他用户，a 表示这三者皆是。</li>
<li>+表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
<li>x 权限的位置上还可能出现t表示文件有执行权限并设置了粘滞位权限、T表示文件没有执行权限并设置了粘滞位权限、S表示setuid（S）的特殊权限，setuid权限允许可执行文件以其拥有者的权限来执行，即使这个可执行文件是由其他用户运行的。</li>
<li>同时，mode也可以使用3位八进制数来表示，每一位按顺序分别对应用户、用户组和其他用户。其中r=4，w=2，x=1。所以：<ul>
<li>rwx属性：4+2+1=7；</li>
<li>rw-属性：4+2=6；</li>
<li>r-x属性：4+1=5；</li>
<li>以此类推…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-c</strong></p>
<ul>
<li>若该文件权限确实已经更改，才显示其更改动作</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>若该文件权限无法被更改也不要显示错误讯息</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>显示权限变更的详细资料</li>
</ul>
</li>
<li><p><strong>-R</strong></p>
<ul>
<li>对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助说明</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将文件 file1.txt 设为所有人皆可读取</span><br><span class="line">$ chmod ugo+r file1.txt</span><br><span class="line">或</span><br><span class="line">$ chmod a+r file1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 file1.txt 设定为只有该文件拥有者可以执行 :</span><br><span class="line">$ chmod u+x file1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一用户组的用户可写入，但其他以外的人则不可写入 </span><br><span class="line">$ chmod ug+w,o-w file1.txt file2.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将目前目录下的所有文件与子目录皆设为任何人可读取 :</span><br><span class="line">$ chmod -R a&#x3D;rwx *</span><br><span class="line">或</span><br><span class="line">$ chmod 777 . -R</span><br><span class="line">或</span><br><span class="line">$  chmod 777 &quot;$(pwd)&quot; -R</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给所有用户赋值读写执行权限</span><br><span class="line">$ chmod a&#x3D;rwx file</span><br><span class="line">或</span><br><span class="line">$ chmod 777 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给文件拥有用户和其相同用户组用户读写执行权限，其他用户可执行权限。</span><br><span class="line">$ chmod ug&#x3D;rwx,o&#x3D;x file</span><br><span class="line">或</span><br><span class="line">$ chmod 771 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给特定目录加粘滞位权限（设置粘滞位后，只有目录的所有者才能够删除目录中的文件，即使其他人有该目录的写权限也无法执行删除操作。）</span><br><span class="line">$ chmod a+t directoryName</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>chmod 4755 filename 使此程序具有root的权限</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="chown-更改文件或目录的所有权"><a href="#chown-更改文件或目录的所有权" class="headerlink" title="chown-更改文件或目录的所有权"></a>chown-更改文件或目录的所有权</h2><ul>
<li>简介：<ul>
<li>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</li>
</ul>
</li>
</ul>
<pre><code>- 一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</code></pre><ul>
<li><p>语法：</p>
<ul>
<li><code>chown [选项参数] [--help] [--version] user[:group] file...</code></li>
<li>其中user表示新的文件拥有者的使用者 ID。group表示新的文件拥有者的使用者组(group)</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-c</strong></p>
<ul>
<li>显示更改的部分的信息</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>忽略错误信息</li>
</ul>
</li>
<li><p><strong>-h</strong></p>
<ul>
<li>修复符号链接</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>显示详细的处理信息</li>
</ul>
</li>
<li><p><strong>-R</strong></p>
<ul>
<li>处理指定目录以及其子目录下的所有文件</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助说明</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</span><br><span class="line">$ chown runoob:runoobgroup file1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将目前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</span><br><span class="line">$ chown -R runoob:runoobgroup *</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="cp-于复制文件或目录"><a href="#cp-于复制文件或目录" class="headerlink" title="cp-于复制文件或目录"></a>cp-于复制文件或目录</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux cp命令主要用于复制文件或目录。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>cp [options] source dest 或 cp [options] source... directory</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li>
</ul>
</li>
<li><p><strong>-d</strong></p>
<ul>
<li>复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>覆盖已经存在的目标文件而不给出提示。</li>
</ul>
</li>
<li><p><strong>-i</strong></p>
<ul>
<li>与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>不复制文件，只是生成链接文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用指令&quot;cp&quot;将当前目录&quot;test&#x2F;&quot;下的所有文件复制到新目录&quot;newtest&quot;下</span><br><span class="line">$ cp –r test&#x2F; newtest</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>用户使用该指令复制目录时，必须使用参数”-r”或者”-R”。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="curl——发送各种HTTP请求"><a href="#curl——发送各种HTTP请求" class="headerlink" title="curl——发送各种HTTP请求"></a>curl——发送各种HTTP请求</h2><ul>
<li><p>简介：</p>
<ul>
<li>curl命令的用途广泛，其功能包括下载、发送各种HTTP请求以及指定HTTP头部。</li>
<li>cURL默认会将下载文件输出到stdout，将进度信息输出到stderr。如果不想显示进度信息，可以使用–silent选项</li>
<li>cURL可以使用HTTP、HTTPS、FTP协议在客户端与服务器之间传递数据。它支持POST、cookie、认证、从指定偏移处下载部分文件、参照页（referer）、用户代理字符串、扩展头部、限速、文件大小限制、进度条等特性。cURL可用于网站维护、数据检索以及服务器配置核对。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>curl [选项] url</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>–silent</strong></p>
<ul>
<li>不显示进度信息</li>
</ul>
</li>
<li><p><strong>-O</strong></p>
<ul>
<li>指明将下载数据写入文件，采用从URL中解析出的文件名。注意，其中的URL必须是完整的，不能仅是站点的域名</li>
<li><code>$ curl www.knopper.net/index.htm -O</code></li>
</ul>
</li>
<li><p><strong>-o</strong></p>
<ul>
<li>指明将下载数据写入文件，可以指定输出文件名。如果使用了该选项，只需要写明站点的域名就可以下载其主页了</li>
<li><code>$ curl www.knopper.net -o knoppix_index.html</code></li>
</ul>
</li>
<li><p><strong>–progress</strong></p>
<ul>
<li>在下载过程中显示形如#的进度条</li>
<li><code>$ curl http://knopper.net -o index.html --progress</code><br>################################## 100.0%</li>
</ul>
</li>
<li><p><strong>-C</strong></p>
<ul>
<li>够从特定的文件偏移处继续下载，偏移量是以字节为单位的整数。</li>
<li><code>$ curl URL/file -C offset</code></li>
<li>如果只是想断点续传，那么cURL不需要指定准确的字节偏移。要是你希望cURL推断出正确的续传位置，请使用选项-C -。cURL会自动计算出应该从哪里开始续传</li>
<li><code>$ curl -C - www.xxx.com</code></li>
</ul>
</li>
<li><p><strong>–referer</strong></p>
<ul>
<li>指定参照页字符串。参照页（referer）①是位于HTTP头部中的一个字符串，用来标识用户是从哪个页面到达当前页面的。如果用户通过点击页面A中的某个链接跳转到了页面B，那么页面B头部的参照页字符串就会包含页面A的URL。</li>
<li>一些动态页面会在返回HTML数据前检测参照页字符串。例如，如果用户是通过Google搜索来到了当前页面，那么页面上就可以显示一个Google的logo；</li>
<li><code>$ curl --referer Referer_URL target_URL 如 $ curl --referer http://google.com http://knopper.org</code></li>
</ul>
</li>
<li><p><strong>–cookie</strong></p>
<ul>
<li>指定储HTTP操作过程中使用到的cookie，cookies需要以name=value的形式来给出。多个cookie之间使用分号分隔</li>
<li><code>$ curl http://example.com --cookie &quot;user=username;pass=hack&quot;</code></li>
</ul>
</li>
<li><p><strong>–cookie-jar</strong></p>
<ul>
<li>可以将cookie另存为文件</li>
<li><code>$ curl URL --cookie-jar cookie_file</code></li>
</ul>
</li>
<li><p><strong>-b <filename></strong></p>
<ul>
<li>指定以一个存储了Cookie值的本地文件内容作为cookie</li>
<li><code>$ curl -b stored_cookies_in_file www.baidu.com</code></li>
</ul>
</li>
<li><p><strong>–user-agent或-A</strong></p>
<ul>
<li>设置用户代理字符串,如果不指定用户代理（user agent），一些需要检验用户代理的页面就无法显示。例如，有些旧网站只能在Internet Explorer（IE）下正常工作。如果使用其他浏览器，则会提示只能用IE访问。这是因为这些网站检查了用户代理。</li>
<li><code>$ curl URL --user-agent &quot;Mozilla/5.0&quot;</code></li>
</ul>
</li>
<li><p><strong>-H</strong></p>
<ul>
<li>发送HTTP头部信息</li>
<li><code>$ curl -H &quot;Host: www.knopper.net&quot; -H &quot;Accept-language: en&quot; URL</code></li>
</ul>
</li>
<li><p><strong>–limit-rate</strong></p>
<ul>
<li>如果多个用户共享带宽有限，我们可以用–limit-rate限制cURL的下载速度。在命令中用k（千字节）和m（兆字节）指定下载速度限制</li>
<li><code>$ curl URL --limit-rate 20k</code></li>
</ul>
</li>
<li><p><strong>–max-filesize</strong></p>
<ul>
<li>指定可下载的最大文件大小。如果文件大小超出限制，命令返回一个非0的退出码。如果文件下载成功，则返回0。</li>
<li><code>$ curl URL --max-filesize bytes</code></li>
</ul>
</li>
<li><p><strong>-u</strong></p>
<ul>
<li>指定用户名和密码完成HTTP或FTP认证</li>
<li><code>$ curl -u user:pass http://test_auth.com</code></li>
<li>如果你喜欢经提示后输入密码，只需要使用用户名即可</li>
<li><code>$ curl -u user http://test_auth.com</code></li>
</ul>
</li>
<li><p><strong>-I 或–head</strong></p>
<ul>
<li>只打印HTTP头部信息，无须下载远程文件。只检查头部信息就足以完成很多检查或统计。例如，如果要检查某个页面是否能够打开，并不需要下载整个页面内容。只读取HTTP响应头部就足够了。</li>
<li><code>$ curl -I http://knopper.net</code></li>
</ul>
</li>
<li><p><strong>-E或–cert</strong></p>
<ul>
<li>指定本地证书</li>
<li><code>$ curl -E mycert.pem https:/itbilu.com</code></li>
</ul>
</li>
<li><p><strong>-T 或–upload-file</strong></p>
<ul>
<li>上传文件</li>
<li><code>$ curl -T ./index.html www.uploadhttp.com/receive.cgi</code></li>
</ul>
</li>
<li><p><strong>-d 或–data</strong></p>
<ul>
<li>POST提交表单数据</li>
<li><code>$ curl -X POST --data &#39;keyword=linux&#39; itbilu.com</code></li>
</ul>
</li>
<li><p><strong>-X</strong></p>
<ul>
<li>拓展http请求方法，使curl支持put，delete等</li>
<li><code>$ curl -X DELETE itbilu.com/examlple.html</code></li>
<li><code>$ curl -X PUT --data &#39;keyword=linux&#39; itbilu.com</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;访问一个网页时，可以使用curl命令后加上要访问的网址</span><br><span class="line">$ curl www.baidu.com</span><br><span class="line">&gt; &lt;!DOCTYPE html&gt;</span><br><span class="line">&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv&#x3D;content-type content&#x3D;text&#x2F;html;...</span><br><span class="line">&#x2F;&#x2F;我们就看到所访问网址的页面源码。</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="cut——按列切分文件"><a href="#cut——按列切分文件" class="headerlink" title="cut——按列切分文件"></a>cut——按列切分文件</h2><ul>
<li><p>简介：</p>
<ul>
<li>cut命令能够提取指定位置或列之间的字符。你可以指定每列的分隔符。在cut的术语中，每列被称为一个字段。</li>
<li>cut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、CSV文件或是由空格分隔的文件（例如标准日志文件）。</li>
<li>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>cut  [选项参数] [file]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-b <range></strong></p>
<ul>
<li>以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</li>
<li>range可以为如下格式，如cut -b 2-5 file<ul>
<li>N-：从第N个字节、字符、字段到结尾；</li>
<li>N-M：从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段；</li>
<li>-M：从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>-c <range></strong></p>
<ul>
<li>以字符为单位进行分割。</li>
<li>range可以为如下格式，如cut -c 2-5 file<ul>
<li>N-：从第N个字节、字符、字段到结尾；</li>
<li>N-M：从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段；</li>
<li>-M：从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>-d</strong></p>
<ul>
<li>自定义分隔符，默认为制表符。</li>
</ul>
</li>
<li><p><strong>-f <FIELD_LIST></strong></p>
<ul>
<li>指定要提取的列。FIELD_LIST是需要显示的列。它由列号组成，彼此之间用逗号分隔。</li>
</ul>
</li>
<li><p><strong>-n</strong></p>
<ul>
<li>取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除</li>
</ul>
</li>
<li><p><strong>–complement</strong></p>
<ul>
<li>显示出没有被-f指定的那些字段。</li>
</ul>
</li>
<li><p><strong>–output-delimiter</strong></p>
<ul>
<li>指定输出分隔符。在显示多组数据时，该选项尤为有用</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从使用制表符作为分隔符的文件中提取列</span><br><span class="line">$ cat student_data.txt </span><br><span class="line">&gt; No Name Mark Percent </span><br><span class="line">&gt; 1 Sarath 45 90 </span><br><span class="line">&gt; 2 Alex 49 98 </span><br><span class="line">&gt; 3 Anu 45 90</span><br><span class="line">$ cut -f 1 student_data.txt</span><br><span class="line">&gt; No </span><br><span class="line">&gt; 1 </span><br><span class="line">&gt; 2 </span><br><span class="line">&gt; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;要想提取多个字段，就得给出由逗号分隔的多个字段编号</span><br><span class="line">$ cut -f 2,4 student_data.txt </span><br><span class="line">&gt; Name Percent </span><br><span class="line">&gt; Sarath 90 </span><br><span class="line">&gt; Alex 98 </span><br><span class="line">&gt; Anu 90</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用cut处理由分号分隔的字段</span><br><span class="line">$ cat delimited_data.txt</span><br><span class="line">&gt; No;Name;Mark;Percent </span><br><span class="line">&gt; 1;Sarath;45;90 </span><br><span class="line">&gt; 2;Alex;49;98 </span><br><span class="line">&gt; 3;Anu;45;90</span><br><span class="line">$ cut -f2 -d&quot;;&quot; delimited_data.txt</span><br><span class="line">&gt; Name </span><br><span class="line">&gt; Sarath </span><br><span class="line">&gt; Alex </span><br><span class="line">&gt; Anu</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印第2个到第5个字符</span><br><span class="line">$ cat range_fields.txt</span><br><span class="line">&gt; abcdefghijklmnopqrstuvwxyz </span><br><span class="line">&gt; abcdefghijklmnopqrstuvwxyz </span><br><span class="line">&gt; abcdefghijklmnopqrstuvwxyz</span><br><span class="line">&#x2F;&#x2F;打印第2个到第5个字符</span><br><span class="line">$ cut -c2-5 range_fields.txt</span><br><span class="line">&gt; ab </span><br><span class="line">&gt; ab </span><br><span class="line">&gt; ab </span><br><span class="line">&#x2F;&#x2F;--output-delimiter指定输出分隔符</span><br><span class="line">$ cut range_fields.txt -c1-3,6-9 --output-delimiter &quot;,&quot;</span><br><span class="line">&gt; abc,fghi </span><br><span class="line">&gt; abc,fghi </span><br><span class="line">&gt; abc,fghi</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="date-显示或设定系统的日期与时间"><a href="#date-显示或设定系统的日期与时间" class="headerlink" title="date-显示或设定系统的日期与时间"></a>date-显示或设定系统的日期与时间</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>date [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help] [--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-d datestr</strong></p>
<ul>
<li>显示 datestr 中所设定的时间 (非系统时间)</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助讯息</li>
</ul>
</li>
<li><p><strong>-s datestr 或 –set</strong></p>
<ul>
<li>将系统时间设为 datestr 中所设定的时间</li>
</ul>
</li>
<li><p><strong>-u 或 –utc</strong></p>
<ul>
<li>显示目前的格林威治时间</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本编号</li>
</ul>
</li>
<li><p><strong>–date</strong></p>
<ul>
<li>显示该选项指定的输入日期所设定的时间</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>格式字段datestr必须以+号开头</p>
</blockquote>
<blockquote>
<p>当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。</p>
</blockquote>
<blockquote>
<p>date命令的最小精度是秒</p>
</blockquote>
<blockquote>
<p>只有取得权限者(比如说 root)才能设定系统时间。当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。</p>
</blockquote>
<blockquote>
<p>datestr的值有如下这些可选：</p>
</blockquote>
<ul>
<li><p><strong>%</strong></p>
<ul>
<li>印出 %</li>
</ul>
</li>
<li><p><strong>%n</strong></p>
<ul>
<li>下一行</li>
</ul>
</li>
<li><p><strong>%t</strong></p>
<ul>
<li>跳格，一个tab</li>
</ul>
</li>
<li><p><strong>%H</strong></p>
<ul>
<li>小时(00-23)</li>
</ul>
</li>
<li><p><strong>%I</strong></p>
<ul>
<li>小时(01-12)</li>
</ul>
</li>
<li><p><strong>%k</strong></p>
<ul>
<li>小时(0-23)</li>
</ul>
</li>
<li><p><strong>%l</strong></p>
<ul>
<li>小时(1-12)</li>
</ul>
</li>
<li><p><strong>%M</strong></p>
<ul>
<li>分钟(00-59)</li>
</ul>
</li>
<li><p><strong>%p</strong></p>
<ul>
<li>显示本地 AM 或 PM</li>
</ul>
</li>
<li><p><strong>%S</strong></p>
<ul>
<li>秒(00-61)</li>
</ul>
</li>
<li><p><strong>%T</strong></p>
<ul>
<li>直接显示时间 (24 小时制)</li>
</ul>
</li>
<li><p><strong>%Z</strong></p>
<ul>
<li>显示时区</li>
</ul>
</li>
<li><p><strong>%a</strong></p>
<ul>
<li>星期几 (Sun-Sat)</li>
</ul>
</li>
<li><p><strong>%A</strong></p>
<ul>
<li>星期几 (Sunday-Saturday)</li>
</ul>
</li>
<li><p><strong>%b</strong></p>
<ul>
<li>月份 (Jan-Dec)</li>
</ul>
</li>
<li><p><strong>%B</strong></p>
<ul>
<li>月份 (January-December)</li>
</ul>
</li>
<li><p><strong>%c</strong></p>
<ul>
<li>直接显示日期与时间</li>
</ul>
</li>
<li><p><strong>%d</strong></p>
<ul>
<li>日 (01-31)</li>
</ul>
</li>
<li><p><strong>%D</strong></p>
<ul>
<li>直接显示日期 (mm/dd/yy)</li>
</ul>
</li>
<li><p><strong>%h</strong></p>
<ul>
<li>同 %b</li>
</ul>
</li>
<li><p><strong>%j</strong></p>
<ul>
<li>一年中的第几天 (001-366)</li>
</ul>
</li>
<li><p><strong>%m</strong></p>
<ul>
<li>月份 (01-12)</li>
</ul>
</li>
<li><p><strong>%U</strong></p>
<ul>
<li>一年中的第几周 (00-53) (以 Sunday 为一周的第一天的情形)</li>
</ul>
</li>
<li><p><strong>%w</strong></p>
<ul>
<li>一周中的第几天 (0-6)</li>
</ul>
</li>
<li><p><strong>%W</strong></p>
<ul>
<li>一年中的第几周 (00-53) (以 Monday 为一周的第一天的情形)</li>
</ul>
</li>
<li><p><strong>%x</strong></p>
<ul>
<li>直接显示日期 (mm/dd/yy)</li>
</ul>
</li>
<li><p><strong>%y</strong></p>
<ul>
<li>年份的最后两位数字 (00-99)</li>
</ul>
</li>
<li><p><strong>%Y</strong></p>
<ul>
<li>完整年份 (0000-9999)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>代码示例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;读取当前时间</span><br><span class="line">$ date</span><br><span class="line">&gt; Thu May 20 23:09:04 IST 2010</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印unix时间</span><br><span class="line">$ date +%s</span><br><span class="line">&gt; 1290047248</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将输入的时间转换成unix时间</span><br><span class="line">$ date --date &quot;Wed mar 15 08:09:16 EDT 2017&quot; +%s</span><br><span class="line">&gt; 1489579718</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取当前时间</span><br><span class="line">$ date &quot;+%d %B %Y&quot;</span><br><span class="line">&gt; 20 May 2010</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置日期和时间</span><br><span class="line">$ date -s &quot;21 June 2009 11:01:22&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示时间后换行，再显示目前日期</span><br><span class="line">$ date &#39;+%T%n%D&#39;</span><br><span class="line">&gt;23:09:00</span><br><span class="line">&gt;07&#x2F;09&#x2F;19</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按自己的格式输出</span><br><span class="line">$ date &#39;+usr_time: $1:%M %P -hey&#39;</span><br><span class="line">&gt; usr_time: $1:16 下午 -hey</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="echo-打印内容"><a href="#echo-打印内容" class="headerlink" title="echo-打印内容"></a>echo-打印内容</h2><ul>
<li><p>简介：</p>
</li>
<li><p>echo命令是linux中最基础的命令,也是很常用的命令,功能说明用以显示文字。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>echo [-ne][字符串]或 echo [--help][--version]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-n</strong></p>
<ul>
<li>echo会在输出文本的尾部追加一个换行符。可以使用选项-n来禁止这种行为。</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">激活转义字符。使用-e选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：</span><br><span class="line">\a 发出警告声；</span><br><span class="line">\b 删除前一个字符；</span><br><span class="line">\c 最后不加上换行符号；</span><br><span class="line">\f 换行但光标仍旧停留在原来的位置；</span><br><span class="line">\n 换行且光标移至行首；</span><br><span class="line">\r 光标移至行首，但不换行；</span><br><span class="line">\t 插入tab；</span><br><span class="line">\v 与\f相同；</span><br><span class="line">\\ 插入\字符；</span><br><span class="line">\e 打印彩色文本 </span><br><span class="line">	文本颜色是由对应的色彩码来描述的。其中包括：重置&#x3D;0，黑色&#x3D;30，红色&#x3D;31，绿色&#x3D;32，黄色&#x3D;33，蓝色&#x3D;34，洋红&#x3D;35，青色&#x3D;36，白色&#x3D;37。</span><br><span class="line">	对于彩色背景，经常使用的颜色码是：重置&#x3D;0，黑色&#x3D;40，红色&#x3D;41，绿色&#x3D;42，黄色&#x3D;43，蓝色&#x3D;44，洋红&#x3D;45，青色&#x3D;46，白色&#x3D;47。</span><br><span class="line">	用法：echo -e &quot;\e[1;31m This is red text \e[0m&quot; </span><br><span class="line">	其中\e[1;31m是一个转义字符串，可以将颜色设为红色，\e[0m将颜色重新置回。</span><br><span class="line">\nnn 插入nnn（八进制）所代表的ASCII字符；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>echo的单引号不会解释文本中的特殊字符，双引号会。</p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ a&#x3D;1;</span><br><span class="line">- echo &#39;$a+1&#39;</span><br><span class="line">&gt; a+1</span><br><span class="line">$ echo &quot;$a+1&quot;</span><br><span class="line">&gt; 1+1</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="find-查找文件"><a href="#find-查找文件" class="headerlink" title="find-查找文件"></a>find-查找文件</h2><ul>
<li><p>简介：</p>
<ul>
<li>find命令的工作方式如下：沿着文件层次结构向下遍历，匹配符合条件的文件，执行相应<br>的操作。默认的操作是打印出文件和目录，这也可以使用-print选项来指定。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-mount或 -xdev</strong></p>
<ul>
<li>只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</li>
</ul>
</li>
<li><p><strong>-newer file</strong></p>
<ul>
<li>找出比file文件更新的（更近的修改时间）所有文件。</li>
</ul>
</li>
<li><p><strong>-anewer file</strong></p>
<ul>
<li>查找比文件 file 更晚被读取过的文件</li>
</ul>
</li>
<li><p><strong>-cnewer file</strong></p>
<ul>
<li>查找比文件 file 更新的文件</li>
</ul>
</li>
<li><p><strong>-amin n</strong></p>
<ul>
<li>根据用户最近一次访问文件的时间查找，查找在过去 n 分钟内被读取过的文件,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-atime n</strong></p>
<ul>
<li>根据用户最近一次访问文件的时间查找，查找在过去 n 天内被读取过的文件,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-cmin n</strong></p>
<ul>
<li>根据文件元数据（例如权限或所有权）最后一次改变的时间查找，查找在过去 n 分钟内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-ctime n</strong></p>
<ul>
<li>根据文件元数据（例如权限或所有权）最后一次改变的时间查找，查找在过去 n 天内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-mtime n</strong></p>
<ul>
<li>根据文件内容最后一次被修改的时间查找，查找在过去 n 分钟内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-mmin n</strong></p>
<ul>
<li>根据文件内容最后一次被修改的时间查找，查找在过去 n 天内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-ipath p, -path p</strong></p>
<ul>
<li>查找路径名称符合 p 的文件，ipath 会忽略大小写。p一般可以为通配符如’<em>/slynux/</em>‘</li>
</ul>
</li>
<li><p><strong>-regex r,-iregex r</strong></p>
<ul>
<li>查找路径名称符合 r 的文件。r 一般可以为正则表达式</li>
</ul>
</li>
<li><p><strong>-name name, -iname name</strong></p>
<ul>
<li>查找文件名称符合 name 的文件。iname 会忽略大小写。这个模式可以是通配符，也可以是正则表达式。如’*.txt’能够匹配所有名字以.txt结尾的文件或目录</li>
</ul>
</li>
<li><p><strong>-size n</strong></p>
<ul>
<li>可以根据文件的大小展开搜索，n可以为+2k，数字前面可以加上-或+。-表示小于，+表示大于。单位取值可以为<ul>
<li>b：块（512字节）。</li>
<li>c：字节。</li>
<li>w：字（2字节）。</li>
<li>k：千字节（1024字节）。</li>
<li>M：兆字节（1024K字节）。</li>
<li>G：吉字节（1024M字节）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>-maxdepth n,–mindepth n</strong></p>
<ul>
<li>-maxdepth和–mindepth选项可以限制find命令遍历的目录深度。这可以避免find命令没完没了地查找。</li>
</ul>
</li>
<li><p><strong>–user USER</strong></p>
<ul>
<li>找出由某个特定用户权限下所拥有的文件。参数USER可以是用户名或UID。</li>
</ul>
</li>
<li><p><strong>-prune n</strong></p>
<ul>
<li>在搜索时排除某些文件或目录,一般与其他选项一起使用，如.git目录应该被排除在外：<br><code>$ find devel/source_path -name &#39;.git&#39; -prune -o -type f -print</code></li>
</ul>
</li>
<li><p><strong>-perm n</strong></p>
<ul>
<li>指明find应该只匹配具有特定权限值的文件。n为文件权限<br><code>$ find devel/source_path -name &#39;.git&#39; -prune -o -type f -print</code></li>
</ul>
</li>
<li><p><strong>pid n</strong></p>
<ul>
<li>process id 是 n 的文件</li>
</ul>
</li>
<li><p><strong>-type t</strong></p>
<ul>
<li><p>类Unix系统将一切都视为文件。文件具有不同的类型，例如普通文件、目录、字符设备、块<br>设备、符号链接、硬链接、套接字以及FIFO等。可以使用-type选项对文件搜索进行过滤。借助这个选项，我们可以告诉find命令只匹配指定类型的文件。t的取值可以是</p>
<ul>
<li><p>d：目录</p>
</li>
<li><p>c: 字符设备</p>
</li>
<li><p>b: 块设备</p>
</li>
<li><p>p: FIFO具名贮列</p>
</li>
<li><p>f: 一般文件</p>
</li>
<li><p>l: 符号链接</p>
</li>
<li><p>s: socket套接字</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;列出给定目录下所有的文件和子目录 find base_path</span><br><span class="line">$ find . -print</span><br><span class="line">&gt; .history </span><br><span class="line">&gt; Downloads</span><br><span class="line">&gt; Downloads&#x2F;tcl.fossil </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;够匹配所有名字以.txt结尾的文件或目录。</span><br><span class="line">$ find &#x2F;home&#x2F;slynux -name &#39;*.txt&#39; -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;find命令支持逻辑操作符。-a和-and选项可以执行逻辑与（AND）操作，-o和-or选项可以执行逻辑或（OR）操作。</span><br><span class="line">$ find . \( -name &#39;*.txt&#39; -o -name &#39;*.pdf&#39; \) -print </span><br><span class="line">&gt; .&#x2F;text.pdf </span><br><span class="line">&gt; .&#x2F;new.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用-and操作符选择名字以s开头且其中包含e的文件</span><br><span class="line">$ find . \( -name &#39;*e*&#39; -and -name &#39;s*&#39; \)</span><br><span class="line">&gt; .&#x2F;some.jpg</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匹配.py或.sh文件</span><br><span class="line">$ find . -regex &#39;.*\.(py\|sh\)$&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;find也可以用!排除匹配到的模式,匹配所有不以.txt结尾的文件</span><br><span class="line">$ find . ! -name &quot;*.txt&quot; -print</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印出在最近7天内被访问过的所有文件</span><br><span class="line">$ find . -type f -atime -7 -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印出访问时间超过7天的所有文件。</span><br><span class="line">$ find . -type f -atime +7 -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找出比file.txt修改时间更近的所有文件</span><br><span class="line">$ find . -type f -newer file.txt -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印出用户slynux拥有的所有文件</span><br><span class="line">$ find . -type f -user slynux -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;利用find执行相应操作</span><br><span class="line">&#x2F;&#x2F;删除匹配的文件</span><br><span class="line">&#x2F;&#x2F;find命令的-delete选项可以删除所匹配到的文件。下面的命令能够从当前目录中删除.swp文件：</span><br><span class="line">$ find . -type f -name &quot;*.swp&quot; -delete</span><br><span class="line"></span><br><span class="line">&#x2F;利用find执行相应操作</span><br><span class="line">&#x2F;&#x2F;执行命令,利用-exec选项，find命令可以结合其他命令使用。</span><br><span class="line">&#x2F;&#x2F;将某位用户（比如root）所拥有的全部文件的所有权更改成另一位用户（比如用户www-data）</span><br><span class="line">&#x2F;&#x2F;那么可以用-user找出root拥有的所有文件，然后用-exec更改所有权。</span><br><span class="line">&#x2F;&#x2F;在下面的例子中，对于每一个匹配的文件，find命令会将&#123;&#125;替换成相应的文件名并更改该文件的所有权。</span><br><span class="line">$ find . -type f -user root -exec chown slynux &#123;&#125; \;</span><br><span class="line">&#x2F;&#x2F;find命令使用一对花括号&#123;&#125;代表文件名。</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>注意 find . -type f -user root -exec chown slynux {} ; 该命令结尾的;。必须对分号进行转义，否则shell会将其视为find命令的结束，而非chown命令的结束。</p>
</blockquote>
<blockquote>
<p>为每个匹配到的文件调用命令可是个不小的开销。如果指定的命令接受多个参数（如chown），你可以换用加号（+）作为命令的结尾。这样find会生成一份包含所有搜索结果的列表，然后将其作为指定命令的参数，一次性执行。</p>
</blockquote>
<blockquote>
<p>我们无法在-exec选项中直接使用多个命令。该选项只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个 shell脚本中（例如command.sh），然后在-exec中使用这个脚本：<br>-exec ./commands.sh {} ;</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="ftp-lftp——使用ftp协议共享文件"><a href="#ftp-lftp——使用ftp协议共享文件" class="headerlink" title="ftp/lftp——使用ftp协议共享文件"></a>ftp/lftp——使用ftp协议共享文件</h2><ul>
<li><p>简介：</p>
<ul>
<li>文件传输协议（File Transfer Protocol，FTP）是一个古老的协议，在很多公共站点上用于文件共享。</li>
<li>FTP服务器通常运行在端口21上。远程主机上必须安装并运行FTP服务器才能使用FTP。</li>
<li>我们可以使用传统的ftp命令或更新的lftp命令访问FTP服务器。两者都支持下面要讲到的命令。很多公共网站都是用FTP共享文件</li>
</ul>
</li>
<li><p>使用步骤</p>
<ol>
<li>要连接FTP服务器传输文件，可以使用<ul>
<li><code>$ lftp username@ftphost</code></li>
<li>它会提示你输入密码，然后显示一个像下面这样的登录提示符<br><code>lftp username@ftphost:~&gt;</code></li>
</ul>
</li>
<li>你可以在提示符后输入各种命令，如下所示<ul>
<li>cd directory：更改远程主机目录。</li>
<li>lcd：更改本地主机目录。</li>
<li>mkdir：在远程主机上创建目录。</li>
<li>ls：列出远程主机当前目录下的文件。</li>
<li>get FILENAME：将文件下载到本地主机的当前目录中。<ul>
<li><code>lftp username@ftphost:~&gt; get filename</code></li>
</ul>
</li>
<li>put filename：将文件从当前目录上传到远程主机。<ul>
<li><code>lftp username@ftphost:~&gt; put filename</code></li>
</ul>
</li>
<li>quit命令可以退出lftp会话</li>
</ul>
</li>
</ol>
</li>
<li><p>注意事项</p>
<blockquote>
<p>lftp提示符支持命令自动补全。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="grep——在文件中搜索文本"><a href="#grep——在文件中搜索文本" class="headerlink" title="grep——在文件中搜索文本"></a>grep——在文件中搜索文本</h2><ul>
<li><p>简介：</p>
<ul>
<li><p>Linux grep命令用于查找文件里符合条件的字符串。</p>
</li>
<li><p>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一行显示出来。</p>
</li>
<li><p>若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。</p>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>grep [选项参数][范本样式][文件或目录...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a 或 –text</strong></p>
<ul>
<li>不要忽略二进制的数据。</li>
</ul>
</li>
<li><p><strong>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt;</strong></p>
<ul>
<li>除了显示符合范本样式的那一行之外，并显示该行之后的内容。</li>
</ul>
</li>
<li><p><strong>-b 或 –byte-offset</strong></p>
<ul>
<li>可以打印出匹配出现在行中的偏移。字符在行中的偏移是从0开始计数，不是1。</li>
</ul>
</li>
<li><p><strong>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt;</strong></p>
<ul>
<li>除了显示符合样式的那一行之外，并显示该行之前的内容。</li>
</ul>
</li>
<li><p><strong>-c 或 –count</strong></p>
<ul>
<li>计算符合样式的行数。需要注意的是-c只是统计匹配行的数量，并不是匹配的次数</li>
</ul>
</li>
<li><p><strong>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong></p>
<ul>
<li>除了显示符合样式的那一行之外，并显示该行之前和之后的内容。</li>
</ul>
</li>
<li><p><strong>-d &lt;动作&gt; 或 –directories=&lt;动作&gt;</strong></p>
<ul>
<li>当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li>
</ul>
</li>
<li><p><strong>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt;</strong></p>
<ul>
<li>指定字符串做为查找文件内容的样式。可以指定多个匹配模式。</li>
</ul>
</li>
<li><p><strong>-E 或 –extended-regexp</strong></p>
<ul>
<li>将样式为延伸的普通表示法来使用。grep命令默认使用基础正则表达式。这是先前描述的正则表达式的一个子集。选项-E可以使grep使用扩展正则表达式。也可以使用默认启用扩展正则表达式的egrep命令。</li>
</ul>
</li>
<li><p><strong>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt;</strong></p>
<ul>
<li>指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li>
</ul>
</li>
<li><p><strong>-F 或 –fixed-regexp</strong></p>
<ul>
<li>将样式视为固定字符串的列表。</li>
</ul>
</li>
<li><p><strong>-G 或 –basic-regexp</strong></p>
<ul>
<li>将样式视为普通的表示法来使用。</li>
</ul>
</li>
<li><p><strong>-h 或 –no-filename</strong></p>
<ul>
<li>在显示符合样式的那一行之前，不标示该行所属的文件名称。</li>
</ul>
</li>
<li><p><strong>-H 或 –with-filename</strong></p>
<ul>
<li>在显示符合样式的那一行之前，表示该行所属的文件名称。</li>
</ul>
</li>
<li><p><strong>-i 或 –ignore-case</strong></p>
<ul>
<li>忽略字符大小写的差别。</li>
</ul>
</li>
<li><p><strong>-l 或 –file-with-matches</strong></p>
<ul>
<li>列出文件内容符合指定的样式的文件名称。</li>
</ul>
</li>
<li><p><strong>-L 或 –files-without-match</strong></p>
<ul>
<li>列出文件内容不符合指定的样式的文件名称。</li>
</ul>
</li>
<li><p><strong>-n 或 –line-number</strong></p>
<ul>
<li>在显示符合样式的那一行之前，标示出该行的列数编号。</li>
</ul>
</li>
<li><p><strong>-o 或 –only-matching</strong></p>
<ul>
<li>只显示匹配PATTERN 部分。</li>
</ul>
</li>
<li><p><strong>-q 或 –quiet或–silent</strong></p>
<ul>
<li>不显示任何信息。</li>
</ul>
</li>
<li><p><strong>-r 或 –recursive</strong></p>
<ul>
<li>此参数的效果和指定”-d recurse”参数相同。</li>
</ul>
</li>
<li><p><strong>-s 或 –no-messages</strong></p>
<ul>
<li>不显示错误信息。</li>
</ul>
</li>
<li><p><strong>-v 或 –revert-match</strong></p>
<ul>
<li>显示不包含匹配文本的所有行。</li>
</ul>
</li>
<li><p><strong>-V 或 –version</strong></p>
<ul>
<li>显示版本信息。</li>
</ul>
</li>
<li><p><strong>-w 或 –word-regexp</strong></p>
<ul>
<li>只显示全字符合的列。</li>
</ul>
</li>
<li><p><strong>-x –line-regexp</strong></p>
<ul>
<li>只显示全列符合的列。</li>
</ul>
</li>
<li><p><strong>-y</strong></p>
<ul>
<li>此参数的效果和指定”-i”参数相同。</li>
</ul>
</li>
<li><p><strong>–color</strong></p>
<ul>
<li>在输出行中着重标记出匹配到的模式，一般为–color=auto。</li>
</ul>
</li>
<li><p><strong>–include</strong></p>
<ul>
<li>在搜索过程中使用通配符指定（include）某些文件</li>
</ul>
</li>
<li><p><strong>–exclude</strong></p>
<ul>
<li>在搜索过程中使用通配符排除（exclude）某些文件</li>
</ul>
</li>
<li><p><strong>–exclude-dir</strong></p>
<ul>
<li>在搜索过程中使用通配符以排除目录</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在当前目录中，查找有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。</span><br><span class="line">$ grep test *file* </span><br><span class="line">&gt; file1:This a Linux testfile! #列出file1 文件中包含test字符的行  </span><br><span class="line">&gt; file_2:This is a linux testfile! #列出file_2 文件中包含test字符的行  </span><br><span class="line">&gt; file_2:Linux test #列出file_2 文件中包含test字符的行 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以递归的方式查找符合条件的文件。</span><br><span class="line">&#x2F;&#x2F;例如，查找指定目录&#x2F;etc&#x2F;acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串&quot;update&quot;的文件</span><br><span class="line">&#x2F;&#x2F;并打印出该字符串所在行的内容</span><br><span class="line">$ grep -r update &#x2F;etc&#x2F;acpi </span><br><span class="line">&gt; &#x2F;etc&#x2F;acpi&#x2F;ac.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  Rather than  </span><br><span class="line">&gt; &#x2F;etc&#x2F;acpi&#x2F;resume.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.) Rather than  </span><br><span class="line">&gt; &#x2F;etc&#x2F;acpi&#x2F;events&#x2F;thinkpad-cmos: action&#x3D;&#x2F;usr&#x2F;sbin&#x2F;thinkpad-keys--update </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;反向查找。前面各个例子是查找并打印出符合条件的行，通过&quot;-v&quot;参数可以打印出不符合条件行的内容。</span><br><span class="line">&#x2F;&#x2F;查找文件名中包含 file 的文件中不包含test 的行，</span><br><span class="line">$ grep -v test *file*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在stdin中搜索匹配特定模式的文本行</span><br><span class="line">$ $ echo -e &quot;this is a word \n next line&quot; | grep word</span><br><span class="line">&gt; this is a word</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用扩展正则，只输出匹配到的文本，</span><br><span class="line">$ echo this is a line. | grep -o -E &quot;[a-z]+\.&quot;</span><br><span class="line">&gt; line</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计出匹配模式的文本行数，-c只是统计匹配行的数量，并不是匹配的次数</span><br><span class="line">$ grep -c &quot;text&quot; filename</span><br><span class="line">&gt; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计文件中匹配项的数量，可以使用下面的技巧</span><br><span class="line">$ echo -e &quot;1 2 3 4\nhello\n5 6&quot; | egrep -o &quot;[0-9]&quot; | wc -l</span><br><span class="line">&gt; 6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印多个文件包含Linux的行，输出行号</span><br><span class="line">$ grep linux -n sample1.txt sample2.txt</span><br><span class="line">&gt; sample1.txt:2:linux is fun </span><br><span class="line">&gt; sample2.txt:2:planetlinux</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选项-b可以打印出匹配出现在行中的偏移。配合选项-o可以打印出匹配所在的字符或字节偏移</span><br><span class="line">$ echo gnu is not unix | grep -b -o &quot;not&quot;</span><br><span class="line">&gt; 7:not</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出匹配模式所在的文件</span><br><span class="line">$ grep -l linux sample1.txt sample2.txt</span><br><span class="line">&gt; sample1.txt </span><br><span class="line">&gt; sample2.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对当前目录中对文本进行递归搜索</span><br><span class="line">$  grep &quot;text&quot; . -R -n</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在匹配模式时不考虑字符的大小写</span><br><span class="line">$ echo hello world | grep -i &quot;HELLO&quot;</span><br><span class="line">&gt; hello</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用-e指定多个匹配模式，打印出匹配任意一种模式的行，每个匹配对应一行输出。</span><br><span class="line">$  echo this is a line of text | grep -o -e &quot;this&quot; -e &quot;line&quot;</span><br><span class="line">&gt; this </span><br><span class="line">&gt; line</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以将多个模式定义在文件中。选项-f可以读取文件并使用其中的模式（一个模式一行）</span><br><span class="line">$ cat pat_file </span><br><span class="line">&gt; hello </span><br><span class="line">&gt; cool</span><br><span class="line">$ echo hello this is cool | grep -f pat_file</span><br><span class="line">&gt; hello this is cool</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用--include选项在目录中递归搜索所有的 .c和 .cpp文件。</span><br><span class="line">&#x2F;&#x2F;注意，some&#123;string1,string2,string3&#125;会被扩展成somestring1 somestring2 somestring3。</span><br><span class="line">$ grep &quot;main()&quot; . -r --include *.&#123;c,cpp&#125;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用选项--exclude在搜索过程中排除所有的README文件</span><br><span class="line">$ grep &quot;main()&quot; . -r --exclude &quot;README&quot;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选项--exclude-dir可以排除目录：</span><br><span class="line">$ grep main . -r -exclude-dir CVS</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;grep的静默输出。可以通过设置grep的静默选项（-q）来实现。</span><br><span class="line">&#x2F;&#x2F;在静默模式中，grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。</span><br><span class="line">&#x2F;&#x2F;0表示匹配成功，非0表示匹配失败。</span><br><span class="line">$ grep -q word file</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h2 id="head-打印文件的前n行"><a href="#head-打印文件的前n行" class="headerlink" title="head-打印文件的前n行"></a>head-打印文件的前n行</h2><ul>
<li><p>简介：</p>
</li>
<li><p>head命令用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>head [选项] fileName</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-n&lt;数字&gt;</strong></p>
<ul>
<li>指定显示头部内容的行数,负数时表示倒数n行</li>
</ul>
</li>
<li><p><strong>-c&lt;字符数&gt;</strong></p>
<ul>
<li>指定显示头部内容的字符数；</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>总是显示文件名的头信息；</li>
</ul>
</li>
<li><p><strong>-q</strong></p>
<ul>
<li>不显示文件名的头信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示 test.log 文件中前 20 行</span><br><span class="line">$ head -n 20 test.log</span><br><span class="line">&#x2F;&#x2F;显示 test.log 文件中前 20 字节</span><br><span class="line">$ head -c 20 test.log</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示 test.log 文件中除了最后20行之外的所有行</span><br><span class="line">$ head -n -20 test.log</span><br></pre></td></tr></table></figure>
<p>  <img src="https://oscimg.oschina.net/oscnet/15e07e85dcfeca736889def8b923fd05a0f.jpg" alt=""></p>
</li>
</ul>
<hr>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><h2 id="ifconfig——配置和展示网络信息"><a href="#ifconfig——配置和展示网络信息" class="headerlink" title="ifconfig——配置和展示网络信息"></a>ifconfig——配置和展示网络信息</h2><ul>
<li><p>简介：</p>
</li>
<li><p>ifconfig可设置网络设备的状态，或是显示目前的设置。注意和Windows的命令ipconfig区分。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>ifconfig [选项参数]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>add&lt;地址&gt;</strong></p>
<ul>
<li>设置网络设备IPv6的IP地址。</li>
</ul>
</li>
<li><p><strong>del&lt;地址&gt;</strong></p>
<ul>
<li>删除网络设备IPv6的IP地址。</li>
</ul>
</li>
<li><p><strong>down</strong></p>
<ul>
<li>关闭指定的网络设备。</li>
</ul>
</li>
<li><p><strong>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;</strong></p>
<ul>
<li>设置网络设备的类型与硬件地址。</li>
</ul>
</li>
<li><p><strong>io_addr&lt;I/O地址&gt;</strong></p>
<ul>
<li>设置网络设备的I/O地址。</li>
</ul>
</li>
<li><p><strong>irq&lt;IRQ地址&gt;</strong></p>
<ul>
<li>设置网络设备的IRQ。</li>
</ul>
</li>
<li><p><strong>media&lt;网络媒介类型&gt;</strong></p>
<ul>
<li>设置网络设备的媒介类型。</li>
</ul>
</li>
<li><p><strong>mem_start&lt;内存地址&gt;</strong></p>
<ul>
<li>设置网络设备在主内存所占用的起始地址。</li>
</ul>
</li>
<li><p><strong>metric&lt;数目&gt;</strong></p>
<ul>
<li>指定在计算数据包的转送次数时，所要加上的数目。</li>
</ul>
</li>
<li><p><strong>mtu&lt;字节&gt;</strong></p>
<ul>
<li>设置网络设备的MTU。</li>
</ul>
</li>
<li><p><strong>netmask&lt;子网掩码&gt;</strong></p>
<ul>
<li>设置网络设备的子网掩码。</li>
</ul>
</li>
<li><p><strong>tunnel&lt;地址&gt;</strong></p>
<ul>
<li>建立IPv4与IPv6之间的隧道通信地址。</li>
</ul>
</li>
<li><p><strong>up</strong></p>
<ul>
<li>启动指定的网络设备。</li>
</ul>
</li>
<li><p><strong>-broadcast&lt;地址&gt;</strong></p>
<ul>
<li>将要送往指定地址的数据包当成广播数据包来处理。</li>
</ul>
</li>
<li><p><strong>-pointopoint&lt;地址&gt;</strong></p>
<ul>
<li>与指定地址的网络设备建立直接连线，此模式具有保密功能。</li>
</ul>
</li>
<li><p><strong>-promisc</strong></p>
<ul>
<li>关闭或启动指定网络设备的promiscuous模式。</li>
</ul>
</li>
<li><p><strong>[IP地址]</strong></p>
<ul>
<li>指定网络设备的IP地址。</li>
</ul>
</li>
<li><p><strong>[网络设备]</strong></p>
<ul>
<li>指定网络设备的名称。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示网络设备信息，ifconfig输出的最左边一列是网络接口名，右边的若干列显示对应的网络接口的详细信息。</span><br><span class="line">$ ifconfig</span><br><span class="line">&gt; eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C </span><br><span class="line">&gt; .....以下省略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ifconfig会显示系统中所有活动网络接口的详细信息。不过，我们可以限制它只显示某个特定接口的信息</span><br><span class="line">$ ifconfig  wlan0</span><br><span class="line">&gt; wlan0 Link encap:EthernetHWaddr 00:1c:bf:87:25:d2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置网络接口的IP地址</span><br><span class="line">$ ifconfig wlan0 192.168.0.80</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置此IP地址的子网掩码</span><br><span class="line">$ ifconfig wlan0 192.168.0.80 netmask 255.255.252.0</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><h2 id="less——对文件或其它输出进行分页显示"><a href="#less——对文件或其它输出进行分页显示" class="headerlink" title="less——对文件或其它输出进行分页显示"></a>less——对文件或其它输出进行分页显示</h2><ul>
<li><p>简介：</p>
<ul>
<li>对文件或其它输出进行分页显示。缓冲加载。</li>
<li>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>less [参数] 文件</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-e</strong></p>
<ul>
<li>当文件显示结束后，自动离开</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>强迫打开特殊文件，例如外围设备代号、目录和二进制文件</li>
</ul>
</li>
<li><p><strong>-g</strong></p>
<ul>
<li>只标志最后搜索的关键词</li>
</ul>
</li>
<li><p><strong>-i</strong></p>
<ul>
<li>忽略搜索时的大小写</li>
</ul>
</li>
<li><p><strong>-m</strong></p>
<ul>
<li>显示类似more命令的百分比</li>
</ul>
</li>
<li><p><strong>-N</strong></p>
<ul>
<li>显示每行的行号</li>
</ul>
</li>
<li><p><strong>-Q</strong></p>
<ul>
<li>不使用警告音</li>
</ul>
</li>
<li><p><strong>-s</strong></p>
<ul>
<li>显示连续空行为一行</li>
</ul>
</li>
<li><p><strong>-S</strong></p>
<ul>
<li>行过长时间将超出部分舍弃</li>
</ul>
</li>
</ul>
</li>
<li><p>快捷键</p>
<ul>
<li><p><strong>/&lt;字符串&gt;</strong></p>
<ul>
<li>向下搜索”字符串”的功能</li>
</ul>
</li>
<li><p><strong>?&lt;字符串&gt;</strong></p>
<ul>
<li>向上搜索”字符串”的功能</li>
</ul>
</li>
<li><p><strong>n</strong></p>
<ul>
<li>针对 / 或 ?的结果，重复前一个搜索</li>
</ul>
</li>
<li><p><strong>N</strong></p>
<ul>
<li>针对 / 或 ?的结果，反向重复前一个搜索</li>
</ul>
</li>
<li><p><strong>b</strong></p>
<ul>
<li>向后翻一页</li>
</ul>
</li>
<li><p><strong>d</strong></p>
<ul>
<li>向后翻半页</li>
</ul>
</li>
<li><p><strong>h</strong></p>
<ul>
<li>显示帮助界面</li>
</ul>
</li>
<li><p><strong>u</strong></p>
<ul>
<li>向前滚动半页</li>
</ul>
</li>
<li><p><strong>y</strong></p>
<ul>
<li>向前滚动一行</li>
</ul>
</li>
<li><p><strong>空格键</strong></p>
<ul>
<li>滚动一页</li>
</ul>
</li>
<li><p><strong>回车键</strong></p>
<ul>
<li>滚动一行</li>
</ul>
</li>
<li><p><strong>q / ZZ</strong></p>
<ul>
<li>退出 less 命令</li>
</ul>
</li>
<li><p><strong>v</strong></p>
<ul>
<li>使用配置的编辑器编辑当前文件</li>
<li>对于提示的^X等操作，^X即为CTRL+X。</li>
</ul>
</li>
<li><p><strong>h</strong></p>
<ul>
<li>显示 less 的帮助文档</li>
</ul>
</li>
<li><p><strong>F</strong></p>
<ul>
<li>类似 tail -f 的效果，读取写入文件的最新内容， 按 ctrl+C 停止。</li>
</ul>
</li>
<li><p><strong>&amp;</strong></p>
<ul>
<li>开启模式匹配模式，可继续键入正则匹配，使得less仅显示匹配模式的行，而不是整个文件</li>
</ul>
</li>
<li><p><strong>m</strong></p>
<ul>
<li>mark的意思，开启mark模式,让你键入一个字符，比如我们键入了a，那么less会使用 a 标记文本的当前位置。当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置</li>
</ul>
</li>
<li><p><strong>‘</strong></p>
<ul>
<li>单引号，开启goto mark模式，让你键入一个字符，到达你键入字符标记的位置，比如你键入啊，那么导航到你标记的 a 处</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看文件</span><br><span class="line">$ less log.log</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ps查看进程信息并通过less分页显示</span><br><span class="line">$ ps -ef |less</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看命令历史使用记录并通过less分页显示</span><br><span class="line">$ history | less</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;浏览多个文件，输入 &quot;:n&quot; (n&#x3D;next) 后，切换到 log2.log;输入&quot;:p&quot; (p&#x3D;preview)后，切换到log1.log</span><br><span class="line">$ less log1.log log2.log</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="ls———显示指定工作目录下之内容"><a href="#ls———显示指定工作目录下之内容" class="headerlink" title="ls———显示指定工作目录下之内容"></a>ls———显示指定工作目录下之内容</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。它是list的简写。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>ls [选项参数] [name...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>显示所有文件及目录(ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>将文件以相反次序显示(原定依英文字母次序)</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>将文件依建立时间之先后次序列出</li>
</ul>
</li>
<li><p><strong>-A</strong></p>
<ul>
<li>同-a，但不列出”.”(目前目录)及”..”(父目录)</li>
</ul>
</li>
<li><p><strong>-R</strong></p>
<ul>
<li>若目录下有文件，则以下之文件亦皆依序列出</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;列出目前工作目录下所有名称是 s 开头的文件，越新的排越后面 </span><br><span class="line">$ ls -ltr s*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;bin 目录以下所有目录及文件详细资料列出 </span><br><span class="line">$ ls -lR &#x2F;bin</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出目前工作目录下所有文件及目录；目录于名称后加 &quot;&#x2F;&quot;, 可执行档于名称后加 &quot;*&quot; </span><br><span class="line">$ ls -AF</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><h1 id="N"><a href="#N" class="headerlink" title="N"></a>N</h1><h1 id="O"><a href="#O" class="headerlink" title="O"></a>O</h1><h1 id="P"><a href="#P" class="headerlink" title="P"></a>P</h1><h2 id="paste——合并文件的列"><a href="#paste——合并文件的列" class="headerlink" title="paste——合并文件的列"></a>paste——合并文件的列</h2><ul>
<li><p>简介：</p>
</li>
<li><p>paste指令会把每个文件以列对列的方式，一列列地加以合并。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>paste [选项参数][文件...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-d&lt;间隔字符&gt;或–delimiters=&lt;间隔字符&gt;</strong></p>
<ul>
<li>用指定的间隔字符取代跳格字符。</li>
</ul>
</li>
<li><p><strong>-s或–serial</strong></p>
<ul>
<li>串列进行而非平行处理。</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>在线帮助。</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示帮助信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;合并file1.txt 和file2.txt，先看看这两个文件的内容</span><br><span class="line">$ cat file1.txt </span><br><span class="line">&gt; 1 </span><br><span class="line">&gt; 2 </span><br><span class="line">&gt; 3 </span><br><span class="line">&gt; 4 </span><br><span class="line">&gt; 5 </span><br><span class="line">$ cat file2.txt </span><br><span class="line">&gt; slynux </span><br><span class="line">&gt; gnu </span><br><span class="line">&gt; bash </span><br><span class="line">&gt; hack</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用paste合并</span><br><span class="line">$ paste file1.txt file2.txt </span><br><span class="line">&gt; 1 slynux </span><br><span class="line">&gt; 2 gnu </span><br><span class="line">&gt; 3 bash </span><br><span class="line">&gt; 4 hack </span><br><span class="line">&gt; 5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认的分隔符是制表符，也可以用-d指定分隔符</span><br><span class="line">$ paste file1.txt file2.txt -d &quot;,&quot; </span><br><span class="line">&gt; 1,slynux </span><br><span class="line">&gt; 2,gnu </span><br><span class="line">&gt; 3,bash </span><br><span class="line">&gt; 4,hack </span><br><span class="line">&gt; 5,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若使用paste指令的参数&quot;-s&quot;，则可以将一个文件中的多行数据合并为一行进行显示。</span><br><span class="line">&#x2F;&#x2F;例如，将文件&quot;file&quot;中的3行数据合并为一行数据进行显示，输入如下命令</span><br><span class="line">$ paste -s file </span><br><span class="line">&gt; xiongdan 200 lihaihui 233 lymlrl 231</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>参数”-s”只是将testfile文件的内容调整显示方式，并不会改变原文件的内容格式。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="printf-打印内容"><a href="#printf-打印内容" class="headerlink" title="printf-打印内容"></a>printf-打印内容</h2><ul>
<li><p>简介：</p>
<ul>
<li>printf命令接受<strong>引用文本或由空格分隔的参数</strong>。我们可以在printf中使用格式化字符串来指定字符串的宽度、左右对齐方式等。</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4s\n"</span> No Name Mark ;</span></span><br><span class="line">- printf "%-5s %-10s %-4.2f\n" 1 Sarath 80.3456 11 ;</span><br><span class="line">- printf "%-5s %-10s %-4.2f\n" 2 James 90.9989 ;</span><br><span class="line">- printf "%-5s %-10s %-4.2f\n" 3 Jeff 77.564</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> No Name Mark </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1 Sarath 80.35 </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2 James 91.00 14 </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 3 Jeff 77.56</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<ul>
<li><p>%s、%c、%d和%f都是格式替换符（format substitution character），它们定义了该如何打印后续参数。%-5s指明了一个格式为左对齐且宽度为5的字符串替换（-表示左对齐）。如果不指明-，字符串就采用右对齐形式。</p>
</li>
<li><p>宽度指定了保留给某个字符串的字符数量。对Name而言，其保留宽度是10。因此，任何Name字段的内容都会被显示在10字符宽的保留区域内，如果内容不足10个字符，余下的则以空格填充。</p>
</li>
<li><p>对于浮点数，可以使用其他参数对小数部分进行舍入（round off）。 对于Mark字段，我们将其格式化为%-4.2f，其中.2指定保留两位小数。注意，在每行的格式字符串后都有一个换行符（\n）。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><h2 id="read-从键盘或标准输入中读取文本"><a href="#read-从键盘或标准输入中读取文本" class="headerlink" title="read-从键盘或标准输入中读取文本"></a>read-从键盘或标准输入中读取文本</h2><ul>
<li><p>简介：</p>
<ul>
<li><p>我们可以使用read以交互的形式读取用户输入，不过read能做的可远不止这些。编程语言的大多数输入库都是从键盘读取输入，当回车键按下的时候，标志着输入完毕。</p>
</li>
<li><p>但有时候是没法按回车键的，输入结束与否是由读取到的字符数或某个特定字符来决定的。例如在交互式游戏中，当按下 + 键时，小球就会向上移动。那么若每次都要按下 + 键，然后再按回车键来确认已经按过 + 键，这就显然太低效了。</p>
</li>
<li><p>read命令提供了一种不需要按回车键就能够搞定这个任务的方法。</p>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><strong>-a</strong></li>
</ul>
</li>
<li><p>后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。</p>
<ul>
<li><p><strong>-d</strong></p>
<ul>
<li>用特定的定界符delim_char作为输入行的结束,结果存入var变量（不包括边界符）：<code>read -d delim_char var</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	$ read -d &quot;:&quot; var</span><br><span class="line">$ hello:</span><br><span class="line">	</span><br><span class="line">	$ echo $var</span><br><span class="line">	&gt; hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>后面跟提示信息，即在输入前打印提示信息。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -p &quot;输入网站名:&quot; website</span><br><span class="line">echo &quot;你输入的网站名是 $website&quot; </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 输入网站名:www.cherish.com</span><br><span class="line">&gt; 你输入的网站名是 www.cherish.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
<ul>
<li>在输入的时候可以使用命令补全功能。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下实例输入字符 a 后按下 Tab 键就会输出相关的文件名(该目录存在的)：</span><br><span class="line">$ read -e -p &quot;输入文件名:&quot; str</span><br><span class="line">$ 输入文件名:a</span><br><span class="line">a.out    a.py     a.pyc    abc.txt  </span><br><span class="line">&gt; 输入文件名:a</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-n</strong></p>
<ul>
<li>后跟一个数字，定义输入文本的长度，很实用。<br>例如：下面的语句从输入中读取n个字符并存入变量variable_name：<br><code>read -n number_of_chars variable_name</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -n 2 -p &quot;请随便输入两个字符: &quot; any</span><br><span class="line">echo &quot;\n您输入的两个字符是:$any&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 请随便输入两个字符: 12</span><br><span class="line">&gt; 您输入的两个字符是:12</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-s</strong></p>
</li>
<li><p>安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</p>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li><p>后面跟秒数，定义输入字符的等待时间。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">if read -t 5 -p &quot;输入网站名:&quot; website</span><br><span class="line">then</span><br><span class="line">	echo &quot;你输入的网站名是 $website&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;\n抱歉，你输入超时了。&quot;</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;执行程序不输入，等待 5 秒后：</span><br><span class="line">$ 输入网站名:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>抱歉，你输入超时了</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-u</strong></p>
<ul>
<li>后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#这里默认会换行  </span><br><span class="line">echo &quot;输入网站名: &quot;  </span><br><span class="line">#读取从键盘的输入  </span><br><span class="line">read website  </span><br><span class="line">echo &quot;你输入的网站名是 $website&quot;  </span><br><span class="line">exit 0  #退出</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;常规用法</span><br><span class="line">$ .&#x2F;testcat.sh</span><br><span class="line">&gt; 输入网站名:</span><br><span class="line">$ www.baidu.com</span><br><span class="line">&gt; 你输入的网站名是 www.baidu.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="rm-删除一个文件或者目录"><a href="#rm-删除一个文件或者目录" class="headerlink" title="rm-删除一个文件或者目录"></a>rm-删除一个文件或者目录</h2><ul>
<li><p>简介：</p>
</li>
<li><p>rm [options] filename…</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>Linux rm命令用于删除一个文件或者目录。</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-i</strong></p>
<ul>
<li>删除前逐一询问确认。</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>即使原档案属性设为只读，亦直接删除，无需逐一确认。</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>将目录及以下之档案逐一删除。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除文件可以直接使用rm命令，若删除目录则必须配合选项&quot;-r&quot;</span><br><span class="line">$ rm  test.txt </span><br><span class="line">&#x2F;&#x2F;删除当前目录下的所有文件及目录</span><br><span class="line">$ rm  -r  *</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="rsync——数据远程同步工具"><a href="#rsync——数据远程同步工具" class="headerlink" title="rsync——数据远程同步工具"></a>rsync——数据远程同步工具</h2><ul>
<li><p>简介：</p>
<ul>
<li>rsync命令广泛用于网络文件复制以及备份。</li>
<li>rsync可以在最小化数据传输量同时，同步不同位置上的文件和目录。</li>
<li>相较于cp命令，rsync的优势在于比较文件修改日期，仅复制较新的文件。另外，它还支持远程数据传输以及压缩和加密。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>rsync [选项参数] [源文件路径] [目标文件路径]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>进行归档操作</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>表示在stdout上打印出细节信息或进度</li>
</ul>
</li>
<li><p><strong>-z</strong></p>
<ul>
<li>指定在传输时压缩数据</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>强制rsync以递归方式复制目录中所有的内容</li>
</ul>
</li>
<li><p><strong>–exclude</strong></p>
<ul>
<li>指定不需要传输的文件，可以使用通配符指定需要排除的文件</li>
<li><code>$ rsync -avz /home/code/app /mnt/disk/backup/code --exclude &quot;*.o&quot;</code></li>
</ul>
</li>
<li><p><strong>–exclude-from</strong></p>
<ul>
<li>我们也可以通过一个列表文件指定需要排除的文件</li>
<li><code>$ rsync -avz /home/code/app /mnt/disk/backup/code --exclude-from FILEPATH</code></li>
</ul>
</li>
<li><p><strong>–delete</strong></p>
<ul>
<li>在更新rsync备份时，删除不存在的文件。默认情况下，rsync并不会在目的端删除那些在源端已不存在的文件。如果要删除这类文件，可以使用rsync的–delete选项：</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将源目录（本地路径）复制到目的路径(远程路径)</span><br><span class="line">$ rsync -av &#x2F;home&#x2F;slynux&#x2F;data  slynux@192.168.0.6:&#x2F;home&#x2F;backups&#x2F;data</span><br><span class="line">&#x2F;&#x2F; 上面的命令会以递归的方式将所有的文件从源路径复制到目的路径。源路径和目的路径既可以是远程路径，也可以是本地路径。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以将远程主机上的数据恢复到本地</span><br><span class="line">$ rsync -av slynux@192.168.0.6:&#x2F;home&#x2F;backups&#x2F;data &#x2F;home&#x2F;slynux&#x2F;data</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将一个目录中的内容同步到另一个目录，这条命令将源目录（&#x2F;home&#x2F;test）中的内容（不包括目录本身）复制到现有的backups目录中。</span><br><span class="line">$  rsync -av &#x2F;home&#x2F;test&#x2F; &#x2F;home&#x2F;backups</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将包括目录本身在内的内容复制到另一个目录中，将包括源目录本身（&#x2F;home&#x2F;test）在内的内容复制到新的backups目录中</span><br><span class="line">$ rsync -av &#x2F;home&#x2F;test &#x2F;home&#x2F;backups</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>rsync命令用SSH连接远程主机，因此必须使用username<a href="https://my.oschina.net/u/116016" target="_blank" rel="noopener">@host</a>:PATH 这种形式设定远程主机的地址，其中user代表用户名，host代表远程主机的IP地址或主机名。而PATH指定了远程主机中待复制数据所在的路径。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1><h2 id="scp——安全复制工具"><a href="#scp——安全复制工具" class="headerlink" title="scp——安全复制工具"></a>scp——安全复制工具</h2><ul>
<li><p>简介：</p>
<ul>
<li>SCP是一个安全的文件复制命令，和旧式的、不安全的远程复制命令rcp类似。文件均通过SSH加密通道进行传输。</li>
<li>因为是基于ssh，远程地址格式同样为<code>username@host:/path</code></li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>scp [选项参数] [源文件路径] [目标文件路径]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-oPort=PORTNO</strong></p>
<ul>
<li>SSH服务器有时候并不在默认的端口22上运行。如果它在其他端口运行，我们可以在scp中用选项-oPort=PORTNO来指定端口号。</li>
</ul>
</li>
<li><p><strong>-1</strong></p>
<ul>
<li>强制scp命令使用协议ssh1</li>
</ul>
</li>
<li><p><strong>-2</strong></p>
<ul>
<li>强制scp命令使用协议ssh2</li>
</ul>
</li>
<li><p><strong>-4</strong></p>
<ul>
<li>强制scp命令只使用IPv4寻址</li>
</ul>
</li>
<li><p><strong>-6</strong></p>
<ul>
<li>强制scp命令只使用IPv6寻址</li>
</ul>
</li>
<li><p><strong>-B</strong></p>
<ul>
<li>使用批处理模式（传输过程中不询问传输口令或短语）</li>
</ul>
</li>
<li><p><strong>-C</strong></p>
<ul>
<li>允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>保留原文件的修改时间，访问时间和访问权限。</li>
</ul>
</li>
<li><p><strong>-q</strong></p>
<ul>
<li>不显示传输进度条。</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>递归复制整个目录。</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
</ul>
</li>
<li><p><strong>-c cipher</strong></p>
<ul>
<li>以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
</ul>
</li>
<li><p><strong>-F ssh_config</strong></p>
<ul>
<li>指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
</ul>
</li>
<li><p><strong>-i identity_file</strong></p>
<ul>
<li>从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
</ul>
</li>
<li><p><strong>-l limit</strong></p>
<ul>
<li>限定用户所能使用的带宽，以Kbit/s为单位。</li>
</ul>
</li>
<li><p><strong>-o ssh_option</strong></p>
<ul>
<li>如果习惯于使用ssh_config(5)中的参数传递方式，</li>
</ul>
</li>
<li><p><strong>-P port</strong></p>
<ul>
<li>注意是大写的P, port是指定数据传输用到的端口号</li>
</ul>
</li>
<li><p><strong>-S program</strong></p>
<ul>
<li>指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将远程主机中的文件复制到当前目录并使用给定的文件名</span><br><span class="line">$ scp user@remotehost:&#x2F;home&#x2F;path&#x2F;filename filename</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="sed——对文本进行编辑"><a href="#sed——对文本进行编辑" class="headerlink" title="sed——对文本进行编辑"></a>sed——对文本进行编辑</h2><ul>
<li><p>简介：</p>
</li>
<li><p>sed是stream editor（流编辑器）的缩写。sed 可依照脚本的指令来处理、编辑文本文件。主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>sed [选项参数][文本文件]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-e<action>或–expression=<action></strong></p>
<ul>
<li><p>以选项中指定的action动作来处理输入的文本文件。-e可省略，sed默认为该模式</p>
</li>
<li><p>action动作包括：</p>
<ul>
<li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li>
<li>c ：取代行， c 的后面可以接字串，这些字串可以取代指定的行！</li>
<li>d ：删除，因为是删除啊，所以 d 后面通常不接任何字符</li>
<li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li>
<li>s ：取代部分数据，可以直接进行取代的工作！通常s的动作可以搭配正规表示法！例如 1,20s/old/new/g</li>
</ul>
<blockquote>
<p>注意动作符号后面，需要使用\符号分隔开动作与字符</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>-f&lt;script文件&gt;或–file=&lt;script文件&gt;</strong></p>
</li>
<li><p>以选项中指定的script文件(文件内容为action)来处理输入的文本文件。</p>
</li>
</ul>
</li>
<li><p><strong>-h或–help</strong></p>
<ul>
<li><p>显示帮助。</p>
</li>
<li><p><strong>-n或–quiet或–silent</strong></p>
</li>
<li><p>仅显示script处理后的结果。</p>
</li>
<li><p><strong>-V或–version</strong></p>
<ul>
<li>显示版本信息。</li>
</ul>
</li>
<li><p><strong>-i</strong></p>
<ul>
<li>in place的意思，在参数为文件时，选项-i会使得sed用修改后的数据替换原始文件，相当于直接修改文件<br><code>$ sed -i &#39;s/text/replace/&#39; file</code><br>直接修改文件十分危险，我们可以使用如下命令，这时的sed不仅替换文件内容，还会创建一个名为file.bak的文件，其中包含着原始文件内容的副本。<br><code>sed -i.bak &#39;s/text/replace/&#39; file</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
<ul>
<li><p>a 添加</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在testfile文件的第一行后添加一行，并将结果输出到标准输出</span><br><span class="line">$ cat testfile #查看testfile 中的内容  </span><br><span class="line">&gt; HELLO LINUX!  </span><br><span class="line">&gt; Linux is a free unix-type opterating system.</span><br><span class="line"></span><br><span class="line">$ sed -e 1a\newLine testfile </span><br><span class="line">或</span><br><span class="line">$ sed -e &#39;1a newLine&#39; testfile </span><br><span class="line">&gt; HELLO LINUX! #testfile文件原有的内容  </span><br><span class="line">&gt; newline </span><br><span class="line">&gt; Linux is a free unix-type opterating system.</span><br></pre></td></tr></table></figure>
</li>
<li><p>d 添加</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出，同时，请将第 2~5 行删除！(nl命令，给文本内容添加行号)</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;2,5d&#39;</span><br><span class="line">&gt; 1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; 6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">&gt; 7 shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown</span><br><span class="line">&gt; .....(后面省略).....</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出，同时，请将第 2 行删除！</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;2d&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出，同时，要删除第 3 到最后一行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;3,$d&#39; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出,要在第二行前加上drink tea</span><br><span class="line">$ cat &#x2F;etc&#x2F;passwd | sed &#39;2i drink tea&#39; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除&#x2F;etc&#x2F;passwd所有包含root的行，其他行输出</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed  &#39;&#x2F;root&#x2F;d&#39;</span><br><span class="line">&gt; 2  daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; 3  bin:x:2:2:bin:&#x2F;bin:&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; ....下面忽略,第一行的匹配root已经删除了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除空行</span><br><span class="line">$ sed &#39;&#x2F;^$&#x2F;d&#39; file</span><br></pre></td></tr></table></figure>
</li>
<li><p>c 替换</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将第2-5行的内容取代成为No 2-5 number</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;2,5c No 2-5 number&#39;</span><br><span class="line">&gt; 1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; No 2-5 number</span><br><span class="line">&gt; 6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">&gt; .....(后面省略).....</span><br></pre></td></tr></table></figure></li>
<li><p>p 打印</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;仅列出 &#x2F;etc&#x2F;passwd 文件内的第 5-7 行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed -n &#39;5,7p&#39;</span><br><span class="line">&gt; 5 lp:x:4:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;sbin&#x2F;nologin</span><br><span class="line">&gt; 6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">&gt; 7 shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;搜索 &#x2F;etc&#x2F;passwd有root关键字的行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed -n &#39;&#x2F;root&#x2F;p&#39;</span><br><span class="line">&gt; 1  root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li>
<li><p>s 取代（语法：<code>sed &#39;s/正则表达式/新的字串/&#39;</code>）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;替换第一个出现的this</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;&#39;</span><br><span class="line">&gt; THISthisthisthis</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;g标记可以使sed执行全局替换。</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;g&#39;</span><br><span class="line">&gt; THISTHISTHISTHIS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;#g标记可以使sed替换第N次起出现的匹配</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;2g&#39;</span><br><span class="line">&gt; thisTHISTHISTHIS</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;3g&#39;</span><br><span class="line">&gt; thisthisTHISTHIS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;g标记可以使sed执行全局替换。</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;g&#39;</span><br><span class="line">&gt; THISTHISTHISTHIS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;搜索&#x2F;etc&#x2F;passwd,找到root对应的行，执行后面花括号中的一组命令。</span><br><span class="line">&#x2F;&#x2F;每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed -n &#39;&#x2F;root&#x2F;&#123;s&#x2F;bash&#x2F;blueshell&#x2F;;p;q&#125;&#39; #s为替换，p为打印，最后的q是退出。</span><br><span class="line">&gt; 1  root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;blueshell</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sed命令会将s之后的字符视为命令分隔符。这允许我们更改默认的分隔符&#x2F;：</span><br><span class="line">$ sed &#39;s:text:replace:g&#39; #此时分隔符是：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果作为分隔符的字符出现在模式中，必须使用\对其进行转义。\|是出现在模式中被转义的分隔符</span><br><span class="line">$ sed &#39;s|te\|xt|replace|g&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在sed中，我们可以用&amp;指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹配的内容</span><br><span class="line">&#x2F;&#x2F;在这个例子中，正则表达式\w\+匹配每一个单词，然后我们用[&amp;]替换它。&amp;对应于之前所匹配到的单词。</span><br><span class="line">$ echo this is an example | sed &#39;s&#x2F;\w\+&#x2F;[&amp;]&#x2F;g&#39;</span><br><span class="line">&gt; [this] [is] [an] [example]</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>注意事项</p>
<blockquote>
<p>可以利用管道组合多个sed命令，多个模式之间可以用分号分隔，或是使用选项-e PATTERN ;如下命令都是等价的：<br><code>sed &#39;expression&#39; | sed &#39;expression&#39;</code><br><code>sed &#39;expression; expression&#39;</code><br><code>sed -e &#39;expression&#39; -e &#39;expression&#39;</code></p>
</blockquote>
<blockquote>
<p>如果想在sed表达式中使用变量，双引号就能派上用场了。<br>$ text=hello<br>$ echo hello world | sed “s/$text/HELLO/“<br>HELLO world</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="set-调试执行命令"><a href="#set-调试执行命令" class="headerlink" title="set-调试执行命令"></a>set-调试执行命令</h2><ul>
<li><p>简介：</p>
</li>
<li><p>set命令能设置所使用shell的执行方式，可依照不同的需求来做设置。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>set [+-abCdefhHklmnpPtuvx]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>　标示已修改的变量，以供输出至环境变量。</li>
</ul>
</li>
<li><p><strong>-b</strong></p>
<ul>
<li>　使被中止的后台程序立刻回报执行状态。</li>
</ul>
</li>
<li><p><strong>-C</strong></p>
<ul>
<li>　转向所产生的文件无法覆盖已存在的文件。</li>
</ul>
</li>
<li><p><strong>-d</strong></p>
<ul>
<li>　Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
<ul>
<li>　若指令传回值不等于0，则立即退出shell。</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>　取消使用通配符。</li>
</ul>
</li>
<li><p><strong>-h</strong></p>
<ul>
<li>　自动记录函数的所在位置。</li>
</ul>
</li>
<li><p><strong>-k</strong></p>
<ul>
<li>　指令所给的参数都会被视为此指令的环境变量。</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>　记录for循环的变量名称。</li>
</ul>
</li>
<li><p><strong>-m</strong></p>
<ul>
<li>　使用监视模式。</li>
</ul>
</li>
<li><p><strong>-n</strong></p>
<ul>
<li>　只读取指令，而不实际执行。</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>　启动优先顺序模式。</li>
</ul>
</li>
<li><p><strong>-P</strong></p>
<ul>
<li>　启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>　执行完随后的指令，即退出shell。</li>
</ul>
</li>
<li><p><strong>-u</strong></p>
<ul>
<li>　当执行时使用到未定义过的变量，则显示错误信息。</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>　显示shell所读取的输入值。</li>
</ul>
</li>
<li><p><strong>-x</strong></p>
<ul>
<li>　执行指令后，会先显示该指令及参数。</li>
</ul>
</li>
<li><p><strong>+&lt;参数&gt;</strong></p>
<ul>
<li>　取消某个set曾启动的参数。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>+&lt;参数&gt;:取消某个set曾启动的参数。</p>
</blockquote>
<blockquote>
<p>set命令不带任何参数时，为打印所有环境变量</p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;执行指令后，会先显示该指令及参数。</span><br><span class="line">$ #!&#x2F;bin&#x2F;bash </span><br><span class="line">- #文件名: debug.sh </span><br><span class="line">- for i in &#123;1..2&#125;; </span><br><span class="line">- do</span><br></pre></td></tr></table></figure>
<ul>
<li><p>set -x </p>
</li>
<li><p>echo $i </p>
<ul>
<li>set +x </li>
<li>done </li>
</ul>
<blockquote>
<ul>
<li>echo 1<br>1</li>
<li>set +x</li>
<li>echo 2<br>2</li>
<li>set +x</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统"><a href="#sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统" class="headerlink" title="sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统"></a>sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统</h2><ul>
<li><p>简介：</p>
<ul>
<li>它不需要远端运行FTP服务器来进行文件传输，但必须要有SSH服务器。sftp是一个交互式命令，提供了命令提示符。</li>
<li>sftp支持与ftp和lftp相同的命令。不赘述。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>xxxxxxxxxxxxxxxxx</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><strong>-oPort=PORTNO</strong><ul>
<li>SSH服务器有时候并不在默认的端口22上运行。如果它在其他端口运行，我们可以在sftp中用选项-oPort=PORTNO来指定端口号。  </li>
<li><code>$ sftp -oPort=422 user@slynux.org</code></li>
<li>-oPort应该作为sftp命令的第一个参数。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动sftp会话</span><br><span class="line">$ sftp user@domainname</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="sleep-命令延迟一段时间执行。"><a href="#sleep-命令延迟一段时间执行。" class="headerlink" title="sleep-命令延迟一段时间执行。"></a>sleep-命令延迟一段时间执行。</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux sleep命令可以用来将目前动作延迟一段时间。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>sleep [--help] [--version] number[smhd]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助讯息</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本编号</li>
</ul>
</li>
<li><p><strong>number</strong></p>
<ul>
<li>时间长度，后面可接 s、m、h 或 d。其中 s 为秒，m 为 分钟，h 为小时，d 为日数</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示目前时间后延迟 1 分钟，之后再次显示时间</span><br><span class="line">$ date;sleep 1m;date</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="ssh——远程连接工具"><a href="#ssh——远程连接工具" class="headerlink" title="ssh——远程连接工具"></a>ssh——远程连接工具</h2><ul>
<li><p>简介：</p>
<ul>
<li>SSH代表的是Secure Shell（安全shell）。它使用加密隧道连接两台计算机。</li>
<li>SSH能够让你访问远程计算机上的shell，从而在其上执行交互命令并接收结果，或是启动交互会话。</li>
<li>GNU/Linux发布版中默认并不包含SSH，需要使用软件包管理器安装openssh-server和openssh-client。SSH服务默认运行在端口22之上。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>ssh [选项参数] [user@]hostname] [command]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-p  &lt;端口号&gt;</strong></p>
<ul>
<li>SSH服务器默认在端口22上运行。但有些SSH服务器并没有使用这个端口。针对这种情况，可以用ssh命令的-p &lt;端口号&gt;来指定端口</li>
<li><code>ssh user@locahost -p 422</code></li>
</ul>
</li>
<li><p><strong>- -C</strong></p>
<ul>
<li>SSH协议也支持对数据进行压缩传输。当带宽有限时，这一功能很方便。</li>
<li><code>ssh -C user@hostname COMMANDS</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;连接运行了SSH服务器的远程主机</span><br><span class="line">$  ssh mec@192.168.0.1</span><br><span class="line">&#x2F;&#x2F;mec是远程主机上的用户,192.168.0.1是IP地址,这里也可以是域名</span><br><span class="line">&#x2F;&#x2F;SSH会询问用户密码，一旦认证成功，就会连接到远程主机上的登录shell</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在远程执行命令whoami</span><br><span class="line">$ ssh mec@192.168.0.1 &#39;whoami&#39;</span><br><span class="line">&gt; mec</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以输入多条命令，命令之间用分号分隔</span><br><span class="line">$ ssh mec@192.168.0.1 &quot;echo user: $(whoami);echo OS: $(uname)&quot;</span><br><span class="line">&gt; user: mec </span><br><span class="line">&gt; OS: Linux</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将数据重定向至远程shell命令的stdin</span><br><span class="line">$  echo &#39;text&#39; | ssh user@remote_host &#39;echo&#39;</span><br><span class="line">&gt; text</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将本地主机上的tar存档文件传给远程主机</span><br><span class="line">$ &gt; tar -czf - LOCALFOLDER | ssh &#39;tar -xzvf-&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h1 id="T"><a href="#T" class="headerlink" title="T"></a>T</h1><h2 id="tar——归档或者压缩，解压文件"><a href="#tar——归档或者压缩，解压文件" class="headerlink" title="tar——归档或者压缩，解压文件"></a>tar——归档或者压缩，解压文件</h2><ul>
<li><p>简介：</p>
</li>
<li><p>tar命令可以归档文件。它最初是设计用来将数据存储在磁带上，因此其名字也来源于TapeARchive。tar可以将多个文件和文件夹打包为单个文件，同时还能保留所有的文件属性，如所有者、权限等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>tar [选项参数]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-A或–catenate</strong></p>
<ul>
<li>新增文件到已存在的备份文件。</li>
</ul>
</li>
<li><p><strong>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt;</strong></p>
<ul>
<li>设置每笔记录的区块数目，每个区块大小为12Bytes。</li>
</ul>
</li>
<li><p><strong>-B或–read-full-records</strong></p>
<ul>
<li>读取数据时重设区块大小。</li>
</ul>
</li>
<li><p><strong>-c或–create</strong></p>
<ul>
<li>建立新的备份文件。</li>
</ul>
</li>
<li><p><strong>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt;</strong></p>
<ul>
<li>切换到指定的目录。</li>
</ul>
</li>
<li><p><strong>-d或–diff或–compare</strong></p>
<ul>
<li>对比备份文件内和文件系统上的文件的差异。</li>
</ul>
</li>
<li><p><strong>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt;</strong></p>
<ul>
<li>指定备份文件。</li>
</ul>
</li>
<li><p><strong>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt;</strong></p>
<ul>
<li>每次更换磁带时，就执行指定的Script文件。</li>
</ul>
</li>
<li><p><strong>-g或–listed-incremental</strong></p>
<ul>
<li>处理GNU格式的大量备份。</li>
</ul>
</li>
<li><p><strong>-G或–incremental</strong></p>
<ul>
<li>处理旧的GNU格式的大量备份。</li>
</ul>
</li>
<li><p><strong>-h或–dereference</strong></p>
<ul>
<li>不建立符号连接，直接复制该连接所指向的原始文件。</li>
</ul>
</li>
<li><p><strong>-i或–ignore-zeros</strong></p>
<ul>
<li>忽略备份文件中的0 Byte区块，也就是EOF。</li>
</ul>
</li>
<li><p><strong>-k或–keep-old-files</strong></p>
<ul>
<li>解开备份文件时，不覆盖已有的文件。</li>
</ul>
</li>
<li><p><strong>-K&lt;文件&gt;或–starting-file=&lt;文件&gt;</strong></p>
<ul>
<li>从指定的文件开始还原。</li>
</ul>
</li>
<li><p><strong>-l或–one-file-system</strong></p>
<ul>
<li>复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li>
</ul>
</li>
<li><p><strong>-m或–modification-time</strong></p>
<ul>
<li>还原文件时，不变更文件的更改时间。</li>
</ul>
</li>
<li><p><strong>-M或–multi-volume</strong></p>
<ul>
<li>在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
</ul>
</li>
<li><p><strong>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt;</strong></p>
<ul>
<li>只将较指定日期更新的文件保存到备份文件里。</li>
</ul>
</li>
<li><p><strong>-o或–old-archive或–portability</strong></p>
<ul>
<li>将资料写入备份文件时使用V7格式。</li>
</ul>
</li>
<li><p><strong>-O或–stdout</strong></p>
<ul>
<li>把从备份文件里还原的文件输出到标准输出设备。</li>
</ul>
</li>
<li><p><strong>-p或–same-permissions</strong></p>
<ul>
<li>用原来的文件权限还原文件。</li>
</ul>
</li>
<li><p><strong>-P或–absolute-names</strong></p>
<ul>
<li>文件名使用绝对名称，不移除文件名称前的”/“号。</li>
</ul>
</li>
<li><p><strong>-r或–append</strong></p>
<ul>
<li>新增文件到已存在的备份文件的结尾部分。</li>
</ul>
</li>
<li><p><strong>-R或–block-number</strong></p>
<ul>
<li>列出每个信息在备份文件中的区块编号。</li>
</ul>
</li>
<li><p><strong>-s或–same-order</strong></p>
<ul>
<li>还原文件的顺序和备份文件内的存放顺序相同。</li>
</ul>
</li>
<li><p><strong>-S或–sparse</strong></p>
<ul>
<li>倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
</ul>
</li>
<li><p><strong>-t或–list</strong></p>
<ul>
<li>列出备份文件的内容。</li>
</ul>
</li>
<li><p><strong>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt;</strong></p>
<ul>
<li>指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
</ul>
</li>
<li><p><strong>-u或–update</strong></p>
<ul>
<li><p>仅置换较备份文件内的文件更新的文件。追加选项（-r）可以将指定的任意文件加入到归档文件中。如果同名文件已经存在，那么归档文件中就会包含两个名字一样的文件。我们可以用更新选项-u指明：只添加比归档文件中的同<br>名文件更新（newer）的文件。</p>
</li>
<li><p><code>$ tar -uf archive.tar filea</code>  #如果两个filea的时间戳相同，则什么都不会发生。</p>
</li>
</ul>
</li>
<li><p><strong>-U或–unlink-first</strong></p>
<ul>
<li>解开压缩文件还原文件之前，先解除文件的连接。</li>
</ul>
</li>
<li><p><strong>-v或–verbose</strong></p>
<ul>
<li>显示指令执行过程。</li>
</ul>
</li>
<li><p><strong>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt;</strong></p>
<ul>
<li>建立使用指定的卷册名称的备份文件。</li>
</ul>
</li>
<li><p><strong>-w或–interactive</strong></p>
<ul>
<li>遭遇问题时先询问用户。</li>
</ul>
</li>
<li><p><strong>-W或–verify</strong></p>
<ul>
<li>写入备份文件后，确认文件正确无误。</li>
</ul>
</li>
<li><p><strong>-x或–extract或–get</strong></p>
<ul>
<li>从备份文件中还原文件。</li>
</ul>
</li>
<li><p><strong>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt;</strong></p>
<ul>
<li>指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li>
</ul>
</li>
<li><p><strong>-z或–gzip或–ungzip</strong></p>
<ul>
<li>通过gzip指令处理备份文件。</li>
</ul>
</li>
<li><p><strong>-Z或–compress或–uncompress</strong></p>
<ul>
<li>通过compress指令处理备份文件。</li>
</ul>
</li>
<li><p><strong>-&lt;设备编号&gt;&lt;存储密度&gt;</strong></p>
<ul>
<li>设置备份用的外围设备编号及存放数据的密度。</li>
</ul>
</li>
<li><p><strong>–after-date=&lt;日期时间&gt;</strong></p>
<ul>
<li>此参数的效果和指定”-N”参数相同。</li>
</ul>
</li>
<li><p><strong>–atime-preserve</strong></p>
<ul>
<li>不变更文件的存取时间。</li>
</ul>
</li>
<li><p><strong>–backup=&lt;备份方式&gt;或–backup</strong></p>
<ul>
<li>移除文件前先进行备份。</li>
</ul>
</li>
<li><p><strong>–checkpoint</strong></p>
<ul>
<li>读取备份文件时列出目录名称。</li>
</ul>
</li>
<li><p><strong>–concatenate</strong></p>
<ul>
<li>此参数的效果和指定”-A”参数相同。</li>
</ul>
</li>
<li><p><strong>–confirmation</strong></p>
<ul>
<li>此参数的效果和指定”-w”参数相同。</li>
</ul>
</li>
<li><p><strong>–delete</strong></p>
<ul>
<li>从备份文件中删除指定的文件。</li>
</ul>
</li>
<li><p><strong>–exclude=&lt;范本样式&gt;</strong></p>
<ul>
<li>排除符合范本样式的文件。</li>
</ul>
</li>
<li><p><strong>–group=&lt;群组名称&gt;</strong></p>
<ul>
<li>把加入设备文件中的文件的所属群组设成指定的群组。</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>在线帮助。</li>
</ul>
</li>
<li><p><strong>–ignore-failed-read</strong></p>
<ul>
<li>忽略数据读取错误，不中断程序的执行。</li>
</ul>
</li>
<li><p><strong>–new-volume-script=&lt;Script文件&gt;</strong></p>
<ul>
<li>此参数的效果和指定”-F”参数相同。</li>
</ul>
</li>
<li><p><strong>–newer-mtime</strong></p>
<ul>
<li>只保存更改过的文件。</li>
</ul>
</li>
<li><p><strong>–no-recursion</strong></p>
<ul>
<li>不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
</ul>
</li>
<li><p><strong>–null</strong></p>
<ul>
<li>从null设备读取文件名称。</li>
</ul>
</li>
<li><p><strong>–numeric-owner</strong></p>
<ul>
<li>以用户识别码及群组识别码取代用户名称和群组名称。</li>
</ul>
</li>
<li><p><strong>–owner=&lt;用户名称&gt;</strong></p>
<ul>
<li>把加入备份文件中的文件的拥有者设成指定的用户。</li>
</ul>
</li>
<li><p><strong>–posix</strong></p>
<ul>
<li>将数据写入备份文件时使用POSIX格式。</li>
</ul>
</li>
<li><p><strong>–preserve</strong></p>
<ul>
<li>此参数的效果和指定”-ps”参数相同。</li>
</ul>
</li>
<li><p><strong>–preserve-order</strong></p>
<ul>
<li>此参数的效果和指定”-A”参数相同。</li>
</ul>
</li>
<li><p><strong>–preserve-permissions</strong></p>
<ul>
<li>此参数的效果和指定”-p”参数相同。</li>
</ul>
</li>
<li><p><strong>–record-size=&lt;区块数目&gt;</strong></p>
<ul>
<li>此参数的效果和指定”-b”参数相同。</li>
</ul>
</li>
<li><p><strong>–recursive-unlink</strong></p>
<ul>
<li>解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
</ul>
</li>
<li><p><strong>–remove-files</strong></p>
<ul>
<li>文件加入备份文件后，就将其删除。</li>
</ul>
</li>
<li><p><strong>–rsh-command=&lt;执行指令&gt;</strong></p>
<ul>
<li>设置要在远端主机上执行的指令，以取代rsh指令。</li>
</ul>
</li>
<li><p><strong>–same-owner</strong></p>
<ul>
<li>尝试以相同的文件拥有者还原文件。</li>
</ul>
</li>
<li><p><strong>–suffix=&lt;备份字尾字符串&gt;</strong></p>
<ul>
<li>移除文件前先行备份。</li>
</ul>
</li>
<li><p><strong>–totals</strong></p>
<ul>
<li>备份文件建立后，列出文件大小。</li>
</ul>
</li>
<li><p><strong>–use-compress-program=&lt;执行指令&gt;</strong></p>
<ul>
<li>通过指定的指令处理备份文件。</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本信息。</li>
</ul>
</li>
<li><p><strong>–volno-file=&lt;编号文件&gt;</strong></p>
<ul>
<li>使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>tar命令默认只归档文件，并不对其进行压缩。不过tar支持用于压缩的相关选项。我们日常理解的tar能压缩，其实都并非其命令的本意。压缩能够显著减少文件的体积。<br>归档文件通常被压缩成下列格式之一。<br>gzip格式：file.tar.gz或file.tgz。<br>bzip2格式：file.tar.bz2。<br>Lempel-Ziv-Markov格式：file.tar.lzma。  </p>
</blockquote>
<blockquote>
<p>不同的tar选项可以用来指定不同的压缩格式<br> -j 指定bunzip2格式；<br> -z 指定gzip格式；<br> –lzma 指定lzma格式。  </p>
</blockquote>
<blockquote>
<p>不明确指定上面那些特定的选项也可以使用压缩功能。tar能够基于输出或输入文件的扩展名来进行压缩。为了让tar支持根据扩展名自动选择压缩算法，使用-a或–auto-compress选项<br> <code>$ tar -acvf archive.tar.gz filea fileb filec</code></p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;归档文件，选项-c表示创建新的归档文件。选项-f表示归档文件名，该选项后面必须跟一个或多个文件</span><br><span class="line">$ tar -cf output.tar file</span><br><span class="line">$ $ tar -cf archive.tar file1 file2 file3 folder1 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出归档文件内容</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">&gt; file1 </span><br><span class="line">&gt; file2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出压缩文件内容,而且还要展示更多的细节，使用v选项表示冗长模式，vv为非常冗长模式；</span><br><span class="line">$ tar -tvf archive.tar</span><br><span class="line">&gt; -rw-rw-r-- shaan&#x2F;shaan 0 2013-04-08 21:34 file1 </span><br><span class="line">&gt; -rw-rw-r-- shaan&#x2F;shaan 0 2013-04-08 21:34 file2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向归档文件中追加文件,选项-r可以将新文件追加到已有的归档文件末尾</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">&gt; hello.txt </span><br><span class="line">$ tar -rf archive.tar world.txt </span><br><span class="line">$ tar -tf archive.tar </span><br><span class="line">&gt; hello.txt </span><br><span class="line">&gt; world.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提取文件，-x可以将归档文件的内容提取到当前目录</span><br><span class="line">$ tar -xf archive.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解压文件</span><br><span class="line">$ tar -xzf archive.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们也可以用选项-C来指定将文件提取到哪个目录：</span><br><span class="line">$ tar -xf archive.tar -C &#x2F;path&#x2F;to&#x2F;extraction_directory</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;上述命令将归档文件的内容提取到指定目录中。它提取的是归档文件中的全部内容。</span><br><span class="line">&#x2F;&#x2F;我们可以通过将文件名作为命令行参数来提取特定的文件，下述命令只提取file1和file4，忽略其他文件</span><br><span class="line">$ tar -xvf file.tar file1 file4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在归档时，我们可以将stdout指定为输出文件，这样另一个命令就可以通过管道来读取（作为stdin）并进行其他处理。</span><br><span class="line">&#x2F;&#x2F;当通过安全shell（Secure Shell，SSH）传输数据时，这招很管用。</span><br><span class="line">$ tar cvf - files&#x2F; | ssh user@example.com &quot;tar xv -C Documents&#x2F;&quot;</span><br><span class="line">&#x2F;&#x2F;在上面的例子中，对files目录中的内容进行了归档并将其输出到stdout（由-指明），然后提取到远程系统中的Documents目录中。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们可以用选项-A合并多个tar文件。</span><br><span class="line">&#x2F;&#x2F;假设我们现在有两个tar文件：file1.tar和file2.tar。下面的命令可以将file2.tar的内容合并到file1.tar中</span><br><span class="line">$ tar -Af file1.tar file2.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从归档中删除文件</span><br><span class="line">$ tar -f archive.tar --delete file1 file2</span><br><span class="line">或</span><br><span class="line">$ tar --delete --file archive.tar [FILE LIST]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在归档过程中排除部分文件</span><br><span class="line">&#x2F;&#x2F;选项--exclude [PATTERN]可以将匹配通配符模式的文件排除在归档过程之外。例如，排除所有的.txt文件</span><br><span class="line">&#x2F;&#x2F;注意，模式应该使用双引号来引用，避免shell对其进行扩展。</span><br><span class="line">$ tar -cf arch.tar * --exclude &quot;*.txt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以配合选项-X将需要排除的文件列表放入文件中</span><br><span class="line">$ cat list </span><br><span class="line">&gt; filea </span><br><span class="line">&gt; fileb</span><br><span class="line">$ tar -cf arch.tar * -X list</span><br><span class="line">&#x2F;&#x2F;这样就把filea和fileb排除了。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="tail–打印文件尾部内容"><a href="#tail–打印文件尾部内容" class="headerlink" title="tail–打印文件尾部内容"></a>tail–打印文件尾部内容</h2><ul>
<li><p>简介：</p>
</li>
<li><p>tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。<strong>如果没有指定文件或者文件名为“-”，则读取标准输入。</strong></p>
</li>
<li><p>语法：</p>
<ul>
<li><code>tail [选项][参数]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>–retry</strong></p>
<ul>
<li>即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；</li>
</ul>
</li>
<li><p><strong>-c <N>或–bytes=N</strong></p>
<ul>
<li>输出文件尾部的N（N为整数）个字节内容；N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。N值后面可以有后缀：b表示512，k表示1024，m表示1 048576(1M)。</li>
</ul>
</li>
<li><p><strong>-f &lt;name/descriptor&gt;或；–follow &lt;name/descript&gt;</strong></p>
<ul>
<li>显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；</li>
</ul>
</li>
<li><p><strong>-F</strong></p>
<ul>
<li>与选项“-follow=name”和“–retry”连用时功能相同；</li>
</ul>
</li>
<li><p><strong>-n<N>或–line=N</strong></p>
<ul>
<li>输出文件的尾部N（N位数字）行内容。N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。</li>
</ul>
</li>
<li><p><strong>–pid=&lt;进程号&gt;</strong></p>
<ul>
<li>与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；</li>
</ul>
</li>
<li><p><strong>-q或–quiet或–silent</strong></p>
<ul>
<li>当有多个文件参数时，不输出各个文件名；</li>
</ul>
</li>
<li><p><strong>-s&lt;秒数&gt;或–sleep-interal=&lt;秒数&gt;</strong></p>
<ul>
<li>与“-f”选项连用，指定监视文件变化时间隔的秒数；</li>
</ul>
</li>
<li><p><strong>-v或–verbose</strong></p>
<ul>
<li>当有多个文件参数时，总是输出各个文件名；</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示指令的帮助信息；</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示指令的版本信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示文件file的最后10行</span><br><span class="line">$ tail file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示文件file的内容，从第20行至文件末尾</span><br><span class="line">$ tail +20 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示文件file的最后10个字符</span><br><span class="line">$ tail -c 10 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实时查看file追加的内容</span><br><span class="line">$ tail -f file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;间隔五秒刷新file追加的内容</span><br><span class="line">$ tail -f -s 5 file</span><br></pre></td></tr></table></figure>
<p>  <img src="https://oscimg.oschina.net/oscnet/4d13470cc8c44cb148b7e75722332757ea9.jpg" alt=""></p>
</li>
</ul>
<hr>
<h2 id="time-量测命令执行消耗的时间"><a href="#time-量测命令执行消耗的时间" class="headerlink" title="time-量测命令执行消耗的时间"></a>time-量测命令执行消耗的时间</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux time命令的用途，在于量测特定指令执行时所需消耗的时间及系统资源等资讯。例如 CPU 时间、记忆体、输入输出等等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>time [options] COMMAND [arguments]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-o 或 –output=FILE</strong></p>
<ul>
<li>设定结果输出档。这个选项会将 time 的输出写入 所指定的档案中。如果档案已经存在，系统将覆写其内容。</li>
</ul>
</li>
<li><p><strong>-a 或 –append</strong></p>
<ul>
<li>配合 -o 使用，会将结果写到档案的末端，而不会覆盖掉原来的内容。</li>
</ul>
</li>
<li><p><strong>-f <FORMAT> 或 –format=FORMAT</strong></p>
<ul>
<li>以 FORMAT 字串设定显示方式。当这个选项没有被设定的时候，会用系统预设的格式。不过你可以用环境变数 time 来设定这个格式，如此一来就不必每次登入系统都要设定一次。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;检测date命令运行时间和资源</span><br><span class="line">$ time date</span><br><span class="line">&gt; real    0m0.136s</span><br><span class="line">&gt; user    0m0.010s</span><br><span class="line">&gt; sys     0m0.070s</span><br><span class="line">&#x2F;&#x2F;在以上实例中，执行命令&quot;time date&quot;。系统先执行命令&quot;date&quot;，第2行为命令&quot;date&quot;的执行结果。</span><br><span class="line">&#x2F;&#x2F;第3-6行为执行命令&quot;date&quot;的时间统计结果，其中第4行&quot;real&quot;为实际时间，</span><br><span class="line">&#x2F;&#x2F;第5行&quot;user&quot;为用户CPU时间，第6行&quot;sys&quot;为系统CPU时间。以上三种时间的显示格式均为MMmNN[.FFF]s。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="tr-转换或删除文件中的字符。"><a href="#tr-转换或删除文件中的字符。" class="headerlink" title="tr-转换或删除文件中的字符。"></a>tr-转换或删除文件中的字符。</h2><ul>
<li><p>简介：</p>
</li>
<li><p>tr 可以对来自标准输入的内容进行字符替换、字符删除以及重复字符压缩，将结果输出到标准输出设备。tr是translate（转换）的简写，因为它可以将一组字符转换成另一组字符。</p>
</li>
<li><p>语法：</p>
<ul>
<li><p><code>tr [选项参数][--help][--version][第一字符集][第二字符集]   或 tr [OPTION] SET1[SET2]</code></p>
<blockquote>
<p>来自stdin的输入字符会按照位置从set1映射到set2（set1中的第一个字符映射到set2中的第一个字符，以此类推），然后将输出写入stdout（标准输出）。</p>
</blockquote>
<blockquote>
<p>set1和set2是字符类或字符组。如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-c, –complement</strong></p>
<ul>
<li>反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换</li>
</ul>
</li>
<li><p><strong>-d, –delete</strong></p>
<ul>
<li>删除指令字符</li>
</ul>
</li>
<li><p><strong>-s, –squeeze-repeats</strong></p>
<ul>
<li>缩减连续重复的字符成指定的单个字符</li>
</ul>
</li>
<li><p><strong>-t, –truncate-set1</strong></p>
<ul>
<li>削减 SET1 指定范围，使之与 SET2 设定长度相等</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示程序用法信息</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示程序本身的版本信息</li>
</ul>
</li>
</ul>
</li>
<li><p>字符集合的范围</p>
<ul>
<li><p><strong>\NNN</strong></p>
<ul>
<li>八进制值的字符 NNN (1 to 3 为八进制值的字符)</li>
</ul>
</li>
<li><p><strong>\a Ctrl-G</strong></p>
<ul>
<li>铃声</li>
</ul>
</li>
<li><p><strong>\b Ctrl-H</strong></p>
<ul>
<li>退格符</li>
</ul>
</li>
<li><p><strong>\f Ctrl-L</strong></p>
<ul>
<li>走行换页</li>
</ul>
</li>
<li><p><strong>\n Ctrl-J</strong></p>
<ul>
<li>新行</li>
</ul>
</li>
<li><p><strong>\r Ctrl-M</strong></p>
<ul>
<li>回车</li>
</ul>
</li>
<li><p><strong>\t Ctrl-I</strong></p>
<ul>
<li>tab键</li>
</ul>
</li>
<li><p><strong>\v Ctrl-X</strong></p>
<ul>
<li>水平制表符</li>
</ul>
</li>
<li><p><strong>CHAR1-CHAR2</strong></p>
<ul>
<li>字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。<br>‘ABD-}’、’aA.,’、’a-ce-x’以及’a-c0-9’等均是合法的集合。<br>定义集合也很简单，不需要书写一长串连续的字符序列，只需要使用“起始字符-终止字符”这种格式就行了。</li>
</ul>
</li>
<li><p><strong>[CHAR*]</strong></p>
<ul>
<li>这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止</li>
</ul>
</li>
<li><p><strong>[CHAR*REPEAT]</strong></p>
<ul>
<li>这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)</li>
</ul>
</li>
<li><p><strong>[:alnum:]</strong></p>
<ul>
<li>所有字母字符与数字</li>
</ul>
</li>
<li><p><strong>[:alpha:]</strong></p>
<ul>
<li>所有字母字符</li>
</ul>
</li>
<li><p><strong>[:blank:]</strong></p>
<ul>
<li>所有水平空格</li>
</ul>
</li>
<li><p><strong>[:cntrl:]</strong></p>
<ul>
<li>所有控制（非打印）字符</li>
</ul>
</li>
<li><p><strong>[:digit:]</strong></p>
<ul>
<li>所有数字</li>
</ul>
</li>
<li><p><strong>[:graph:]</strong></p>
<ul>
<li>所有可打印的字符(不包含空格符)</li>
</ul>
</li>
<li><p><strong>[:lower:]</strong></p>
<ul>
<li>所有小写字母</li>
</ul>
</li>
<li><p><strong>[:print:]</strong></p>
<ul>
<li>所有可打印的字符(包含空格符)</li>
</ul>
</li>
<li><p><strong>[:punct:]</strong></p>
<ul>
<li>所有标点字符</li>
</ul>
</li>
<li><p><strong>[:space:]</strong></p>
<ul>
<li>所有水平与垂直空格符</li>
</ul>
</li>
<li><p><strong>[:upper:]</strong></p>
<ul>
<li>所有大写字母</li>
</ul>
</li>
<li><p><strong>[:xdigit:]</strong></p>
<ul>
<li>所有 16 进位制的数字</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;文件testfile中的小写字母全部转换成大写字母，然后输出</span><br><span class="line">$ cat testfile |tr a-z A-Z</span><br><span class="line">或反过来</span><br><span class="line">$ echo &quot;HELLO WHO IS THIS&quot; |tr [:upper:] [:lower:]</span><br><span class="line">&gt; hello who is this</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用tr进行数字加密和解密</span><br><span class="line">&#x2F;&#x2F;加密</span><br><span class="line">$ echo 12345 | tr &#39;0-9&#39; &#39;9876543210&#39;</span><br><span class="line">&gt; 87654 # 已加密</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解密</span><br><span class="line">$  echo 87654 | tr &#39;9876543210&#39; &#39;0-9&#39;</span><br><span class="line">&gt; 12345 # 已解密</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将制表符转换成单个空格</span><br><span class="line">$ tr &#39;\t&#39; &#39; &#39; &lt; file.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用tr删除字符，语法上只使用set1，不使用set2</span><br><span class="line">&#x2F;&#x2F;将stdin中的数字删除并打印删除后的结果</span><br><span class="line">$ echo &quot;Hello 123 world 456&quot; | tr -d &#39;0-9&#39;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从输入文本中删除不在补集中的所有字符</span><br><span class="line">$ echo hello 1 char 2 next 4 | tr -d -c &#39;0-9 \n&#39;</span><br><span class="line">&gt; 124</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将不在set1中的字符替换成空格</span><br><span class="line">$ echo hello 1 char 2 next 4 | tr -c &#39;0-9&#39; &#39; &#39;</span><br><span class="line">&gt;  1 2 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果你习惯在点号后面放置两个空格，你需要在不删除重复字母的情况下去掉多余的空格（-s 缩减连续重复的字符成指定的单个字符）</span><br><span class="line">$  echo &quot;GNU is not UNIX. Recursive right ?&quot; | tr -s &#39; &#39;</span><br><span class="line">&gt; GNU is not UNIX. Recursive right ?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件中的数字进行相加,先删除字母，再将&#39; &#39;替换成+号，得到 $[ 1+2+3+4+5 ]，$[ operation ]执行算术运算，得出结果</span><br><span class="line">$ cat test.txt | tr -d [a-z] | echo &quot;total: $[$(tr &#39; &#39; &#39;+&#39;)]&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>tr只能通过stdin（标准输入）接收输入（无法通过命令行参数接收）</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="U"><a href="#U" class="headerlink" title="U"></a>U</h1><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><h1 id="W"><a href="#W" class="headerlink" title="W"></a>W</h1><h2 id="which-查找并显示给定命令的绝对路径"><a href="#which-查找并显示给定命令的绝对路径" class="headerlink" title="which-查找并显示给定命令的绝对路径"></a>which-查找并显示给定命令的绝对路径</h2><ul>
<li><p>简介：</p>
</li>
<li><p>环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>which cmdName</code></li>
</ul>
</li>
<li><p>选项值：</p>
</li>
<li><p>注意事项</p>
<blockquote>
<p>which是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p>
</blockquote>
<blockquote>
<p>cd 这种常用的命令找不到,因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以找不到的！</p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查找文件、显示命令路径</span><br><span class="line">$ which pwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;pwd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><h2 id="xargs-参数传递过滤器"><a href="#xargs-参数传递过滤器" class="headerlink" title="xargs-参数传递过滤器"></a>xargs-参数传递过滤器</h2><ul>
<li><p>简介：</p>
<ul>
<li>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</li>
<li>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</li>
<li>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</li>
<li>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</li>
<li>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</li>
<li>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;sbin -perm +700 |ls -l       #这个命令是错误的</span><br><span class="line">find &#x2F;sbin -perm +700 |xargs ls -l   #这样才是正确的</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>somecommand |xargs -item  command</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a file</strong></p>
<ul>
<li>从文件中读入作为sdtin</li>
</ul>
</li>
<li><p><strong>-e flag 或 -E flag</strong></p>
<ul>
<li>flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>当每次执行一个argument的时候询问一次用户。</li>
</ul>
</li>
<li><p><strong>-n num</strong></p>
<ul>
<li>后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。如果用在输出场景，那就是一行有n个</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>表示先打印命令，然后再执行。</li>
</ul>
</li>
<li><p><strong>-i 或-I</strong></p>
<ul>
<li>可以用于指定替换字符串，这个字符串会在xargs解析输入时被参数替换掉。如 复制所有图片文件到/data/images 目录下：-I 指定替换符号是{}，那么xargs每个输出，都会替换cp后面的{}<br><code>ls *.jpg | xargs -n1 -I {} cp {} /data/images</code></li>
</ul>
</li>
<li><p><strong>-r no-run-if-empty</strong></p>
<ul>
<li>当xargs的输入为空的时候则停止xargs，不用再去执行了。</li>
</ul>
</li>
<li><p><strong>-s num</strong></p>
<ul>
<li>命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li>
</ul>
</li>
<li><p><strong>-L num</strong></p>
<ul>
<li>从标准输入一次读取 num 行送给 command 命令。</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>同 -L。</li>
</ul>
</li>
<li><p><strong>-d delim</strong></p>
<ul>
<li>xargs对于输入的默认分隔符是空格，-d选项可以为输入数据指定自定义的分隔符</li>
</ul>
</li>
<li><p><strong>-x</strong></p>
<ul>
<li>exit的意思，主要是配合-s使用。。</li>
</ul>
</li>
<li><p><strong>-P</strong></p>
<ul>
<li>修改最大的进程数，默认是1，为0时候为as many as it can</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;多行输入单行输出</span><br><span class="line">$ cat test.txt</span><br><span class="line">&gt; a b c d e f g</span><br><span class="line">&gt; h i j k l m n</span><br><span class="line"></span><br><span class="line">$ cat test.txt | xargs</span><br><span class="line">&gt; a b c d e f g h i j k l m n</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-n 选项多行输出,每行三个元素</span><br><span class="line">$ cat test.txt | xargs -n 3</span><br><span class="line">&gt; a b c</span><br><span class="line">&gt; d e f</span><br><span class="line">&gt; g h i</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;stdin中是一个包含了多个X字符的字符串。我们可以用–d选项将X定义为输入分隔符。</span><br><span class="line">$ echo &quot;splitXsplit2Xsplit3Xsplit4&quot; | xargs -d X </span><br><span class="line">&gt; Split1 split2 split3 split4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在系统中搜索.docx文件，这些文件名中通常会包含大写字母和空格。其中使用了grep找出内容中不包含image的文件</span><br><span class="line">$ find &#x2F;smbMount -iname &#39;*.docx&#39; -print0 | xargs -0 grep -L image</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>xargs 一般是和管道一起使用。</p>
</blockquote>
<blockquote>
<p>xargs命令可以同find命令很好地结合在一起。find的输出可以通过管道传给xargs，由后者执行-exec选项所无法处理的复杂操作。如果文件系统的有些文件名中包含空格，find命令的-print0选项可以使用0（NULL）来分隔查找到的元素，然后再用xargs对应的-0选项进行解析。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h1><h1 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h1><h2 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h2><ul>
<li><p>简介：</p>
<ul>
<li>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>xxxxxxxxxxxxxxxxx</code></li>
</ul>
</li>
<li><p>选项值：</p>
</li>
</ul>
<ul>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">$ </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/17/shell-notes-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/17/shell-notes-tips/" itemprop="url">shell notes&tips</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-17T18:56:32+08:00">
                2019-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/Linux%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">Linux相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/17/shell-notes-tips/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/07/17/shell-notes-tips/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  8.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  31
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><blockquote>
<p>ps：下文中，我们使用$ 表示终端提示符表示输入命令的符号，- 表示多行命令的换行（多行命令不挤在一行以便美观），&gt; 表示终端的输出。</p>
</blockquote>
<blockquote>
<p>右侧边有导航栏，可进行跳转</p>
</blockquote>
<hr>
<ul>
<li>shell脚本通常以shebang起始，/bin/bash是Bash的解释器命令路径 <code>#!/bin/bash</code></li>
</ul>
<h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><h3 id="fork模式"><a href="#fork模式" class="headerlink" title="fork模式"></a>fork模式</h3><p>我们所执行的任何程序，都是由父进程(parent process)所产生出来的一个子进程(child process)，子进程在结束后，将返回到父进程去。此一现像在Linux系统中被称为 fork。当子进程被产生的时候，将会从父进程那里获得一定的资源分配、及(更重要的是)继承父进程的环境。</p>
<ul>
<li><p>fork模式，脚本的执行方式有两种。</p>
<ul>
<li><p>将脚本名作为命令行参数（无须设置权限）</p>
<p>  <code>$ bash myScript.sh</code></p>
</li>
<li><p>授予脚本执行权限，将其变为可执行文件：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 755 myScript.sh</span><br><span class="line">$ .&#x2F;myScript.sh.</span><br></pre></td></tr></table></figure>
<h3 id="source模式"><a href="#source模式" class="headerlink" title="source模式"></a>source模式</h3><p>source方式的特点是，在不另外创建子进程，而是在当前的的Shell环境中执行。</p>
</li>
</ul>
</li>
<li><p>source模式，脚本的执行方式有两种。</p>
<ul>
<li><p>source命令+文件路径</p>
<p>  <code>$ source myScript.sh 或 source ./myScript.sh</code></p>
</li>
<li><p>. 命令</p>
<p>  <code>$ . myScript.sh 或 . ./myScript.sh</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="exec模式"><a href="#exec模式" class="headerlink" title="exec模式"></a>exec模式</h3><p>exec模式和source方式一样，不另外创建子进程，而是在当前的的Shell环境中执行脚本，但是执行完后会终止当前的shell进程，如果使用终端，可以看见执行exec后终端退出。</p>
<ul>
<li><p>exec命令</p>
<p>  <code>exec ./mytest.sh 或 exec myScript.sh</code></p>
</li>
</ul>
<hr>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>你在命令行中输入的绝大部分命令都可以放置在一个特殊的文件中，留待登录或启动新的bash会话时执行。将函数定义、别名以及环境变量设置放置在这种特殊文件中，是一种定制shell的常用方法。</p>
<ul>
<li>当用户登录shell时，会执行下列文件：<ul>
<li>/etc/profile</li>
<li>$HOME/.profile</li>
<li>$HOME/.bash_login</li>
<li>$HOME/.bash_profile<blockquote>
<p>注意，如果你是通过图形化登录管理器登入的话，是不会执行/etc/profile、$HOME/.profile和$HOME/.bash_profile这3个文件的。这是因为图形化窗口管理器并不会启动shell。当你打开终端窗口时才会创建shell，但这个shell也不是登录shell。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果.bash_profile或.bash_login文件存在，则不会去读取.profile文件。</p>
</blockquote>
<ul>
<li>交互式shell（如X11终端会话）或ssh执行单条命令（如ssh 192.168.1.1 ls /tmp）时，<br>会读取并执行以下文件：<ul>
<li>/etc/bash.bashrc</li>
<li>$HOME/.bashrc</li>
</ul>
</li>
<li>调用ssh登录会话<br>  <code>ssh 192.168.1.100</code><br>  这会创建一个新的登录bash shell，该shell会读取并执行以下文件：<ul>
<li>/etc/profile</li>
<li>/etc/bash.bashrc</li>
<li>$HOME/.profile</li>
<li>.bashrc_profile</li>
</ul>
</li>
<li>运行脚本  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果运行如下脚本：</span><br><span class="line">$&gt; cat myscript.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">echo &quot;Running&quot;</span><br></pre></td></tr></table></figure>
  不会执行任何配置文件，除非定义了环境变量BASH_ENV：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&gt; export BASH_ENV&#x3D;~&#x2F;.bashrc </span><br><span class="line">$&gt; .&#x2F;myscript.sh</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2></li>
</ul>
<p>Shell变量大致可以分为3种类型： </p>
<ul>
<li><p>内部变量：系统提供，不用定义，不能修改，比如$#，$?，$*，$0等 </p>
</li>
<li><p>环境变量：系统提供，不用定义，可以修改，当前进程及其子进程中使用，比如PATH，PWD，SHELL等 </p>
</li>
<li><p>用户变量（本地变量）：用户定义，可以修改，在当前进程使用，比如var=123等</p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量有如下几种形式</p>
<ul>
<li>不加符号的等号操作符赋值</li>
</ul>
<p><code>varName=value</code>  </p>
<blockquote>
<p>如果value不包含任何空白字符（例如空格），那么就不需要将其放入引号中，否则必须使用单引号或双引号。</p>
</blockquote>
<ul>
<li>单引号的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;单引号不扩展或解释任何变量和符号</span><br><span class="line">$ test&#x3D;&#39;ps$?&#39;</span><br><span class="line">$ echo $test</span><br><span class="line">&gt; ps$?</span><br></pre></td></tr></table></figure></li>
<li>双引号的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;双引号会扩展解释变量和符号，其中$?为上条命令执行的结果</span><br><span class="line">$ test&#x3D;&quot;ps$?&quot;</span><br><span class="line">$ echo $test</span><br><span class="line">&gt; ps0</span><br></pre></td></tr></table></figure></li>
<li>反引号的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;反引号（键盘上的~键），将内容命令的输出存入变量，该例中将ps命令的输出存入test</span><br><span class="line">$ test&#x3D;&#96;ps&#96;</span><br><span class="line">$ echo $test</span><br><span class="line">PID TTY TIME CMD 2856 pts&#x2F;0 00:00:00 bash 3234 pts&#x2F;0 00:00:00 ps</span><br></pre></td></tr></table></figure></li>
<li>子shell的等号操作符赋值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用$()，将开启子shell，或者说子进程执行内容命令，并将内容命令的输出存入变量，该例中将ps命令的输出存入test</span><br><span class="line">$ test&#x3D;$(ps)</span><br><span class="line">$ echo $test</span><br><span class="line">PID TTY TIME CMD 2856 pts&#x2F;0 00:00:00 bash 3234 pts&#x2F;0 00:00:00 ps</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，var = value不同于var=value。两边没有空格的等号是赋值操作符，加上空格的等号表示的是等量关系测试。</p>
</blockquote>
</li>
<li>export命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> HTTP_PROXY=192.168.1.23:3128</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> HTTP_PROXY</span></span><br><span class="line">//export命令声明了将由子进程所继承的一个或多个变量。</span><br><span class="line">//这些变量被导出后，当前shell脚本所执行的任何应用程序都会获得这个变量。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要append变量，例如对PATH中添加一条新路径，可以使用如下命令：</p>
<figure class="highlight plain"><figcaption><span>export PATH</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 常见的环境变量</span><br><span class="line">- SHELL：环境变量SHELL获知当前使用的是哪种shell </span><br></pre></td></tr></table></figure>
<p>$ echo $SHELL<br>$ echo $0<br>/bin/bash</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- UID：环境变量UID中保存的是用户ID。root用户的UID是0。</span><br><span class="line">- PS1：当我们打开终端或是运行shell时，会看到类似于user@hostname:&#x2F;home&#x2F;$ 的提示字符串。不同的GNU&#x2F;Linux发布版中的提示字符串及颜色各不相同。我们可以利用PS1环境变量来定义主提示字符串。</span><br><span class="line">- PATH：PATH环境变量通常保存了可用于搜索可执行文件的路径列表。&#96;PATH&#x3D;&#x2F;usr&#x2F;bin; &#x2F;bin&#96;这意味着只要shell执行应用程序（二进制文件或脚本）时，它就会首先查找&#x2F;usr&#x2F;bin，然后查找&#x2F;bin。</span><br><span class="line">- LD_LIBRARY_PATH：LD_LIBRARY_PATH环境变量通常保存了可用于搜索库文件的路径列表。&#96;LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;lib; &#x2F;lib&#96;这意味着只要shell执行库文件时，它就会首先查找&#x2F;usr&#x2F;lib，然后查找&#x2F;lib。</span><br><span class="line">- IFS:内部字段分隔符（internal field separator）。IFS环境变量保存了用于分隔的字符。它是当前shell环境使用的默认定界字符串。IFS的默认值为空白字符（换行符、制表符或者空格）。</span><br></pre></td></tr></table></figure>
$ oldIFS=$IFS </li>
<li>IFS=, #IFS现在被设置为, </li>
<li>for item in $data; </li>
<li>do </li>
<li>echo Item: $item </li>
<li>done </li>
<li>IFS=$oldIFS</li>
</ul>
<blockquote>
<p>Item: name<br>Item: gender<br>Item: rollno<br>Item: location</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SHLVL：保存当前shell的层级</span><br><span class="line">### 访问变量</span><br><span class="line">- 和编译型语言不同，大多数脚本语言不要求在创建变量之前声明其类型。用到什么类型就是什么类型。在变量名前面加上一个美元符号就可以访问到变量的值。也可以使用$&#123;var&#125;。其分别如下：</span><br></pre></td></tr></table></figure>
<p>$ fruit=apple<br>$ count=5<br>$ echo “We have $count ${fruit}s”</p>
<blockquote>
<p>We have 5 apples<br>//因为shell使用空白字符来分隔单词，<br>//所以我们需要加上一对花括号来告诉shell这里的变量名是fruit，<br>//而不是fruits。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 获得字符串的长度</span><br><span class="line">- 可以用下面的方法获得变量值的长度：</span><br></pre></td></tr></table></figure>
<p>$ var=12345678901234567890<br>$ echo $操作符</p>
</li>
</ul>
<p>% %% # ## 操作符可以得到变量var删除特定的值后的结果：</p>
<p>假设我们定义file=/dir1/dir2/dir3/my.file.txt</p>
<p>可以用${ }分别替换得到不同的值：</p>
<ul>
<li>${file#*/}：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt</li>
<li>${file##*/}：删掉最后一个 /  及其左边的字符串：my.file.txt</li>
<li>${file#*.}：删掉第一个 .  及其左边的字符串：file.txt</li>
<li>${file##*.}：删掉最后一个 .  及其左边的字符串：txt</li>
<li>${file%/*}：删掉最后一个  /  及其右边的字符串：/dir1/dir2/dir3</li>
<li>${file%%/*}：删掉第一个 /  及其右边的字符串：(空值)</li>
<li>${file%.*}：删掉最后一个  .  及其右边的字符串：/dir1/dir2/dir3/my.file</li>
<li>${file%%.*}：删掉第一个  .   及其右边的字符串：/dir1/dir2/dir3/my</li>
</ul>
<blockquote>
<p>记忆方法：  </p>
<h1 id="是去掉左边（键盘上-在-的左边）去掉左边的时候，通配符-就要在指定的符号左边"><a href="#是去掉左边（键盘上-在-的左边）去掉左边的时候，通配符-就要在指定的符号左边" class="headerlink" title="是去掉左边（键盘上#在 $ 的左边）去掉左边的时候，通配符*就要在指定的符号左边"></a>是去掉左边（键盘上#在 $ 的左边）去掉左边的时候，通配符*就要在指定的符号左边</h1><p>% 是去掉右边（键盘上% 在$ 的右边）去掉右边的时候，通配符*就要在指定的符号右边<br>单一符号是最小匹配；吝啬匹配<br>两个符号是最大匹配；贪婪匹配</p>
</blockquote>
<hr>
<h4 id="操作符"><a href="#操作符" class="headerlink" title="${::}操作符"></a>${::}操作符</h4><ul>
<li>${file:0:5} ：提取从第0个开始的连续5个字节：/dir1</li>
<li>${file:5:5} ：提取第5个开始的连续5个字节：/dir2<h4 id=""><a href="#" class="headerlink" title="${//}"></a>${//}</h4></li>
<li>${file/dir/path}：将第一个dir替换为path：/path1/dir2/dir3/my.file.txt</li>
<li>${file//dir/path}：将全部dir 替换为 path：/path1/path2/path3/my.file.txt<blockquote>
<p>同样的：单一符号是最小匹配；吝啬匹配<br>两个符号是最大匹配；贪婪匹配</p>
</blockquote>
<h3 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp;和||"></a>&amp;&amp;和||</h3></li>
<li>shell 在执行某个命令的时候，会返回一个返回值，该返回值保存在 shell 变量 $? 中。当 $? == 0 时，表示执行成功；当 $? == 1 时（我认为是非0的数，返回值在0-255间），表示执行失败。</li>
<li>有时候，下一条命令依赖前一条命令是否执行成功。如：在成功地执行一条命令之后再执行另一条命令，或者在一条命令执行失败后再执行另一条命令等。shell 提供了 &amp;&amp; 和 || 来实现命令执行控制的功能，shell 将根据 &amp;&amp; 或 || 前面命令的返回值来控制其后面命令的执行。</li>
<li>无论是&amp;&amp;还是||，联合命令行都会尽量执行至成功为止。（这才有了短路的意义）  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">command1 &amp;&amp; command2 [&amp;&amp; command3 ...]</span><br><span class="line">&#x2F;&#x2F;命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。</span><br><span class="line">&#x2F;&#x2F;只有在 &amp;&amp; 左边的命令返回真（命令返回值 $? &#x3D;&#x3D; 0），&amp;&amp; 右边的命令才会被执行。</span><br><span class="line">&#x2F;&#x2F;只要有一个命令返回假（命令返回值 $? &#x3D;&#x3D; 1），后面的命令就不会被执行。</span><br><span class="line"></span><br><span class="line">command1 || command2 [|| command3 ...]</span><br><span class="line">&#x2F;&#x2F;命令之间使用 || 连接，实现逻辑或的功能。</span><br><span class="line">&#x2F;&#x2F;只有在 || 左边的命令返回假（命令返回值 $? &#x3D;&#x3D; 1），|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作。</span><br><span class="line">&#x2F;&#x2F;只要有一个命令返回真（命令返回值 $? &#x3D;&#x3D; 0），后面的命令就不会被执行。 –直到返回真的地方停止执行。</span><br></pre></td></tr></table></figure>
<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h3></li>
</ul>
<p>Unix shell脚本最棒的特性之一就是可以轻松地将多个命令组合起来生成输出。一个命令的输出可以作为另一个命令的输入，而这个命令的输出又会传递至下一个命令，以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这里我们组合了3个命令。cmd1的输出传递给cmd2，cmd2的输出传递给cmd3，最终的输出 12（来自cmd3）会出现在显示器中或被导入某个文件。</span><br><span class="line">$ cmd1 | cmd2 | cmd3</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="shell代码执行顺序"><a href="#shell代码执行顺序" class="headerlink" title="shell代码执行顺序"></a>shell代码执行顺序</h2><h3 id="重定向执行顺序"><a href="#重定向执行顺序" class="headerlink" title="重定向执行顺序"></a>重定向执行顺序</h3><ul>
<li><p>先读取输入重定向符&lt;后的内容做为输入，如果一条命令有多个&lt;，会读取最后一个&lt;后的内容<br>输入重定向符&lt;放在命令前后都可以，例如【&lt; /etc/hosts cat】相当于【cat /etc/hosts】</p>
</li>
<li><p>执行命令</p>
</li>
<li><p>如果有&gt;或&gt;&gt;会将结果进行重定向，如果输出重定向多个文件，只会将内容重定向到最后一个文件<br>例如 cat /etc/hosts &gt; test1.txt &gt;test2.txt，只有test2.txt会出现内容，test1.txt内容是空的<br>输出重定向&gt;和&gt;&gt;的位置放在哪里都可以，例如【&gt; test.txt  cat /etc/hosts】，表示将/etc/hosts的内容输入到test.txt中</p>
</li>
</ul>
<h3 id="管道符执行顺序"><a href="#管道符执行顺序" class="headerlink" title="管道符执行顺序"></a>管道符执行顺序</h3><p><code>command1 | command2</code><br>命令1必须要有输出，且是正确的。命令2才会执行。命令1的输出作为命令2的输入</p>
<hr>
<h2 id="数学运算-let、-和"><a href="#数学运算-let、-和" class="headerlink" title="数学运算-let、(( ))和[]"></a>数学运算-let、(( ))和[]</h2><p>Bash shell使用let、(( ))和[]执行基本的算术操作。工具expr和bc可以用来执行高级操作。</p>
<ul>
<li>let命令<ul>
<li>let命令可以直接执行基本的算术操作。当使用let时，变量名之前不需要再添加$，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ no1&#x3D;4; </span><br><span class="line">$ no2&#x3D;5;</span><br><span class="line">$ let result&#x3D;no1</span><br><span class="line">$ echo $result</span><br><span class="line">&gt; 9</span><br></pre></td></tr></table></figure></li>
<li>let自操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ let no1++</span><br><span class="line">$ let no1--</span><br><span class="line">$ let no+&#x3D;6</span><br><span class="line">$ let no-&#x3D;6</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>操作符$[]和$(())<ul>
<li>操作符[]的使用方法和let命令一样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ result&#x3D;$[ no1 + no2 ]</span><br><span class="line">&#x2F;&#x2F;在[]中也可以使用$前缀，例如：</span><br><span class="line">$ result&#x3D;$[ $no1 + 5 ]</span><br><span class="line">&#x2F;&#x2F;也可以使用操作符(())</span><br><span class="line">$ result&#x3D;$(( no1 + 50 ))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>expr<ul>
<li>expr同样可以用于基本算术操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ result&#x3D;&#96;expr 3 + 4&#96;</span><br><span class="line">$ result&#x3D;$(expr $no1 + 5)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>bc<ul>
<li>上述命令不支持浮点数计算，浮点数计算需要使用bc命令，bc是一个用于数学运算的高级实用工具，这个精密的计算器包含了大量的选项。我们可以借助它执行浮点数运算并使用一些高级函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;4 * 0.56&quot; | bc</span><br><span class="line">&gt; 2.24</span><br><span class="line">$ no&#x3D;54; </span><br><span class="line">$ result&#x3D;&#96;echo &quot;$no * 1.5&quot; | bc&#96;</span><br><span class="line">$ echo $result</span><br><span class="line">&gt; 81.0</span><br></pre></td></tr></table></figure></li>
<li>设定小数精度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在下面的例子中，参数scale&#x3D;2将小数位个数设置为2。因此，bc将会输出包含两个小数位的数值：</span><br><span class="line">$ echo &quot;scale&#x3D;2;22&#x2F;7&quot; | bc</span><br><span class="line">&gt; 3.14</span><br></pre></td></tr></table></figure></li>
<li>进制转换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用bc可以将一种进制系统转换为另一种。来看看下面的代码是如何在十进制与二进制之间相互转换的：</span><br><span class="line">$ no&#x3D;100 </span><br><span class="line">$ echo &quot;obase&#x3D;2;$no&quot; | bc</span><br><span class="line">&gt; 1100100</span><br><span class="line">$ no&#x3D;1100100 </span><br><span class="line">$ echo &quot;obase&#x3D;10;ibase&#x3D;2;$no&quot; | bc</span><br><span class="line">&gt; 100</span><br></pre></td></tr></table></figure></li>
<li>计算平方以及平方根。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;sqrt(100)&quot; | bc #Square root </span><br><span class="line">$ echo &quot;10^10&quot; | bc #Square</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="文件描述符与重定向"><a href="#文件描述符与重定向" class="headerlink" title="文件描述符与重定向"></a>文件描述符与重定向</h2><p>文件描述符是与输入和输出流相关联的整数。最广为人知的文件描述符是stdin、stdout和stderr。文件描述符0、1以及2是系统预留的。</p>
<ul>
<li><p>文件描述符</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 —— stdin （标准输入）。</span><br><span class="line">1 —— stdout（标准输出）。</span><br><span class="line">2 —— stderr（标准错误）。</span><br></pre></td></tr></table></figure></li>
<li><p>重定向符号</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt; file</td>
<td align="center">输入重定向，将&lt;后的file文件内容作为command执行前的输入</td>
</tr>
<tr>
<td align="center">&gt; file 或1&gt;file</td>
<td align="center">输出重定向，将标准正确输出覆盖到后面的file文件内</td>
</tr>
<tr>
<td align="center">&gt;&gt; file或1&gt;&gt;file</td>
<td align="center">输出重定向，将标准正确输出追加到后面的file文件内</td>
</tr>
<tr>
<td align="center">2&gt;file</td>
<td align="center">输出重定向，将标准错误输出覆盖到后面的file文件内</td>
</tr>
<tr>
<td align="center">2&gt;&gt;file</td>
<td align="center">输出重定向，将标准错误输出追加到后面的file文件内</td>
</tr>
<tr>
<td align="center">&amp;&gt;file 或 &gt;file 2&gt;&amp;1</td>
<td align="center">输出重定向，将标准正确输出和标准错误输出覆盖到后面的file文件内</td>
</tr>
<tr>
<td align="center">&amp;&gt;&gt;file 或 &gt;&gt;file 2&gt;&amp;1</td>
<td align="center">输出重定向，将标准正确输出和标准错误输出追加到后面的file文件内</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>如果你不想看到或保存错误信息，那么可以将stderr的输出重定向到/dev/null，保证一切都<br>会被清除得干干净净。</p>
</blockquote>
<blockquote>
<p>cat&lt;<EOF>log.txt，注意，&lt;&lt;EOF是固定用法，&lt;&lt;不是指输入重定向两次，命令&lt;&lt;EOF会将键入的、以EOF输入字符为标准输入结束的流内容作为输入。然后按照重定向执行顺序，第二步骤执行cat命令，输出&lt;&lt;EOF键入的内容，最后将其重定向进log.txt</p>
</blockquote>
<hr>
<h2 id="数组与关联数组"><a href="#数组与关联数组" class="headerlink" title="数组与关联数组"></a>数组与关联数组</h2><p>数组允许脚本利用索引将数据集合保存为独立的条目。Bash支持普通数组和关联数组，前者使用整数作为数组索引，后者使用字符串作为数组索引。当数据以数字顺序组织的时候，应该使用普通数组，例如一组连续的迭代。当数据以字符串组织的时候，关联数组就派上用场了，例如主机名称。</p>
<h3 id="值序列"><a href="#值序列" class="headerlink" title="值序列"></a>值序列</h3><p>值序列在循环中经常使用，我们可以使用{1..5}来得到1-5的数字序列,也可以使用{1,2,3,4,5}得到同样的序列，也可以用{a..z}得到a-z的集合。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;1..5&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1,2,3,4,5,6&#125;;</span></span><br><span class="line">- do</span><br><span class="line">-  echo $i </span><br><span class="line">- done</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><ul>
<li><p>定义数组</p>
<ul>
<li>可以在单行中使用数值列表来定义一个数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这些值将会存储在以0为起始索引的连续位置上</span><br><span class="line">$ array_var&#x3D;(test1 test2 test3 test4)</span><br></pre></td></tr></table></figure></li>
<li>定义特定索引数组值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ array_var[2]&#x3D;&quot;test3&quot;</span><br></pre></td></tr></table></figure></li>
<li>定义空数组并加值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ array_var&#x3D;();</span><br><span class="line">&#x2F;&#x2F;加入someVar变量值 </span><br><span class="line">$ array_var+&#x3D;(&quot;$someVar&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>访问数组</p>
<ul>
<li>访问特定索引的数组元素内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;array_var[0]&#125; </span><br><span class="line">&gt; test1 </span><br><span class="line">$ index&#x3D;5 </span><br><span class="line">$ echo $&#123;array_var[$index]&#125; </span><br><span class="line">&gt; test6</span><br></pre></td></tr></table></figure></li>
<li>以列表形式打印出数组中的所有值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;array_var[*]&#125; </span><br><span class="line">&gt; test1 test2 test3 test4 test5 test6</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">$ echo $&#123;array_var[@]&#125; </span><br><span class="line">&gt; test1 test2 test3 test4 test5 test6</span><br></pre></td></tr></table></figure></li>
<li>打印数组长度（即数组中元素的个数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;#array_var[*]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3>关联数组从Bash 4.0版本开始被引入。当使用字符串（站点名、用户名、非顺序数字等）作为索引时，关联数组要比数字索引数组更容易使用。</li>
</ul>
</li>
<li><p>定义关联数组</p>
<p>  在关联数组中，我们可以用任意的文本作为数组索引。首先，需要使用声明语句将一个变量定义为关联数组</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ declare -A fruits_value</span><br><span class="line">$ fruits_value&#x3D;([apple]&#x3D;&#39;100 dollars&#39; [orange]&#x3D;&#39;150 dollars&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>访问数组</p>
<ul>
<li>用下面的方法显示数组内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;Apple costs $&#123;fruits_value[apple]&#125;&quot;</span><br><span class="line">&gt; Apple costs 100 dollars</span><br></pre></td></tr></table></figure></li>
<li>列出数组索引(对于普通数组，这个方法同样可行。)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;!fruits_value[*]&#125;</span><br><span class="line">&gt; orange apple</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">$ echo $&#123;!fruits_value[@]&#125;</span><br><span class="line">&gt; orange apple</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数和别名乍一看很相似，不过两者在行为上还是略有不同。alias是使用纯文本代替命令名，它在命令解析阶段就会把内容进行替换，由于替换过程完全是基于文本的，因而别名可以改变shell的语法；</p>
<p>函数的函数体是复合命令(bash)，函数名在命令解析阶段并不会被替换，只是在命令执行阶段调用相应的函数处理对应的复合命令。</p>
<p>函数参数可以在函数体中任意位置上使用，而别名只能将参数放在命令尾部。</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>函数的定义包括function命令、函数名、开/闭括号以及包含在一对花括号中的函数体。</p>
<ul>
<li>function 关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function fname()</span><br><span class="line">&#123;</span><br><span class="line"> statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>无 function 关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fname()</span><br><span class="line">&#123;</span><br><span class="line"> statements;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">fname() &#123; statement; &#125;</span><br></pre></td></tr></table></figure></li>
<li>返回值<br>在定义函数时，可以在函数体中使用return来定义返回值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fname() </span><br><span class="line">&#123; </span><br><span class="line"> if [ $1 -eq 0 ];</span><br><span class="line"> then</span><br><span class="line"> 	return 0; #返回值</span><br><span class="line"> else</span><br><span class="line"> 	return 1; #返回值</span><br><span class="line"> fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们知道，在使用&amp;&amp;和||连接符时，判断依据即为符号前后命令的成功与否，返回值等于0为成功，大于0为失败。</p>
</blockquote>
</li>
</ul>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ fname ; &#x2F;&#x2F;执行函数</span><br><span class="line">或者</span><br><span class="line">$ fname arg1 arg2 ; &#x2F;&#x2F;函数参数可以按位置访问，$1是第一个参数，$2是第二个参数，</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数体中，要活用$1,$2,$*,$@等符号</p>
</blockquote>
<ul>
<li><p>递归调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fname() &#123;</span><br><span class="line">	echo $1; fname hello;</span><br><span class="line">	sleep 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义函数示例"><a href="#自定义函数示例" class="headerlink" title="自定义函数示例"></a>自定义函数示例</h3><blockquote>
<p>自定义函数需要定义在rc或者profile文件中，此文件的作用可详见<a href="https://wido.me/sunteya/understand-bashrc-and-profile/" target="_blank" rel="noopener" title="理解 bashrc 和 profile">理解 bashrc 和 profile</a></p>
</blockquote>
</li>
<li><p>对于<code>export PATH=/opt/myapp/bin:$PATH</code>，我们可以在.bashrc文件中定义一个新的函数，来简化这一追加路径的功能，使得<code>export PATH=/opt/myapp/bin:$PATH</code>等价于<code>prepend PATH /opt/myapp/bin</code>，其中$1=PATH,$2=/opt/myapp/bin：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">prepend() &#123; [ -d &quot;$2&quot; ] &amp;&amp; eval $1&#x3D;\&quot;$2\$\&#123;$1:+&#39;:&#39;\$$1\&#125;\&quot; &amp;&amp; export $1 ; &#125;</span><br><span class="line">&#x2F;&#x2F; [ -d &quot;$2&quot; ]含义为先确认该函数第二个参数所指定的目录是否存在。</span><br><span class="line">&#x2F;&#x2F;如果存在，eval表达式将第一个参数所指定的变量值设置成第二个参数的值加上$\&#123;$1:+&#39;:&#39;\$$1\&#125;表达式的值</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;\&quot;$2\$\&#123;$1:+&#39;:&#39;\$$1\&#125;\&quot;</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;&quot;$2$&#123;PATH:+&#39;:&#39;$PATH&#125;&quot;   &#x2F;&#x2F;$1&#x3D;PATH有值</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;&quot;$2&#39;:&#39;$PATH&quot;</span><br><span class="line">&#x2F;&#x2F;	$1&#x3D;&quot;&#x2F;opt&#x2F;myapp&#x2F;bin:$PATH&quot;</span><br><span class="line">&#x2F;&#x2F;如果第二步执行成功，第三步，export，完成</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="逻辑关键字"><a href="#逻辑关键字" class="headerlink" title="逻辑关键字"></a>逻辑关键字</h2><h3 id="循环-for、while、until"><a href="#循环-for、while、until" class="headerlink" title="循环-for、while、until"></a>循环-for、while、until</h3><ul>
<li><p>面向列表的for循环</p>
<pre><code>list可以是一个字符串，也可以是一个值序列。</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in &#123;1..50&#125;;</span><br><span class="line">do</span><br><span class="line">	commands;#使用变量$var</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>迭代指定范围的数字</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for((i&#x3D;0;i&lt;10;i++))</span><br><span class="line">&#123;</span><br><span class="line">	commands; #使用变量$i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>循环到条件满足为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;当条件为真时，while循环继续执行；当条件不为真时，until循环继续执行。</span><br><span class="line">&#x2F;&#x2F;用true或者:作为循环条件能够产生无限循环。</span><br><span class="line">while condition</span><br><span class="line">do</span><br><span class="line"> commands;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>until循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在Bash中还可以使用一个特殊的循环until。它会一直循环，直到给定的条件为真。例如：</span><br><span class="line">x&#x3D;0; </span><br><span class="line">until [ $x -eq 9 ]; #条件是[$x -eq 9 ] </span><br><span class="line">do</span><br><span class="line"> let x++; echo $x; </span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="判断-if-else"><a href="#判断-if-else" class="headerlink" title="判断-if else"></a>判断-if else</h3></li>
<li><p>if条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if condition; </span><br><span class="line">then </span><br><span class="line">   commands; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
</li>
<li><p>else if和else</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if condition; </span><br><span class="line">then </span><br><span class="line">  commands; </span><br><span class="line">else if condition; then </span><br><span class="line">  commands; </span><br><span class="line">else </span><br><span class="line">  commands; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<blockquote>
<p>if和else语句能够嵌套使用。if的条件判断部分可能会变得很长，但可以用<br>逻辑运算符将它变得简洁一些：<br>[ condition ] &amp;&amp; action; # 如果condition为真，则执行action<br>[ condition ] || action; # 如果condition为假，则执行action</p>
</blockquote>
</li>
</ul>
<h2 id="判断条件-和"><a href="#判断条件-和" class="headerlink" title="判断条件- [] 和 [[]]"></a>判断条件- [] 和 [[]]</h2><p>判断条件通常被放置在封闭的中括号内。一定要注意在 [ 和 ] 与操作数<strong>之间有一个空格</strong>。如果忘记了这个空格，脚本就会报错。<code>[$var -eq 0 ] or [ $var -eq 0]会报错</code></p>
<blockquote>
<p>在[]和[[ ]]中，其实任何一个符号两边都要有空格，所以在判断的时候，不要吝啬空格。</p>
</blockquote>
<ul>
<li><p>对数字变量或值进行算术条件比较</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ $var -eq 0 ] #当$var等于0时，返回真</span><br><span class="line">[ $var -ne 0 ] #当$var不为0时，返回真</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其他重要的操作符如下</p>
<ul>
<li><p>-gt：大于。</p>
</li>
<li><p>-lt：小于。</p>
</li>
<li><p>-ge：大于或等于。 </p>
</li>
<li><p>-le：小于或等于。</p>
<blockquote>
<p>这些操作符只适用于数值。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- 文件系统相关判断</span><br><span class="line"></span><br><span class="line">	我们可以使用不同的条件标志测试各种文件系统相关的属性。</span><br><span class="line">	- [ -f $file_var ]：如果给定的变量包含正常的文件路径或文件名，则返回真。</span><br><span class="line">	- [ -x $var ]：如果给定的变量包含的文件可执行，则返回真。</span><br><span class="line">	- [ -d $var ]：如果给定的变量包含的是目录，则返回真。</span><br><span class="line">	- [ -e $var ]：如果给定的变量包含的文件存在，则返回真。</span><br><span class="line">	- [ -c $var ]：如果给定的变量包含的是一个字符设备文件的路径，则返回真。</span><br><span class="line">	- [ -b $var ]：如果给定的变量包含的是一个块设备文件的路径，则返回真。</span><br><span class="line">	- [ -w $var ]：如果给定的变量包含的文件可写，则返回真。</span><br><span class="line">	- [ -r $var ]：如果给定的变量包含的文件可读，则返回真。</span><br><span class="line">	- [ -L $var ]：如果给定的变量包含的是一个符号链接，则返回真</span><br><span class="line">	- [ -s $var ]：如果给定的变量包含的文件大小大于0字节，则返回真</span><br><span class="line">	- [ $var1 -nt $var2 ]：new than操作，如果给定的变量包含的文件1比文件2新，则返回真</span><br><span class="line">	- [ $var1 -ot $var2 ]：old than操作，如果给定的变量包含的文件1比文件2旧，则返回真</span><br><span class="line">	- [ $var1 -ef $var2 ]：equal file操作，如果给定的变量包含的文件1和文件2为同一文件，则返回真</span><br><span class="line">- 字符串比较</span><br><span class="line"></span><br><span class="line">	**进行字符串比较时，最好用双中括号**，因为有时候采用单个中括号会产生错误。</span><br><span class="line">	- 测试两个字符串是否相同</span><br></pre></td></tr></table></figure>
//当str1等于str2时，返回真。也就是说，str1和str2包含的文本是一模一样的。
[[ $str1 = $str2 ]]

//这是检查字符串是否相同的另一种写法。
[[ $str1 == $str2 ]]

//如果str1和str2不相同，则返回真。
[[ $str1 != $str2 ]]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		&gt; 注意在&#x3D;前后各有一个空格。如果忘记加空格，那就不是比较关系了，而是变成了赋值语句。</span><br><span class="line">	- 字符串比较</span><br><span class="line">	</span><br><span class="line">		字符串是依据字符的ASCII值进行比较的。例如，A的值是0x41，a的值是0x61。因此，A</span><br><span class="line">小于a，AAa小于Aaa。</span><br></pre></td></tr></table></figure>
//如果str1的字母序比str2大，则返回真。
 [[ $str1 &gt; $str2 ]]
//如果str1的字母序比str2小，则返回真。
 [[ $str1 &lt; $str2 ]]
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 判断空串</span><br></pre></td></tr></table></figure>
 [[ -z $str1 ]]    //如果str1为空串，则返回真。
 [[ ! -z $str1 ]]   //如果str1为空串，则返回假。与-n 等价
 [[ -n $str1 ]     //如果str1不为空串，则返回真。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 逻辑与和逻辑或</span><br><span class="line"></span><br><span class="line">	- -a是逻辑与操作符，-o是逻辑或操作符。可以按照下面的方法结合多个条件进行</span><br></pre></td></tr></table></figure>
[ $var1 -ne 0 -a $var2 -gt 2 ] #使用逻辑与-a
[ $var1 -ne 0 -o $var2 -gt 2 ] #逻辑或-o
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- [] 和 [[ ]]的区别</span><br><span class="line"></span><br><span class="line">二者基本相等，除了下述几点</span><br><span class="line"></span><br><span class="line">- 逻辑运算符不同</span><br><span class="line">	- []使用 -a 和 -o 来表达 与 和 或，不识别&amp;&amp; 和 ||</span><br><span class="line">	- [[ ]]使用 &amp;&amp; 和 || 来表达 与 和 或，不识别-a 和 -o</span><br><span class="line"></span><br><span class="line">- &#x3D;&#x3D;含义不同</span><br><span class="line"></span><br><span class="line">	- 在[[ ]]中，表达式&quot;&#x3D;&#x3D;&quot;和&quot;!&#x3D;&quot;的右边其实会被当做pattern匹配，只不过不是正则匹配，是通配符匹配（即？表示匹配单个字符，*表示匹配零个一个或多个字符）。</span><br><span class="line"></span><br><span class="line">- [[ ]]支持正则匹配</span><br><span class="line"></span><br><span class="line">	- 在[[ ]]中，表达式&quot;&#x3D;~&quot;的右边会被当做正则匹配</span><br><span class="line">		- 不过要注意，使用&quot;&#x3D;~&quot;时，右边表达式不需要引号，如：[[ &#39;$var&#39; &#x3D;~ a* ]]</span><br><span class="line"></span><br><span class="line">&gt; 使用建议，无论是[]还是[[ ]]，都建议对其变量使用双引号包围，换句话说，能做字符比较的时候，不要做数值比较。例如&#96;var&#x3D;&#39;shell script&#39; [ $var &#x3D; &quot;shell script&quot; ]&#96; 会报错，因为变量不加双引号，相当于[ shell script &#x3D; &quot;shell script&quot; ],这显然是错误的，所以应该加上引号&#96;[ &quot;$var&quot; &#x3D; &quot;shell script&quot; ]&#96;</span><br><span class="line"></span><br><span class="line">&gt; 使用建议，使用-eq数值比较的时候，可以在操作符两边同时+0，避免变量为空报错，当日，一边为常数的话可以不用+0：&#96; [ $((a+0)) -le 1]&#96;</span><br><span class="line"></span><br><span class="line">&gt; test命令可以用来测试条件。用test可以避免使用过多的括号，增强代码的可读性。[]中的测试条件同样可以用于test命令。&#96;if [ $var -eq 0 ]; then echo &quot;True&quot;; fi&#96; 等价于 &#96;if test $var -eq 0 ; then echo &quot;True&quot;; fi&#96;</span><br><span class="line">---</span><br><span class="line">## Linux&#x2F;unix文件系统</span><br><span class="line">### 文件权限</span><br><span class="line"></span><br><span class="line">文件权限和所有权是Unix&#x2F;Linux文件系统的显著特性之一。这些特性能够在多用户环境中保护你的个人信息。每一个文件都拥有多种类型的权限。在这些权限中，我们通常要和三组权限打交道：用户、用户组以及其他用户。</span><br><span class="line"></span><br><span class="line">用户（user）是文件的所有者，通常拥有所有的访问权。用户组（group）是多个用户的集合（由系统管理员指定），可能拥有文件的部分访问权。其他用户（others）是除文件所有者或用户组成员之外的任何人。</span><br><span class="line"></span><br><span class="line">ls命令的-l选项可以显示出包括文件类型、权限、所有者以及组在内的多方面信息：</span><br></pre></td></tr></table></figure></code></pre><p>$ ls -l </p>
<blockquote>
<p>-rw-r–r– 1 slynux users 2497 2010-02-28 11:22 bot.py<br>drwxr-xr-x 2 slynux users 4096 2010-05-27 14:31 a.py<br>-rw-r–r– 1 slynux users 539 2010-02-10 09:11 cl.pl</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">上述代码中，第1列表明了文件类型。字符串slynux users分别对应用户和用户组。在这里，slynux是文件所有者，也是组成员之一。</span><br><span class="line"></span><br><span class="line">其中文件类型有如下几种：</span><br><span class="line">- -：普通文件。</span><br><span class="line">- d：目录。</span><br><span class="line">- c：字符设备。</span><br><span class="line">- b：块设备。</span><br><span class="line">- l：符号链接。</span><br><span class="line">- s：套接字。</span><br><span class="line">- p：管道</span><br><span class="line"></span><br><span class="line">接下来的9个字符可以划分成三组，每组3个字符（--- --- ---）第一组的3个字符对应用户权限（所有者），第二组对应用户组权限，第三组对应其他用户权限。这9个字符（即9个权限）中的每一个字符指明是否其设置了某种权限。如果已设置，对应位置上会出现一个字符，否则出现一个-，表明没有设置对应的权限。</span><br><span class="line"></span><br><span class="line">有3种常见的字符。</span><br><span class="line"></span><br><span class="line">- r（read）：如果设置，表明该文件、设备或目录可读。</span><br><span class="line">- w（write）：如果设置，表明该文件、设备或目录可以被修改。对于目录而言，此权限指定了是否可以在目录下创建或删除文件。</span><br><span class="line">- x（execute）：如果设置，表明该文件可执行。对于目录而言，此权限指定了能否访问目录下的文件。</span><br><span class="line"></span><br><span class="line">同时这三组权限含义如下：</span><br><span class="line"></span><br><span class="line">- 用户（权限序列：rwx------）：定义了用户权限。通常来说，对于数据文件，用户权限是rw-；对于脚本或可执行文件，用户权限是rwx。用户还有一个称为setuid（S）的特殊权限，它出现在执行权限（x）的位置。setuid权限允许可执行文件以其拥有者的权限来执行，即使这个可执行文件是由其他用户运行的。具有setuid权限文件的权限序列可以是这样的：-rwS------。</span><br><span class="line">- 用户组（权限序列：---rwx---）：第二组字符指定了组权限。组权限中并没有setuid，但是有一个setgid（S）位。它允许使用与可执行文件所属组权限相同的有效组来运行该文件。但是这个组和实际发起命令的用户组未必相同。例如，组权限的权限序列可以是这样的：----rwS---。</span><br><span class="line">- 其他用户（权限序列：------rwx）：最后3个字符是其他用户权限。如果设置了相应的权限，其他用户也可以访问特定的文件或目录。作为一种规则，通常将这组权限设置为---。</span><br><span class="line"></span><br><span class="line">&gt; 目录有一个叫作粘滞位（sticky bit）的特殊权限。如果目录设置了粘滞位，只有创建该目录的用户才能删除目录中的文件，就算用户组和其他用户也有写权限，仍无能无力。粘滞位出现在其他用户权限组中的执行权限（x）位置。它使用t或T来表示。如果没有设置执行权限，但设置了粘滞位，就使用T；如果同时设置了执行权限和粘滞位，就使用t。例如：  </span><br><span class="line">&gt; &#96;------rwt , ------rwT&#96;  </span><br><span class="line">&gt; 设置目录粘滞位的一个典型例子就是&#x2F;tmp，也就是说任何人都可以在该目录中创建文件，</span><br><span class="line">&gt; 但只有文件的所有者才能删除其所创建的文件。</span><br><span class="line"></span><br><span class="line">&gt; 可使用chmod命令设置文件权限。具体参见博文 [常用shell命令导航（Linux shell脚本攻略笔记）](https:&#x2F;&#x2F;my.oschina.net&#x2F;u&#x2F;4133922&#x2F;blog&#x2F;3077074 &quot;常用shell命令导航（Linux shell脚本攻略笔记）&quot;)</span><br><span class="line"></span><br><span class="line">## 有用的函数或者脚本</span><br><span class="line"></span><br><span class="line">### 持续运行命令直至执行成功</span><br><span class="line">有时候命令只有在满足某些条件时才能够成功执行。例如，在下载文件之前必须先创建该文件。这种情况下，你可能希望重复执行命令，直到成功为止。</span><br></pre></td></tr></table></figure>
<p>//定义如下函数：<br>repeat()<br>{<br> while true<br> do<br> $@ &amp;&amp; return<br> done<br>}<br>//函数repeat()中包含了一个无限while循环，该循环执行以函数参数形式（通过$@访问）传入的命令。如果命令执行成功，则返回，进而退出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在大多数现代系统中，true是作为&#x2F;bin中的一个二进制文件来实现的。</span><br><span class="line">这就意味着每执行一次之前提到的while循环，shell就不得不生成一个进程。为了避免这种情况，可以使用shell的内建命令:，该命令的退出状态总是为0：</span><br></pre></td></tr></table></figure>
<p>repeat() { while :; do $@ &amp;&amp; return; done }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">加入延时</span><br></pre></td></tr></table></figure>
<p>//每30秒才会运行一次<br>repeat() { while :; do $@ &amp;&amp; return; sleep 30; done }</p>
<pre><code>---</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/17/git%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%EF%BC%88Linux-Ubuntu%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/17/git%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%EF%BC%88Linux-Ubuntu%EF%BC%89/" itemprop="url">git安装集成（Linux Ubuntu）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-17T21:41:16+08:00">
                2019-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">工具&软件安装集成相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/17/git%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%EF%BC%88Linux-Ubuntu%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/17/git安装集成（Linux-Ubuntu）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  41
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>git 拥有官方的安装指导页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;git-scm.com&#x2F;download&#x2F;linux</span><br></pre></td></tr></table></figure>

<p>ubuntu中我们使用<br><code>apt install git</code><br><img src="https://oscimg.oschina.net/oscnet/5b073f890c52cf1086a47b7649f9d9c035c.jpg" alt=""></p>
<p>安装完成后执行</p>
<p><code>git --version</code></p>
<p>得到</p>
<p><img src="https://oscimg.oschina.net/oscnet/66a3e034fecab46135045cb751a71d6977a.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/gradle%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/gradle%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90/" itemprop="url">Gradle安装集成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-16T21:34:57+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">工具&软件安装集成相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/05/16/gradle%E5%AE%89%E8%A3%85%E9%9B%86%E6%88%90/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/05/16/gradle安装集成/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网寻找资源 <a href="https://gradle.org/releases/" target="_blank" rel="noopener">https://gradle.org/releases/</a> 红框部分得到下载链接<br><img src="https://oscimg.oschina.net/oscnet/8ffdfd582da547044513263a75684c10a73.jpg" alt=""></p>
<p>在Ubuntu环境下，使用<br><code>wget https://downloads.gradle.org/distributions/gradle-3.4.1-bin.zip</code><br>下载gradle</p>
<p>根据Gradle官方推荐，我们将安装包的内容解压至想要的路径（千万不要放在高权限路径）。<br><code>sudo unzip -d /home/lisheng/tools/gradle gradle-3.4.1-bin.zip</code></p>
<p>修改环境变量</p>
<p><code>sudo vim /etc/profile</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;$PATH:&#x2F;home&#x2F;lisheng&#x2F;tools&#x2F;gradle&#x2F;gradle-3.4.1&#x2F;bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>配置生效</p>
<p><code>source /etc/profile</code></p>
<p>输入gradle -v检查gradle是否安全完成，以及查看其版本号。<br><img src="https://oscimg.oschina.net/oscnet/97541a0ea7ae241c549c8ff65460c020209.jpg" alt=""></p>
<p>使用，直接创建gradle项目即可<br><img src="https://oscimg.oschina.net/oscnet/781840e501ad6e329cd99badf00692733cf.jpg" alt=""></p>
<h1 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a>wrapper</h1><p>当我们平时使用gradle来构建项目的时候，可以现在电脑上安装gradle，在配置环境变量之后就能正常使用了</p>
<p>不过当我们把项目分享给一个电脑上没安装gradle的人时，整体的项目构建还需要配置，显得麻烦。</p>
<p>由此就有了今天的主角：gradle wrapper 一个gradle的封装体，即使电脑上没有安装gradle也能构建。</p>
<p>初衷是因为gradle处于快速迭代阶段，经常发布新版本，如果我们的项目直接去引用，那么更改版本等会变得无比麻烦。而且每个项目又有可能用不一样的gradle版本，这样去手动配置每一个项目对应的gradle版本就会变得麻烦，gradle的引入本来就是想让大家构建项目变得轻松，如果这样的话，岂不是又增加了新的麻烦？所以android想到了包装，引入gradle-wrapper，通过读取配置文件中gradle的版本，为每个项目自动的下载和配置gradle，就是这么简单。</p>
<p>gradle建议开发者为每一个项目创建wrapper，以便其他人在没有gradle环境的机器上运行该项目。</p>
<p>如何创建wrapper呢？使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle wrapper</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/19e49b805f3219d5d183af9b616af9e6acf.jpg" alt=""></p>
<p>目录下会生成以下目录结构<br>Project-name/<br>  gradlew<br>  gradlew.bat<br>  gradle/wrapper/<br>    gradle-wrapper.jar<br>    gradle-wrapper.properties</p>
<p>因为就像wrapper本身的意义，gradle命令行也是善变的，所以wrapper对命令行也进行了一层封装，使用同一的gradlew命令，wrapper会自动去执行具体版本对应的gradle命令。需要使用gradle wrapper的时候，我们就直接在项目根目录下直接执行gradlew(gradle wrapper的简写), 使用gradlew的方式和gradle一模一样, 例如通过gradlew tasks来查看所有的任务。事实上，执行gradlew命令的时候，gradlew会委托gradle命令来做相应的事情，所以gradlew真的只是一个壳而已。</p>
<p>当执行gradlew的时候，wrapper会检查当前机器是否已经安装了对应版本的gradle，如果安装了那么gradlew就会委托gradle执行用户输入的命令。如果还未安装的话，那么首先会自动帮我们从gradle repository下载安装。当然你也可以在配置文件中指定想要下载的server来替代默认的gradle repo。</p>
<p>那么我们如何去修改要下载的gradle版本呢？通过修改gradle-wrapper.properties文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Fri May 17 00:24:36 CST 2019</span><br><span class="line">distributionBase&#x3D;GRADLE_USER_HOME</span><br><span class="line">distributionPath&#x3D;wrapper&#x2F;dists</span><br><span class="line">zipStoreBase&#x3D;GRADLE_USER_HOME</span><br><span class="line">zipStorePath&#x3D;wrapper&#x2F;dists</span><br><span class="line">distributionUrl&#x3D;https\:&#x2F;&#x2F;services.gradle.org&#x2F;distributions&#x2F;gradle-0.9-preview-1-bin.zip</span><br></pre></td></tr></table></figure>

<p>distributionUrl:要下载的gradle地址以及版本，gradle-wrapper会去wrapper/list目录下查找，如果没有对应版本的gradle就调用url资源采取下载</p>
<p>gradle的3种版本：</p>
<ul>
<li><p>gradle-xx-all.zip是完整版，包含了各种二进制文件，源代码文件，和离线的文档。例如，<a href="https://services.gradle.org/distributions/gradle-3.1-all.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-all.zip</a></p>
</li>
<li><p>gradle-xx-bin.zip是二进制版，只包含了二进制文件（可执行文件），没有文档和源代码。例如，<a href="https://services.gradle.org/distributions/gradle-3.1-bin.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-bin.zip</a></p>
</li>
<li><p>gradle-xx-src.zip是源码版，只包含了Gradle源代码，不能用来编译你的工程。例如，<a href="https://services.gradle.org/distributions/gradle-3.1-src.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-src.zip</a></p>
</li>
</ul>
<p>gradle-wrapper.properties各项属性的整体含义，如下：</p>
<ol>
<li><p>去 <a href="https://services.gradle.org/distributions/gradle-3.1-bin.zip" target="_blank" rel="noopener">https://services.gradle.org/distributions/gradle-3.1-bin.zip</a> 下载gradle的3.1版本，只包含binary的版本。</p>
</li>
<li><p>下载的gradle-3.1-bin.zip存放到C:\Users&lt;user_name&gt;.gradle\wrapper\dists目录中。（注：具体还有2级目录，即全路径为C:\Users&lt;user_name&gt;.gradle\wrapper\dists\gradle-3.1-bin&lt;url-hash&gt;\，gradle-3.1-bin目录是根据下载的gradle的文件名来定的，<url-hash>目录是根据distribution url路径字符串计算md5值得来的</p>
</li>
<li><p>解压gradle-3.1-bin.zip，将解压后的文件存放到C:\Users&lt;user_name&gt;.gradle\wrapper\dists中。（注：具体还有2级目录，同上）</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/" itemprop="url">ElasticSearch升级记录 ver.1.4.5→ver.5.2.0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-02T22:03:06+08:00">
                2018-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ElasticSearch/" itemprop="url" rel="index">
                    <span itemprop="name">ElasticSearch</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/08/02/ElasticSearch升级记录-ver-1-4-5→ver-5-2-0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  3.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>项目中的es由ver.1.4.5升级至ver.5.2.0。</p>
<h1 id="安装elasticSearch"><a href="#安装elasticSearch" class="headerlink" title="安装elasticSearch"></a>安装elasticSearch</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#下载</span><br><span class="line">wget https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;elasticsearch&#x2F;elasticsearch-5.2.0.tar.gz</span><br><span class="line"># 解压</span><br><span class="line">tar zxvf elasticsearch-5.5.0.tar.gz</span><br></pre></td></tr></table></figure>
<h1 id="修改elasticsearch-yml"><a href="#修改elasticsearch-yml" class="headerlink" title="修改elasticsearch.yml"></a>修改elasticsearch.yml</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ES_HOME&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure>
<p>在这里不详细展开elasticsearch.yml的各个配置项，附上链接。<br><a href="https://www.cnblogs.com/zlslch/p/6419948.html" target="_blank" rel="noopener">配置es外部链接</a></p>
<h1 id="安装elasticsearch-head"><a href="#安装elasticsearch-head" class="headerlink" title="安装elasticsearch-head"></a>安装elasticsearch-head</h1><p>lasticsearch-head是一个很好的可视化前端框架，方便用可视化界面对es进行调用。elasticsearch-head在Github的地址如下：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a><br>安装也不复杂，由于它是一个前端的工具，因此需要我们预先安装了node和npm，之后执行下面的步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>安装完成后，运行命令npm run start就行。</p>
<h1 id="调整弃用api的兼容问题"><a href="#调整弃用api的兼容问题" class="headerlink" title="调整弃用api的兼容问题"></a>调整弃用api的兼容问题</h1><h2 id="1-setting"><a href="#1-setting" class="headerlink" title="1.setting"></a>1.setting</h2><p>1.4.5的org.elasticsearch.common.settings.ImmutableSettings已经弃用，生成配置对象setting的方式改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Settings settings &#x3D; Settings.builder().put(&quot;cluster.name&quot;, clusterName).put(&quot;client.transport.sniff&quot;, true).build();</span><br></pre></td></tr></table></figure>

<h2 id="2-InetSocketTransportAddress"><a href="#2-InetSocketTransportAddress" class="headerlink" title="2.InetSocketTransportAddress"></a>2.InetSocketTransportAddress</h2><p>org.elasticsearch.common.transport.InetSocketTransportAddress#InetSocketTransportAddress(java.lang.String, int)方法已经弃用，注入集群地址的方式改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clusterNodeAddressList.add(new InetSocketTransportAddress(InetAddress.getByName(host), 9300));</span><br></pre></td></tr></table></figure>
<h2 id="3-TransportClient"><a href="#3-TransportClient" class="headerlink" title="3.TransportClient"></a>3.TransportClient</h2><p>org.elasticsearch.client.transport.TransportClient#TransportClient(org.elasticsearch.common.settings.Settings)，该构造方法已经弃用，生成TransportClient实例的方式改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transportClient &#x3D; new PreBuiltTransportClient(settings);</span><br></pre></td></tr></table></figure>
<h2 id="4-ClusterHealthStatus"><a href="#4-ClusterHealthStatus" class="headerlink" title="4.ClusterHealthStatus"></a>4.ClusterHealthStatus</h2><p>org.elasticsearch.action.admin.cluster.health.ClusterHealthStatus类已经弃用，相同功能由org.elasticsearch.cluster.health.ClusterHealthStatus继承</p>
<h2 id="5-ScriptSortBuilder调整"><a href="#5-ScriptSortBuilder调整" class="headerlink" title="5.ScriptSortBuilder调整"></a>5.ScriptSortBuilder调整</h2><p>原版写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Integer&gt; optionalSortMap &#x3D; manualSortMapBuilder.put(&quot;other&quot;, sortIndex + 1).build();</span><br><span class="line"></span><br><span class="line">String script &#x3D; &quot;paramsMap.containsKey(doc[\&quot;%s\&quot;].value) ? paramsMap.get(doc[\&quot;%s\&quot;].value) : paramsMap.get(&#39;other&#39;)&quot;;</span><br><span class="line"></span><br><span class="line">script &#x3D; String.format(script, sort.getFieldName(), sort.getFieldName());</span><br><span class="line"></span><br><span class="line">sortBuilder &#x3D; SortBuilders.scriptSort(script, &quot;number&quot;).param(&quot;paramsMap&quot;, optionalSortMap).order(SortOrder.ASC).missing(optionalSortMap.get(&quot;other&quot;));</span><br></pre></td></tr></table></figure>

<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Object, Integer&gt; optionalSortMap &#x3D; manualSortMapBuilder.put(&quot;other&quot;, sortIndex + 1).build();</span><br><span class="line"></span><br><span class="line">String script &#x3D; &quot;paramsMap.containsKey(doc[\&quot;%s\&quot;].value) ? paramsMap.get(doc[\&quot;%s\&quot;].value) : paramsMap.get(&#39;other&#39;)&quot;;</span><br><span class="line"></span><br><span class="line">script &#x3D; String.format(script, sort.getFieldName(), sort.getFieldName());</span><br><span class="line">Map&lt;String, Object&gt; params &#x3D; Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">params.put(&quot;paramsMap&quot;, optionalSortMap);</span><br><span class="line"></span><br><span class="line">Script scriptObject &#x3D; new Script(Script.DEFAULT_SCRIPT_TYPE, Script.DEFAULT_SCRIPT_LANG, script, params);</span><br><span class="line"></span><br><span class="line">sortBuilder &#x3D; SortBuilders.scriptSort(scriptObject, ScriptSortBuilder.ScriptSortType.fromString(&quot;number&quot;)).order(SortOrder.ASC);</span><br></pre></td></tr></table></figure>
<h2 id="6-FilterBuilder调整"><a href="#6-FilterBuilder调整" class="headerlink" title="6.FilterBuilder调整"></a>6.FilterBuilder调整</h2><p>org.elasticsearch.index.query.FilterBuilder类已经弃用，基本上从2.x版本开始，Filter就已经弃用了（不包括bool查询内的filter），所有FilterBuilder全都要用QueryBuilder的各种子类来调整：</p>
<h3 id="1-org-elasticsearch-index-query-BoolFilterBuilder"><a href="#1-org-elasticsearch-index-query-BoolFilterBuilder" class="headerlink" title="1.org.elasticsearch.index.query.BoolFilterBuilder"></a>1.org.elasticsearch.index.query.BoolFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoolFilterBuilder boolFilterBuilder &#x3D; FilterBuilders.boolFilter();</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BoolQueryBuilder boolFilterBuilder &#x3D; new BoolQueryBuilder();</span><br></pre></td></tr></table></figure>

<h3 id="2-org-elasticsearch-index-query-NestedFilterBuilder"><a href="#2-org-elasticsearch-index-query-NestedFilterBuilder" class="headerlink" title="2.org.elasticsearch.index.query.NestedFilterBuilder"></a>2.org.elasticsearch.index.query.NestedFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; FilterBuilders.nestedFilter(param.getPath(), boolFilterBuilder);</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; new NestedQueryBuilder(param.getPath(), boolFilterBuilder, ScoreMode.None);</span><br></pre></td></tr></table></figure>

<h3 id="3-org-elasticsearch-index-query-MissingFilterBuilder"><a href="#3-org-elasticsearch-index-query-MissingFilterBuilder" class="headerlink" title="3.org.elasticsearch.index.query.MissingFilterBuilder"></a>3.org.elasticsearch.index.query.MissingFilterBuilder</h3><p>5.x版本中，missing关键字已经弃用，其功能由其逆运算exist继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MissingFilterBuilder missingFilterBuilder &#x3D; FilterBuilders.missingFilter(paramName);</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.EXISTS) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.boolFilter().mustNot(missingFilterBuilder);</span><br><span class="line">&#125;</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.MISSING) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.boolFilter().must(missingFilterBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExistsQueryBuilder existsQueryBuilder &#x3D; new ExistsQueryBuilder(paramName);</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.EXISTS) &#123;</span><br><span class="line">    filterBuilder &#x3D; new BoolQueryBuilder().must(existsQueryBuilder);</span><br><span class="line">&#125;</span><br><span class="line">if (param.getNvlType() &#x3D;&#x3D; QueryFieldType.MISSING) &#123;</span><br><span class="line">    filterBuilder &#x3D; new BoolQueryBuilder().mustNot(existsQueryBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-org-elasticsearch-index-query-TermFilterBuilder"><a href="#4-org-elasticsearch-index-query-TermFilterBuilder" class="headerlink" title="4.org.elasticsearch.index.query.TermFilterBuilder"></a>4.org.elasticsearch.index.query.TermFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; FilterBuilders.termFilter(paramName, param.getEqValue());</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; new TermQueryBuilder(paramName, param.getEqValue());</span><br></pre></td></tr></table></figure>

<h3 id="5-org-elasticsearch-index-query-TermsFilterBuilder"><a href="#5-org-elasticsearch-index-query-TermsFilterBuilder" class="headerlink" title="5.org.elasticsearch.index.query.TermsFilterBuilder"></a>5.org.elasticsearch.index.query.TermsFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; FilterBuilders.inFilter(paramName, param.getInValues());</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterBuilder &#x3D; new TermsQueryBuilder(paramName, param.getInValues());</span><br></pre></td></tr></table></figure>

<h3 id="6-org-elasticsearch-index-query-RangeFilterBuilder"><a href="#6-org-elasticsearch-index-query-RangeFilterBuilder" class="headerlink" title="6.org.elasticsearch.index.query.RangeFilterBuilder"></a>6.org.elasticsearch.index.query.RangeFilterBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;gte</span><br><span class="line">if (null !&#x3D; param.getGteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).gte(param.getGteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;gt</span><br><span class="line">if (null !&#x3D; param.getGtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).gt(param.getGtValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lte</span><br><span class="line">if (null !&#x3D; param.getLteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).lte(param.getLteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lt</span><br><span class="line">if (null !&#x3D; param.getLtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; FilterBuilders.rangeFilter(paramName).lt(param.getLtValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;gte</span><br><span class="line">if (null !&#x3D; param.getGteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).gte(param.getGteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;gt</span><br><span class="line">if (null !&#x3D; param.getGtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).gt(param.getGtValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lte</span><br><span class="line">if (null !&#x3D; param.getLteValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).lte(param.getLteValue());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;lt</span><br><span class="line">if (null !&#x3D; param.getLtValue()) &#123;</span><br><span class="line">    filterBuilder &#x3D; new RangeQueryBuilder(paramName).lt(param.getLtValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-search-type-count"><a href="#7-search-type-count" class="headerlink" title="7.search_type=count"></a>7.search_type=count</h2><p>原来我们想要计算文档的需要用到search_type=count，现在5.0已经将该API移除，取而代之你只需将size置于0即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;my_index&#x2F;_search?search_type&#x3D;count</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;my_terms&quot;: &#123;</span><br><span class="line">       &quot;terms&quot;: &#123;</span><br><span class="line">         &quot;field&quot;: &quot;foo&quot;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#5.0以后</span><br><span class="line">GET &#x2F;my_index&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;my_terms&quot;: &#123;</span><br><span class="line">       &quot;terms&quot;: &#123;</span><br><span class="line">         &quot;field&quot;: &quot;foo&quot;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-RangeBuilder"><a href="#8-RangeBuilder" class="headerlink" title="8.RangeBuilder"></a>8.RangeBuilder</h2><p>org.elasticsearch.search.aggregations.bucket.range.RangeBuilder已经弃用，相应功能由org.elasticsearch.search.aggregations.bucket.range.RangeAggregationBuilder实现，直接替换即可。</p>
<h2 id="9-TopHitsAggregationBuilder"><a href="#9-TopHitsAggregationBuilder" class="headerlink" title="9.TopHitsAggregationBuilder"></a>9.TopHitsAggregationBuilder</h2><p>org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder已经弃用，相应功能由org.elasticsearch.search.aggregations.metrics.tophits.TopHitsAggregationBuilder实现，直接替换即可。</p>
<h2 id="10-FiltersAggregationBuilder"><a href="#10-FiltersAggregationBuilder" class="headerlink" title="10.FiltersAggregationBuilder"></a>10.FiltersAggregationBuilder</h2><p>org.elasticsearch.search.aggregations.bucket.filters.FiltersAggregationBuilder构造报文调整</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FiltersAggregationBuilder filtersAggregationBuilder &#x3D; AggregationBuilders.filters(aggregationField.getAggName());</span><br><span class="line">LufaxSearchConditionBuilder tmpConditionBuilder &#x3D; new LufaxSearchConditionBuilder();</span><br><span class="line">for (String key : aggregationField.getFiltersMap().keySet()) &#123;</span><br><span class="line">    LufaxFilterCondition tmpLufaxFilterCondition &#x3D; aggregationField.getFiltersMap().get(key);</span><br><span class="line">    FilterBuilder tmpFilterBuilder &#x3D; tmpConditionBuilder.constructFilterBuilder(tmpLufaxFilterCondition.getAndParams(),tmpLufaxFilterCondition.getOrParams(),tmpLufaxFilterCondition.getNotParams());</span><br><span class="line">    filtersAggregationBuilder.filter(key, tmpFilterBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调整成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;FiltersAggregator.KeyedFilter&gt; keyedFilters &#x3D; new LinkedList&lt;FiltersAggregator.KeyedFilter&gt;();</span><br><span class="line">LufaxSearchConditionBuilder tmpConditionBuilder &#x3D; new LufaxSearchConditionBuilder();</span><br><span class="line">for (String key : aggregationField.getFiltersMap().keySet()) &#123;</span><br><span class="line">    LufaxFilterCondition tmpLufaxFilterCondition &#x3D; aggregationField.getFiltersMap().get(key);</span><br><span class="line">    QueryBuilder tmpFilterBuilder &#x3D; tmpConditionBuilder.constructFilterBuilder(tmpLufaxFilterCondition.getAndParams(),tmpLufaxFilterCondition.getOrParams(),tmpLufaxFilterCondition.getNotParams());</span><br><span class="line">    keyedFilters.add(new FiltersAggregator.KeyedFilter(key, tmpFilterBuilder));</span><br><span class="line">&#125;</span><br><span class="line">FiltersAggregationBuilder filtersAggregationBuilder &#x3D; AggregationBuilders.filters(aggregationField.getAggName(), keyedFilters.toArray(new FiltersAggregator.KeyedFilter[]&#123;&#125;));</span><br></pre></td></tr></table></figure>
<h2 id="11-HighlightBuilder"><a href="#11-HighlightBuilder" class="headerlink" title="11.HighlightBuilder;"></a>11.HighlightBuilder;</h2><p>org.elasticsearch.search.highlight.HighlightBuilder弃用，相关功能由org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder实现。</p>
<h2 id="12-OptimizeRequestBuilder"><a href="#12-OptimizeRequestBuilder" class="headerlink" title="12.OptimizeRequestBuilder"></a>12.OptimizeRequestBuilder</h2><p>org.elasticsearch.action.admin.indices.optimize.OptimizeRequestBuilder 已经弃用，聚合索引的功能由org.elasticsearch.action.admin.indices.forcemerge.ForceMergeRequestBuilder来实现。</p>
<h2 id="13-IndicesAliasesRequestBuilder"><a href="#13-IndicesAliasesRequestBuilder" class="headerlink" title="13.IndicesAliasesRequestBuilder"></a>13.IndicesAliasesRequestBuilder</h2><h3 id="1-newAddAliasAction"><a href="#1-newAddAliasAction" class="headerlink" title="1.newAddAliasAction"></a>1.newAddAliasAction</h3><p>旧版删除了AliasAction类的newAddAliasAction方法，故而IndicesAliasesRequestBuilder添加AliasActions应该：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(AliasAction.newAddAliasAction(toIndex, indexAlias));</span><br></pre></td></tr></table></figure>

<p>调整成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(IndicesAliasesRequest.AliasActions.add().index(toIndex).alias(indexAlias));</span><br></pre></td></tr></table></figure>

<h3 id="2-newRemoveAliasAction"><a href="#2-newRemoveAliasAction" class="headerlink" title="2.newRemoveAliasAction"></a>2.newRemoveAliasAction</h3><p>旧版删除了AliasAction类的newRemoveAliasAction方法，故而IndicesAliasesRequestBuilder删除AliasActions应该：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(AliasAction.newRemoveAliasAction(fromIdx, indexAlias));</span><br></pre></td></tr></table></figure>

<p>调整成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestBuilder.addAliasAction(IndicesAliasesRequest.AliasActions.remove().index(fromIdx).alias(indexAlias));</span><br></pre></td></tr></table></figure>

<h2 id="14-AbstractAggregationBuilder的子类变更"><a href="#14-AbstractAggregationBuilder的子类变更" class="headerlink" title="14.AbstractAggregationBuilder的子类变更"></a>14.AbstractAggregationBuilder的子类变更</h2><h3 id="1-org-elasticsearch-search-aggregations-bucket-terms-TermsBuilder"><a href="#1-org-elasticsearch-search-aggregations-bucket-terms-TermsBuilder" class="headerlink" title="1.org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder"></a>1.org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder</h3><p>org.elasticsearch.search.aggregations.bucket.terms.TermsBuilder更名为<br>org.elasticsearch.search.aggregations.bucket.terms.TermsAggregationBuilder</p>
<h3 id="2-org-elasticsearch-search-aggregations-bucket-range-date-DateRangeBuilder"><a href="#2-org-elasticsearch-search-aggregations-bucket-range-date-DateRangeBuilder" class="headerlink" title="2.org.elasticsearch.search.aggregations.bucket.range.date.DateRangeBuilder"></a>2.org.elasticsearch.search.aggregations.bucket.range.date.DateRangeBuilder</h3><p>org.elasticsearch.search.aggregations.bucket.range.date.DateRangeBuilder更名为<br>org.elasticsearch.search.aggregations.bucket.range.date.DateRangeAggregationBuilder</p>
<h3 id="3-org-elasticsearch-search-aggregations-metrics-tophits-TopHitsBuilder"><a href="#3-org-elasticsearch-search-aggregations-metrics-tophits-TopHitsBuilder" class="headerlink" title="3.org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder"></a>3.org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder</h3><p>org.elasticsearch.search.aggregations.metrics.tophits.TopHitsBuilder更名为<br>org.elasticsearch.search.aggregations.metrics.tophits.TopHitsAggregationBuilder</p>
<h2 id="15-SearchHit类"><a href="#15-SearchHit类" class="headerlink" title="15.SearchHit类"></a>15.SearchHit类</h2><p>org.elasticsearch.search.SearchHit#isSourceEmpty方法改为org.elasticsearch.search.SearchHit#hasSource方法，反向替换。</p>
<h2 id="16-DeleteByQueryResponse"><a href="#16-DeleteByQueryResponse" class="headerlink" title="16.DeleteByQueryResponse"></a>16.DeleteByQueryResponse</h2><p>org.elasticsearch.action.deletebyquery.DeleteByQueryResponse已经弃用，</p>
<h1 id="调整关键字等结构性问题"><a href="#调整关键字等结构性问题" class="headerlink" title="调整关键字等结构性问题"></a>调整关键字等结构性问题</h1><h2 id="1-String数据类型弃用"><a href="#1-String数据类型弃用" class="headerlink" title="1. String数据类型弃用"></a>1. String数据类型弃用</h2><p>在 ES2.x 版本字符串数据是没有 keyword 和 text 类型的，只有string类型，ES更新到5版本后，取消了 string 数据类型，代替它的是 keyword 和 text 数据类型。区别在于：</p>
<p>text类型定义的文本会被分析，在建立索引前会将这些文本进行分词，转化为词的组合，建立索引。允许 ES来检索这些词语。text 数据类型不能用来排序和聚合。</p>
<p>keyWord类型表示精确查找的文本，不需要进行分词。可以被用来检索过滤、排序和聚合。keyword 类型字段只能用本身来进行检索。</p>
<p>在没有显性定义时，es默认为“text”类型。</p>
<h2 id="2-multi-field关键字弃用"><a href="#2-multi-field关键字弃用" class="headerlink" title="2. multi_field关键字弃用"></a>2. multi_field关键字弃用</h2><p>相关mapping方式改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#对需要设置的字段，在&#39;type&#39;属性后增加&quot;fields&quot;: </span><br><span class="line">#其中的&quot;raw&quot;为自定义的名称,想象它是city的一个分身。</span><br><span class="line">PUT &#x2F;my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;city&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;raw&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">查询raw字段时，使用city.raw表示</span><br></pre></td></tr></table></figure>
<h2 id="3-analyzer"><a href="#3-analyzer" class="headerlink" title="3. analyzer"></a>3. analyzer</h2><h3 id="1-改版后，设置了search-analyzer的情况下，analyzer也要设置，否则会报："><a href="#1-改版后，设置了search-analyzer的情况下，analyzer也要设置，否则会报：" class="headerlink" title="1.改版后，设置了search_analyzer的情况下，analyzer也要设置，否则会报："></a>1.改版后，设置了search_analyzer的情况下，analyzer也要设置，否则会报：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyzer on field [name] must be set when search_analyzer is set。</span><br></pre></td></tr></table></figure>
<h3 id="2-改版后，index-analyzer设置被弃用，如果设置，会报"><a href="#2-改版后，index-analyzer设置被弃用，如果设置，会报" class="headerlink" title="2.改版后，index_analyzer设置被弃用，如果设置，会报"></a>2.改版后，index_analyzer设置被弃用，如果设置，会报</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapperParsingException[Mapping definition for [fields] has unsupported parameters:  [index_analyzer : ik_max_word]];</span><br></pre></td></tr></table></figure>


<p><img src="https://oscimg.oschina.net/oscnet/17d3a80c1adff9f8b379c9006036a58cdb0.jpg" alt=""></p>
<p>这里扩展一下，在原来的版本中，index_analyzer负责建立索引时的分词器定义，search_analyzer负责搜索时的分词器定义。</p>
<p>索引期间查找解析器的完整顺序是这样的：</p>
<ul>
<li>定义在字段映射中的index_analyzer</li>
<li>定义在字段映射中的analyzer</li>
<li>定义在文档_analyzer字段中的解析器</li>
<li>type的默认index_analyzer</li>
<li>type的默认analyzer</li>
<li>索引设置中default_index对应的解析器</li>
<li>索引设置中default对应的解析器</li>
<li>节点上default_index对应的解析器</li>
<li>节点上default对应的解析器</li>
<li>standard解析器</li>
</ul>
<p>而查询期间的完整顺序则是：</p>
<ul>
<li>直接定义在查询中的analyzer</li>
<li>定义在字段映射中的search_analyzer</li>
<li>定义在字段映射中的analyzer</li>
<li>type的默认search_analyzer</li>
<li>type的默认analyzer</li>
<li>索引设置中的default_search对应的解析器</li>
<li>索引设置中的default对应的解析器</li>
<li>节点上default_search对应的解析器</li>
<li>节点上default对应的解析器</li>
<li>standard解析器</li>
</ul>
<p><strong>现在新版删除index_analyzer，具体功能由analyzer关键字承担，analyzer关键字生效与index时和search时（除非search_analyzer已经被显性定义）。</strong></p>
<h2 id="3-timestamp在2-0弃用"><a href="#3-timestamp在2-0弃用" class="headerlink" title="3. _timestamp在2.0弃用"></a>3. _timestamp在2.0弃用</h2><p>_timestamp官方建议自定义一个字段，自己赋值用来表示时间戳。</p>
<p><img src="https://oscimg.oschina.net/oscnet/83fad879140e27f9bdece1502d0076ef9db.jpg" alt=""></p>
<h2 id="4-嵌套字段排序时字段名称调整"><a href="#4-嵌套字段排序时字段名称调整" class="headerlink" title="4. 嵌套字段排序时字段名称调整"></a>4. 嵌套字段排序时字段名称调整</h2><p>对于如下的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;my_index&#x2F;blogpost&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Investment secrets&quot;,</span><br><span class="line">  &quot;body&quot;:  &quot;What they don&#39;t tell you ...&quot;,</span><br><span class="line">  &quot;tags&quot;:  [ &quot;shares&quot;, &quot;equities&quot; ],</span><br><span class="line">  &quot;comments&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;Mary Brown&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;Lies, lies, lies&quot;,</span><br><span class="line">      &quot;age&quot;:     42,</span><br><span class="line">      &quot;stars&quot;:   1,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-10-18&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;:    &quot;John Smith&quot;,</span><br><span class="line">      &quot;comment&quot;: &quot;You&#39;re making it up!&quot;,</span><br><span class="line">      &quot;age&quot;:     28,</span><br><span class="line">      &quot;stars&quot;:   2,</span><br><span class="line">      &quot;date&quot;:    &quot;2014-10-16&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老版本中，对stars字段进行排序时，直接可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;stars&quot; : &#123;</span><br><span class="line">      &quot;order&quot; : &quot;desc&quot;,</span><br><span class="line">      &quot;mode&quot; : &quot;min&quot;,</span><br><span class="line">      &quot;nested_path&quot; : &quot;comments&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>但在新版中，上述报文会报</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No mapping found for [stars] in order to sort on</span><br></pre></td></tr></table></figure>
<p>需要改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;comments.stars&quot; : &#123;</span><br><span class="line">       &quot;order&quot; : &quot;desc&quot;,</span><br><span class="line">       &quot;mode&quot; : &quot;min&quot;</span><br><span class="line">     &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>

<h2 id="5-script脚本参数名变更"><a href="#5-script脚本参数名变更" class="headerlink" title="5. _script脚本参数名变更"></a>5. _script脚本参数名变更</h2><p>老版中，_script可以这样定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_script&quot; : &#123;</span><br><span class="line">        &quot;script&quot; : &#123;</span><br><span class="line">          &quot;inline&quot; : &quot;paramsMap.containsKey(doc[\&quot;id\&quot;].value) ? params.paramsMap.get(doc[\&quot;id\&quot;].value) : params.paramsMap.get(&#39;other&#39;)&quot;,</span><br><span class="line">          &quot;lang&quot; : &quot;painless&quot;,</span><br><span class="line">          &quot;params&quot; : &#123;</span><br><span class="line">            &quot;paramsMap&quot; : &#123;</span><br><span class="line">              &quot;1&quot; : 1,</span><br><span class="line">              &quot;2&quot; : 1,</span><br><span class="line">              &quot;3&quot; : 2,</span><br><span class="line">              &quot;other&quot; : 3</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;type&quot; : &quot;number&quot;,</span><br><span class="line">        &quot;order&quot; : &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>新版中，对于params的参数paramsMap必须用params.paramsMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_script&quot; : &#123;</span><br><span class="line">        &quot;script&quot; : &#123;</span><br><span class="line">          &quot;inline&quot; : &quot;params.paramsMap.containsKey(doc[\&quot;productCategory\&quot;].value) ? params.paramsMap.get(doc[\&quot;productCategory\&quot;].value) : params.paramsMap.get(&#39;other&#39;)&quot;,</span><br><span class="line">          &quot;lang&quot; : &quot;painless&quot;,</span><br><span class="line">          &quot;params&quot; : &#123;</span><br><span class="line">            &quot;paramsMap&quot; : &#123;</span><br><span class="line">              &quot;901&quot; : 1,</span><br><span class="line">              &quot;902&quot; : 1,</span><br><span class="line">              &quot;701&quot; : 2,</span><br><span class="line">              &quot;other&quot; : 3</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;type&quot; : &quot;number&quot;,</span><br><span class="line">        &quot;order&quot; : &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>注意：<strong>es 5.2.0默认禁用了动态语言，所以lang为painless之外的语言</strong>，默认情况下会报</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScriptException[scripts of type [inline], operation [update] and lang [groovy] are disabled];</span><br></pre></td></tr></table></figure>

<p>需要在yml文件中添加配置（如groovy）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">script.engine.groovy.inline:true </span><br><span class="line">script.engine.groovy.stored.search:true </span><br><span class="line">script.engine.groovy.stored.aggs:true</span><br></pre></td></tr></table></figure>

<h2 id="6-获取特定字段返回"><a href="#6-获取特定字段返回" class="headerlink" title="6 .获取特定字段返回"></a>6 .获取特定字段返回</h2><p>在旧版本中，获取特定文档特定字段返回，可以使用stored_fields：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;from&quot; : 0,</span><br><span class="line">  &quot;size&quot; : 1,</span><br><span class="line">  &quot;query&quot; : &#123;&#125;,</span><br><span class="line">  &quot;stored_fields&quot; : &quot;timestamp&quot;,</span><br><span class="line">  &quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;order&quot; : &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版本中，引入了更为强大的_source过滤器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;from&quot; : 0,</span><br><span class="line">  &quot;size&quot; : 1,</span><br><span class="line">  &quot;query&quot; : &#123;&#125;,</span><br><span class="line">  &quot;_source&quot; : &quot;timestamp&quot;,</span><br><span class="line">  &quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;order&quot; : &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot; : 0,</span><br><span class="line">  &quot;size&quot; : 1,</span><br><span class="line">  &quot;query&quot; : &#123;&#125;,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;includes&quot; : [ &quot;timestamp&quot; ],</span><br><span class="line">    &quot;excludes&quot; : [ &quot;&quot; ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;order&quot; : &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java的api主要调用SearchRequestBuilder的setFetchSource方法</p>
<h2 id="7-date字段的format定义"><a href="#7-date字段的format定义" class="headerlink" title="7. date字段的format定义"></a>7. date字段的format定义</h2><p>改版后，date字段最好再mapping时定义好format信息，以防止在请求前后因为格式转换问题报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElasticsearchParseException[failed to parse date field [Thu Jun 18 00:00:00 CST 2015] with format [strict_date_optional_time||epoch_millis]]; nested: IllegalArgumentException[Parse failure at index [0] of [Thu Jun 18 00:00:00 CST 2015]]; &#125;</span><br></pre></td></tr></table></figure>
<p>[strict_date_optional_time||epoch_millis]是es默认的date字段解析格式</p>
<h2 id="8-UncategorizedExecutionException"><a href="#8-UncategorizedExecutionException" class="headerlink" title="8. UncategorizedExecutionException"></a>8. UncategorizedExecutionException</h2><p>改版前，transport client发送数据之前将java代码中的字段序列化成了json然后进行传输和请求，而在5.x以后，es改用使用的内部的transport protocol，这时候，如果定义一个比如bigDecimal类型，es不支持bigDecimal，数据类型不匹配会抛错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UncategorizedExecutionException[Failed execution]; nested: IOException[can not write type [class java.math.BigDecimal]];</span><br></pre></td></tr></table></figure>


<p>es支持的格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Writer&gt; writers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    writers.put(String.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 0);</span><br><span class="line">        o.writeString((String) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Integer.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 1);</span><br><span class="line">        o.writeInt((Integer) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Long.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 2);</span><br><span class="line">        o.writeLong((Long) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Float.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 3);</span><br><span class="line">        o.writeFloat((float) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Double.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 4);</span><br><span class="line">        o.writeDouble((double) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Boolean.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 5);</span><br><span class="line">        o.writeBoolean((boolean) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(byte[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 6);</span><br><span class="line">        final byte[] bytes &#x3D; (byte[]) v;</span><br><span class="line">        o.writeVInt(bytes.length);</span><br><span class="line">        o.writeBytes(bytes);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(List.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 7);</span><br><span class="line">        final List list &#x3D; (List) v;</span><br><span class="line">        o.writeVInt(list.size());</span><br><span class="line">        for (Object item : list) &#123;</span><br><span class="line">            o.writeGenericValue(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Object[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 8);</span><br><span class="line">        final Object[] list &#x3D; (Object[]) v;</span><br><span class="line">        o.writeVInt(list.length);</span><br><span class="line">        for (Object item : list) &#123;</span><br><span class="line">            o.writeGenericValue(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Map.class, (o, v) -&gt; &#123;</span><br><span class="line">        if (v instanceof LinkedHashMap) &#123;</span><br><span class="line">            o.writeByte((byte) 9);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            o.writeByte((byte) 10);</span><br><span class="line">        &#125;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        final Map&lt;String, Object&gt; map &#x3D; (Map&lt;String, Object&gt;) v;</span><br><span class="line">        o.writeVInt(map.size());</span><br><span class="line">        for (Map.Entry&lt;String, Object&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            o.writeString(entry.getKey());</span><br><span class="line">            o.writeGenericValue(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Byte.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 11);</span><br><span class="line">        o.writeByte((Byte) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Date.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 12);</span><br><span class="line">        o.writeLong(((Date) v).getTime());</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(ReadableInstant.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 13);</span><br><span class="line">        final ReadableInstant instant &#x3D; (ReadableInstant) v;</span><br><span class="line">        o.writeString(instant.getZone().getID());</span><br><span class="line">        o.writeLong(instant.getMillis());</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(BytesReference.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 14);</span><br><span class="line">        o.writeBytesReference((BytesReference) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Text.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 15);</span><br><span class="line">        o.writeText((Text) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(Short.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 16);</span><br><span class="line">        o.writeShort((Short) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(int[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 17);</span><br><span class="line">        o.writeIntArray((int[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(long[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 18);</span><br><span class="line">        o.writeLongArray((long[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(float[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 19);</span><br><span class="line">        o.writeFloatArray((float[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(double[].class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 20);</span><br><span class="line">        o.writeDoubleArray((double[]) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(BytesRef.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 21);</span><br><span class="line">        o.writeBytesRef((BytesRef) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    writers.put(GeoPoint.class, (o, v) -&gt; &#123;</span><br><span class="line">        o.writeByte((byte) 22);</span><br><span class="line">        o.writeGeoPoint((GeoPoint) v);</span><br><span class="line">    &#125;);</span><br><span class="line">    WRITERS &#x3D; Collections.unmodifiableMap(writers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ThreadPoolExecutor/" itemprop="url">线程池源码分析--ThreadPoolExecutor</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-27T21:54:11+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA线程与并发控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ThreadPoolExecutor/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/03/27/线程池源码分析-ThreadPoolExecutor/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  13.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  58
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>我们知道，线程池帮我们重复管理线程，避免创建大量的线程增加开销。<br>合理的使用线程池能够带来3个很明显的好处：</p>
<ol>
<li>降低资源消耗：通过重用已经创建的线程来降低线程创建和销毁的消耗</li>
<li>提高响应速度：任务到达时不需要等待线程创建就可以立即执行。</li>
<li>提高线程的可管理性：线程池可以统一管理、分配、调优和监控。<br>java源生的线程池，实现于ThreadPoolExecutor类，这也是我们今天讨论的重点<h1 id="1-ThreadPoolExecutor类构造方法"><a href="#1-ThreadPoolExecutor类构造方法" class="headerlink" title="1. ThreadPoolExecutor类构造方法"></a>1. ThreadPoolExecutor类构造方法</h1>Jdk使用ThreadPoolExecutor类来创建线程池，我们来看看它的构造方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">     * parameters.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">     *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">     *        pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">     *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">     *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">     *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">     *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment">     *        creates a new thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment">     *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">     *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>int corePoolSize,    //核心线程的数量</p>
</li>
<li><p>int maximumPoolSize,    //最大线程数量</p>
</li>
<li><p>long keepAliveTime,    //超出核心线程数量以外的线程空闲时，线程存活的时间</p>
</li>
<li><p>TimeUnit unit,    //存活时间的单位，有如下几种选择</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;               <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure></li>
<li><p>BlockingQueue<Runnable> workQueue,    //保存待执行任务的队列，常见的也有如下几种：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue;</span><br><span class="line">LinkedBlockingQueue;</span><br><span class="line">SynchronousQueue;</span><br><span class="line">PriorityBlockingQueue</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><img src="https://oscimg.oschina.net/oscnet/up-bda4412c9b4f21b10a98afa00b74b1ebf6d.png" alt=""></p>
</li>
<li><p>ThreadFactory threadFactory,    //创建新线程使用的工厂</p>
</li>
<li><p>RejectedExecutionHandler handler // 当任务无法执行时的处理器（线程拒绝策略）</p>
<h1 id="2-核心类变量"><a href="#2-核心类变量" class="headerlink" title="2. 核心类变量"></a>2. 核心类变量</h1><h2 id="2-1-ctl变量"><a href="#2-1-ctl变量" class="headerlink" title="2.1 ctl变量"></a>2.1 ctl变量</h2><p>ThreadPoolExecutor中有一个控制状态的属性叫ctl，它是一个AtomicInteger类型的变量，它一个int值可以储存两个概念的信息：</p>
</li>
<li><p>workerCount：表明当前池中有效的线程数，通过workerCountOf方法获得，workerCount上限是(2^29)-1。（最后存放在ctl的低29bit）</p>
</li>
<li><p>runState：表明当前线程池的状态，通过workerCountOf方法获得，最后存放在ctl的高3bit中，他们是整个线程池的运行生命周期，有如下取值，分别的含义是：</p>
<ol>
<li>RUNNING：可以新加线程，同时可以处理queue中的线程。线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，</li>
<li>SHUTDOWN：不增加新线程，但是可以处理queue中的线程。调用线程池的shutdown()方法时，线程池由RUNNING -&gt; SHUTDOWN。</li>
<li>STOP 不增加新线程，同时不处理queue中的线程，会中断正在处理任务的线程。调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</li>
<li>TIDYING 当所有的任务已终止，ctl记录的”任务数量”为0，阻塞队列为空，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 </li>
<li>TERMINATED 线程池彻底终止，就变成TERMINATED状态。线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</li>
</ol>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-806a4c5ac5673a256b5bb5eb71f87f6a7b1.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<p>COUNT_BITS=32（integer的size）-3=29，于是五种状态左移29位分别是：</p>
<ul>
<li>RUNNING：   <strong>111</strong>00000000000000000000000000000 </li>
<li>SHUTDOWN：  <strong>000</strong>00000000000000000000000000000</li>
<li>STOP：      <strong>001</strong>00000000000000000000000000000</li>
<li>TIDYING：   <strong>010</strong>00000000000000000000000000000</li>
<li>TERMINATED：<strong>011</strong>00000000000000000000000000000<br>而ThreadPoolExecutor是通过runStateOf和workerCountOf获得者两个概念的值的。</li>
</ul>
<blockquote>
<p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。</p>
</blockquote>
<p>runStateOf和workerCountOf方法是如何剥离出ctl变量的两个有效值呢？这其中我们可以看到CAPACITY是实现一个字段存两个值的最重要的字段。</p>
<h2 id="2-2-CAPACITY变量"><a href="#2-2-CAPACITY变量" class="headerlink" title="2.2 CAPACITY变量"></a>2.2 CAPACITY变量</h2><p>CAPACITY=(1 &lt;&lt; COUNT_BITS) – 1 转成二进制为：000 11111111111111111111111111111，他是线程池理论上可以允许的最大的线程数。<br>所以很明显，它的重点在于，其高3bit为0，低29bit为1；<br>这样，workderCountOf方法中，CAPACITY和ctl进行&amp;运算时，它能获得高3位都是0，低29位和ctl低29位相同的值，<strong>这个值就是workerCount</strong>；<br>同理，runStateOf方法，CAPACITY的取反和ctl进行&amp;操作，获得高3位和ctl高三位相等，低29位都为0的值，<strong>这个值就是runState</strong>；</p>
<h2 id="2-3-workQueue"><a href="#2-3-workQueue" class="headerlink" title="2.3 workQueue"></a>2.3 workQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The queue used for holding tasks and handing off to worker</span></span><br><span class="line"><span class="comment">     * threads.  We do not require that workQueue.poll() returning</span></span><br><span class="line"><span class="comment">     * null necessarily means that workQueue.isEmpty(), so rely</span></span><br><span class="line"><span class="comment">     * solely on isEmpty to see if the queue is empty (which we must</span></span><br><span class="line"><span class="comment">     * do for example when deciding whether to transition from</span></span><br><span class="line"><span class="comment">     * SHUTDOWN to TIDYING).  This accommodates special-purpose</span></span><br><span class="line"><span class="comment">     * queues such as DelayQueues for which poll() is allowed to</span></span><br><span class="line"><span class="comment">     * return null even if it may later return non-null when delays</span></span><br><span class="line"><span class="comment">     * expire.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure>
<p>一个BlockingQueue<Runnable>队列，本身的结构可以保证访问的线程安全（这里不展开了）。这是一个排队等待队列。当我们线程池里线程达到corePoolSize的时候，一些需要等待执行的线程就放在这个队列里等待。</p>
<h2 id="2-4-workers"><a href="#2-4-workers" class="headerlink" title="2.4 workers"></a>2.4 workers</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set containing all worker threads in pool. Accessed only when</span></span><br><span class="line"><span class="comment">     * holding mainLock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>
<p>一个HashSet<Worker>的集合。线程池里所有可以立即执行的线程都放在这个集合里。这也是我们直观理解的<strong>线程的池子</strong>。</p>
<h2 id="2-5-mainLock"><a href="#2-5-mainLock" class="headerlink" title="2.5 mainLock"></a>2.5 mainLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>

<p>mainLock是线程池的主锁，是可重入锁，当要操作workers set这个保持线程的HashSet时，需要先获取mainLock，还有当要处理largestPoolSize、completedTaskCount这类统计数据时需要先获取mainLock</p>
<h2 id="2-6-其他重要属性"><a href="#2-6-其他重要属性" class="headerlink" title="2.6 其他重要属性"></a>2.6 其他重要属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br></pre></td></tr></table></figure>

<h1 id="3-核心内部类"><a href="#3-核心内部类" class="headerlink" title="3 核心内部类"></a>3 核心内部类</h1><h2 id="3-1-Worker"><a href="#3-1-Worker" class="headerlink" title="3.1 Worker"></a>3.1 Worker</h2><p>Worker类是线程池中具化一个线程的对象，线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class Worker mainly maintains interrupt control state for</span></span><br><span class="line"><span class="comment">     * threads running tasks, along with other minor bookkeeping.</span></span><br><span class="line"><span class="comment">     * This class opportunistically extends AbstractQueuedSynchronizer</span></span><br><span class="line"><span class="comment">     * to simplify acquiring and releasing a lock surrounding each</span></span><br><span class="line"><span class="comment">     * task execution.  This protects against interrupts that are</span></span><br><span class="line"><span class="comment">     * intended to wake up a worker thread waiting for a task from</span></span><br><span class="line"><span class="comment">     * instead interrupting a task being run.  We implement a simple</span></span><br><span class="line"><span class="comment">     * non-reentrant mutual exclusion lock rather than use</span></span><br><span class="line"><span class="comment">     * ReentrantLock because we do not want worker tasks to be able to</span></span><br><span class="line"><span class="comment">     * reacquire the lock when they invoke pool control methods like</span></span><br><span class="line"><span class="comment">     * setCorePoolSize.  Additionally, to suppress interrupts until</span></span><br><span class="line"><span class="comment">     * the thread actually starts running tasks, we initialize lock</span></span><br><span class="line"><span class="comment">     * state to a negative value, and clear it upon start (in</span></span><br><span class="line"><span class="comment">     * runWorker).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">         * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line">        <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="comment">//设置AQS的同步状态private volatile int state，是一个计数器，大于0代表锁已经被获取</span></span><br><span class="line">            <span class="comment">// 在调用runWorker()前，禁止interrupt中断，在interruptIfStarted()方法中会判断 getState()&gt;=0</span></span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);<span class="comment">//根据当前worker创建一个线程对象</span></span><br><span class="line">            <span class="comment">//当前worker本身就是一个runnable任务，也就是不会用参数的firstTask创建线程，而是调用当前worker.run()时调用firstTask.run()</span></span><br><span class="line">            <span class="comment">//后面在addworker中，我们会启动worker对象中组合的Thread，而我们的执行逻辑runWorker方法是在worker的run方法中被调用。</span></span><br><span class="line">            <span class="comment">//为什么执行thread的run方法会调用worker的run方法呢，原因就是在这里进行了注入，将worker本身this注入到了thread中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;<span class="comment">//runWorker()是ThreadPoolExecutor的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lock methods</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The value 0 represents the unlocked state. 0代表“没被锁定”状态</span></span><br><span class="line">        <span class="comment">// The value 1 represents the locked state. 1代表“锁定”状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试获取锁</span></span><br><span class="line"><span class="comment">         * 重写AQS的tryAcquire()，AQS本来就是让子类来实现的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//尝试一次将state从0设置为1，即“锁定”状态，但由于每次都是state 0-&gt;1，而不是+1，那么说明不可重入</span></span><br><span class="line">            <span class="comment">//且state==-1时也不会获取到锁</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 尝试释放锁</span></span><br><span class="line"><span class="comment">         * 不是state-1，而是置为0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 中断（如果运行）</span></span><br><span class="line"><span class="comment">         * shutdownNow时会循环对worker线程执行</span></span><br><span class="line"><span class="comment">         * 且不需要获取worker锁，即使在worker运行时也可以中断</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="comment">//如果state&gt;=0、t!=null、且t没有被中断</span></span><br><span class="line">            <span class="comment">//new Worker()时state==-1，说明不能中断</span></span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Worker这个工作线程实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；</p>
<p>firstTask用来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2568e2bd076e9580f60c91b0f0430b5704b.png" alt=""></p>
<p>之所以要将thread和firstTask封装成一个Worker，是因为线程池需要利用Worker来实现工作线程的加锁，以及控制中断。</p>
<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中。</li>
<li>如果正在执行任务，则不应该中断线程。</li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。</li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-1d2cd8d142fbec20fc022903572f6a71b33.png" alt=""></p>
<h1 id="4-核心方法"><a href="#4-核心方法" class="headerlink" title="4 核心方法"></a>4 核心方法</h1><p>好了，基本上我们将线程池的几个主角，ctl，workQueue，workers，Worker简单介绍了一遍，现在，我们来看看线程池是怎么玩的。</p>
<h2 id="4-1-线程的运行"><a href="#4-1-线程的运行" class="headerlink" title="4.1 线程的运行"></a>4.1 线程的运行</h2><p>我们先来看一个简单的线程池的运行流程图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bc31566378230a3221224e69c4c758db003.png" alt=""></p>
<h3 id="4-1-1-execute方法"><a href="#4-1-1-execute方法" class="headerlink" title="4.1.1 execute方法"></a>4.1.1 execute方法</h3><p>这是线程池实现类外露供给外部实现提交线程任务command的核心方法，对于无需了解线程池内部的使用者来说，<strong>这个方法就是把某个任务交给线程池，正常情况下，这个任务会在未来某个时刻被执行</strong>，实现和注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment"> * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment"> * * 在未来的某个时刻执行给定的任务。这个任务用一个新线程执行，或者用一个线程池中已经存在的线程执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment"> * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment"> * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment"> * 如果任务无法被提交执行，要么是因为这个Executor已经被shutdown关闭，要么是已经达到其容量上限，任务会被当前的RejectedExecutionHandler处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     * 如果运行的线程少于corePoolSize，尝试开启一个新线程去运行command，command作为这个线程的第一个任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *  如果任务成功放入队列，我们仍需要一个双重校验去确认是否应该新建一个线程（因为可能存在有些线程在我们上次检查后死了）</span></span><br><span class="line"><span class="comment">     *  或者 从我们进入这个方法后，pool被关闭了</span></span><br><span class="line"><span class="comment">     *  所以我们需要再次检查state，如果线程池停止了需要回滚入队列，如果池中没有线程了，新开启一个线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     * 如果无法将任务入队列（可能队列满了），需要新开区一个线程（自己：往maxPoolSize发展）</span></span><br><span class="line"><span class="comment">    * 如果失败了，说明线程池shutdown 或者 饱和了，所以我们拒绝任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 1、如果当前线程数少于corePoolSize（addWorker()操作已经包含对线程池状态的判断，所以此处没判断状态，而入workQueue前判断了）</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//则创建并启动一个线程来执行这个任务</span></span><br><span class="line">        <span class="comment">//第一个参数为command，说明表示新建一个worker线程，指定firstTask初始任务为command</span></span><br><span class="line">        <span class="comment">//第二个参数为true代表占用corePoolSize，false占用maxPoolSize</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果没有成功addWorker()，再次获取c（凡是需要再次用ctl做判断时，都会再次调用ctl.get()）</span></span><br><span class="line"><span class="comment">         * 失败的原因可能是：</span></span><br><span class="line"><span class="comment">         * 1、线程池已经shutdown，shutdown的线程池不再接收新任务</span></span><br><span class="line"><span class="comment">         * 2、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、此时，workerCount &gt;= corePoolSize，任务要加入队列，如果线程池是RUNNING状态，且入队列成功（阻塞队列未满）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再次校验放入workerQueue中的任务是否能被执行。</span></span><br><span class="line"><span class="comment">         * 如果线程池不是运行状态了，应该拒绝添加新任务，从workQueue中删除任务，执行拒绝策略</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//如果再次校验过程中，线程池不是RUNNING状态，那么任务出列，remove(command)--workQueue.remove()成功</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">//执行拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这里，说明线程池是RUNNING状态。</span></span><br><span class="line">        <span class="comment">//如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null</span></span><br><span class="line">        <span class="comment">//为什么只检查运行的worker数量是不是0呢？？ 为什么不和corePoolSize比较呢？？</span></span><br><span class="line">        <span class="comment">//只保证有一个worker线程可以从queue中获取任务执行就行了？？</span></span><br><span class="line">        <span class="comment">//是的，因为只要还有活动的worker线程，就可以消费workerQueue中的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//第一个参数为null，说明只为新建一个worker线程，没有指定firstTask初始任务</span></span><br><span class="line">            <span class="comment">//第二个参数为true代表占用corePoolSize，false占用maxPoolSize</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、如果线程池不是running状态 或者 无法入队列</span></span><br><span class="line"><span class="comment">     *   尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以简单归纳如下：<br><img src="https://oscimg.oschina.net/oscnet/c7f7e9ea8b1c04f7c662794a2f166596e42.jpg" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f31e3c2040c24197558e1c0715928488f63.png" alt=""></p>
<h3 id="4-1-2-addWorker"><a href="#4-1-2-addWorker" class="headerlink" title="4.1.2 addWorker"></a>4.1.2 addWorker</h3><p>在execute方法中，我们看到核心的逻辑是由addWorker方法来实现的，当我们将一个任务提交给线程池，线程池会如何处理，就是主要由这个方法加以规范：</p>
<p><img src="https://oscimg.oschina.net/oscnet/de623c63ae5fbf518b0b43d176165ef28d2.jpg" alt=""></p>
<p>该方法有两个参数：</p>
<ol>
<li>firstTask：    worker线程的初始任务，可以为空</li>
<li>core：       true：将corePoolSize作为上限，false：将maximumPoolSize作为上限  </li>
</ol>
<p>排列组合，addWorker方法有4种传参的方式：  </p>
<ol>
<li>addWorker(command, true)  </li>
<li>addWorker(command, false)  </li>
<li>addWorker(null, false)  </li>
<li>addWorker(null, true)  </li>
</ol>
<p>在execute方法中就使用了前3种，结合这个核心方法进行以下分析  </p>
<ul>
<li>第一个：线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false  </li>
<li>第二个：当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false  </li>
<li>第三个：放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务  </li>
<li>第四个：这个方法就是放一个空的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment"> * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment"> * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment"> * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment"> * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment"> * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment"> * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment"> * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment"> * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment"> * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment"> * 检查根据当前线程池的状态和给定的边界(core or maximum)是否可以创建一个新的worker</span></span><br><span class="line"><span class="comment"> * 如果是这样的话，worker的数量做相应的调整，如果可能的话，创建一个新的worker并启动，参数中的firstTask作为worker的第一个任务</span></span><br><span class="line"><span class="comment"> * 如果方法返回false，可能因为pool已经关闭或者调用过了shutdown</span></span><br><span class="line"><span class="comment"> * 如果线程工厂创建线程失败，也会失败，返回false</span></span><br><span class="line"><span class="comment"> * 如果线程创建失败，要么是因为线程工厂返回null，要么是发生了OutOfMemoryError</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment"> * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment"> * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment"> * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment"> * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment"> * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment"> * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//外层循环，负责判断线程池状态</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程池的state越小越是运行状态，runnbale=-1，shutdown=0,stop=1,tidying=2，terminated=3</span></span><br><span class="line"><span class="comment">         * 要想这个if为true，线程池state必须已经至少是shutdown状态了</span></span><br><span class="line"><span class="comment">         * 这时候以下3个条件任意一个是false都会进入if语句，即无法addWorker()：</span></span><br><span class="line"><span class="comment">         *   1，rs == SHUTDOWN         （隐含：rs&gt;=SHUTDOWN）false情况： 线程池状态已经超过shutdown，</span></span><br><span class="line"><span class="comment">         *                               可能是stop、tidying、terminated其中一个，即线程池已经终止</span></span><br><span class="line"><span class="comment">         *  2，firstTask == null      （隐含：rs==SHUTDOWN）false情况： firstTask不为空，rs==SHUTDOWN 且 firstTask不为空，</span></span><br><span class="line"><span class="comment">         *                               return false，场景是在线程池已经shutdown后，还要添加新的任务，拒绝</span></span><br><span class="line"><span class="comment">         *  3，! workQueue.isEmpty()  （隐含：rs==SHUTDOWN，firstTask==null）false情况： workQueue为空，</span></span><br><span class="line"><span class="comment">         *                               当firstTask为空时是为了创建一个没有任务的线程，再从workQueue中获取任务，</span></span><br><span class="line"><span class="comment">         *                               如果workQueue已经为空，那么就没有添加新worker线程的必要了</span></span><br><span class="line"><span class="comment">         * return false，</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//内层循环，负责worker数量+1</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//入参core在这里起作用，表示加入的worker是加入corePool还是非corepool，换句话说，受到哪个size的约束</span></span><br><span class="line">            <span class="comment">//如果worker数量&gt;线程池最大上限CAPACITY（即使用int低29位可以容纳的最大值）</span></span><br><span class="line">            <span class="comment">//或者( worker数量&gt;corePoolSize 或  worker数量&gt;maximumPoolSize )，即已经超过了给定的边界,不添加worker</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//CAS尝试增加线程数，,如果成功加了wc，那么break跳出检查</span></span><br><span class="line">            <span class="comment">//如果失败，证明有竞争，那么重新到retry。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">//如果不成功，重新获取状态继续检查</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">//如果状态不等于之前获取的state，跳出内层循环，继续去外层循环判断</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            <span class="comment">// else CAS失败时因为workerCount改变了，继续内层循环尝试CAS对worker数量+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//worker数量+1成功的后续操作</span></span><br><span class="line">     <span class="comment">// 添加到workers Set集合，并启动worker线程</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//新建worker//构造方法做了三件事//1、设置worker这个AQS锁的同步状态state=-1</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);  <span class="comment">//2、将firstTask设置给worker的成员变量firstTask</span></span><br><span class="line">                                    <span class="comment">//3、使用worker自身这个runnable，调用ThreadFactory创建一个线程，并设置给worker的成员变量thread</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取重入锁，并且锁上</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                 <span class="comment">// rs!=SHUTDOWN ||firstTask!=null</span></span><br><span class="line">                 <span class="comment">// 如果线程池在运行running&lt;shutdown 或者</span></span><br><span class="line">                 <span class="comment">// 线程池已经shutdown，且firstTask==null（可能是workQueue中仍有未执行完成的任务，创建没有初始任务的worker线程执行）</span></span><br><span class="line">                 <span class="comment">// worker数量-1的操作在最后的addWorkerFailed()</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// // precheck that t is startable   线程已经启动，抛非法线程状态异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">//设置最大的池大小largestPoolSize，workerAdded设置为true</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;<span class="comment">//如果往HashSet中添加worker成功，启动线程</span></span><br><span class="line">                <span class="comment">//通过t.start()方法正式执行线程。在这里一个线程才算是真正的执行起来了。</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果启动线程失败</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，我们可以归纳一下：<br><img src="https://oscimg.oschina.net/oscnet/55b3f4a3ea7eacc4dfddbba6628e0ade821.jpg" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2531c740cfac915d6519893a542b3b1c073.png" alt=""></p>
<h3 id="4-1-3-runWorker-方法"><a href="#4-1-3-runWorker-方法" class="headerlink" title="4.1.3 runWorker 方法"></a>4.1.3 runWorker 方法</h3><p>在addWorker方法中，我们将一个新增进去的worker所组合的线程属性thread启动了，但我们知道，在worker的构造方法中，它将自己本身注入到了thread的target属性里，所以绕了一圈，线程启动后，调用的还是worker的run方法，而在这里面，runWorker定义了线程执行的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main worker run loop.  Repeatedly gets tasks from queue and</span></span><br><span class="line"><span class="comment">     * executes them, while coping with a number of issues:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. We may start out with an initial task, in which case we</span></span><br><span class="line"><span class="comment">     * don't need to get the first one. Otherwise, as long as pool is</span></span><br><span class="line"><span class="comment">     * running, we get tasks from getTask. If it returns null then the</span></span><br><span class="line"><span class="comment">     * worker exits due to changed pool state or configuration</span></span><br><span class="line"><span class="comment">     * parameters.  Other exits result from exception throws in</span></span><br><span class="line"><span class="comment">     * external code, in which case completedAbruptly holds, which</span></span><br><span class="line"><span class="comment">     * usually leads processWorkerExit to replace this thread.</span></span><br><span class="line"><span class="comment">     * 我们可能使用一个初始化任务开始，即firstTask为null</span></span><br><span class="line"><span class="comment">     * 然后只要线程池在运行，我们就从getTask()获取任务</span></span><br><span class="line"><span class="comment">     * 如果getTask()返回null，则worker由于改变了线程池状态或参数配置而退出</span></span><br><span class="line"><span class="comment">     * 其它退出因为外部代码抛异常了，这会使得completedAbruptly为true，这会导致在processWorkerExit()方法中替换当前线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. Before running any task, the lock is acquired to prevent</span></span><br><span class="line"><span class="comment">     * other pool interrupts while the task is executing, and then we</span></span><br><span class="line"><span class="comment">     * ensure that unless pool is stopping, this thread does not have</span></span><br><span class="line"><span class="comment">     * its interrupt set.</span></span><br><span class="line"><span class="comment">     * 在任何任务执行之前，都需要对worker加锁去防止在任务运行时，其它的线程池中断操作</span></span><br><span class="line"><span class="comment">     * clearInterruptsForTaskRun保证除非线程池正在stoping，线程不会被设置中断标示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. Each task run is preceded by a call to beforeExecute, which</span></span><br><span class="line"><span class="comment">     * might throw an exception, in which case we cause thread to die</span></span><br><span class="line"><span class="comment">     * (breaking loop with completedAbruptly true) without processing</span></span><br><span class="line"><span class="comment">     * the task.</span></span><br><span class="line"><span class="comment">     * 每个任务执行前会调用beforeExecute()，其中可能抛出一个异常，这种情况下会导致线程die（跳出循环，且completedAbruptly==true），没有执行任务</span></span><br><span class="line"><span class="comment">     * 因为beforeExecute()的异常没有cache住，会上抛，跳出循环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 4. Assuming beforeExecute completes normally, we run the task,</span></span><br><span class="line"><span class="comment">     * gathering any of its thrown exceptions to send to afterExecute.</span></span><br><span class="line"><span class="comment">     * We separately handle RuntimeException, Error (both of which the</span></span><br><span class="line"><span class="comment">     * specs guarantee that we trap) and arbitrary Throwables.</span></span><br><span class="line"><span class="comment">     * Because we cannot rethrow Throwables within Runnable.run, we</span></span><br><span class="line"><span class="comment">     * wrap them within Errors on the way out (to the thread's</span></span><br><span class="line"><span class="comment">     * UncaughtExceptionHandler).  Any thrown exception also</span></span><br><span class="line"><span class="comment">     * conservatively causes thread to die.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 5. After task.run completes, we call afterExecute, which may</span></span><br><span class="line"><span class="comment">     * also throw an exception, which will also cause thread to</span></span><br><span class="line"><span class="comment">     * die. According to JLS Sec 14.20, this exception is the one that</span></span><br><span class="line"><span class="comment">     * will be in effect even if task.run throws.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The net effect of the exception mechanics is that afterExecute</span></span><br><span class="line"><span class="comment">     * and the thread's UncaughtExceptionHandler have as accurate</span></span><br><span class="line"><span class="comment">     * information as we can provide about any problems encountered by</span></span><br><span class="line"><span class="comment">     * user code.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">//标识线程是不是异常终止的</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//task不为null的情况一般是线程数小于核心数时，如果task为null，则去队列中取任务---&gt;getTask()</span></span><br><span class="line">        <span class="comment">//可以看到，只要getTask方法被调用且返回null，那么worker必定被销毁，因为一旦while进不去，就会执行processWorkerExit方法，销毁线程。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//而确定一个线程能否获取得到task的逻辑，在getTask方法中</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程开始执行之前执行此方法，可以实现Worker未执行退出，本类中未实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();<span class="comment">//runWorker方法最本质的存在意义，就是调用task的run方法</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//线程执行后执行，可以实现标识Worker异常中断的功能，本类中未实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;<span class="comment">//运行过的task标null</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标识线程不是异常终止的,是因为不满足while条件，被迫销毁的</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//处理worker退出的逻辑</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们归纳：<br><img src="https://oscimg.oschina.net/oscnet/eb572be61e780fff0d6af69d42a832ef41b.jpg" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-22e07ae564c67b11875b27b5b0cb6fa422e.png" alt=""></p>
<h3 id="4-1-4-getTask方法"><a href="#4-1-4-getTask方法" class="headerlink" title="4.1.4 getTask方法"></a>4.1.4 getTask方法</h3><p>runWorker方法中的getTask()方法是线程处理完一个任务后，从队列中获取新任务的实现，也是处理判断一个线程是否应该被销毁的逻辑所在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment"> * current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment"> * must exit because of any of:  以下情况会返回null</span></span><br><span class="line"><span class="comment"> * 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment"> *    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment"> *    超过了maximumPoolSize设置的线程数量（因为调用了setMaximumPoolSize()）</span></span><br><span class="line"><span class="comment"> * 2. The pool is stopped.</span></span><br><span class="line"><span class="comment"> *    线程池被stop</span></span><br><span class="line"><span class="comment"> * 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment"> *    线程池被shutdown，并且workQueue空了</span></span><br><span class="line"><span class="comment"> * 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment"> *    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment"> *    both before and after the timed wait.</span></span><br><span class="line"><span class="comment"> *    线程等待任务超时</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment"> *         workerCount is decremented</span></span><br><span class="line"><span class="comment"> *         返回null表示这个worker要结束了，这种情况下workerCount-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// timedOut 主要是判断后面的poll是否要超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于判断线程池状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 对线程池状态的判断，两种情况会workerCount-1，并且返回null</span></span><br><span class="line"><span class="comment">         * 1，线程池状态为shutdown，且workQueue为空（反映了shutdown状态的线程池还是要执行workQueue中剩余的任务的）</span></span><br><span class="line"><span class="comment">         * 2，线程池状态为&gt;=stop（只有TIDYING和TERMINATED会大于stop）（shutdownNow()会导致变成STOP）（此时不用考虑workQueue的情况）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();<span class="comment">//循环的CAS减少worker数量，直到成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//allowCoreThreadTimeOut字段，表示是否允许核心线程超过闲置时间后被摧毁，默认为false</span></span><br><span class="line">        <span class="comment">//我们前面说过，如果getTask方法返回null，那么这个worker只有被销毁一途</span></span><br><span class="line">        <span class="comment">//于是这个timed有3种情况</span></span><br><span class="line">        <span class="comment">//(1)当线程数没有超过核心线程数，且默认allowCoreThreadTimeOut为false时</span></span><br><span class="line">        <span class="comment">//          timed值为false。看下面if的判断逻辑，除非目前线程数大于最大值,否则下面的if始终进不去，该方法不可能返回null，worker也就不会被销毁。</span></span><br><span class="line">        <span class="comment">//          因为前提"线程数不超过核心线程数"与"线程数大于最大值"两个命题互斥，所以（1）情况，逻辑进入下面的if（返回null的线程销毁逻辑）的可能性不存在。</span></span><br><span class="line">        <span class="comment">//          也就是说，当线程数没有超过核心线程数时，线程不会被销毁。</span></span><br><span class="line">        <span class="comment">//(2)当当前线程数超过核心线程数，且默认allowCoreThreadTimeOut为false时</span></span><br><span class="line">        <span class="comment">//          timed值为true。</span></span><br><span class="line">        <span class="comment">//(3)如果allowCoreThreadTimeOut为true，则timed始终为true</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wc &gt; maximumPoolSize则必销毁，因为这情况下，wc&gt;1也肯定为true</span></span><br><span class="line">        <span class="comment">//wc &lt;= maximumPoolSize,且(timed &amp;&amp; timedOut) = true，这种情况下一般也意味着worker要被销毁，因为超时一般是由阻塞队列为空造成的，所以workQueue.isEmpty()也大概率为真，进入if逻辑。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//一般情况是这样，那不一般的情况呢？阻塞队列没有为空，但是因为一些原因，还是超时了，这时候取决于wc &gt; 1，它为真就销毁，为假就不销毁。</span></span><br><span class="line">        <span class="comment">// 也就是说，如果阻塞队列还有任务，但是wc=1，线程池里只剩下自己这个线程了，那么就不能销毁,这个if不满足，我们的代码继续往下走</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果timed为true那么使用poll取线程。否则使用take()</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                <span class="comment">//workQueue.poll()：如果在keepAliveTime时间内，阻塞队列还是没有任务，返回null</span></span><br><span class="line">                workQueue.take();</span><br><span class="line">                <span class="comment">//workQueue.take()：如果阻塞队列为空，当前线程会被挂起等待；当队列中有任务加入时，线程被唤醒，take方法返回任务</span></span><br><span class="line">            <span class="comment">//如果正常返回，那么返回取到的task。</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">//否则，设为超时，重新执行循环,</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">        <span class="comment">//当线程阻塞在从workQueue中获取任务时，可以被interrupt()中断，代码中捕获了InterruptedException，重置timedOut为初始值false，再次执行第1步中的判断，满足就继续获取任务，不满足return null，会进入worker退出的流程</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>归纳：<br><img src="https://oscimg.oschina.net/oscnet/a398f6d2a65424c1aa570c76cabaf381209.jpg" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c6974734b449431bbae8e223fc6ec434ea4.png" alt=""></p>
<h3 id="4-1-5-processWorkerExit方法"><a href="#4-1-5-processWorkerExit方法" class="headerlink" title="4.1.5 processWorkerExit方法"></a>4.1.5 processWorkerExit方法</h3><p>在runWorker方法中，我们看到当不满足while条件后，线程池会执行退出线程的操作，这个操作，就封装在processWorkerExit方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs cleanup and bookkeeping for a dying worker. Called</span></span><br><span class="line"><span class="comment"> * only from worker threads. Unless completedAbruptly is set,</span></span><br><span class="line"><span class="comment"> * assumes that workerCount has already been adjusted to account</span></span><br><span class="line"><span class="comment"> * for exit.  This method removes thread from worker set, and</span></span><br><span class="line"><span class="comment"> * possibly terminates the pool or replaces the worker if either</span></span><br><span class="line"><span class="comment"> * it exited due to user task exception or if fewer than</span></span><br><span class="line"><span class="comment"> * corePoolSize workers are running or queue is non-empty but</span></span><br><span class="line"><span class="comment"> * there are no workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> completedAbruptly if the worker died due to user exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//参数：</span></span><br><span class="line">        <span class="comment">//worker：                      要结束的worker</span></span><br><span class="line">        <span class="comment">//completedAbruptly： 是否突然完成（是否因为异常退出）</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、worker数量-1</span></span><br><span class="line"><span class="comment">     * 如果是突然终止，说明是task执行时异常情况导致，即run()方法执行时发生了异常，那么正在工作的worker线程数量需要-1</span></span><br><span class="line"><span class="comment">     * 如果不是突然终止，说明是worker线程没有task可执行了，不用-1，因为已经在getTask()方法中-1了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted 代码和注释正好相反啊</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、从Workers Set中移除worker</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks; <span class="comment">//把worker的完成任务数加到线程池的完成任务数</span></span><br><span class="line">        workers.remove(w); <span class="comment">//从HashSet&lt;Worker&gt;中移除</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、在对线程池有负效益的操作时，都需要“尝试终止”线程池</span></span><br><span class="line"><span class="comment">     * 主要是判断线程池是否满足终止的状态</span></span><br><span class="line"><span class="comment">     * 如果状态满足，但线程池还有线程，尝试对其发出中断响应，使其能进入退出流程</span></span><br><span class="line"><span class="comment">     * 没有线程了，更新状态为tidying-&gt;terminated</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、是否需要增加worker线程</span></span><br><span class="line"><span class="comment">     * 线程池状态是running 或 shutdown</span></span><br><span class="line"><span class="comment">     * 如果当前线程是突然终止的，addWorker()</span></span><br><span class="line"><span class="comment">     * 如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()</span></span><br><span class="line"><span class="comment">     * 故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//如果状态是running、shutdown，即tryTerminate()没有成功终止线程池，尝试再添加一个worker</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">//不是突然完成的，即没有task任务可以获取而完成的，计算min，并根据当前worker数量判断是否需要addWorker()</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize; <span class="comment">//allowCoreThreadTimeOut默认为false，即min默认为corePoolSize</span></span><br><span class="line">             </span><br><span class="line">            <span class="comment">//如果min为0，即不需要维持核心线程数量，且workQueue不为空，至少保持一个线程</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//如果线程数量大于最少数量，直接返回，否则下面至少要addWorker一个</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//添加一个没有firstTask的worker</span></span><br><span class="line">        <span class="comment">//只要worker是completedAbruptly突然终止的，或者线程数量小于要维护的数量，就新添一个worker线程，即使是shutdown状态</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总而言之：如果线程池还没有完全终止，就仍需要保持一定数量的线程。  </p>
<p>线程池状态是running 或 shutdown的情况下：  </p>
<ul>
<li>如果当前线程是突然终止的，addWorker()</li>
<li>如果当前线程不是突然终止的，但当前线程数量 &lt; 要维护的线程数量，addWorker()  </li>
</ul>
<p>故如果调用线程池shutdown()，直到workQueue为空前，线程池都会维持corePoolSize个线程，然后再逐渐销毁这corePoolSize个线程。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c7a13a999c99e52700c91ca5a5cdc968baa.png" alt=""></p>
<hr>
<h3 id="4-1-6-submit方法"><a href="#4-1-6-submit方法" class="headerlink" title="4.1.6 submit方法"></a>4.1.6 submit方法</h3><p>前面我们讲过execute方法，其作用是将一个任务提交给线程池，以期在未来的某个时间点被执行。  </p>
<p>submit方法在作用上，和execute方法是一样的，将某个任务提交给线程池，让线程池调度线程去执行它。  </p>
<p>那么它和execute方法有什么区别呢？我们来看看submit方法的源码：<br>submit方法的实现在ThreadPoolExecutor的父类AbstractExecutorService类中，有三种重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该Future的get方法在成功完成时将会返回null。</span></span><br><span class="line"><span class="comment">     * submit 参数： task - 要提交的任务 返回：表示任务等待完成的 Future</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。</span></span><br><span class="line"><span class="comment">     * submit 参数： task - 要提交的任务 result - 完成任务时要求返回的结果 </span></span><br><span class="line"><span class="comment">     * 返回： 表示任务等待完成的 Future</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个Callable的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get </span></span><br><span class="line"><span class="comment">方法在成功完成时将会返回该任务的结果。 </span></span><br><span class="line"><span class="comment">     * 如果想立即阻塞任务的等待，则可以使用 result = </span></span><br><span class="line"><span class="comment">exec.submit(aCallable).get(); 形式的构造。</span></span><br><span class="line"><span class="comment">     * 参数： task - 要提交的任务 返回： 表示任务等待完成的Future</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>源码很简单，submit方法，将任务task封装成FutureTask(newTaskFor方法中就是new了一个FutureTask)，然后调用execute。<strong>所以submit方法和execute的所有区别，都在这FutureTask所带来的差异化实现上</strong>。  </p>
<p>总而言之，submit方法将一个任务task用future模式封装成FutureTask对象，提交给线程执行，并将这个FutureTask对象返回，以供<strong>主线程</strong>在<strong>该任务被线程池执行之后</strong>得到<strong>执行结果</strong>。  </p>
<p>注意，获得执行结果的方法FutureTask.get()，会阻塞执行该方法的线程，尤其是当任务被DiscardPolicy策略和DiscardOldestPolicy拒绝的时候，get方法会一直阻塞在那里，所以我们最好使用自带超时时间的future。</p>
<h2 id="4-2-线程池的关闭"><a href="#4-2-线程池的关闭" class="headerlink" title="4.2 线程池的关闭"></a>4.2 线程池的关闭</h2><h3 id="4-2-1-shutdown方法"><a href="#4-2-1-shutdown方法" class="headerlink" title="4.2.1 shutdown方法"></a>4.2.1 shutdown方法</h3><p>讲完了线程池的基本运转过程，在方法章的最后，我们来看看负责线程池生命周期最后收尾工作的几个重要方法，首先是shutdown方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment">     * tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment">     * Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment">     * complete execution.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125;</span></span><br><span class="line"><span class="comment">     * to do that.</span></span><br><span class="line"><span class="comment">     * 开始一个顺序的shutdown操作，shutdown之前被执行的已提交任务，新的任务不会再被接收了。如果线程池已经被shutdown了，该方法的调用没有其他任何效果了。</span></span><br><span class="line"><span class="comment">     * **该方法不会等待之前已经提交的任务执行完毕**，awaitTermination方法才有这个效果。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//判断是否可以操作关闭目标线程。</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//advanceRunState方法，参数：目标状态；作用：一直执行，直到成功利用CAS将状态置为目标值。            </span></span><br><span class="line">            <span class="comment">//设置线程池状态为SHUTDOWN,此处之后，线程池中不会增加新Task</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">//中断所有的空闲线程</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试进行terminate操作，但其实我们上面将状态置为shutdown，就已经算是“中止”了一个线程池了，它不会再执行任务，于外部而言，已经失去了作用。而这里，也只是尝试去将线程池的状态一撸到底而已，并不是一定要terminate掉。该方法我们后面会说到。</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，shutdown方法只不过是中断唤醒了所有阻塞的线程，并且把线程池状态置为shutdown，正如注释所说的，它没有等待所有正在执行任务的线程执行完任务，把状态置为shutdown，已经足够线程池丧失基本的功能了。 </p>
<p>在该方法中，线程池如何中断线程是我们最需要关心的，我们来看一下interruptIdleWorkers方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;<span class="comment">//参数onlyOne表示是否只中断一个线程就退出，在shutdown中该值为false。</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//遍历workers 对所有worker做中断处理。</span></span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="comment">// w.tryLock()对Worker获取锁，因为正在执行的worker已经加锁了(见runWorker方法，w.lock()语句)</span></span><br><span class="line">                <span class="comment">//所以这保证了正在运行执行Task的Worker不会被中断。只有阻塞在getTask方法的空闲线程才会进这个if判断（被中断），但中断不代表线程立刻停止，它要继续处理到阻塞队列为空时才会被销毁。</span></span><br><span class="line">                <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在中断方法中，我们调用了worker的tryLock方法去尝试获取worker的锁，<strong>所以我们说，worker类这一层的封装，是用来控制线程中断的</strong>，正在执行任务的线程已经上了锁，无法被中断，只有在获取阻塞队列中的任务的线程（我们称为空闲线程）才会有被中断的可能。  </p>
<p>之前我们看过getTask方法，在这个方法中， worker是不加锁的，所以可以被中断。我们为什么说“中断不代表线程立刻停止，它要继续处理到阻塞队列为空时才会被销毁”呢？具体逻辑，我们再来看一下getTask的源码，以及我们的注释（我们模拟中断发生时的场景）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 当执行过程中抛出InterruptedException 的时候，该异常被catch住，逻辑重新回到这个for循环</span></span><br><span class="line"><span class="comment">         * catch块在getTask方法的最后。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 因为逻辑是在抛出中断异常后来到这里的，那说明线程池的状态已经在shutdown方法中被置为shutdown了，rs &gt;= SHUTDOWN为true，rs &gt;=STOP为false(只有TIDYING和TERMINATED状态会大于stop)</span></span><br><span class="line"><span class="comment">             * 这时候，如果workQueue为空，判断为真，线程被销毁。</span></span><br><span class="line"><span class="comment">             * 否则，workQueue为非空，判断为假，线程不会进入销毁逻辑。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();<span class="comment">//循环的CAS减少worker数量，直到成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//因为在catch块中，timeOut已经为false了。</span></span><br><span class="line">            <span class="comment">//所以只要不发生当前线程数超过最大线程数这种极端情况，命题(wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)一定为false，线程依旧不被销毁。</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//继续执行正常的从阻塞队列中取任务的逻辑，直到阻塞队列彻底为空，这时候，上面第一个if判断符合，线程被销毁，寿命彻底结束。</span></span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="comment">//如果正常返回，那么返回取到的task。</span></span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                <span class="comment">//否则，设为超时，重新执行循环,</span></span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                <span class="comment">//捕获中断异常</span></span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总结：<strong>正阻塞在getTask()获取任务的worker在被中断后，会抛出InterruptedException，不再阻塞获取任务。捕获中断异常后，将继续循环到getTask()最开始的判断线程池状态的逻辑，当线程池是shutdown状态，且workQueue.isEmpty时，return null，进行worker线程退出逻辑</strong>。</p>
<p>所以，这就是我们为什么说，shutdown方法不会立刻停止线程池，它的作用是阻止新的任务被添加进来（逻辑在addWorker方法的第一个if判断中，可以返回去看一下），并且继续处理完剩下的任务，然后tryTerminated，尝试关闭。</p>
<h3 id="4-2-2-tryTerminate方法"><a href="#4-2-2-tryTerminate方法" class="headerlink" title="4.2.2 tryTerminate方法"></a>4.2.2 tryTerminate方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span></span><br><span class="line"><span class="comment"> * and queue empty) or (STOP and pool empty).  If otherwise</span></span><br><span class="line"><span class="comment"> * eligible to terminate but workerCount is nonzero, interrupts an</span></span><br><span class="line"><span class="comment"> * idle worker to ensure that shutdown signals propagate. This</span></span><br><span class="line"><span class="comment"> * method must be called following any action that might make</span></span><br><span class="line"><span class="comment"> * termination possible -- reducing worker count or removing tasks</span></span><br><span class="line"><span class="comment"> * from the queue during shutdown. The method is non-private to</span></span><br><span class="line"><span class="comment"> * allow access from ScheduledThreadPoolExecutor.</span></span><br><span class="line"><span class="comment"> * 在以下情况将线程池变为TERMINATED终止状态</span></span><br><span class="line"><span class="comment"> * shutdown 且 正在运行的worker 和 workQueue队列 都empty</span></span><br><span class="line"><span class="comment"> * stop 且  没有正在运行的worker</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个方法必须在任何可能导致线程池终止的情况下被调用，如：</span></span><br><span class="line"><span class="comment"> * 减少worker数量</span></span><br><span class="line"><span class="comment"> * shutdown时从queue中移除任务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这个方法不是私有的，所以允许子类ScheduledThreadPoolExecutor调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程池是否需要终止</span></span><br><span class="line"><span class="comment">         * 如果以下3中情况任一为true，return，不进行终止</span></span><br><span class="line"><span class="comment">         * 1、还在运行状态</span></span><br><span class="line"><span class="comment">         * 2、状态是TIDYING、或 TERMINATED，已经终止过了</span></span><br><span class="line"><span class="comment">         * 3、SHUTDOWN 且 workQueue不为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 只有shutdown状态 且 workQueue为空，或者 stop状态能执行到这一步</span></span><br><span class="line"><span class="comment">             * 如果此时线程池还有线程（正在运行任务或正在等待任务，总之count不等于0）</span></span><br><span class="line"><span class="comment">             * 中断唤醒一个正在等任务的空闲worker</span></span><br><span class="line"><span class="comment">             *（中断唤醒的意思就是让阻塞在阻塞队列中的worker抛出异常，然后重新判断状态，getTask方法逻辑）</span></span><br><span class="line"><span class="comment">             * 线程被唤醒后再次判断线程池状态，会return null，进入processWorkerExit()流程（runWorker逻辑）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);<span class="comment">//中断workers集合中的空闲任务，参数为true，只中断一个。（该逻辑的意义应该在于通知被阻塞在队列中的线程：别瞎jb等了，这个线程池都要倒闭了，赶紧收拾铺盖准备销毁吧你个逼玩意儿）。</span></span><br><span class="line">            <span class="comment">//尝试终止失败，返回。可能大家会有疑问，shutdown只调用了一次tryTerminate方法，如果一次尝试失败了，是不是就意味着shutdown方法很可能最终无法终止线程池？</span></span><br><span class="line">            <span class="comment">//其实看注释，我们知道线程池在进行所有负面效益的操作时都会调用该方法尝试终止，上面我们中断了一个阻塞线程让他被销毁，他销毁时也会尝试终止（这其中又唤醒了一个阻塞线程去销毁），以此类推，直到最后一个线程执行tryTerminate时，逻辑才有可能走到下面去。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果状态是SHUTDOWN，workQueue也为空了，正在运行的worker也没有了，开始terminated</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//CAS：将线程池的ctl变成TIDYING（所有的任务被终止，workCount为0，为此状态时将会调用terminated()方法），期间ctl有变化就会失败，会再次for循环</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//方法为空，需子类实现</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//将状态置为TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">//最后执行termination.signalAll()，并唤醒所有等待线程池终止这个Condition的线程（也就是调用了awaitTermination方法的线程，这个方法的作用是阻塞调用它的线程，直到调用该方法的线程池真的已经被终止了。）</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下：tryTerminate被调用的时机主要有：  </p>
<ol>
<li>shutdown方法时</li>
<li>processWorkerExit方法销毁一个线程时</li>
<li>addWorkerFailed方法添加线程失败或启动线程失败时</li>
<li>remove方法，从阻塞队列中删掉一个任务时</li>
</ol>
<h3 id="4-2-3-shutdownNow方法"><a href="#4-2-3-shutdownNow方法" class="headerlink" title="4.2.3 shutdownNow方法"></a>4.2.3 shutdownNow方法</h3><p>我们知道，shutdown后线程池将变成shutdown状态，此时不接收新任务，但会处理完正在运行的 和 在阻塞队列中等待处理的任务。</p>
<p>我们接下来要说的shutdownNow方法，作用是：shutdownNow后线程池将变成stop状态，此时不接收新任务，不再处理在阻塞队列中等待的任务，还会尝试中断正在处理中的工作线程。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment"> * processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment"> * that were awaiting execution. These tasks are drained (removed)</span></span><br><span class="line"><span class="comment"> * from the task queue upon return from this method.</span></span><br><span class="line"><span class="comment"> * 尝试停止所有活动的正在执行的任务，停止等待任务的处理，并返回正在等待被执行的任务列表</span></span><br><span class="line"><span class="comment"> * 这个任务列表是从任务队列中排出（删除）的</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment"> * terminate.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125; to</span></span><br><span class="line"><span class="comment"> * do that.</span></span><br><span class="line"><span class="comment"> * 这个方法不用等到正在执行的任务结束，要等待线程池终止可使用awaitTermination()</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment"> * processing actively executing tasks.  This implementation</span></span><br><span class="line"><span class="comment"> * cancels tasks via &#123;<span class="doctag">@link</span> Thread#interrupt&#125;, so any task that</span></span><br><span class="line"><span class="comment"> * fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment"> * 除了尽力尝试停止运行中的任务，没有任何保证</span></span><br><span class="line"><span class="comment"> * 取消任务是通过Thread.interrupt()实现的，所以任何响应中断失败的任务可能永远不会结束</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SecurityException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//判断调用者是否有权限shutdown线程池</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//CAS+循环设置线程池状态为stop</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//中断所有线程，包括正在运行任务的</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//将workQueue中的元素放入一个List并返回</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="comment">//返回workQueue中未执行的任务</span></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interruptWorkers 很简单，循环对所有worker调用 interruptIfStarted，其中会判断worker的AQS state是否大于0，即worker是否已经开始运作，再调用Thread.interrupt</p>
<p>需要注意的是，对于运行中的线程调用Thread.interrupt并不能保证线程被终止，task.run内部可能捕获了InterruptException，没有上抛，导致线程一直无法结束</p>
<h3 id="4-2-4-awaitTermination方法"><a href="#4-2-4-awaitTermination方法" class="headerlink" title="4.2.4 awaitTermination方法"></a>4.2.4 awaitTermination方法</h3><p>该方法的作用是等待线程池终止，参数是timeout：超时时间和unit：     timeout超时时间的单位，返回结果：true：线程池终止，false：超过timeout指定时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//是否terminated终止</span></span><br><span class="line">                <span class="keyword">if</span> (runStateAtLeast(ctl.get(), TERMINATED))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                 <span class="comment">//是否已经超过超时时间</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 <span class="comment">//核心逻辑：看注释我们能知道，该方法让调用线程等待一段时间，直到被唤醒（有且仅有之前我们说过的tryTerminate方法中的 termination.signalAll()），或者被异常中断，或者传入了nanos时间参数流逝完。</span></span><br><span class="line">                nanos = termination.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>termination.awaitNanos() 是通过 LockSupport.parkNanos(this, nanosTimeout)实现的阻塞等待</p>
<p>阻塞等待过程中发生以下具体情况会解除阻塞（对上面3种情况的解释）：</p>
<ol>
<li><p>如果发生了 termination.signalAll()（内部实现是 LockSupport.unpark()）会唤醒阻塞等待，且由于ThreadPoolExecutor只有在 tryTerminated()尝试终止线程池成功，将线程池更新为terminated状态后才会signalAll()，故awaitTermination()再次判断状态会return true退出</p>
</li>
<li><p>如果达到了超时时间 termination.awaitNanos() 也会返回，此时nano==0，再次循环判断return false，等待线程池终止失败</p>
</li>
<li><p>如果当前线程被 Thread.interrupt()，termination.awaitNanos()会上抛InterruptException，awaitTermination()继续上抛给调用线程，会以异常的形式解除阻塞</p>
</li>
</ol>
<p>综上，要想优雅的关闭线程池，我们应该：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">executorService.shutdown();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!executorService.awaitTermination(<span class="number">500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        LOGGER.debug(<span class="string">"Waiting for terminate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">//中断处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-拒绝策略"><a href="#5-拒绝策略" class="headerlink" title="5 拒绝策略"></a>5 拒绝策略</h1><p>我们最后来看一下线程池构造函数的最后一个参数：RejectedExecutionHandler。</p>
<p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。</p>
<p>拒绝策略是一个接口，其设计如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户可以通过实现这个接口去定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a39c4be2dab8d65fc33381909b46913746d.png" alt=""></p>
<p>四个拒绝策略的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A handler for rejected tasks that runs the rejected task</span></span><br><span class="line"><span class="comment">* directly in the calling thread of the &#123;<span class="doctag">@code</span> execute&#125; method,</span></span><br><span class="line"><span class="comment">* unless the executor has been shut down, in which case the task</span></span><br><span class="line"><span class="comment">* is discarded.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Executes task r in the caller's thread, unless the executor</span></span><br><span class="line"><span class="comment">    * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A handler for rejected tasks that throws a</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> RejectedExecutionException&#125;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                                <span class="string">" rejected from "</span> +</span><br><span class="line">                                                e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A handler for rejected tasks that silently discards the</span></span><br><span class="line"><span class="comment">* rejected task.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class="line"><span class="comment">* request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</span></span><br><span class="line"><span class="comment">* is shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">    * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">    * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">    * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心的rejectedExecution方法，在ThreadPoolExecutor中被reject方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Invokes the rejected execution handler for the given command.</span></span><br><span class="line"><span class="comment">* Package-protected for use by ScheduledThreadPoolExecutor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而reject方法在execute方法中被调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment">   * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment">   * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment">   * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment">   *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment">   *         cannot be accepted for execution</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池已经关闭，并且当前任务成功从队列中移除</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 执行拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 如果添加任务至队列中失败，执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-hand-o-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">100</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">455.8k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
