<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="纸上得来终觉浅，绝知此事要躬行" />










<meta name="description" content="纸上得来终觉浅">
<meta property="og:type" content="website">
<meta property="og:title" content="cherish">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="纸上得来终觉浅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="纸上得来终觉浅，绝知此事要躬行">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/03/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/" itemprop="url">文章导读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-03T22:56:59+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/03/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/12/03/文章导读/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  720
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><ul>
<li><h2 id="JAVA-JVM"><a href="#JAVA-JVM" class="headerlink" title="JAVA  JVM"></a>JAVA  JVM</h2><ul>
<li><a href="https://cherish-ls.github.io/2019/10/17/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener" title="JAVA内存模型">JAVA内存模型</a></li>
<li><a href="https://cherish-ls.github.io/2019/10/23/JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" target="_blank" rel="noopener" title="JAVA内存结构和内存管理">JAVA内存结构和内存管理</a></li>
<li><a href="https://cherish-ls.github.io/2019/11/21/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" target="_blank" rel="noopener" title="JAVA垃圾回收器">JAVA垃圾回收器</a></li>
<li><a href="https://cherish-ls.github.io/2019/12/03/Class%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener" title="Class文件和类加载机制">Class文件和类加载机制</a></li>
<li><a href="https://cherish-ls.github.io/2019/11/25/JAVA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener" title="JAVA对象的创建和内存分配策略">JAVA对象的创建和内存分配策略</a></li>
<li><a href="https://cherish-ls.github.io/2020/05/07/JVM%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B9%8B%E3%80%8E%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E3%80%8F/" target="_blank" rel="noopener" title="JVM学习总结之『一个类的前世今生』">JVM学习总结之『一个类的前世今生』</a></li>
</ul>
</li>
<li><h2 id="线程与并发控制"><a href="#线程与并发控制" class="headerlink" title="线程与并发控制"></a>线程与并发控制</h2><ul>
<li><a href="https://cherish-ls.github.io/2018/03/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-ThreadPoolExecutor/" target="_blank" rel="noopener" title="线程池源码分析——ThreadPoolExecutor">线程池源码分析——ThreadPoolExecutor</a></li>
<li><a href="https://cherish-ls.github.io/2019/08/29/JAVA%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener" title="JAVA中断机制">JAVA中断机制</a></li>
<li><a href="https://cherish-ls.github.io/2019/08/23/JAVA%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener" title="JAVA并发之AQS详解">JAVA并发之AQS详解</a></li>
<li><a href="https://cherish-ls.github.io/2019/09/26/AQS%E5%AE%9E%E7%8E%B0%E4%B9%8BCountDownLatch-Semaphore-CyclicBarrier/" target="_blank" rel="noopener" title="AQS实现之CountDownLatch/Semaphore/CyclicBarrier">AQS实现之CountDownLatch/Semaphore/CyclicBarrier</a></li>
<li><a href="https://cherish-ls.github.io/2019/10/15/synchronized%E5%8E%9F%E7%90%86%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5-%E5%81%8F%E5%90%91-%E8%BD%BB%E9%87%8F%E7%BA%A7-%E9%87%8D%E9%87%8F%E7%BA%A7/" target="_blank" rel="noopener" title="synchronized原理和锁优化策略(偏向/轻量级/重量级)">synchronized原理和锁优化策略(偏向/轻量级/重量级)</a></li>
<li><a href="https://cherish-ls.github.io/2020/08/05/JAVA%E7%9A%84CAS%E5%8F%8A%E5%85%B6ABA%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener" title="JAVA的CAS及其ABA问题">JAVA的CAS及其ABA问题</a></li>
<li><a href="https://cherish-ls.github.io/2020/08/07/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener" title="volatile关键字详解">volatile关键字详解</a></li>
</ul>
</li>
<li><h2 id="JAVA实现或特性"><a href="#JAVA实现或特性" class="headerlink" title="JAVA实现或特性"></a>JAVA实现或特性</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/07/26/JAVA%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener" title="JAVA静态/动态代理">JAVA静态/动态代理</a></li>
<li><a href="https://cherish-ls.github.io/2020/10/14/JAVA%E5%86%85%E7%BD%AE%E6%8E%92%E5%BA%8FArrays-sort%E5%AE%9E%E7%8E%B0%E7%AE%80%E8%BF%B0/" target="_blank" rel="noopener" title="JAVA内置排序Arrays.sort实现简述">JAVA内置排序Arrays.sort实现简述</a></li>
<li><a href="https://cherish-ls.github.io/2021/01/18/JAVA%E4%B8%AD%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener" title="JAVA中浮点型数据的存储方式">JAVA中浮点型数据的存储方式</a></li>
</ul>
</li>
<li><h2 id="JAVA监控和调优"><a href="#JAVA监控和调优" class="headerlink" title="JAVA监控和调优"></a>JAVA监控和调优</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/12/02/JAVA%E7%9B%91%E6%8E%A7%E5%92%8C%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener" title="JAVA监控和调优工具操作指南">JAVA监控和调优工具操作指南</a></li>
<li><a href="https://cherish-ls.github.io/2019/08/27/dump%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E5%92%8C%E5%88%86%E6%9E%90%E6%9F%A5%E7%9C%8B/" target="_blank" rel="noopener" title="dump文件生成和分析查看">dump文件生成和分析查看</a></li>
</ul>
</li>
<li><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><a href="https://cherish-ls.github.io/2021/01/25/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B7%A5%E5%8E%82-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%8D%95%E4%BE%8B-%E5%BB%BA%E9%80%A0%E8%80%85-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener" title="创建型设计模式（工厂/抽象工厂/单例/建造者/原型模式）">创建型设计模式（工厂/抽象工厂/单例/建造者/原型模式）</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><ul>
<li><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/12/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%92%8C%E6%95%B4%E7%90%86/" target="_blank" rel="noopener" title="算法类型分析和汇总">算法类型分析和汇总</a></li>
<li><a href="https://cherish-ls.github.io/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/" target="_blank" rel="noopener" title="动态规划的分析和简述">动态规划的分析和简述</a></li>
<li><a href="https://cherish-ls.github.io/2020/12/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%92%8C%E6%95%B4%E7%90%86/" target="_blank" rel="noopener" title="排序算法汇总和整理">排序算法汇总和整理</a></li>
</ul>
</li>
<li><h2 id="树-堆"><a href="#树-堆" class="headerlink" title="树/堆"></a>树/堆</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/12/07/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" target="_blank" rel="noopener" title="通俗易懂的二叉树的前中后序遍历">通俗易懂的二叉树的前中后序遍历</a></li>
<li><a href="https://cherish-ls.github.io/2020/11/24/%E7%AE%80%E8%BF%B0%E4%BA%8C%E5%8F%89%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" target="_blank" rel="noopener" title="简述二叉堆和优先级队列">简述二叉堆和优先级队列</a></li>
<li><a href="https://cherish-ls.github.io/2020/04/28/B%E6%A0%91-B-%E6%A0%91%E5%88%86%E6%9E%90/" target="_blank" rel="noopener" title="B树/B+树分析">B树/B+树分析</a></li>
</ul>
</li>
<li><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/09/15/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E5%B9%BF%E5%BA%A6-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener" title="【图论】广度/深度优先搜索算法">【图论】广度/深度优先搜索算法</a></li>
<li><a href="https://cherish-ls.github.io/2020/09/15/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener" title="【图论】拓扑排序详解">【图论】拓扑排序详解</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="计算机协议和技术"><a href="#计算机协议和技术" class="headerlink" title="计算机协议和技术"></a>计算机协议和技术</h1><ul>
<li><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/03/17/TCP-IP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%A7%88/" target="_blank" rel="noopener" title="TCP-IP协议学习导览">TCP-IP协议学习导览</a></li>
<li><a href="https://cherish-ls.github.io/2020/03/18/UDP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" target="_blank" rel="noopener" title="UDP协议分析">UDP协议分析</a></li>
<li><a href="https://cherish-ls.github.io/2020/04/08/TCP%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" target="_blank" rel="noopener" title="TCP协议分析">TCP协议分析</a> </li>
</ul>
</li>
<li><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul>
<li><a href="https://cherish-ls.github.io/2021/01/05/%E3%80%90I-O%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%E4%B8%80%E3%80%91%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener" title="【I/O设计总结一】五种I/O模型总结">【I/O设计总结一】五种I/O模型总结</a></li>
<li><a href="https://cherish-ls.github.io/2020/08/13/%E3%80%90IO%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%E4%BA%8C%E3%80%91%E8%AF%A6%E8%A7%A3IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%92%8C%E5%85%B6%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94select-poll-epoll/" target="_blank" rel="noopener" title="【I/O设计总结二】详解IO多路复用和其三种模式——select/poll/epoll">【I/O设计总结二】详解IO多路复用和其三种模式——select/poll/epoll</a></li>
<li><a href="https://cherish-ls.github.io/2021/01/12/%E3%80%90I-O%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%E4%B8%89%E3%80%91%E8%AF%A6%E8%A7%A3Reactor-Proactor%E9%AB%98%E6%80%A7%E8%83%BDIO%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener" title="【I/O设计总结三】详解Reactor/Proactor高性能IO处理模式">【I/O设计总结三】详解Reactor/Proactor高性能IO处理模式</a></li>
<li><a href="https://cherish-ls.github.io/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/" target="_blank" rel="noopener" title="常用shell命令导航">常用shell命令导航</a></li>
<li><a href="https://cherish-ls.github.io/2019/07/17/shell-notes-tips/" target="_blank" rel="noopener" title="shell notes&amp;tips">shell notes&amp;tips</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><ul>
<li><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/05/25/Spring-IoC%E6%A6%82%E5%BF%B5%E5%88%86%E6%9E%90/" target="_blank" rel="noopener" title="Spring-IoC概念分析">Spring-IoC概念分析</a></li>
<li><a href="https://cherish-ls.github.io/2020/06/29/Spring-Resource%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E4%BD%93%E7%B3%BB/" target="_blank" rel="noopener" title="Spring-Resource资源文件体系">Spring-Resource资源文件体系</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><ul>
<li><h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><ul>
<li><a href="https://cherish-ls.github.io/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper%E7%AE%80%E8%AE%BA/" target="_blank" rel="noopener" title="分布式协调服务zookeeper简论">分布式协调服务zookeeper简论</a></li>
</ul>
</li>
<li><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/02/20/ElasticSearch%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3%EF%BC%88index-type-doc-node-shard-replica-segment%EF%BC%89/" target="_blank" rel="noopener" title="ElasticSearch核心概念详解（index/type/doc/node/shard/replica/segment）">ElasticSearch核心概念详解（index/type/doc/node/shard/replica/segment）</a></li>
<li><a href="https://cherish-ls.github.io/2020/02/18/ElasticSearch-Master%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener" title="ElasticSearch Master选举机制浅析">ElasticSearch Master选举机制浅析</a></li>
<li><a href="https://cherish-ls.github.io/2018/08/02/ElasticSearch%E5%8D%87%E7%BA%A7%E8%AE%B0%E5%BD%95-ver-1-4-5%E2%86%92ver-5-2-0/" target="_blank" rel="noopener" title="ElasticSearch升级记录 ver.1.4.5→ver.5.2.0">ElasticSearch升级记录 ver.1.4.5→ver.5.2.0</a></li>
</ul>
</li>
<li><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul>
<li><a href="https://cherish-ls.github.io/2019/12/19/Redis%E7%9A%845%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener" title="Redis的5种数据类型">Redis的5种数据类型</a></li>
<li><a href="https://cherish-ls.github.io/2019/12/19/Redis%E7%9A%848%E7%A7%8D%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener" title="Redis的8种底层数据结构">Redis的8种底层数据结构</a></li>
<li><a href="https://cherish-ls.github.io/2020/01/08/Redis%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%9E%8B-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener" title="Redis事件模型-主从复制-哨兵模型-集群模式">Redis事件模型-主从复制-哨兵模型-集群模式</a></li>
<li><a href="https://cherish-ls.github.io/2019/12/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84-%E9%94%AE%E7%A9%BA%E9%97%B4-%E8%BF%87%E6%9C%9F%E5%AD%97%E5%85%B8-%E4%BA%8B%E5%8A%A1-%E9%94%81-%E6%8C%81%E4%B9%85%E5%8C%96/" target="_blank" rel="noopener" title="Redis数据库结构/键空间/过期字典/事务/锁/持久化">Redis数据库结构/键空间/过期字典/事务/锁/持久化</a></li>
<li><a href="https://cherish-ls.github.io/2020/04/09/Redis%E7%9A%84%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener" title="Redis的缓存雪崩/缓存穿透/缓存预热+布隆过滤器介绍">Redis的缓存雪崩/缓存穿透/缓存预热+布隆过滤器介绍</a></li>
<li><a href="https://cherish-ls.github.io/2020/08/04/Redis%E4%B8%ADLRU%E5%92%8CLFU%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener" title="LRU和LFU算法以及其在Redis中的实现">LRU和LFU算法以及其在Redis中的实现</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h1><ul>
<li><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/05/06/MySQL%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/" target="_blank" rel="noopener" title="MySQL核心要点汇总">MySQL核心要点汇总</a></li>
<li><a href="https://cherish-ls.github.io/2020/09/30/MySQL%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener" title="MySQL日志体系详解">MySQL日志体系详解</a></li>
<li><a href="https://cherish-ls.github.io/2021/01/05/MySQL%E7%9A%84%E5%88%86%E5%8C%BA-%E5%88%86%E5%BA%93-%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener" title="MySQL的分区/分库/分表总结">MySQL的分区/分库/分表总结</a></li>
<li><a href="https://cherish-ls.github.io/2020/08/31/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E4%B8%80%E3%80%91%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84%E5%92%8C%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7/" target="_blank" rel="noopener" title="【InnoDB详解一】体系架构和关键特性">【InnoDB详解一】体系架构和关键特性</a></li>
<li><a href="https://cherish-ls.github.io/2020/09/08/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E4%BA%8C%E3%80%91MySQL%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8CInnoDB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" target="_blank" rel="noopener" title="【InnoDB详解二】MySQL文件系统和InnoDB存储结构">【InnoDB详解二】MySQL文件系统和InnoDB存储结构</a></li>
<li><a href="https://cherish-ls.github.io/2020/09/21/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E4%B8%89%E3%80%91%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1/" target="_blank" rel="noopener" title="【InnoDB详解三】锁和事务">【InnoDB详解三】锁和事务</a></li>
<li><a href="https://cherish-ls.github.io/2020/09/27/%E3%80%90InnoDB%E8%AF%A6%E8%A7%A3%E5%9B%9B%E3%80%91redo-log%E5%92%8Cundo-log/" target="_blank" rel="noopener" title="【InnoDB详解四】redo log和undo log">【InnoDB详解四】redo log和undo log</a></li>
</ul>
</li>
<li><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/05/06/%E7%90%86%E8%A7%A3sql%E4%B8%AD%E7%9A%84group-by%E5%92%8Chaving/" target="_blank" rel="noopener" title="理解sql中的group by和having">理解sql中的group by和having</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="分布式算法-amp-理论"><a href="#分布式算法-amp-理论" class="headerlink" title="分布式算法&amp;理论"></a>分布式算法&amp;理论</h1><ul>
<li><h2 id="分布式事务和数据一致性"><a href="#分布式事务和数据一致性" class="headerlink" title="分布式事务和数据一致性"></a>分布式事务和数据一致性</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener" title="分布式事务的概念论述和方案总结">分布式事务的概念论述和方案总结</a></li>
<li><a href="https://cherish-ls.github.io/2020/01/21/Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" target="_blank" rel="noopener" title="Raft算法分析">Raft算法分析</a></li>
<li><a href="https://cherish-ls.github.io/2019/08/12/paxos%E7%AE%97%E6%B3%95%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%8E%A8%E5%AF%BC/" target="_blank" rel="noopener" title="paxos算法论述和推导">paxos算法论述和推导</a></li>
<li><a href="https://cherish-ls.github.io/2020/07/26/ZAB%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90%E5%92%8CZooKeeper%E7%9A%84leader%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener" title="ZAB协议分析和ZooKeeper的leader选举机制">ZAB协议分析和ZooKeeper的leader选举机制</a></li>
<li><a href="https://cherish-ls.github.io/2021/01/21/%E8%AF%A6%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener" title="详解分布式锁的三种实现方式">详解分布式锁的三种实现方式</a></li>
</ul>
</li>
<li><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><ul>
<li><a href="https://cherish-ls.github.io/2020/07/26/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener" title="一致性hash算法">一致性hash算法</a></li>
</ul>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/25/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B7%A5%E5%8E%82-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%8D%95%E4%BE%8B-%E5%BB%BA%E9%80%A0%E8%80%85-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/25/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B7%A5%E5%8E%82-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%8D%95%E4%BE%8B-%E5%BB%BA%E9%80%A0%E8%80%85-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89/" itemprop="url">创建型设计模式（工厂/抽象工厂/单例/建造者/原型模式）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-25T21:15:49+08:00">
                2021-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/25/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%B7%A5%E5%8E%82-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-%E5%8D%95%E4%BE%8B-%E5%BB%BA%E9%80%A0%E8%80%85-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%EF%BC%89/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/25/创建型设计模式（工厂-抽象工厂-单例-建造者-原型模式）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  4.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>因为设计模式种类多，且重理解重回忆，所以本文尽量言简意赅，便于时时温习。</p>
</blockquote>
<p>设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</p>
<p>1995年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了23种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-7e246957115eb6c13d3ceee5e73a5ade884.png" alt=""></p>
<p>这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。</p>
<p>当然，软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择：<br>对于简单的程序，可能写一个简单的算法要比引入某种设计模式更加容易；<br>但是对于大型项目开发或者框架设计，用设计模式来组织代码显然更好。</p>
<blockquote>
<p>我们要清楚，设计模式并不是Java的专利，它同样适用于C++、C#、JavaScript等其它面向对象的编程语言。</p>
</blockquote>
<h2 id="根据目的来分类"><a href="#根据目的来分类" class="headerlink" title="根据目的来分类"></a>根据目的来分类</h2><p>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式3种。</p>
<p><strong>创建型模式</strong>：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。<br>    GoF中提供了单例、原型、工厂方法、抽象工厂、建造者等5种创建型模式。<br><strong>结构型模式</strong>：用于描述如何将类或对象按某种布局组成更大的结构。<br>    GoF中提供了代理、适配器、桥接、装饰、外观、享元、组合等7种结构型模式。<br><strong>行为型模式</strong>：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。<br>    GoF中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11种行为型模式。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-396c98f437f19285a26a11eb3bb20c3c554.png" alt=""></p>
<h2 id="根据作用范围来分类"><a href="#根据作用范围来分类" class="headerlink" title="根据作用范围来分类"></a>根据作用范围来分类</h2><p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。<br><strong>类模式</strong>：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。<br>    GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。<br><strong>对象模式</strong>：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。<br>    GoF中除了以上4种，其他的都是对象模式。</p>
<table>
<thead>
<tr>
<th></th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>(类）适配器</td>
<td>模板方法、解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例、原型、抽象工厂、建造者</td>
<td>代理、(对象）适配器、桥接、装饰、外观、享元、组合</td>
<td>策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录</td>
</tr>
</tbody></table>
<h1 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1 工厂模式"></a>1 工厂模式</h1><p><strong>【介绍】</strong>：</p>
<p>工厂模式（Factory Pattern）是Java中最常用的设计模式之一，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们创建对象的逻辑不会对客户端暴露，而是收口在特定类型产品对应的工厂类中。</p>
<p><strong>【比喻】</strong>：<br>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。制造汽车的逻辑都收敛在工厂中。</p>
<p>奔驰工厂实现了汽车工厂类，可以制造奔驰汽车，宝马工厂也实现了汽车工厂类，制造的是宝马汽车。你需要什么车，就调用对应工厂获得。</p>
<p><strong>【优点】</strong>：</p>
<ol>
<li><p>一个调用者想创建一个对象，只要知道其名称就可以了。 </p>
</li>
<li><p>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</p>
</li>
<li><p>屏蔽产品的具体实现，调用者只关心产品的接口。</p>
</li>
</ol>
<p><strong>【缺点】</strong>：</p>
<p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p>
<blockquote>
<p>复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
</blockquote>
<p><strong>【应用】</strong>：</p>
<ol>
<li>Spring框架中BeanFactory，bean生成的创建逻辑，都收敛在其中。</li>
</ol>
<p><strong>【案例】</strong>：</p>
<p>如下图，FactoryPatternDemo 类使用ShapeFactory来获取Shape对象。它将向 ShapeFactory 传递信息（CIRCLE/RECTANGLE/SQUARE），以便获取它所需对象的类型。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5b893bfc7502cfb24438e21d9688c65a93d.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-抽象工厂模式"><a href="#2-抽象工厂模式" class="headerlink" title="2 抽象工厂模式"></a>2 抽象工厂模式</h1><p><strong>【介绍】</strong>：</p>
<p>抽象工厂模式（Abstract Factory Pattern）是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同组的不同产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂模式只生产一个类型的产品，而抽象工厂模式集合了同组的工厂，可生产同组多个类型的产品。</p>
<p>抽象工厂模式主要设计产品组的概念，就是某一个工厂生产出配套的一系列产品。例如，在生产足球的同时，SoccerFactory还可以生产与之配套的足球杂志。</p>
<p><strong>【比喻】</strong>：</p>
<p>前面介绍的工厂模式中考虑的是一类产品的生产，如汽车厂只生产轿车。而这里抽象工厂模式，则是综合汽车厂的模式，它拥有汽车厂，卡车厂，特种车厂。</p>
<p>或者换个维度，抽象工厂模式也可以是全产业链汽车厂，它拥有汽车厂，轮胎厂，汽车车标厂等等。</p>
<p>奔驰车厂实现抽象工厂类，可分别生产奔驰车，奔驰轮胎和奔驰车标。我们如果需要一套奔驰牌的东西，直接调用奔驰车厂就行。宝马车厂同理。</p>
<p><strong>【优点】</strong>： </p>
<p>当一个产品组中的多个对象被设计成一起工作时，它能保证客户端从单个抽象工厂类中始终只能获取同一个产品组中的对象。如从奔驰车厂中获取的，不管是轮胎还是汽车，肯定都是奔驰牌。</p>
<p>我如果想替换一整套的组合，那么只要替换奔驰车厂为宝马车厂类就行了，这样汽车，轮胎和车标，都自动换成了宝马牌。</p>
<p><strong>【缺点】</strong>：</p>
<p>产品组的扩展非常困难，要增加一个系列的某一产品，既要在抽象的工厂里加代码，又要在具体的新产品类里面加代码。</p>
<p><strong>【应用】</strong>：</p>
<ol>
<li>java JDK中的java.sql.Connection类。MySQLConnection和OracleConnection等继承了它，并在各自的内部，实现了自己专用的Statement/PreparedStatement/CallableStatement对象。</li>
</ol>
<p><strong>【案例】</strong>：</p>
<p>抽象工厂模式也就是不仅生产鼠标，同时生产键盘。PC厂商是个父类，有生产鼠标，生产键盘两个接口。戴尔工厂，惠普工厂继承它，可以分别生产戴尔鼠标+戴尔键盘，和惠普鼠标+惠普键盘。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5b93e55ffae071c06502445c24a266fc9ef.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PcFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Mouse <span class="title">createMouse</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Keybo <span class="title">createKeybo</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DellFactory</span> <span class="keyword">extends</span> <span class="title">PcFactory</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Mouse <span class="title">createMouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> DellMouse();</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Keybo <span class="title">createKeybo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DellKeybo();</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HpFactory</span> <span class="keyword">extends</span> <span class="title">PcFactory</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Mouse <span class="title">createMouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HpMouse();</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Keybo <span class="title">createKeybo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HpKeybo();</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3 单例模式"></a>3 单例模式</h1><p><strong>【介绍】</strong>：</p>
<p>单例模式（Singleton Pattern），它的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。</p>
<p>单例模式具备典型的3个特点：1、只有一个实例。 2、自我实例化。 3、提供全局访问点。</p>
<p>因此当系统中只需要一个实例对象或者系统中只允许一个公共访问点，除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式。</p>
<p><strong>【比喻】</strong>：无</p>
<p><strong>【优点】</strong>：</p>
<ol>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>避免对资源的多重占用（比如写文件操作）。</li>
</ol>
<p><strong>【缺点】</strong>：</p>
<ol>
<li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</li>
</ol>
<p><strong>【应用】</strong>：</p>
<ol>
<li>spring框架中的ApplicationContext</li>
<li>数据库中的连接池</li>
</ol>
<p><strong>【案例】</strong>：</p>
<p>我们将创建一个Singleton类。Singleton 类有它的私有构造函数和本身的一个静态实例。</p>
<p>Singleton类提供了一个静态方法，供外界获取它的静态实例。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-84079d23af3520e15931af6aecf02ced595.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1种：懒汉式单例，线程不安全，懒加载</span></span><br><span class="line"><span class="comment">// 类加载时没有生成单例，</span></span><br><span class="line"><span class="comment">// 只有当第一次调用getlnstance方法时才去创建这个单例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建 Singleton 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第2种：饿汉式单例，线程不安全，非懒加载</span></span><br><span class="line"><span class="comment">// 该模式的特点是类一旦加载就创建一个单例，</span></span><br><span class="line"><span class="comment">// 保证在调用getInstance方法之前单例已经存在了。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="comment">//创建 Singleton 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton  instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第3种：双检锁/双重校验锁单例，线程安全，懒加载</span></span><br><span class="line"><span class="comment">// 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</span></span><br><span class="line"><span class="comment">// getInstance()的性能对应用程序很关键。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第4种：登记式/静态内部类，线程安全，懒加载</span></span><br><span class="line"><span class="comment">// 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。</span></span><br><span class="line"><span class="comment">// 这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</span></span><br><span class="line"><span class="comment">// 这种方式同样利用了classloader机制来保证初始化instance时只有一个线程</span></span><br><span class="line"><span class="comment">// 它跟饿汉式不同的是：饿汉式只要Singleton类被装载了，那么instance就会被实例化，</span></span><br><span class="line"><span class="comment">// 而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用</span></span><br><span class="line"><span class="comment">// 只有通过显式调用 getInstance方法时，才会显式装载SingletonHolder类，从而实例化instance。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第5种：枚举，线程安全，非懒加载</span></span><br><span class="line"><span class="comment">// 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</span></span><br><span class="line"><span class="comment">// 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</span></span><br><span class="line"><span class="comment">// 不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般情况下，不建议使用懒汉方式，建议使用第2种饿汉方式。只有在要明确实现lazy loading效果时，才会使用第4种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第5种枚举方式。如果有其他特殊的需求，可以考虑使用第3种双检锁方式。</p>
</blockquote>
<hr>
<h1 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4 建造者模式"></a>4 建造者模式</h1><p><strong>【介绍】</strong>：</p>
<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。一个Builder类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<p><strong>【比喻】</strong>：</p>
<p>将一个复杂对象分布创建。如果一个超大的类的属性特别多，我们可以把属性分门别类，不同属性组成一个稍微小一点的类，再把好几个稍微小点的类窜起来。</p>
<p>比方说一个电脑，可以分成不同的稍微小点的部分CPU、主板、显示器。CPU、主板、显示器分别有更多的组件，不再细分。</p>
<p>生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。</p>
<p><strong>【优点】</strong>：</p>
<ol>
<li>建造者独立，易扩展。 </li>
<li>便于控制细节风险。</li>
</ol>
<p><strong>【缺点】</strong>：</p>
<ol>
<li>产品必须有共同点，范围有限制。 </li>
<li>如内部变化复杂，会有很多的建造类。</li>
</ol>
<p><strong>【应用】</strong>：</p>
<p>主要应用在如下情况中：有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<ol>
<li>java JDK的StringBuilder类。</li>
<li>Zookeeper的Java客户端CuratorFrameworkFactory类中的Builder内部类。</li>
<li>Spring中的BeanDefinitionBuilder类。</li>
</ol>
<p><strong>【案例】</strong>：</p>
<p>以组装一台电脑为例，电脑包含了主机，操作系统，显示器三个核心部分。我们定义抽象的Builder，在生产一个具体的MacbookBuilder，用来创建MacBook。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-895004b132c7decd08a0e68d8d9f8130c6f.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义电脑的抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String mBoard;</span><br><span class="line">    <span class="keyword">protected</span> String mDisplay;</span><br><span class="line">    <span class="keyword">protected</span> String mOs;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Computer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoard</span><span class="params">(String board)</span></span>&#123;</span><br><span class="line">        mBoard=board;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDisplay = display;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setOs</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义MacBook，继承Computer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacBook</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MacBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOs=<span class="string">"Mac OS X 12"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象的Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildOs</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Computer <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的Builder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacBookBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Computer mComputer=<span class="keyword">new</span> MacBook();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildBoard</span><span class="params">(String board)</span> </span>&#123;</span><br><span class="line">        mComputer.setBoard(board);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildDisplay</span><span class="params">(String display)</span> </span>&#123;</span><br><span class="line">        mComputer.setDisplay(display);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildOs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mComputer.setOs();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Computer <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mComputer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Director类，负责具体的构造 Computer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    Builder mBuilser=<span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBuilser = builer;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(String board,String display)</span></span>&#123;</span><br><span class="line">        mBuilser.buildDisplay(display);</span><br><span class="line">        mBuilser.buildBoard(board);</span><br><span class="line">        mBuilser.buildOs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Builder builder=<span class="keyword">new</span> MacBookBuilder();</span><br><span class="line">    Director pcDirector=<span class="keyword">new</span> Director(builder);</span><br><span class="line">    pcDirector.construct(<span class="string">"英特尔主板"</span>,<span class="string">"Retina显示器"</span>);</span><br><span class="line"></span><br><span class="line">    Computer computer = builder.build();</span><br><span class="line">    System.out.println(computer.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5 原型模式"></a>5 原型模式</h1><p><strong>【介绍】</strong>：</p>
<p>原型模式（Prototype Pattern）是用于创建重复的大对象，它实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则可以采用这种模式。</p>
<p>例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现Cloneable的重写，深拷贝是通过实现Serializable读取二进制流。</p>
<p><strong>【比喻】</strong>：</p>
<p>原型模式的创建的对象是一个克隆对象，可以理解成科幻电影中的克隆机器人，直接生产一个机器人可能需要巨大的代价（比如要消耗大量的IO资源或者硬盘资源，或者调用大量的数据库数据等），那么我们就以某个已经生产出来的机器人为原型或者模板，采用克隆技术去复制它。</p>
<p><strong>【优点】</strong>：</p>
<ol>
<li>Java自带的原型模式基于内存二进制流的复制，在性能上比直接new一个对象更加优良。</li>
<li>逃避构造函数的约束。</li>
</ol>
<p><strong>【缺点】</strong>：</p>
<ol>
<li>需要为每一个类都配置一个clone方法</li>
<li>clone方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ol>
<p><strong>【应用】</strong>：</p>
<p>spring中，scope=”singleton”和scope=”prototype”分别表示该bean是单例模式还是非单例模式。prototype作用域部署的bean，每一次请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）都会产生一个新的bean实例，这内部就是使用了原型模式。</p>
<p><strong>【案例】</strong>：</p>
<p>我们将创建一个抽象类Shape和扩展了Shape类的实体类。下一步是定义类ShapeCache，该类把shape对象的原型存储在一个Hashtable中，并在请求的时候返回它们的克隆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义父类shape，三个子类我们就不赘述了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String id;</span><br><span class="line">   <span class="keyword">protected</span> String type;</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Object clone = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         clone = <span class="keyword">super</span>.clone();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> clone;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeCache</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Hashtable&lt;String, Shape&gt; shapeMap </span><br><span class="line">      = <span class="keyword">new</span> Hashtable&lt;String, Shape&gt;();</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">(String shapeId)</span> </span>&#123;</span><br><span class="line">      Shape cachedShape = shapeMap.get(shapeId);</span><br><span class="line">      <span class="keyword">return</span> (Shape) cachedShape.clone();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 对每种形状都运行数据库查询，并创建该形状</span></span><br><span class="line">   <span class="comment">// shapeMap.put(shapeKey, shape);</span></span><br><span class="line">   <span class="comment">// 例如，我们要添加三种形状</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Circle circle = <span class="keyword">new</span> Circle();</span><br><span class="line">      circle.setId(<span class="string">"1"</span>);</span><br><span class="line">      shapeMap.put(circle.getId(),circle);</span><br><span class="line"> </span><br><span class="line">      Square square = <span class="keyword">new</span> Square();</span><br><span class="line">      square.setId(<span class="string">"2"</span>);</span><br><span class="line">      shapeMap.put(square.getId(),square);</span><br><span class="line"> </span><br><span class="line">      Rectangle rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      rectangle.setId(<span class="string">"3"</span>);</span><br><span class="line">      shapeMap.put(rectangle.getId(),rectangle);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypePatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ShapeCache.loadCache();</span><br><span class="line"> </span><br><span class="line">      Shape clonedShape = (Shape) ShapeCache.getShape(<span class="string">"1"</span>);      </span><br><span class="line"> </span><br><span class="line">      Shape clonedShape2 = (Shape) ShapeCache.getShape(<span class="string">"2"</span>);      </span><br><span class="line"> </span><br><span class="line">      Shape clonedShape3 = (Shape) ShapeCache.getShape(<span class="string">"3"</span>);      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/21/%E8%AF%A6%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/21/%E8%AF%A6%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" itemprop="url">详解分布式锁的三种实现方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-21T21:36:41+08:00">
                2021-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">中间件</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/ZooKeeper/" itemprop="url" rel="index">
                    <span itemprop="name">ZooKeeper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/21/%E8%AF%A6%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/21/详解分布式锁的三种实现方式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  0
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/18/JAVA%E4%B8%AD%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/18/JAVA%E4%B8%AD%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" itemprop="url">JAVA中浮点型数据的存储方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-18T22:23:10+08:00">
                2021-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E5%AE%9E%E7%8E%B0%E6%88%96%E7%89%B9%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA实现或特性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/18/JAVA%E4%B8%AD%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/18/JAVA中浮点型数据的存储方式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  1.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在JAVA中，我们知道int和float占用4个字节，double和long占用8个字节。</p>
<p>那为何int和long的取值范围分别是<code>[-2^31,2^31]</code>，float的取值范围却是<code>[-3.40282346638528860e+38 , -1.40129846432481707e-45] ∪ [1.40129846432481707e-45 ~ 3.40282346638528860e+38]</code>？（long和double同理）</p>
<p>或者我们看如下这道题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">float</span> f_v2 = <span class="number">20.3f</span>;</span><br><span class="line">	<span class="keyword">float</span> f_v3 = <span class="number">20.5f</span>;</span><br><span class="line">	<span class="keyword">double</span> d_v2 = <span class="number">20.3</span>d;</span><br><span class="line">	<span class="keyword">double</span> d_v3 = <span class="number">20.5</span>d;</span><br><span class="line">	System.out.println(f_v2 == d_v2?<span class="string">"true"</span>:<span class="string">"false"</span>);</span><br><span class="line">	System.out.println(f_v3 == d_v3?<span class="string">"true"</span>:<span class="string">"false"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是<code>f_v2==d_v2为false</code>，而<code>f_v3==d_v3为true</code>。</p>
<p>一切的原因，都要从java对于浮点型数据的存储说起。</p>
<p>我们开门见山，直接给出将十进制浮点数存储到内存空间中需要的步骤：</p>
<ol>
<li>将十进制浮点数转为二进制浮点数</li>
<li>将二进制浮点数再转换成科学计数法</li>
<li>优化空间，使用一些技巧，提升存储效率</li>
</ol>
<h1 id="1-将十进制浮点数转为二进制浮点数"><a href="#1-将十进制浮点数转为二进制浮点数" class="headerlink" title="1 将十进制浮点数转为二进制浮点数"></a>1 将十进制浮点数转为二进制浮点数</h1><p>计算机的存储是基于二进制的，要存储一个十进制浮点数，那么必然要先将这个其转为二进制。对于整数的十进制转二进制，我想我们大家都很熟悉，那么对于一个浮点数，十进制如何转为二进制呢？</p>
<p>浮点数可以分为三个部分：符号部分，整数部分，小数部分。</p>
<p>符号部分我们先不论，我们来看一个浮点数20.3:</p>
<p><strong>整数部分</strong>：</p>
<p>整数部分是20，转二进制变成<code>10100</code></p>
<p><strong>小数部分</strong>：</p>
<p>小数部分是0.3，小数转为二进制，在java中有如下规则：</p>
<ol>
<li>将小数部分乘2,得到一个小数res。</li>
<li>取res的整数部分为当前bit的值。</li>
<li>再取res的小数部分接着乘2。</li>
<li>重复上述过程，直至最后没有小数或者小数出现循环。</li>
</ol>
<p>以0.3为例：</p>
<p>0.3 * 2 = 0.6 (取整数0)</p>
<p>0.6 * 2 = 1.2 (取整数1)</p>
<p>0.2 * 2 = 0.4 (取整数0)</p>
<p>0.4 * 2 = 0.8 (取整数0)</p>
<p>0.8 * 2 = 1.6 (取整数1)</p>
<p>0.6 * 2 = 1.2 (取整数1)</p>
<p>计算到这里，将再出现0.6，进入循环了，所以最终0.3的二进制结果是：<code>0.3  = 0.01001 1001 1001...1001</code></p>
<p>所以<code>20.3 = 10100.01001 1001 1001...1001</code></p>
<p>再以0.5为例：</p>
<p>0.5 * 2  = 1.0 (取整数1)</p>
<p>0 * 2 = 0 (取整数0)</p>
<p>计算到这里出现0了，计算结束。所以，转换后<code>0.5 = 0.1</code></p>
<p>所以<code>20.5 = 10100.1</code></p>
<h1 id="2-将二进制浮点数转换成科学计数法"><a href="#2-将二进制浮点数转换成科学计数法" class="headerlink" title="2 将二进制浮点数转换成科学计数法"></a>2 将二进制浮点数转换成科学计数法</h1><p>如果要把十进制浮点数，存储到内存空间中，也就是4或者8个字节中，那么还需要进一步将二进制的浮点数转换成科学计数法。</p>
<p>我们可以很容易得到以下等式</p>
<p><code>20.5(十进制) = 10100.1(二进制)  = 1.01001E4(十进制科学计数) = 1.01001E100(二进制科学计数)</code></p>
<p><code>20.3(十进制) = 10100.01001 1001...1001(二进制)  = 1.010011001...1001E4(十进制科学计数) = 1.010011001...1001E100(二进制科学计数)</code></p>
<blockquote>
<p>这里E100指10的4次方，4也要二进制表示就是100；</p>
</blockquote>
<p>用以科学计数法表示的1.01001 E 100举例，1.01001部分叫做<strong>尾数</strong>；E叫做<strong>基数</strong>，在科学计数法里E=10；100部分叫做<strong>指数</strong>；</p>
<p>那么我们要存储1.01001E100，要存哪些信息呢？</p>
<ol>
<li>尾数1.01001要存，如果遇到像0.3那样的无限循环的尾数，空间不够存储的部分直接舍弃就好，这也是为什么浮点数会有精度问题的原因。</li>
<li>基数E不要存，因为E固定等于10。</li>
<li>指数100要存。</li>
<li>除此之外还有遗漏吗？当然，别忘了正负的符号，这也需要一个bit来存。</li>
</ol>
<p>所以我们可以看到，float和double的存储结构是这样的：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fd3d0c90f7e190ceb6839becd066150e6f7.png" alt=""></p>
<p>那么1.01001E100，我们是不是只要将符号位0、尾数位1.01001和指数位100分别存入对应空间就行了呢？当然这么存也是可以的，但为了节约空间，java设计了一些小技巧，使得空间的利用率更大。</p>
<h1 id="3-优化空间"><a href="#3-优化空间" class="headerlink" title="3 优化空间"></a>3 优化空间</h1><h2 id="3-1-尾数的首位1舍弃"><a href="#3-1-尾数的首位1舍弃" class="headerlink" title="3.1 尾数的首位1舍弃"></a>3.1 尾数的首位1舍弃</h2><p>尾数1.01001要存，<strong>但不用全部都存</strong>，因为尾数第一位固定是1，我们没必要存，只要存.01001就行，这样就节省了一个bit。</p>
<h2 id="3-2-指数位采用移位存储法"><a href="#3-2-指数位采用移位存储法" class="headerlink" title="3.2 指数位采用移位存储法"></a>3.2 指数位采用移位存储法</h2><p>值得注意的是指数位的存储，float指数位有8bit，正常情况下，我们可以用常规的第一个bit表示符号，后面7个bit表示数值的存法，这样存储的指数值从-2^7到2^7。（double同理）</p>
<p>然而java中对指数位，采用的是移位存储法，即指数值的二进制，先加上127（float）或者1023（double），再存储。</p>
<p>如1.01001E100中指数是100，存入float中，那么要先加127：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  00000100</span><br><span class="line"> +01111111</span><br><span class="line">———————————</span><br><span class="line"> +10000011</span><br></pre></td></tr></table></figure>



<p>所以20.5存储在float中是这样的: <code>0 | 10000011 | 01001 00000 00000 00000 000</code></p>
<blockquote>
<p>为什么不用传统的存储法，而要采用移位存储法呢？因为传统的存储法，0 000000和1 000000都表示十进制的0，只不过前者是+0，后者是-0；两个0含义相同，而float指数位只有8bit，最多只能表示256个数，现在两个等价的0占用了两种表示方法，那就有一种表示方法被浪费了。而使用移位存储法，则没有正负0的问题，不会造成浪费。</p>
</blockquote>
<h1 id="4-结语"><a href="#4-结语" class="headerlink" title="4 结语"></a>4 结语</h1><p>最后回到我们在前言的题目：为什么<code>2.3f==2.3d为false</code>，而<code>2.5f==2.5f为true</code>。</p>
<p>我们可以知道：</p>
<ul>
<li>2.5的存储是：<ul>
<li>float：<code>0 | 10000011 | 01001000....（补0直到23位）</code></li>
<li>double：<code>0 | 1000 000 0011 | 01001....（补0直到52位）</code></li>
</ul>
</li>
<li>2.3的存储是：<ul>
<li>float：<code>0 | 10000011 | 010011001...（循环直到23位）</code></li>
<li>double：<code>0 | 1000 000 0011 | 010011001...（循环直到52位）</code></li>
</ul>
</li>
</ul>
<p>在先强转后比较的时候，比如float转成double，会将指数部分先-127，得到原始的指数二进制值，再将其+1023，得到double类型的指数值，位数不足的在高位补零。double转为float同理。所以强转和比较，指数部分是没有问题的。</p>
<p>重点就在于尾数部分，float转成double，会在尾数的后面补0，double转为float，则删掉后面多余的尾数位。</p>
<p><strong>对于2.5来说，转换时增删的部分都是0，所以不影响比较的大小</strong>。</p>
<p><strong>而对于2.3来说，增删的部分，删掉的是循环的1001，增的却是0，这就导致了2.3f和2.3d的尾数部分不相等</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/12/%E3%80%90I-O%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%E4%B8%89%E3%80%91%E8%AF%A6%E8%A7%A3Reactor-Proactor%E9%AB%98%E6%80%A7%E8%83%BDIO%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/12/%E3%80%90I-O%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%E4%B8%89%E3%80%91%E8%AF%A6%E8%A7%A3Reactor-Proactor%E9%AB%98%E6%80%A7%E8%83%BDIO%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/" itemprop="url">【I/O设计总结三】详解Reactor/Proactor高性能IO处理模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-12T22:00:01+08:00">
                2021-01-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/Linux%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">Linux相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/12/%E3%80%90I-O%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%E4%B8%89%E3%80%91%E8%AF%A6%E8%A7%A3Reactor-Proactor%E9%AB%98%E6%80%A7%E8%83%BDIO%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/12/【I-O设计总结三】详解Reactor-Proactor高性能IO处理模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着IO多路复用技术的出现，出现了很多事件处理模式，其中Reactor/Proactor模式是其中的佼佼者。</p>
<p>Reactor模式是非阻塞同步的I/O模型，Proactor模式是非阻塞异步I/O模型。</p>
<p>平时接触的开源产品如Netty、Mina、Redis、ACE，事件模型都使用的Reactor模式；</p>
<p>而同样做事件处理的Proactor，由于缺少操作系统支持的原因，相关的开源产品也少；这里学习下其模型结构，重点对比下两者的异同点；</p>
<h1 id="1-Reactor事件处理模型"><a href="#1-Reactor事件处理模型" class="headerlink" title="1 Reactor事件处理模型"></a>1 Reactor事件处理模型</h1><p>我们来回顾一下《【I/O设计总结一】五种I/O模型总结》中学习的IO多路复用模型：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ed8eb2455efdc9bea6421252767316115c1.png" alt=""></p>
<p>同时，我们在《【I/O设计总结二】详解IO多路复用和其三种模式——select/poll/epoll》一文中，我们介绍了linux系统的select，poll和epoll三个事件的分发函数，我们可以直接编写代码，让应用线程去调用这三个函数中的某一个，完成最简单的IO多路复用模型，也就是如上图所示的这般流程。</p>
<p>这样原始版本的IO多路复用模型好吗？显然不好，直接调用无法并发，效率太低，如果当前的请求没有处理完，那么后面的请求只能被阻塞，服务器的吞吐量太低。</p>
<p>利用线程池技术稍加改进，我们想到了经典的connection per thread，每一个连接用一个线程处理，对于每一个请求都分发给一个线程，每个线程中都独自处理I/O操作。tomcat服务器的早期版本确实是这样实现的。</p>
<p>一连接一线程的方式当然有很多优点，但缺点也很明显：对于资源要求太高，系统中创建线程是需要比较高的系统资源的，如果连接数太高，系统无法承受，而且，线程的反复创建-销毁也需要代价。</p>
<p>这时，我们采用了基于事件驱动的设计，当有事件触发时，才会调用处理器进行数据处理。Reactor模式应运而生。</p>
<p>Reactor是“事件反应”的意思，可以通俗地理解为“<strong>来了一个事件Reactor就有相应的反应</strong>”，具体的反应就是我们写的业务代码，Reactor会根据事件类型来调用相应的代码进行处理。</p>
<p>Reactor模式也叫Dispatcher模式（在很多开源的系统里面会看到这个名称的类，其实就是实现Reactor模式的），分发确实更加贴近模式本身的含义，即I/O多路复用统一监听事件，收到事件后分发（Dispatch）给某个进程。</p>
<blockquote>
<p>归根结底，Reactor就是基于事件驱动设计，利用回调和线程池技术来高效率使用select等函数的设计。</p>
</blockquote>
<h2 id="1-1-Reactor模型的架构"><a href="#1-1-Reactor模型的架构" class="headerlink" title="1.1 Reactor模型的架构"></a>1.1 Reactor模型的架构</h2><p><img src="https://oscimg.oschina.net/oscnet/up-8ade82a62a53c4089267e3f277b6c06d432.png" alt=""></p>
<p>模型架构如上图所示，我们来一一解释这些控件：</p>
<ul>
<li><strong>Handle</strong>：句柄，用来封装或标识socket连接或是打开文件，你可以理解为在模型中，它代表一个连接或者I/O流文件。</li>
<li><strong>Event Handler</strong>：事件处理接口，用来绑定某个handle和应用程序所提供的特定事件处理逻辑。Concrete Event HandlerA和Concrete Event HandlerB是它的具体实现类，应用程序可针对不同的连接（handle）定制不同的处理逻辑（event）。</li>
<li><strong>Synchronous Event Demultiplexer</strong>：同步事件多路分解器，由操作系统内核实现的一个函数（如Linux的select/poll/epoll）；用于阻塞等待发生在句柄集合上的一个或多个事件；返回就绪的Event Handler集合。Java NIO的Selector就是一个Demultiplexer。</li>
<li><strong>Initiation Dispatcher</strong>：分发器，定义一个接口，实现以下功能：<ol>
<li>register_handle()：供应用程序注册它定义的Event Handler。即应用程序通过该方法将Event Handler加入Reactor的Synchronous Event Demultiplexer。</li>
<li>remove_handle()：供应用程序删除Synchronous Event Demultiplexer中关注的Event Handler。</li>
<li>handle_events()：核心方法，也是Reactor模式的发动机，这个方法的核心逻辑如下：<ul>
<li>首先通过同步事件多路选择器提供的select()方法监听网络事件。</li>
<li>当有网络事件就绪后，就遍历注册的Event Handler，找到对应的Event Handler来处理该网络事件。</li>
<li>handle_events()是非阻塞的，主程序可以调用handle_events()后继续其他的操作，handle_events()内的逻辑会触发轮询，回调等操作。调用一次handle_events只会触发一次轮询检查。</li>
<li>如果主程序是服务端的话，由于网络事件是源源不断的，主程序一般会不停调用Dispatcher的handle_events()。比如一个server服务端，开辟一个线程，循环调用handle_events()，非阻塞同步性的处理多个客户端的连接。</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>Demultiplexer和Dispatcher是Reactor的核心，如果我们看到有人说Reactor负责监听和分发事件，那么其实就是将Demultiplexer和Dispatcher整合成一个Reactor组件来描述。</p>
</blockquote>
<blockquote>
<p>下文的图，以及描述中出现的单Reactor和多Reactor，指的就是Demultiplexer+Dispatcher的组合提，即Reactor=Demultiplexer+Dispatcher</p>
</blockquote>
<p><img src="https://oscimg.oschina.net/oscnet/up-ec08ba6d00afa6af66da575a3d6249e90ad.png" alt=""></p>
<p>由图可以看到，Reactor模型的简单流程就是：</p>
<ol>
<li>每当有一个客户端连接进来，被服务端接收到，服务端就会将这个连接封装为一个handle，同时会创建的一个个Event Handler，将handle封装进去，并在Event Handler内设定响应的回调函数。</li>
<li>服务端调用Dispatcher的register_handle()方法，将Event Handler注册进来。</li>
<li>服务端会不停的调用Dispatcher的handle_events()方法，而handle_events()方法会调用Demultiplexer的select()方法，得到就绪的Event Handler。然后调用这个Event Handler的handle_event()方法，执行回调函数。</li>
</ol>
<h2 id="1-2-Reactor模型的实现方案"><a href="#1-2-Reactor模型的实现方案" class="headerlink" title="1.2 Reactor模型的实现方案"></a>1.2 Reactor模型的实现方案</h2><p>Reactor模式的设计，一般和资源池（进程池或线程池）相配合。其中Reactor组件包含Demultiplexer和Dispatcher这两个组件，包含数量不固定，分别负责监听和分配事件，处理资源池负责调度来处理事件。</p>
<p>初看Reactor的实现是比较简单的，但实际上结合不同的业务场景，Reactor模式的具体实现方案灵活多变，主要体现在：</p>
<ul>
<li>Reactor的数量可以变化：可以是一个Reactor，也可以是多个Reactor。</li>
<li>资源池的数量可以变化：以进程为例，可以是单个进程，也可以是多个进程，线程同理。</li>
</ul>
<p>将上面两个因素排列组合一下，理论上可以有 4 种选择，但由于<strong>多Reactor单进程</strong>实现方案相比<strong>单Reactor单进程</strong>方案，既复杂又没有性能优势，因此<strong>多Reactor单进程</strong>方案仅仅是一个理论上的方案，实际没有应用。</p>
<p>最终Reactor模式有这三种典型的实现方案：</p>
<ol>
<li>单Reactor单进程/线程。</li>
<li>单Reactor多线程。</li>
<li>多Reactor多进程/线程。</li>
</ol>
<blockquote>
<p>以上方案具体选择进程还是线程，更多地是和编程语言及平台相关。例如，Java语言一般使用线程（例如，Netty），C语言使用进程和线程都可以。例如，Nginx使用进程，Memcache使用线程。</p>
</blockquote>
<h3 id="1-2-1-非Reactor的传统模型"><a href="#1-2-1-非Reactor的传统模型" class="headerlink" title="1.2.1 非Reactor的传统模型"></a>1.2.1 非Reactor的传统模型</h3><p>为了比较Reactor模型的优势，我们先来介绍一下Reactor模型出现以前的传统模型，Java OIO（old IO）时代，这种模型经常被使用：客户端与服务端建立好连接过后，服务端对每一个建立好的连接使用一个handler来处理，而每个handler都会绑定一个线程。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-09c81dbfc714489eeaa4d726cac48f234c7.png" alt=""></p>
<p>图中的acceptor是注册的一个特殊的Event Handler，负责创建连接的请求，如果Dispatcher接收到某个客户端请求，发现是创建连接的请求，那么就会直接将其转发给acceptor来处理。</p>
<p>这样做在连接的客户端不多的情况下，也算是个不错的选择。但在连接的客户端很多的情况下就会出现问题：</p>
<ol>
<li>每一个连接服务端都会产生一个线程，当并发量比较高的情况下，会产生大量的线程。</li>
<li>在服务端很多线程的情况下，大量的线程的上下文切换是一个很大的开销，会比较影响性能。</li>
<li>与服务端连接建立后，连接上未必是时时刻刻都有数据进行传输的，但是创建的线程一直都在，会造成服务端线程资源的一个极大的浪费。</li>
</ol>
<h3 id="1-2-2-单线程Reactor模型"><a href="#1-2-2-单线程Reactor模型" class="headerlink" title="1.2.2 单线程Reactor模型"></a>1.2.2 单线程Reactor模型</h3><p>介绍了非Reactor的传统模型，我们再来介绍Reactor模型的朴素原型——单线程Reactor模型。<strong>这是Java NIO常用的模型</strong>。</p>
<p>由于Java OIO的网络编程模型在客户端很多的情况下回产生服务端线程数过多的问题，因此根据Reactor模式做出了改进。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fd14c7ac7b684607929f8040cb0a0379949.png" alt=""></p>
<p>根据上图，Reactor角色对IO事件进行监听（Demultiplexer负责）和分发（Dispatcher负责）。当事件产生时，Dispatcher会将handle分发给对应的处理器Event Handler进行处理。</p>
<p>面对IO阻塞，传统OIO使用多线程来消除阻塞的影响，一个socket开启一个线程来处理以防止一个连接IO的阻塞影响到其他的连接的处理。</p>
<p>而在单线程Reactor模型中，通过Reactor对于IO事件的监听和分发，服务端只需要一个IO线程就能处理多个客户端的连接。这就解决了导致服务端线程数过多的问题。</p>
<blockquote>
<p>Reactor的单线程模式的单线程主要是针对于IO操作而言，也就是所有的IO的accept()、read()、write()以及connect()操作都在一个线程上完成的。</p>
</blockquote>
<blockquote>
<p>这个线程可以是服务端调用Dispatcher.handle_events()的线程，也可以是Dispatcher自己无限循环调用handle_events()的线程。我们称这个线程为Reactor的IO线程。</p>
</blockquote>
<p>这个IO线程会循环调用Dispatcher的handle_events()方法，handle_events()方法会继续调用Demultiplexer的select方法，轮询检查注册进来的Event Handler中的handle，如果发生事件，那么回调Event Handler的handle_event()，执行包括read、decode、complete、encode、send的完整IO处理逻辑。</p>
<p>但是这种模型还是有缺陷的，那就是所有的客户端的请求都由一个IO线程来进行处理。当并发量比较大的情况下，服务端的处理性能无法避免会下降，因为服务端IO线程每次只能处理一个客户端的请求，其他的请求只能等待。</p>
<h3 id="1-2-3-多线程Reactor模型"><a href="#1-2-3-多线程Reactor模型" class="headerlink" title="1.2.3 多线程Reactor模型"></a>1.2.3 多线程Reactor模型</h3><p>在目前的单线程Reactor模式中，不仅IO操作在该Reactor的IO线程上，连非IO的业务操作也在该线程上进行处理了，这可能会大大延迟IO请求的响应。所以我们应该将非IO的业务逻辑操作从Reactor线程上卸载，以此来加速Reactor线程对IO请求的响应。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-8f9613b8a1fdfb65d1e713d4724e31d2d16.png" alt=""></p>
<p>如上图所示，Reactor还是一个IO线程，负责监听IO事件以及分发。只不过在事件发生时，Dispatcher回调Event Handler的handle_event()，只会执行read和send操作，中间的业务逻辑处理部分，即decode、complete、encode，都使用了一个线程池来进行处理，这样能够提高Reactor线程的I/O响应，不至于因为一些耗时的业务逻辑而延迟对后面I/O请求的处理，解决了服务端单线程处理请求而带来的性能瓶颈。</p>
<p>但是这样还是有问题，这样会把性能的瓶颈转移到IO处理上。因为IO事件的监听和分发采用的还是单个线程，在并发量比较高的情况下，这个也是比较影响性能的。这是否还有继续优化的空间呢？</p>
<h3 id="1-2-4-多线程多Reactor模型"><a href="#1-2-4-多线程多Reactor模型" class="headerlink" title="1.2.4 多线程多Reactor模型"></a>1.2.4 多线程多Reactor模型</h3><p>虽然多线程Reactor模型将非I/O操作交给了线程池来处理，但是所有的I/O操作依然由Reactor单线程执行，在高负载、高并发或大数据量的应用场景，依然较容易成为瓶颈。所以，对于Reactor的优化，又产生出下面的多Reactor模式。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dea05ee1705efc22d1152bf20cedf5f39a4.png" alt=""></p>
<p>对于多个CPU的机器，为充分利用系统资源，将Reactor拆分为两部分，如上图</p>
<p>mainReactor负责监听server socket，用来处理网络新连接的建立，将建立的socketChannel指定注册给subReactor，通常一个线程就可以处理；</p>
<p>subReactor维护自己的Demultiplexer, 基于mainReactor注册的Event Handler多路分离I/O读写事件；</p>
<p>对非I/O的操作，依然转交给线程池（Thread Pool）执行。</p>
<p>此种模型中，每个模块的工作更加专一，耦合度更低，性能和稳定性也大量的提升，支持的可并发客户端数量可达到上百万级别。关于此种模型的应用，目前有很多优秀的框架已经在应用了，比如mina、Nginx、Memcached和Netty等。</p>
<h3 id="1-2-5-总结"><a href="#1-2-5-总结" class="headerlink" title="1.2.5 总结"></a>1.2.5 总结</h3><p>3种模式可以用个比喻来理解：餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务。</p>
<p>单Reactor单线程：接待员和侍应生是同一个人，全程为顾客服务。<br>单Reactor多线程：1 个接待员，多个侍应生，接待员只负责接待。<br>主从Reactor多线程：多个接待员，多个侍应生。</p>
<h2 id="1-3-Reactor模型的优劣"><a href="#1-3-Reactor模型的优劣" class="headerlink" title="1.3 Reactor模型的优劣"></a>1.3 Reactor模型的优劣</h2><ul>
<li>优点：<ul>
<li>Reactor实现相对简单，对于链接多，但耗时短的处理场景高效；</li>
<li>操作系统可以在多个事件源上等待，并且避免了线程切换的性能开销和编程复杂性；</li>
<li>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；</li>
<li>事务分离：将与应用无关的多路复用、分配机制和与应用相关的回调函数分离开来。</li>
</ul>
</li>
<li>缺点：<ul>
<li>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</li>
</ul>
</li>
</ul>
<h2 id="1-4-Reactor模型的应用"><a href="#1-4-Reactor模型的应用" class="headerlink" title="1.4 Reactor模型的应用"></a>1.4 Reactor模型的应用</h2><h3 id="1-4-1-Reactor模型在Java-NIO中"><a href="#1-4-1-Reactor模型在Java-NIO中" class="headerlink" title="1.4.1 Reactor模型在Java NIO中"></a>1.4.1 Reactor模型在Java NIO中</h3><p>我们知道，Java NIO的网络编程中，会有一个死循环执行Selector.select()操作，找出注册到Selector上的Channel中已经准备好的IO事件，然后再对这些事件进行处理。</p>
<p>故而NIO中的Selector组件对应的就是Reactor模式的Synchronous Event Demultiplexer同步事件多路分解器。</p>
<p>选择过后得到的SelectionKey，其实就对应的是上面的handle，也就是代表的一个个的IO事件。而NIO中并没有进行事件分发和封装处理器，因此Reactor模式中的其他组件NIO并没有给出实现。</p>
<h3 id="1-4-2-Reactor模式在Netty中"><a href="#1-4-2-Reactor模式在Netty中" class="headerlink" title="1.4.2 Reactor模式在Netty中"></a>1.4.2 Reactor模式在Netty中</h3><p>上面java NIO实现了reactor模式的两个角色，Demultiplexer和handle。</p>
<p>而剩余的三个角色，则由Netty给出了实现。</p>
<p>学习过Netty的应当知道，Netty服务端的编程有一个bossGroup和一个workerGroup，还需要编写自己的ChannelHandler。</p>
<p>bossGroup和workerGroup都是一个事件循环组（EventLoopGroup，一般我们用的是NIOEventLoopGroup），每个事件循环组有多个事件循环（EventLoop，NIO对应的是NIOEventLoop）。</p>
<p>mainReactor对应Netty中配置的BossGroup线程组，主要负责接受客户端连接的建立。一般只暴露一个服务端口，BossGroup线程组一般一个线程工作即可。</p>
<p>subReactor对应Netty中配置的WorkerGroup线程组，BossGroup线程组接受并建立完客户端的连接后，将网络socket转交给WorkerGroup线程组，然后在WorkerGroup线程组内选择一个线程，进行I/O的处理。WorkerGroup线程组主要处理I/O，一般设置2*CPU核数个线程。</p>
<p>bossGroup/workerGroup中的事件循环EventLoop就充当了Dispatcher的角色。</p>
<p>Netty中我们需要实现的Handler的顶层接口ChannelHandler对应的就是Event Handler角色，而我们添加进去的一个个的Handler对应的就是Concrete Event Handler。</p>
<blockquote>
<p>注意，Netty的Handler是Concrete Event Handler的角色，Netty的SelectionKey才是handle的角色。</p>
</blockquote>
<p>最后我们总结一下Netty和Reactor角色的对应关系：</p>
<ol>
<li>Initiation Dispatcher ———— NioEventLoop</li>
<li>Synchronous Event Demultiplexer ———— Selector</li>
<li>Handle———— SelectionKey</li>
<li>Event Handler ———— ChannelHandler</li>
<li>ConcreteEventHandler ———— 具体的ChannelHandler的实现</li>
<li>mainReactor ———— bossGroup(NioEventLoopGroup)线程组</li>
<li>subReactor ———— workerGroup(NioEventLoopGroup)线程组</li>
<li>acceptor ———— ServerBootstrapAcceptor</li>
<li>ThreadPool ———— 用户自定义线程池或者EventLoopGroup</li>
</ol>
<h1 id="2-Proactor事件处理模型"><a href="#2-Proactor事件处理模型" class="headerlink" title="2 Proactor事件处理模型"></a>2 Proactor事件处理模型</h1><p>Reactor模式是非阻塞同步的I/O模型，Proactor模式是非阻塞异步I/O模型。它们的区别就在于<strong>异步</strong>二字，Proactor能实现真正的异步，但真正的异步IO也需要操作系统更强的支持。</p>
<p>在Reactor模型中，事件循环利用select等函数，<strong>主动地</strong>将已经就绪的handle找出，并通过回调通知给用户线程，由用户线程定义的回调函数自行读取数据、处理数据。<strong>换句话说，用户线程定义的回调函数中，要自行操作write()，将IO数据从内核空间写到用户空间</strong>。</p>
<p>而在Proactor模型中，就不是利用select等函数寻找就绪的handle了，要记得Proactor是异步IO模型，异步是什么？<strong>我们不用主动调用select函数去寻找，而是直接等通知就行了</strong>。</p>
<p>并通过回调通知给用户线程，但当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。<strong>也就是说，此时用户线程定义的回调函数中，不需要自行操作write()，因为IO数据已经从内核空间写到用户空间了</strong>。</p>
<p>Reactor中，write()操作还是同步的，由用户线程自己解决，而Proactor中，真正做到了异步write()，它依赖于内部实现的异步操作处理器(Asynchronous Operation Processor)以及异步事件分离器(Asynchronous Event Demultiplexer)将IO操作与应用回调隔离。</p>
<p>相比于Reactor，Proactor并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用Reactor模型模拟Proactor异步IO的方式：<strong>IO事件触发时不直接通知用户线程，而是非阻塞地将数据读写完毕后放到用户指定的缓冲区中，再执行回调逻辑</strong></p>
<p>Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</p>
<h2 id="2-1-Proactor模型的架构"><a href="#2-1-Proactor模型的架构" class="headerlink" title="2.1 Proactor模型的架构"></a>2.1 Proactor模型的架构</h2><p><img src="https://oscimg.oschina.net/oscnet/up-d8633437606d424d55a36bc1a8167e624a7.png" alt=""></p>
<p>模型架构如上图所示，我们来一一解释这些控件：</p>
<blockquote>
<p>其中Handle的含义，跟Reactor模型一致，Event Handler和Completion Handler也类似，它们都是事件的抽象封装。</p>
</blockquote>
<ul>
<li><p><strong>Handle</strong>：句柄，用来封装或标识socket连接或是打开文件，你可以理解为在模型中，它代表一个连接或者I/O流文件。</p>
</li>
<li><p><strong>Completion Handler</strong>：完成事件接口，用来绑定某个handle和应用程序所提供的特定事件处理逻辑。Concrete Completion Handler是它的具体实现类，应用程序可针对不同的连接（handle）定制不同的回调函数（event）。</p>
</li>
<li><p><strong>Completion Event Queue</strong>：完成事件的队列；异步操作完成的结果放到队列中等待后续使用。</p>
</li>
<li><p><strong>Asynchronous Operation Processor</strong>：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；绑定在Handle上，负责对监听到的Handle事件进行回调唤醒对应的异步操作，生成对应的Completion Event并添加到完成事件的队列中。</p>
</li>
<li><p>Asynchronous Operation：异步操作，主要用于处理程序中长时间持续操作；</p>
</li>
<li><p><strong>Asynchronous Event Demultiplexer</strong>：异步事件多路分解器，和Reactor的Demultiplexer作用类似，但因为Proactor是异步的，故而不需要Demultiplexer主动发起select轮询，只要监视着完成事件的队列，看是否有Completion Handler被异步插入到队列中即可。</p>
</li>
<li><p><strong>Proactor</strong>：Proactor模型的主动器，提供应用程序的事件循环，重复地从Demultiplexer中获得就绪的Completion Handler，并调用其handle_event()方法。</p>
</li>
<li><p><strong>Initiator</strong>：本地应用程序服务入口，初始化一个异步操作并注册一个Completion Handler和一个带有异步操作处理器的Proactor，当操作完成时通知它。</p>
</li>
</ul>
<blockquote>
<p>可以看到，Proactor角色的作用和Reactor的Dispatcher作用一致。它其实就是Proactor模型的Dispatcher，只不过叫法不一样罢了。</p>
</blockquote>
<p>也有部分文章将Dispatcher+Demultiplexer合并在Proactor角色里，就像Reactor模型中有时用Reactor表示Dispatcher+Demultiplexer，如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-453c1f892f612e40929418482187060b01e.png" alt=""></p>
<h2 id="2-2-Proactor模型的流程"><a href="#2-2-Proactor模型的流程" class="headerlink" title="2.2 Proactor模型的流程"></a>2.2 Proactor模型的流程</h2><p><img src="https://oscimg.oschina.net/oscnet/up-b7e5128b8b586776e79f5e16fb038bd6284.png" alt=""></p>
<p>由图可以看到，Proactor模型的流程可以被归纳为：</p>
<ol>
<li><p>Initiator创建Proactor，Completion Event Queue和Completion Handler对象，并将其通过Asynchronous Operation Processor的exec_async_op()方法注册到内核，并调用async_op()方法，开启独立的内核线程执行异步操作，实现真正的异步。</p>
</li>
<li><p>调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；</p>
</li>
<li><p>Initiator调用Proactor.handle_events()方法，启动Proactor主动器，进行无限的事件循环，调用Demultiplexer.wait()方法，等待完成事件到来；</p>
</li>
<li><p>异步事件的就绪被Asynchronous Operation Processor监听到，将其对应的Completion Handler加入Completion Event Queue队列。</p>
</li>
<li><p>Demultiplexer监视着Completion Event Queue队列，发现有数据，便将队列中的Completion Handler返回。</p>
</li>
<li><p>Proactor从Demultiplexer得到就绪的Completion Handler，知道事件已经就绪，随即调用Completion Handler.handle_event()方法。</p>
</li>
</ol>
<blockquote>
<p>虽然Proactor模式中每个异步操作都可以绑定一个Proactor对象（类似多Reactor的实现方式），但是一般在操作系统中，Proactor被实现为Singleton模式，以便于集中化分发操作完成事件。</p>
</blockquote>
<h2 id="2-3-Proactor模型的优劣"><a href="#2-3-Proactor模型的优劣" class="headerlink" title="2.3 Proactor模型的优劣"></a>2.3 Proactor模型的优劣</h2><ul>
<li>优点：<ul>
<li>Proactor在理论上性能更高，能够处理耗时长的并发场景。</li>
</ul>
</li>
<li>缺点：<ul>
<li>Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现。</li>
</ul>
</li>
</ul>
<h2 id="2-4-Proactor模型的应用"><a href="#2-4-Proactor模型的应用" class="headerlink" title="2.4 Proactor模型的应用"></a>2.4 Proactor模型的应用</h2><p>Proactor因为要有操作系统的支持，故而应用的场景并不多，Linux下高性能的网络库中大多使用的Reactor 模式去实现。比如Boost Asio在Linux下用epoll和select去模拟proactor模式。</p>
<p>除此之外，glibc实现的POSIX aio也是采用proactor模式</p>
<h1 id="3-Reactor和Proactor的对比"><a href="#3-Reactor和Proactor的对比" class="headerlink" title="3 Reactor和Proactor的对比"></a>3 Reactor和Proactor的对比</h1><h2 id="3-1-区别"><a href="#3-1-区别" class="headerlink" title="3.1 区别"></a>3.1 区别</h2><ul>
<li><p>同步和异步</p>
<ul>
<li>Reactor无法实现真正的异步，他们所有操作都是同步的，所以有时为了性能考虑，需要借助线程池，将同步的操作并发化。</li>
<li>Proactor基于操作系统的支持，可以实现真正的异步。</li>
</ul>
</li>
<li><p>主动/被动的写操作</p>
<ul>
<li>Reactor将handler放到select()，等待可写就绪，事件就绪后，需要应用程序主动调用write()，将数据从内核空间写入到用户空间，写完数据后再处理后续逻辑；</li>
<li>Proactor调用aoi_write后立刻返回，由内核负责将数据从内核空间写入到用户空间，写完后调用相应的回调函数处理后续逻辑。换句话说，Proactor通知应用线程的时候，数据已经在用户空间就绪了。</li>
</ul>
</li>
<li><p>主动/被动的处理方式</p>
<ul>
<li>Reactor模式被称为反应器，是一种被动的处理，即调用IO多路复用接口来做事件监听（注意此时是在用户空间调用select等函数），select等函数监听事件就是一个等待的过程，有事件来了之后再“做出反应”。</li>
<li>而Proator模式的IO是系统级实现，是在内核中完成，读的过程中，用户空间的函数可以继续处理，并没有被阻塞；读完之后调用相应用户回调函数处理；</li>
</ul>
</li>
</ul>
<h2 id="3-2-实现"><a href="#3-2-实现" class="headerlink" title="3.2 实现"></a>3.2 实现</h2><p>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；</p>
<p>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量。</p>
<p>所以涉及到文件I/O或耗时I/O可以使用Proactor模式，或使用多线程模拟实现异步I/O的方式。</p>
<h2 id="3-3-适用场景"><a href="#3-3-适用场景" class="headerlink" title="3.3 适用场景"></a>3.3 适用场景</h2><p>Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；<br>Proactor：异步接收和同时处理多个服务请求的事件驱动程序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/05/%E3%80%90I-O%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%E4%B8%80%E3%80%91%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/05/%E3%80%90I-O%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%E4%B8%80%E3%80%91%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/" itemprop="url">【I/O设计总结一】五种I/O模型总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-05T22:02:29+08:00">
                2021-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/Linux%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">Linux相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/05/%E3%80%90I-O%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%E4%B8%80%E3%80%91%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/05/【I-O设计总结一】五种I-O模型总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  2.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在了解IO设计之前，我们首先的搞明白几个概念：什么是阻塞和非阻塞，什么是同步和异步；</p>
<ol>
<li><p>同步和异步是针对应用程序和内核的交互而言的；</p>
<ul>
<li>同步指的是应用程序触发IO操作并等待或者轮询的去查看IO操作是否就绪，也就是需要应用程序自己主动去查看。</li>
<li>异步是指应用程序触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知，或者调用应用程序注册的回调函数。也就是说应用程序可以等着被通知。</li>
</ul>
</li>
<li><p>阻塞和非阻塞描述的是用户线程调用内核IO操作的方式；</p>
<ul>
<li>阻塞方式下，应用程序调用读取或者写入函数后将一直阻塞等待着，IO操作需要彻底完成后，才会返回到用户空间。</li>
<li>非阻塞方式下，应用程序调用读取或者写入函数后内核，会立即返回给应用程序一个状态值，表示数据是否准备好，而不是一直将应用程序阻塞着，直到IO操作彻底完成。</li>
</ul>
</li>
</ol>
<blockquote>
<p>Unix的一个输入操作一般有两个不同的阶段：<br>1、等待数据准备好。<br>2、从内核到进程拷贝数据。</p>
</blockquote>
<blockquote>
<p>对于一个套接口上的输入操作，第一步一般是等待数据到达网络，当分组到达时，它被拷贝到内核中的某个缓冲区，第二步是将数据从内核缓冲区拷贝到应用缓冲区。</p>
</blockquote>
<p>于是，同步/非同步，阻塞/非阻塞这两个维度的排列组合，便构成了我们今天常见的I/O设计模型：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5b02b0ee5dc035be67b0015abbf267f60c6.png" alt=""></p>
<blockquote>
<p>另外，Richard Stevens 在《Unix 网络编程》卷1中提到的基于信号驱动的IO（Signal Driven IO）模型，由于该模型并不常用，本文不作太多。</p>
</blockquote>
<ol>
<li>阻塞式I/O（BIO）</li>
<li>非阻塞式I/O（NIO）</li>
<li>I/O多路复用模型（IO multiplexing，即select，poll和epoll）</li>
<li>信号驱动I/O（SIGIO）</li>
<li>异步I/O（Posix.1的aio_系列函数）</li>
</ol>
<h1 id="1-阻塞式I-O模型（BIO）"><a href="#1-阻塞式I-O模型（BIO）" class="headerlink" title="1 阻塞式I/O模型（BIO）"></a>1 阻塞式I/O模型（BIO）</h1><p>在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！</p>
<p>应用程序调用一个IO函数，导致应用程序阻塞，如果数据已经准备好，则从内核拷贝到用户空间，否则一直等待下去。</p>
<p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-fab53319801f6816ff08fca992b61ef42a6.png" alt=""></p>
<p>当用户进程调用了recvfrom这个系统函数，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。</p>
<p>而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<h1 id="2-非阻塞式I-O模型（nonblocking-IO）"><a href="#2-非阻塞式I-O模型（nonblocking-IO）" class="headerlink" title="2 非阻塞式I/O模型（nonblocking IO）"></a>2 非阻塞式I/O模型（nonblocking IO）</h1><p>我们把一个套接口设置为非阻塞就是告诉内核，当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误。</p>
<p>这样我们的I/O操作函数将不断的轮询数据是否已经准备好，如果没有准备好，继续询问，直到数据准备好为止。在这个不断轮询的过程中，会大量的占用CPU的时间。</p>
<p>非阻塞式IO虽然不会让进程阻塞，可以在数据未完备的时候让进程返回，但应用进程会连续不断地查询内核，看看某操作是否准备好，这对CPU时间是极大的浪费，其中目前JAVA的NIO就属于同步非阻塞IO。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-75df53821589c222566dfcad668e5b76133.png" alt=""></p>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个error。</p>
<p>从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。</p>
<p>一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<h1 id="3-I-O多路复用模型"><a href="#3-I-O多路复用模型" class="headerlink" title="3 I/O多路复用模型"></a>3 I/O多路复用模型</h1><p>设想一下，我们想要得到高性能的IO模型，在阻塞I/O模式下，虽然不会占用大量的CPU时间，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。</p>
<p>那么我们再考虑一下非阻塞忙轮询的I/O方式，我们发现我们似乎可以利用非阻塞式I/O来达到处理多个流的目的。我们只要不停的让每个流从头到尾轮流去向内核问一遍，一直循环周而复始。这样就可以处理多个流了。</p>
<p>但这样的做法有个问题：如果所有的流都没有数据，那么只会白白浪费CPU。</p>
<p>为了避免CPU空转，可以引进了一个非阻塞式的代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，select/poll会把应用线程阻塞掉，然后自己会不断的非阻塞式的轮训注册的流，当有一个或多个流有I/O事件时，select/poll就会返回，应用线程就会从阻塞态中醒来，于是我们的程序就会知道有I/O事件完备了，至于是哪个流完备了，还要应用程序轮询一遍所有的流。</p>
<p>然而，如果没有I/O事件产生，我们的程序就会阻塞在select或者poll处，这依然有个问题，我们从select那里仅仅知道了有I/O事件发生了，但却并不知道是哪几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，再对他们进行操作。</p>
<p>即如果用select/poll，我们有O(n)的无差别轮询的时间复杂度，同时处理的流越多，每一次无差别轮询时间就越长。</p>
<p>为了解决这个问题，我们引入了epoll代理，epoll可以理解为event poll，不同于无差别轮询，epoll只会把哪个流发生了怎样的I/O事件通知我们。</p>
<p>IO multiplexing就是我们说的select，poll，epoll。IO多路复用的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e62486f7ed921e5f929d03660eb79310619.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ed8eb2455efdc9bea6421252767316115c1.png" alt=""></p>
<p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。实际上select/epoll的优势并不是对于单个连接能处理得更快。</p>
<p>使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p>
<blockquote>
<p>IO多路复用的详细内容，可见本站博客《【I/O设计总结二】详解IO多路复用和其三种模式——select/poll/epoll》</p>
</blockquote>
<p>IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为应用进程调用select/poll函数的时候，还是会被阻塞。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。</p>
<p>不过Reactor设计模式优化了select/poll的阻塞性，使得IO多路复用模型变成真正的异步IO。Reactor设计模式将在《【I/O设计总结三】详解Reactor/Proactor高性能IO处理模式》中介绍。</p>
<h1 id="4-信号驱动I-O模型"><a href="#4-信号驱动I-O模型" class="headerlink" title="4 信号驱动I/O模型"></a>4 信号驱动I/O模型</h1><p>我们也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们。通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们的进程继续工作，也就是说它没有被阻塞。</p>
<p>当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知应用进程数据已经准备好待处理。</p>
<p>优势：等待数据报到达期间进程不被阻塞。应用进程可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-8133c3db642cf3cef1439420db1a276b707.png" alt=""></p>
<h1 id="5-异步I-O模型（asynchronous-IO）"><a href="#5-异步I-O模型（asynchronous-IO）" class="headerlink" title="5 异步I/O模型（asynchronous IO）"></a>5 异步I/O模型（asynchronous IO）</h1><p>linux下的asynchronous IO其实用得很少。“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-8d938e905de4d6cc394e5408fde573aaf9c.png" alt=""></p>
<p>异步IO模型使用了Proactor设计模式实现了上述的这一机制。Proactor设计模式将在《【I/O设计总结三】详解Reactor/Proactor高性能IO处理模式》中介绍。</p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>下面一图总结上述五种I/O模型：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-1bbe7bd11fdb2bc11a7de90ed4406d9416f.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/05/MySQL%E7%9A%84%E5%88%86%E5%8C%BA-%E5%88%86%E5%BA%93-%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/05/MySQL%E7%9A%84%E5%88%86%E5%8C%BA-%E5%88%86%E5%BA%93-%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/" itemprop="url">MySQL的分区/分库/分表总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-05T21:00:18+08:00">
                2021-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">关系型数据库</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/05/MySQL%E7%9A%84%E5%88%86%E5%8C%BA-%E5%88%86%E5%BA%93-%E5%88%86%E8%A1%A8%E6%80%BB%E7%BB%93/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/05/MySQL的分区-分库-分表总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  7.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  28
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文一切基于MySql InnoDB</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li><p>分区：把一张表的数据分成多个区块，在逻辑上看最终只是一张表，但底层是由多个物理区块组成的</p>
</li>
<li><p>分表：把一张表按一定的规则分解成多个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。</p>
</li>
<li><p>分库：把一个库拆成多个库，突破库级别的数据库操作I/O瓶颈。</p>
</li>
</ol>
<blockquote>
<p>在mysql中，schema和库(database)是一个概念</p>
</blockquote>
<h2 id="数据库架构演变"><a href="#数据库架构演变" class="headerlink" title="数据库架构演变"></a>数据库架构演变</h2><p>一开始，我们只用单机数据库就足够满足业务需要了，但随着业务的拓展，带来越来越多的请求，我们将数据库的写操作和读操作进行分离，使用多个从库副本（Slaver Replication）负责读，使用主库（Master）负责写。从库从主库同步更新数据，保持数据一致。架构上的数据库主从同步，使得从库可以水平扩展，所以更多的读请求不成问题。</p>
<p>但是当用户量级上来后，写请求越来越多，该怎么办？加一个Master是不能解决问题的， 因为数据要保存一致性，写操作需要2个master之间同步，相当于是重复了，而且更加复杂。</p>
<p>这时就需要用到分库分表，对写操作进行切分。</p>
<h2 id="什么情况下要分库分表"><a href="#什么情况下要分库分表" class="headerlink" title="什么情况下要分库分表"></a>什么情况下要分库分表</h2><p>任何问题都是太大或者太小的问题，我们这主要面对的是数据量太大的问题。</p>
<ol>
<li><p>用户请求量太大</p>
<ul>
<li>瓶颈：单服务器的TPS，内存，IO都是有限的。</li>
<li>解决方法：分散请求到多个服务器上； 其实用户请求和执行一个sql查询是本质是一样的，都是请求一个资源，只是用户请求还会经过网关，路由，http服务器等。</li>
</ul>
</li>
<li><p>单表数据量太大</p>
<ul>
<li>瓶颈：索引膨胀，查询耗时长，影响正常CRUD。</li>
<li>解决方法：切分成多个数据集更小的表。</li>
</ul>
</li>
<li><p>单库数据量太大</p>
<ul>
<li>瓶颈：单个数据库处理能力有限，单库所在服务器上磁盘空间不足，I/O有限；</li>
<li>解决方法：切分成更多更小的库</li>
</ul>
</li>
</ol>
<h1 id="1-分区"><a href="#1-分区" class="headerlink" title="1 分区"></a>1 分区</h1><p>首先，我们要明白分区的区是指什么！</p>
<p>我们在《【InnoDB详解二】MySQL文件系统和InnoDB存储结构》一文中提到过，MySQL的物理数据，存储在表空间文件（.ibdata1和.ibd）中，<strong>这里讲的分区的意思是指将同一表中不同行的记录分配到不同的物理文件中，几个分区就有几个.idb文件</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-0ad0669d4a4cb9b37ce32e63ee4fc717fde.png" alt=""></p>
<p>MySQL在5.1时添加了对水平分区的支持。分区是将一个表或索引分解成多个更小，更可管理的部分。每个区都是独立的，可以独立处理，也可以作为一个更大对象的一部分进行处理。这个是MySQL支持的功能，业务代码无需改动。</p>
<p>可以通过使用SHOW VARIABLES命令来确定MySQL是否支持分区，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &#39;%partition%&#39;;</span><br><span class="line"> </span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| have_partition_engine | YES   |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>在如上列出的一个正确的SHOW VARIABLES 命令所产生的输出中，如果没有看到变量have_partition_engine的值为YES，那么MySQL的版本就不支持分区。</p>
<p>MySQL是面向OLTP的数据库，对于分区的使用应该更加小心，如果不清楚如何使用分区可能会对性能产生负面的影响。</p>
<h2 id="1-1-MySQL分区类型"><a href="#1-1-MySQL分区类型" class="headerlink" title="1.1 MySQL分区类型"></a>1.1 MySQL分区类型</h2><p>目前MySQL支持一下几种类型的分区：</p>
<ol>
<li>RANGE分区：基于一个给定区间边界，得到若干个连续区间范围，按照分区键的落点，把数据分配到不同的分区；</li>
<li>LIST分区：类似RANGE分区，区别在于LIST分区是基于枚举出的值列表分区，RANGE是基于给定连续区间范围分区；</li>
<li>HASH分区：基于用户自定义的表达式的返回值，对其根据分区数来取模，从而进行记录在分区间的分配的模式。这个用户自定义的表达式，就是MySQL希望用户填入的哈希函数。</li>
<li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且使用MySQL 服务器提供的自身的哈希函数。</li>
</ol>
<p>如果表存在主键或者唯一索引时，分区列必须是唯一索引的一个组成部分。</p>
<blockquote>
<p>在实战中，十有八九都是用RANGE分区。</p>
</blockquote>
<h3 id="1-1-1-RANGE分区"><a href="#1-1-1-RANGE分区" class="headerlink" title="1.1.1 RANGE分区"></a>1.1.1 RANGE分区</h3><p>RANGE分区是实战最常用的一种分区类型，行数据基于属于一个给定的连续区间的列值被放入分区。</p>
<p>但是记住，当插入的数据不在一个分区中定义的值的时候，会抛异常。</p>
<p>RANGE分区主要用于日期列的分区，比如交易表啊，销售表啊等。可以根据年月来存放数据。</p>
<p>如果你分区走的唯一索引中date类型的数据，那么注意了，优化器只能对YEAR(),TO_DAYS(),TO_SECONDS(),UNIX_TIMESTAMP()这类函数进行优化选择。</p>
<p>实战中可以用int类型的字段来存时间戳做分区列，那么只用存yyyyMM就好了，也不用关心函数了。</p>
<p>MySQL使用PARTITION命令来做分区，sql语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE</span><br><span class="line">    &#96;Order&#96; (</span><br><span class="line">        &#96;id&#96;</span><br><span class="line">        INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">        &#96;partition_key&#96;</span><br><span class="line">        INT NOT NULL,</span><br><span class="line">        &#96;amt&#96;</span><br><span class="line">        DECIMAL(5) NULL) PARTITION BY RANGE(partition_key)</span><br><span class="line">PARTITIONS 5(</span><br><span class="line">    PARTITION part0 VALUES LESS THAN(201901),</span><br><span class="line">    PARTITION part1 VALUES LESS THAN(201902),</span><br><span class="line">    PARTITION part2 VALUES LESS THAN(201903),</span><br><span class="line">    PARTITION part3 VALUES LESS THAN(201904),</span><br><span class="line">    PARTITION part4 VALUES LESS THAN(201905),</span><br><span class="line">    PARTITION part4 VALUES LESS THAN MAXVALUE;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RANGE分区通过使用PARTITION BY RANGE(expr)实现，其中“expr” 可以是某个列值，如id，no，partition_key等。或一个基于某个列值并返回一个整数值的表达式，如YEAR(date)。不过值得注意的是，expr的返回值，不可以为NULL。</p>
</blockquote>
<blockquote>
<p>其中，MAXVALUE 表示最大的可能的整数值。如果没有设置MAXVALUE这个分区，那么此时如果insert一个partition_key大于201905的记录，MySQL就会抛出异常，插入失败。</p>
</blockquote>
<blockquote>
<p>VALUES LESS THAN的排列必须从小到大顺序列出，这样MySQL才能识别一个一个的区间段。</p>
</blockquote>
<p>这时候我们先插入一些数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &#96;Order&#96; (&#96;id&#96;, &#96;partition_key&#96;, &#96;amt&#96;) VALUES (&#39;1&#39;, &#39;201901&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;Order&#96; (&#96;id&#96;, &#96;partition_key&#96;, &#96;amt&#96;) VALUES (&#39;2&#39;, &#39;201902&#39;, &#39;800&#39;);</span><br><span class="line">INSERT INTO &#96;Order&#96; (&#96;id&#96;, &#96;partition_key&#96;, &#96;amt&#96;) VALUES (&#39;3&#39;, &#39;201903&#39;, &#39;1200&#39;);</span><br></pre></td></tr></table></figure>

<p>现在我们查询一下，通过EXPLAIN PARTITION命令发现SQL优化器只需搜对应的区，不会搜索所有分区:</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-2c6597ab4e7854d1fe18bc882da5eb04f8f.png" alt=""></p>
<p>因为partition_key是分区键。当然，我们也可以直接指定搜索哪个分区:</p>
<p><code>SELECT * FROM Order PARTITION (part0,part1) WHERE status amt &gt; 1000</code></p>
<p>注意，如果sql语句不指定分区，则会走所有分区，性能反而会不升反降。所以分区表后，select语句必须走分区键。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ef302df24f6cc6c6e9735100664bfad5b16.png" alt=""></p>
<p>涉及聚合函数SUM()、COUNT()的查询时，如果不指定分区，那么会在每个分区上并行处理。例如执行这条语句<code>SELECT COUNT(1) FROM Order</code>，则会在每个分区上都同时运行查询；</p>
<p>一个例子不够，我们再举一个例子，来看看expr是个函数表达式的场景，假如现在有如下雇员表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,</span><br><span class="line">    job_code INT,</span><br><span class="line">    store_id INT</span><br><span class="line">)</span><br><span class="line">PARTITION BY RANGE (YEAR(separated)) (</span><br><span class="line">    PARTITION p0 VALUES LESS THAN (1991),</span><br><span class="line">    PARTITION p1 VALUES LESS THAN (1996),</span><br><span class="line">    PARTITION p2 VALUES LESS THAN (2001),</span><br><span class="line">    PARTITION p3 VALUES LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这个方案中，在1991年前离职的所有雇员的记录保存在分区p0中，1991年到1995年期间离职的所有雇员的记录保存在分区p1中， 1996年到2000年期间离职的所有雇员的记录保存在分区p2中，2000年后离职的所有工人的信息保存在p3中。</p>
<p>当需要删除“旧的”数据时，使用分区会有意想不到的效果。</p>
<p>假如我们想删除所有在1991年前就已经离职的雇员的记录，你只需简单地使用<code>ALTER TABLE employees DROP PARTITION p0;</code></p>
<p>对于有大量行的表，这比运行<code>DELETE FROM employees WHERE YEAR(separated) &lt;= 1990</code>要有效得多。</p>
<h3 id="1-1-2-LIST分区"><a href="#1-1-2-LIST分区" class="headerlink" title="1.1.2 LIST分区"></a>1.1.2 LIST分区</h3><p>MySQL中的LIST分区在很多方面类似于RANGE分区。和RANGE分区一样，LIST分区的每个分区必须明确定义。它们的主要区别在于，LIST分区是基于枚举出的值列表分区，RANGE是基于给定连续区间范围分区；</p>
<p>LIST分区通过使用<code>PARTITION BY LIST(expr)</code>来实现，我们假定有20个音像店，分布在4个有经销权的地区，如下表所示：</p>
<table>
<thead>
<tr>
<th>地区</th>
<th>商店ID 号</th>
</tr>
</thead>
<tbody><tr>
<td>北区</td>
<td>3, 5, 6, 9, 17</td>
</tr>
<tr>
<td>东区</td>
<td>1, 2, 10, 11, 19, 20</td>
</tr>
<tr>
<td>西区</td>
<td>4, 12, 13, 14, 18</td>
</tr>
<tr>
<td>中心区</td>
<td>7, 8, 15, 16</td>
</tr>
</tbody></table>
<p>要按照属于同一个地区商店的记录保存在同一个分区的原则来分割表，可以使用下面的CREATE TABLE语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,</span><br><span class="line">    job_code INT,</span><br><span class="line">    store_id INT</span><br><span class="line">)</span><br><span class="line">PARTITION BY LIST(store_id)</span><br><span class="line">    PARTITION pNorth VALUES IN (3,5,6,9,17),</span><br><span class="line">    PARTITION pEast VALUES IN (1,2,10,11,19,20),</span><br><span class="line">    PARTITION pWest VALUES IN (4,12,13,14,18),</span><br><span class="line">    PARTITION pCentral VALUES IN (7,8,15,16)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>可以看到，和RANGE分区相比，LIST分区的VALUES IN后面接的是枚举值列表，不像RANGE是用VALUES LESS THAN来定义区间边界。</p>
<blockquote>
<p>如果试图插入字段值（或分区表达式的返回值）不在分区值列表中的任何一行时，那么“INSERT”查询将失败并报错。例如，假定LIST分区的采用上面的方案，那么下面的查询将失败：<code>INSERT INTO employees VALUES (224, &#39;Linus&#39;, &#39;Torvalds&#39;, &#39;2002-05-01&#39;, &#39;2004-10-12&#39;, 42, 21);</code>。因为“store_id”字段值21不能在用于定义分区pNorth, pEast, pWest,或pCentral的值列表中找到。</p>
</blockquote>
<blockquote>
<p>要重点注意的是，LIST分区没有类似如“VALUES LESS THAN MAXVALUE”这样的包含其他值在内的定义。所以将要匹配的任何值都必须在值列表中能够找到。</p>
</blockquote>
<h3 id="1-1-3-HASH分区"><a href="#1-1-3-HASH分区" class="headerlink" title="1.1.3 HASH分区"></a>1.1.3 HASH分区</h3><p>HASH分区主要用来确保数据在预先确定数目的分区中平均分布。在RANGE和LIST分区中，我们必须明确指定一个给定的区间或列值集合，来指定哪些记录进入哪些分区；而在HASH分区中，MySQL自动完成分配记录到区间的工作，你所要做的只是确定一个用来做哈希的字段或者表达式，以及指定被分区的表将要被分割成的分区数量。</p>
<p>要使用HASH分区来分割一个表，要在CREATE TABLE 语句上添加一个<code>PARTITION BY HASH (expr)</code>子句，其中“expr”同样可以是一个返回一个整数的表达式，或者仅仅是字段类型为整型的某个字段。</p>
<p>此外，你很可能需要在后面再添加一个“PARTITIONS num”子句，其中num 是一个非负的整数，它表示表将要被分割成分区的数量。</p>
<p>例如，下面的语句创建了一个使用基于“store_id”列进行哈希处理的表，该表被分成了4个分区：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    fname VARCHAR(30),</span><br><span class="line">    lname VARCHAR(30),</span><br><span class="line">    hired DATE NOT NULL DEFAULT &#39;1970-01-01&#39;,</span><br><span class="line">    separated DATE NOT NULL DEFAULT &#39;9999-12-31&#39;,</span><br><span class="line">    job_code INT,</span><br><span class="line">    store_id INT</span><br><span class="line">)</span><br><span class="line">PARTITION BY HASH(store_id)</span><br><span class="line">PARTITIONS 4；</span><br></pre></td></tr></table></figure>

<p>如果没有包括一个PARTITIONS子句，那么分区的数量将默认为1。</p>
<blockquote>
<p>注意，expr不应该设置的过于复杂，因为每当插入或更新（或者可能删除）一行时，这个表达式都要计算一次；这意味着非常复杂的表达式可能会引起性能问题，尤其是在执行同时影响大量行的运算（例如批量插入）的时候。</p>
</blockquote>
<p>最有效率的哈希函数是只对单个表列进行计算，并且它的结果值随字段值进行一致地增大或减小，因为这考虑了在分区范围上的“修剪”。也就是说，表达式值和它所基于的列的值变化越接近，MySQL就可以越有效地使用该表达式来进行HASH分区。</p>
<p>当使用了“PARTITION BY HASH”时，MySQL将基于用户提供的函数结果的模数来确定使用哪个编号的分区。换句话，对于一个表达式“expr”，将要保存记录的分区编号为N ，其中“N = MOD(expr, num)”。</p>
<h3 id="1-1-4-KEY分区"><a href="#1-1-4-KEY分区" class="headerlink" title="1.1.4 KEY分区"></a>1.1.4 KEY分区</h3><p>按照KEY进行分区类似于按照HASH分区，除了HASH分区使用的用户定义的表达式，而KEY分区的哈希函数是由MySQL 服务器提供。</p>
<p>MySQLCluster使用函数MD5()来实现KEY分区；对于使用其他存储引擎的表，服务器使用其自己内部的 哈希函数，这些函数是基于与PASSWORD()一样的运算法则。</p>
<p>“CREATE TABLE … PARTITION BY KEY”的语法规则类似于创建一个通过HASH分区的表的规则。它们唯一的区别在于使用的关键字是KEY而不是HASH，并且KEY分区只采用一个或多个列名的一个列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tk (</span><br><span class="line">    col1 INT NOT NULL,</span><br><span class="line">    col2 CHAR(5),</span><br><span class="line">    col3 DATE</span><br><span class="line">)</span><br><span class="line">PARTITION BY LINEAR KEY (col1)</span><br><span class="line">PARTITIONS 3;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-5-子分区"><a href="#1-1-5-子分区" class="headerlink" title="1.1.5 子分区"></a>1.1.5 子分区</h3><p>子分区是分区表中每个分区的再次分割。例如，考虑下面的CREATE TABLE 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts (id INT, purchased DATE)</span><br><span class="line">    PARTITION BY RANGE(YEAR(purchased))</span><br><span class="line">    SUBPARTITION BY HASH(TO_DAYS(purchased))</span><br><span class="line">    SUBPARTITIONS 2</span><br><span class="line">    (</span><br><span class="line">        PARTITION p0 VALUES LESS THAN (1990),</span><br><span class="line">        PARTITION p1 VALUES LESS THAN (2000),</span><br><span class="line">        PARTITION p2 VALUES LESS THAN MAXVALUE</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>表ts有3个RANGE分区。这3个分区（p0, p1, 和 p2）中的每一个分区又被进一步分成了2个子分区。实际上，整个表被分成了3 * 2 = 6个分区。但是，由于PARTITION BY RANGE子句的作用，p0分区的子分区里，只会保存“purchased”列中值小于1990的那些记录。</p>
<p>在MySQL 5.1中，对于已经通过RANGE或LIST分区了的表再进行子分区是可能的。子分区既可以使用HASH希分区，也可以使用KEY分区。这也被称为复合分区（composite partitioning）。</p>
<p>为了对个别的子分区指定选项，使用SUBPARTITION 子句来明确定义子分区也是可能的。例如，创建在前面例子中给出的同一个表的、一个更加详细的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts (id INT, purchased DATE)</span><br><span class="line">    PARTITION BY RANGE(YEAR(purchased))</span><br><span class="line">    SUBPARTITION BY HASH(TO_DAYS(purchased))</span><br><span class="line">    (</span><br><span class="line">        PARTITION p0 VALUES LESS THAN (1990)</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s0,</span><br><span class="line">            SUBPARTITION s1</span><br><span class="line">        ),</span><br><span class="line">        PARTITION p1 VALUES LESS THAN (2000)</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s2,</span><br><span class="line">            SUBPARTITION s3</span><br><span class="line">        ),</span><br><span class="line">        PARTITION p2 VALUES LESS THAN MAXVALUE</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s4,</span><br><span class="line">            SUBPARTITION s5</span><br><span class="line">        )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>不过有几点要注意的语法项：</p>
<ol>
<li>每个分区必须有相同数量的子分区。</li>
<li>如果在一个分区表上的某个分区上使用SUBPARTITION来明确定义子分区，那么就必须定义其他所有分区的子分区。</li>
</ol>
<p>子分区可以用于特别大的表，在多个磁盘间分配数据和索引。假设有6个磁盘，分别为/disk0， /disk1， /disk2等。现在考虑下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ts (id INT, purchased DATE)</span><br><span class="line">    PARTITION BY RANGE(YEAR(purchased))</span><br><span class="line">    SUBPARTITION BY HASH(TO_DAYS(purchased))</span><br><span class="line">    (</span><br><span class="line">        PARTITION p0 VALUES LESS THAN (1990)</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s0a</span><br><span class="line">                DATA DIRECTORY &#x3D; &#39;&#x2F;disk0&#39;</span><br><span class="line">                INDEX DIRECTORY &#x3D; &#39;&#x2F;disk1&#39;,</span><br><span class="line">            SUBPARTITION s0b</span><br><span class="line">                DATA DIRECTORY &#x3D; &#39;&#x2F;disk2&#39; </span><br><span class="line">                INDEX DIRECTORY &#x3D; &#39;&#x2F;disk3&#39;</span><br><span class="line">        ),</span><br><span class="line">        PARTITION p1 VALUES LESS THAN (2000)</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s1a</span><br><span class="line">                DATA DIRECTORY &#x3D; &#39;&#x2F;disk4&#x2F;data&#39; </span><br><span class="line">                INDEX DIRECTORY &#x3D; &#39;&#x2F;disk4&#x2F;idx&#39;,</span><br><span class="line">            SUBPARTITION s1b</span><br><span class="line">                DATA DIRECTORY &#x3D; &#39;&#x2F;disk5&#x2F;data&#39; </span><br><span class="line">                INDEX DIRECTORY &#x3D; &#39;&#x2F;disk5&#x2F;idx&#39;</span><br><span class="line">        ),</span><br><span class="line">        PARTITION p2 VALUES LESS THAN MAXVALUE</span><br><span class="line">        (</span><br><span class="line">            SUBPARTITION s2a,</span><br><span class="line">            SUBPARTITION s2b</span><br><span class="line">        )</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>DATA DIRECTORY表示数据的物理文件的存放目录</li>
<li>INDEX DIRECTORY表示索引的物理文件的存放目录</li>
</ul>
<p>在这个例子中，每个RANGE分区的数据和索引都使用一个单独的磁盘。存储的分配如下：</p>
<ol>
<li>购买日期在1990年前的记录占了大量的存储空间，所以把它分为了四个部分进行存储，组成p0分区的两个子分区（s0a 和s0b）的数据和索引都分别用一个单独的磁盘进行存储。换句话说：<ul>
<li>子分区s0a 的数据保存在磁盘/disk0中。</li>
<li>子分区s0a 的索引保存在磁盘/disk1中。</li>
<li>子分区s0b 的数据保存在磁盘/disk2中。</li>
<li>子分区s0b 的索引保存在磁盘/disk3中。</li>
</ul>
</li>
<li>保存购买日期从1990年到1999年间的记录（分区p1）不需要保存购买日期在1990年之前的记录那么大的存储空间。这些记录分在2个磁盘（/disk4和/disk5）上保存，而不是4个磁盘：<ul>
<li>属于分区p1的第一个子分区（s1a）的数据和索引保存在磁盘/disk4上 — 其中数据保存在路径/disk4/data下，索引保存在/disk4/idx下。</li>
<li>属于分区p1的第二个子分区（s1b）的数据和索引保存在磁盘/disk5上 — 其中数据保存在路径/disk5/data下，索引保存在/disk5/idx下。</li>
</ul>
</li>
<li>保存购买日期从2000年到现在的记录（分区p2）不需要前面两个RANGE分区那么大的空间。当前，在默认的位置能够足够保存所有这些记录。</li>
</ol>
<h2 id="1-2-分区维护"><a href="#1-2-分区维护" class="headerlink" title="1.2 分区维护"></a>1.2 分区维护</h2><p>MySQL提供了许多修改分区表的方式。添加、删除、重新定义、合并或拆分已经存在的分区是可能的。所有这些操作都可以通过使用<code>ALTER TABLE</code>命令的分区扩展来实现。</p>
<p>下面我们来总结一下所有分区维护的命令，为简便计，我们定义几种partitions_exprs来替代如下子命令：</p>
<ul>
<li>RANGE分区，range_partitions_exprs(n)即为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PARTITION p VALUES LESS THAN (xxx)</span><br><span class="line">...(n个PARTITION子句)</span><br></pre></td></tr></table></figure></li>
<li>LIST分区，list_partitions_exprs即为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PARTITION p VALUES IN (xxx,yyy,...),</span><br><span class="line">...(n个PARTITION子句)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-2-1-添加分区"><a href="#1-2-1-添加分区" class="headerlink" title="1.2.1 添加分区"></a>1.2.1 添加分区</h3><ol>
<li>为已创建的未分区表创建分区：<ul>
<li>RANGE：<code>ALTER TABLE tb PARTITION BY RANGE (expr) ( range_partitions_exprs(n&gt;0) );</code></li>
<li>LIST：<code>ALTER TABLE tb PARTITION BY LIST (expr) ( list_partitions_exprs(n&gt;0) );</code></li>
<li>HASH：<code>ALTER TABLE tb PARTITION BY HASH(expr) PARTITIONS 2;</code></li>
<li>KEY：<code>ALTER TABLE tb PARTITION BY KEY(expr) PARTITIONS 2;</code></li>
</ul>
</li>
<li>为分区表添加n个分区：<ul>
<li>RANGE：<code>ALTER TABLE tb ADD PARTITION ( range_partitions_exprs(n&gt;0) );</code></li>
<li>LIST：<code>ALTER TABLE tb ADD PARTITION ( list_partitions_exprs(n&gt;0) );</code></li>
<li>HASH &amp; KEY：<code>ALTER TABLE tb ADD PARTITION PARTITIONS n;</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>对于通过RANGE分区的表，只可以使用ADD PARTITION添加新的分区到分区列表的尾端。设法通过这种方式在现有分区的前面或之间增加一个新的分区，将会导致报错。此时建议使用下文的拆分操作，REORGANIZE命令可以运行expr重叠。</p>
</blockquote>
<blockquote>
<p>不能添加这样一个新的LIST分区，该分区包含有已经包含在现有分区值列表中的任意值。如果试图这样做，将会导致错误。此时建议使用下文的拆分操作，REORGANIZE命令可以运行expr重叠。</p>
</blockquote>
<h3 id="1-2-2-重调整分区"><a href="#1-2-2-重调整分区" class="headerlink" title="1.2.2 重调整分区"></a>1.2.2 重调整分区</h3><ol>
<li>数据不丢失的前提下，将m个分区<strong>合并</strong>为n个分区（m&gt;n），即减量重新组织分区<ul>
<li>RANGE：<code>ALTER TABLE tb REORGANIZE PARTITION s0,s1,... INTO ( range_partitions_exprs(n) )</code></li>
<li>LIST：<code>ALTER TABLE tb REORGANIZE PARTITION s0,s1,... INTO ( list_partitions_exprs(n) )</code></li>
<li>HASH &amp; KEY：<code>ALTER TABLE clients COALESCE PARTITION n; (n小于原有分区数)</code></li>
</ul>
</li>
<li>数据不丢失的前提下，将分区表的m个分区<strong>拆分</strong>为n个分区（m&lt;n），即增量重新组织分区<ul>
<li>RANGE：<code>ALTER TABLE tb REORGANIZE PARTITION p0,p1,... INTO ( range_partitions_exprs(n) )</code></li>
<li>LIST：<code>ALTER TABLE tb REORGANIZE PARTITION p0,p1,... INTO ( list_partitions_exprs(n) )</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>不能使用REORGANIZE PARTITION来改变表的分区类型；也就是说，例如，不能把RANGE分区变为HASH分区，反之亦然。也不能使用该命令来改变分区表达式或列。</p>
</blockquote>
<ol start="3">
<li>重建分区，即先删除分区中的所有记录，然后重新插入。可用于整理分区碎片。<ul>
<li><code>ALTER TABLE tb REBUILD PARTITION p0, p1;</code></li>
</ul>
</li>
<li>优化分区，整理分区碎片<ul>
<li><code>ALTER TABLE tb OPTIMIZE PARTITION p0, p1;</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>如从分区中删除了大量的行，或者对一个带有可变长度字段（VARCHAR、BLOB、TEXT类型）的行作了许多修改，可以使用优化分区来收回没有使用的空间，并整理分区数据文件的碎片。<br>5. 修复分区，修补被破坏的分区。<br>    - <code>ALTER TABLE tb REPAIR PARTITION p0,p1;</code><br>6.  检查分区，这个命令可以告诉你分区中的数据或索引是否已经被破坏，如果被破坏，请使用修复分区来修补<br>    - <code>ALTER TABLE tb CHECK PARTITION p1;</code></p>
</blockquote>
<h3 id="1-2-3-删除分区"><a href="#1-2-3-删除分区" class="headerlink" title="1.2.3 删除分区"></a>1.2.3 删除分区</h3><ol>
<li>删除一个分区，以及分区内的所有数据：<ul>
<li><code>ALTER TABLE tb DROP PARTITION p2;</code></li>
</ul>
</li>
<li>删除一个分区，但保留分区内的所有数据(MySQL 5.5引入)：<ul>
<li><code>ALTER TABLE tb TRUNCATE PARTITION p2;</code></li>
</ul>
</li>
</ol>
<h3 id="1-2-4-查询分区数据"><a href="#1-2-4-查询分区数据" class="headerlink" title="1.2.4 查询分区数据"></a>1.2.4 查询分区数据</h3><ol>
<li>查看某个schema下某个表的分区信息<ul>
<li><code>SELECT * FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_SCHEMA = &#39;xxx&#39; AND TABLE_NAME LIKE &#39;xxxx&#39;;</code></li>
</ul>
</li>
<li>分析某个分区,主要看行数和名称以及状态<ul>
<li><code>ALTER TABLE tb ANALYZE PARTITION p3;</code></li>
</ul>
</li>
</ol>
<h1 id="2-分表"><a href="#2-分表" class="headerlink" title="2 分表"></a>2 分表</h1><p>分表顾名思义，就是把一张超大的数据表，拆分为多个较小的表，使得一些超大表的痼疾，得到有效的缓解。</p>
<p>超大表会带来如下的影响：</p>
<ol>
<li>单表数据量太大，会被频繁读写，加锁操作密集，导致性能降低。</li>
<li>单表数据量太大，对应的索引也会很大，查询效率降低，增删操作的性能也会降低。</li>
</ol>
<p>分表和分区看起来十分类似，确实，分区已经能够在磁盘层面将一张表拆分成多个文件了，理论上前面提到的大表的问题都能得到有效解决。因为分区就是分表的数据库实现版本。</p>
<p>在MySQL 5.1分区功能出现以前，要想解决超大表问题，只能采用分表操作，因为这类问题十分常见，MySQL才自带了一个分区功能，以达到相同的效果。</p>
<p>所以你可以直接说分区就是分表的替代，分表是分区出现以前的做法。不过这不代表我们就没有必要学习分表了，相反，水平分表的功能或许可以用更加便捷的分区来替代，但是垂直分表的功能，分区却无法替代。</p>
<p>分表只能通过程序代码来实现，目前市面上有许多分表的框架。</p>
<h2 id="2-1-分表和分区的区别"><a href="#2-1-分表和分区的区别" class="headerlink" title="2.1 分表和分区的区别"></a>2.1 分表和分区的区别</h2><ol>
<li>分区只是一张表中的数据和索引的存储位置发生改变，分表则是将一张表分成多张表，是真实的有多套表的配套文件</li>
<li>分区没法突破数据库层面，不论怎么分区，这些分区都要在一个数据库下。而分表可以将子表分配在同一个库中，也可以分配在不同库中，突破数据库性能的限制。</li>
<li>分区只能替代水平分表的功能，无法取代垂直分表的功能。</li>
</ol>
<h2 id="2-2-分表的类型"><a href="#2-2-分表的类型" class="headerlink" title="2.2 分表的类型"></a>2.2 分表的类型</h2><p>分表分为水平分表和垂直分表。</p>
<h3 id="2-2-1-水平分表"><a href="#2-2-1-水平分表" class="headerlink" title="2.2.1 水平分表"></a>2.2.1 水平分表</h3><p>水平分表和分区很像，或者说分区就是水平分表的数据库实现版本，它们分的都是行记录，就像用一把刀，水平的将一个表切成多张表一样。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-84df96079a112e74ce0b9fb080cc16b4c84.png" alt=""></p>
<p>针对数据量巨大的单张表（比如订单表），我们按照某种规则，切分到多张表里面去。</p>
<p>但是需要注意，如果这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。分表可以将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与子表，这是分区所不能有的优势。</p>
<p>水平分表的切分规则一般有如下几种：</p>
<ol>
<li>范围切分<ul>
<li>可以根据某个字段的范围做划分，比如订单号字段，从0到10000一个表，10001到20000一个表。</li>
</ul>
</li>
<li>HASH取模<ul>
<li>可以根据某个字段的HASH取模做划分，比如将一个用户表分成10个子表，可以取用户id，然后hash后取10的模，从而分配到不同的数据库上。不过这种划分一旦确定后，就无法改变子表数量了。</li>
</ul>
</li>
<li>地理/国籍/类型等<ul>
<li>比如按照华东，华南，华北这样来区分业务表，或者安卓用户，IOS用户等来区分用户表。</li>
</ul>
</li>
<li>时间<ul>
<li>按照时间切分，比如将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。</li>
</ul>
</li>
</ol>
<h3 id="2-2-2-垂直分表"><a href="#2-2-2-垂直分表" class="headerlink" title="2.2.2 垂直分表"></a>2.2.2 垂直分表</h3><p>水平分表分的是行记录，而垂直分表，分的是列字段，它就像用一把刀，垂直的将一个表切成多张表一样。</p>
<p>垂直分表是基于列字段进行的。一般是表中的字段较多，或者有数据较大长度较长（比如text，blob，varchar(1000)以上的字段）的字段时，我们将不常用的，或者数据量大的字段拆分到“扩展表”上。这样避免查询时，数据量太大造成的“跨页”问题。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-82f7ac5bade04db64ad8a3b49cc82777b12.png" alt=""></p>
<p>垂直分表的切分规则很好理解，一般是“不常用”或者“字段数据量大”这两点来做切割，我们不多赘述。</p>
<h1 id="3-分库"><a href="#3-分库" class="headerlink" title="3 分库"></a>3 分库</h1><p>分库同样是为了应对超大数据带来的巨大的IO需求，如果不拆库，那么单库所能支持的吞吐能力和磁盘空间，就会成为制衡业务发展的瓶颈。分库的主要目的是为突破单节点数据库服务器的I/O能力限制，解决数据库水平扩展性问题。</p>
<h2 id="3-1-分区分表之外的分库作用"><a href="#3-1-分区分表之外的分库作用" class="headerlink" title="3.1 分区分表之外的分库作用"></a>3.1 分区分表之外的分库作用</h2><p>也许你会问，我们有了分区和分表技术，还需要分库来解决大数据量的问题吗？对的，需要。</p>
<p>分区和分表可以把单表分到不同的硬盘上，但不能分配到不同服务器上。一台机器的性能是有限制的，用分库可以解决单台服务器性能不够，或者成本过高问题。</p>
<p>将一个库分成多个库，并在多个服务器上部署，就可以突破单服务器的性能瓶颈，这是分库必要性的最主要原因。</p>
<h2 id="3-2-分库的类型"><a href="#3-2-分库的类型" class="headerlink" title="3.2 分库的类型"></a>3.2 分库的类型</h2><p>分库同样分为水平分库和垂直分库。</p>
<ol>
<li>水平分库<ul>
<li>水平分库和水平分表相似，并且关系紧密，水平分库就是将单个库中的表作水平分表，然后将子表分别置于不同的子库当中，独立部署。</li>
<li>因为库中内容的主要载体是表，所以水平分库和水平分表基本上如影随形。</li>
<li>例如用户表，我们可以使用注册时间的范围来分表，将2020年注册的用户表usrtb2020部署在usrdata20中，2021年注册的用户表usrtb2021部署在usrdata21中。</li>
</ul>
</li>
<li>垂直分库<ul>
<li>同样的，垂直分库和垂直分表也十分类似，不过垂直分表拆分的是字段，而垂直分库，拆分的是表。</li>
<li>垂直分库是将一个库下的表作不同维度的分类，然后将其分配给不同子库的策略。</li>
<li>例如，我们可以将用户相关的表都放置在usrdata这个库中，将订单相关的表都放置在odrdata中，以此类推。</li>
<li>垂直分库的分类维度有很多，可以按照业务模块划分（用户/订单…），按照技术模块分（日志类库/图片类库…），或者空间，时间等等。</li>
</ul>
</li>
</ol>
<h1 id="4-分库分表存在的问题"><a href="#4-分库分表存在的问题" class="headerlink" title="4 分库分表存在的问题"></a>4 分库分表存在的问题</h1><ol>
<li>事务问题。<ul>
<li><strong>问题描述</strong>：在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</li>
<li><strong>解决方法</strong>：利用分布式事务，协调不同库之间的数据原子性，一致性。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>跨库跨表的join问题。</p>
<ul>
<li><strong>问题描述</strong>：在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。</li>
<li><strong>解决方法</strong>：tddl、MyCAT等都支持跨分片join。但是我们应该尽力避免跨库join，如果一定要整合数据，那么请在代码中多次查询完成。</li>
</ul>
</li>
<li><p>额外的数据管理负担和数据运算压力。</p>
<ul>
<li><strong>问题描述</strong>：额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。</li>
<li><strong>解决方法</strong>：无解，这是水平拓展的代价。</li>
</ul>
</li>
</ol>
<h1 id="5-分库分表方案产品"><a href="#5-分库分表方案产品" class="headerlink" title="5 分库分表方案产品"></a>5 分库分表方案产品</h1><p>目前市面上的分库分表中间件相对较多，其中基于代理方式的有MySQL Proxy和Amoeba；基于Hibernate框架的是Hibernate Shards；基于jdbc的有当当sharding-jdbc；基于mybatis的类似maven插件式的有蘑菇街的蘑菇街TSharding；通过重写spring的ibatis template类的Cobar Client。</p>
<p>还有一些大公司的开源产品：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-92e5751b3c11a7cbf834051e6129b5cf0cb.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/" itemprop="url">动态规划的分析和简述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-04T21:29:35+08:00">
                2021-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/01/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%80%E8%BF%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2021/01/04/动态规划的分析和简述/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  21
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-动态规划的概念"><a href="#1-动态规划的概念" class="headerlink" title="1 动态规划的概念"></a>1 动态规划的概念</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解<strong>决策过程最优化</strong>的数学方法。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。</p>
<p><strong>决策过程是什么呢</strong>？在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。各个阶段决策的选取依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题称为多阶段决策问题。</p>
<p>在多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前的<strong>状态</strong>，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化的过程为动态规划方法。</p>
<h2 id="1-2-概念和术语"><a href="#1-2-概念和术语" class="headerlink" title="1.2 概念和术语"></a>1.2 概念和术语</h2><p>关于动态规划，我们要了解如下概念和术语，我们以0-1背包问题为例：</p>
<blockquote>
<p>0-1背包问题:我们有n种物品，物品j的重量为wj，价格为pj，背包的总重量是W，如果限定每种物品只能选择0个或1个，那么如何选取物品，使背包内物品的总价值最大。</p>
</blockquote>
<ol>
<li>阶段：<ul>
<li>把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同</li>
<li>0-1背包问题中，我们每一次选取一个新的物品放入背包的这个过程，就是一个阶段。</li>
</ul>
</li>
<li>状态：<ul>
<li>状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。</li>
<li>0-1背包问题中，我们每一次选取一个新的物品后，（已选取物品，已选取的物品总价值），这二者的值就是一个阶段的状态。</li>
</ul>
</li>
<li>决策<ul>
<li>一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。</li>
<li>0-1背包问题中，每次我们选取哪个物品放入，这就是一个决策，</li>
</ul>
</li>
<li>策略：<ul>
<li>由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</li>
<li>一次连续阶段的多个决策序列就是策略，比如策略A可以是：放入钢笔——放入水壶——放入睡袋。策略B是放入钢笔——放入睡袋——放入头盔。以此类推</li>
</ul>
</li>
<li>多阶段决策问题：<ul>
<li>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题</li>
<li>0-1背包问题就是一个典型的多阶段决策问题。</li>
</ul>
</li>
</ol>
<h2 id="1-3-核心思路"><a href="#1-3-核心思路" class="headerlink" title="1.3 核心思路"></a>1.3 核心思路</h2><p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>不过与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往<strong>不是互相独立的</strong>。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。</p>
<p>如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。在动态规划中，我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p>
<p>动态规划的核心除了<strong>分阶段决策</strong>外，还有上面所说的<strong>避免重复计算</strong>。这个如何理解呢？</p>
<p>比如0-1背包问题，我们现在有1，2，3三个物品，xj=1表示j物品放入背包，xj=0则表示j物品没放入。同时策略C(x1x2x3)=001，表示x1和x2都没有放入背包，x3放入了背包。</p>
<p>现在假如通过穷举得到了如下的5种可行策略：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b0743e22223d2b97f33727c532090c6508e.png" alt=""></p>
<p>那么由图我们可以知道，C2=011和C3=010这两种策略，都要经过01这个策略，如果在计算011的时候我们计算一遍01，在计算010的时候我们又计算一遍01，那么就重复计算了，我们为什么不把01这个策略的状态（已选取物品，已选取的物品总价值）保存下来呢？这样在计算010的时候，直接就可以把01的结果拿出来用了。</p>
<p>动态规划算法可以理解为是<strong>分治法</strong>和<strong>穷举法</strong>的结合：</p>
<ol>
<li>它用分治法的思想将一个问题分为多个决策阶段，既将问题复杂性减小，也为后续的局部结果复用提供前提。</li>
<li>它搜索解的方式还是穷举法那一套，只不过因为可以局部复用，所以它的复杂性会大大降低。</li>
</ol>
<p>其关键在于解决冗余，这是动态规划算法的<strong>根本目的</strong>。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其他的算法。选择动态规划算法是因为动态规划算法在空间上可以承受，而搜索算法在时间上却无法承受，所以我们舍空间而取时间</p>
<h2 id="1-4-适用场景"><a href="#1-4-适用场景" class="headerlink" title="1.4 适用场景"></a>1.4 适用场景</h2><p>动态规划算法通常用于求解具有某种最优性质的多阶段决策问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p>
<p>任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和状态无后效性：</p>
<ol>
<li>最优化原理（最优子结构性质）<ul>
<li>最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。</li>
<li>在0-1背包问题中，我们假设策略C=011是最优解，也就是说背包存放x2和x3，才能使价值最高，那么它的子策略，01x和x11，也同样都是最优解。最优化原理通俗的讲就是：011是最优解，那么01x肯定也是最优解，01x表示x3先不论，x1肯定不能选，x2肯定要选，否则就不是最优解。</li>
</ul>
</li>
<li>状态无后效性：<ul>
<li>状态无后效性指的是每个阶段的状态都是过去阶段的一个完整总结，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策。这就是无后向性，又称为无后效性。</li>
<li>在0-1背包问题中，我们的状态是（已选取物品，已选取的物品总价值），我们之所以选择这样的两个值作为状态，就是因为它都是对过去阶段的完整总结。这使得从这个状态基础上进行的新的决策，可以不用去关心之前的状态，因为之前的状态被总结了。之所以要使状态无后效性，就是为了便于存储和复用阶段的结果，避免重复计算。</li>
<li>试想一下，如果状态不是无后效性的，比如我们选择的状态是（本次选取的物品），那么我们保存这个状态的值，根本对后面的复用没有帮助，后面要想知道背包还剩多少空间，还是要把之前经历过的阶段的解都计算一遍。</li>
</ul>
</li>
</ol>
<h2 id="1-5-解题技巧"><a href="#1-5-解题技巧" class="headerlink" title="1.5 解题技巧"></a>1.5 解题技巧</h2><p>前文我们提到过，动态规划是分治法和穷举法的结合，同时，在动态规划中，我们可以用一个表来记录所有已穷举出的已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p>
<p>那么，如何将上述的经验整理成解题技巧呢？还是用0-1背包问题为例，来看下所谓的填表格式到底是什么：</p>
<blockquote>
<p>假设你是个小偷，背着一个可装4磅东西的背包。你可盗窃的商品有如下3件。为了让盗窃的商品价值最高，你该选择哪些商品？</p>
</blockquote>
<table>
<thead>
<tr>
<th>商品名称</th>
<th>重量（磅）</th>
<th>价值（美元）</th>
</tr>
</thead>
<tbody><tr>
<td>音响</td>
<td>4</td>
<td>3000</td>
</tr>
<tr>
<td>笔记本电脑</td>
<td>3</td>
<td>2000</td>
</tr>
<tr>
<td>吉他</td>
<td>1</td>
<td>1500</td>
</tr>
</tbody></table>
<p>每个动态规划算法都从一个填表的网格开始，背包问题的网格如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-acaa938a3d53c298fca66158871c356f97f.png" alt=""></p>
<ul>
<li>网格的各行为商品，各列为不同容量（1～4磅）的背包。单元格内填入当前情况下的最大背包价值。</li>
<li>第一行表示只能选吉他，第二行表示可以选吉他+音响，以此类推。</li>
<li>虽然我们题目的背包是4磅，但我们仍然需要1到3磅的前三列，因为它们将帮助我们在计算剩余空间时发挥作用。</li>
<li>网格最初是空的。我们将填充其中的每个单元格，网格填满后，就找到了问题的答案！</li>
</ul>
<p>【填充第一行】</p>
<p>第一个单元格表示背包的容量为1磅。吉他的重量也是1磅，这意味着它能装入背包！因此这个单元格包含吉他，价值为1500美元。</p>
<p>由于这是第一行，只有吉他可供你选择，于是不管背包多大，单元格内的值都是1500美元，所以第一行的值都是1500。</p>
<p>【填充第二行】</p>
<p>我们现在处于第二行，可偷的商品有吉他和音响。我们先来看第一个单元格，它表示容量为1磅的背包。在此之前，可装入1磅背包的商品的最大价值为1500美元，由于容量1磅的背包装不下音响，因此最大价值依然是1500美元。接下来的两个单元格的情况与此相同。在这些单元格中，背包的容量分别为2磅和3磅，而以前的最大价值为1500美元。由于这些背包装不下音响，因此最大价值保持不变。</p>
<p>但如果背包的容量为4磅，那就能够装下音响！原来的最大价值为1500美元，但如果在背包中装入音响而不是吉他，价值将为3000美元！你更新了最大价值！在这个网格中，你逐步地更新最大价值。</p>
<p>于是我们得到了第二行：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9eb1183a125b7d520063b9e2186994a2829.png" alt=""></p>
<p>【填充第三行】</p>
<p>笔记本电脑重3磅，没法将其装入容量为1磅或2磅的背包，因此前两个单元格的最大价值还是1500美元。</p>
<p>对于容量为3磅的背包，原来的最大价值为1500美元，但现在你可选择盗窃价值2000美元的笔记本电脑而不是吉他，这样新的最大价值将为2000美元！</p>
<p><strong>对于容量为4磅的背包</strong>，当前的最大价值为3000美元，你可不偷音响，而偷笔记本电脑，但它只值2000美元。价值没有原来高。但笔记本电脑的重量只有3磅，背包还有1磅的容量没用！</p>
<p>在1磅的容量中，可装入的商品的最大价值是多少呢？根据之前计算的最大价值可知（第一列中最大的值），在1磅的容量中可装入吉他，价值1500美元。</p>
<blockquote>
<p>注意，此时我们就用到了背包容量为1的那一列，所以我们之所以要算出与4磅无关的容量为1,2,3磅的结果，就是为了这一刻。</p>
</blockquote>
<p>笔记本电脑和吉他的总价值为3500美元，因此偷它们是更好的选择。最终的网格类似于下面这样。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-8da65c224aabb364fa3138a3251ca96f4b2.png" alt=""></p>
<p>【总结】</p>
<p>经过上面的分析，我们可以发现，题目所要的答案，其实只是网格最右下角的那一个单元格。那我们为什么要算出其他的单元格呢？</p>
<p>因为下一个单元格的值，需要用到之前单元格的值来计算，比如最后的答案3500美元，就用到了背包容量为1的那一列的数据来计算剩余1磅空间的时候选择哪个物品最合算。</p>
<p>我们记录下之前单元格的值，就是为了计算新单元格的时候不用重复计算，就像这道题，我们最后想知道背包容量为1时应该如何选取物品，如果没有保存下结果，那我们要重新算一遍第一列的场景，那效率就很低了。</p>
<blockquote>
<p>记忆化搜索，即用一个二维数组保存已经计算好的子问题的解，下次再计算相同子问题时，就不用重复求解了。</p>
</blockquote>
<p>每一个新的单元格的值，都需要复用到之前单元格的数据来算出，如果我们能归纳出一个通用的<strong>以旧单元格值推导出新单元格值的公式</strong>，那就相当于找到了一条可得到最优解的方法。这个公式，我们称为<strong>状态转移方程</strong>。</p>
<p>我们前文提到过，状态是每一个阶段的总结，动态规划是多阶段决策的过程，我们在多个阶段间行进，状态也在一直转移。状态转移方程，顾名思义，就是状态变化的方程，比如说我们可以归纳出该题的状态转移方程如下图：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-31a037616da8a00acebff111b6ab70b8839.png" alt=""></p>
<p>于是我们知道了：</p>
<ol>
<li>填表法是动态规划的固定套路，它能帮助我们理解状态转移的过程，并且记录和复用之前的结果。</li>
<li>网格的每一个单元格，都可以理解为是一个阶段，阶段变量有两个，可选取物品类型和背包重量，也就是网格的横纵轴。</li>
<li>每个阶段的策略，就是我们的状态转移方程，即我们用现有的状态，决策出了当前阶段的状态。</li>
<li>动态规划的核心就在于：<ul>
<li><strong>将题目划分为多个子问题，对应多个阶段</strong></li>
<li><strong>确定哪些变量属于状态</strong></li>
<li><strong>归纳出状态转移方程</strong></li>
</ul>
</li>
</ol>
<h1 id="2-经典题型"><a href="#2-经典题型" class="headerlink" title="2 经典题型"></a>2 经典题型</h1><h2 id="2-1-0-1背包问题"><a href="#2-1-0-1背包问题" class="headerlink" title="2.1 0-1背包问题"></a>2.1 0-1背包问题</h2><h3 id="2-1-1-题目"><a href="#2-1-1-题目" class="headerlink" title="2.1.1 题目"></a>2.1.1 题目</h3><p>【描述】：有 n 个物品和一个大小为 bagSize 的背包. 给定数组 itemSizes 表示每个物品的大小和数组 itemValues 表示每个物品的价值。问最多能装入背包的总价值是多大?</p>
<ul>
<li><code>itemSizes[i], itemValues[i], n, bagSize 均为整数</code></li>
<li><code>你不能将物品进行切分</code></li>
<li><code>你所挑选的要装入背包的物品的总大小不能超过 bagSize</code></li>
<li><code>每个物品只能取一次</code></li>
</ul>
<p>【样例 1】:</p>
<ul>
<li>输入: <code>bagSize = 10, itemSizes = [2, 3, 5, 7], itemValues = [1, 5, 2, 4]</code></li>
<li>输出: 9</li>
<li>解释: 装入 <code>itemSizes[1] 和 itemSizes[3]</code> 可以得到最大价值, <code>itemValues[1] + itemValues[3] = 9</code></li>
</ul>
<p>【样例 2】:</p>
<ul>
<li>输入: <code>bagSize = 10, itemSizes = [2, 3, 8], itemValues = [2, 5, 8]</code></li>
<li>输出: 10</li>
<li>解释: 装入 <code>itemSizes[0] 和 itemSizes[2]</code> 可以得到最大价值, <code>itemValues[0] + itemValues[2] = 10</code></li>
</ul>
<h3 id="2-1-2-题解"><a href="#2-1-2-题解" class="headerlink" title="2.1.2 题解"></a>2.1.2 题解</h3><p>前文已叙述，不再赘述。</p>
<h3 id="2-1-3-代码"><a href="#2-1-3-代码" class="headerlink" title="2.1.3 代码"></a>2.1.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int backPack(int bagSize, int[] itemSizes, int[] itemValues) &#123;</span><br><span class="line">    int itemsNum &#x3D; itemSizes.length;</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组，存放已计算过的结果，填表法。</span><br><span class="line">    int[][] values &#x3D; new int[itemsNum][bagSize];</span><br><span class="line">    &#x2F;&#x2F; 开始填表，itemSizes数组中，0-itemIdx区间内的物品，为当前可选物品</span><br><span class="line">    for (int itemIdx &#x3D; 0;itemIdx &lt; itemsNum;itemIdx++)&#123;</span><br><span class="line">        for (int bagIdx &#x3D; 0;bagIdx &lt; bagSize;bagIdx++)&#123;</span><br><span class="line">            int thisBagSize &#x3D; bagIdx+1;&#x2F;&#x2F; 因为下标为0开始，但背包size从1开始。</span><br><span class="line">            &#x2F;&#x2F; 从已计算的结果中获取【当前背包size下，如果当前物品不可取时，背包可存放的最大价值】。</span><br><span class="line">            int maxValueWithoutThisItem &#x3D; getCachedValue(itemIdx-1,bagIdx,values);</span><br><span class="line">            &#x2F;&#x2F; 计算【当前背包size下，如果当前物品可取时，背包可存放的最大价值】</span><br><span class="line">            &#x2F;&#x2F; 计算方法为：如果当前物品可以被当前背包size容纳</span><br><span class="line">            &#x2F;&#x2F;      那么尝试优先存放该物品，并从之前的不包含当前物品的结果中</span><br><span class="line">            &#x2F;&#x2F;          寻找【可以填满剩余空间的最大价值】，二者相加即为结果。</span><br><span class="line">            int maxValueIncludeThisItem &#x3D; itemSizes[itemIdx] &lt;&#x3D; thisBagSize ?</span><br><span class="line">                    itemValues[itemIdx] + getCachedValue(itemIdx-1,thisBagSize-itemSizes[itemIdx]-1,values): maxValueWithoutThisItem;</span><br><span class="line">            &#x2F;&#x2F; 比较【当前背包size下，如果当前物品不可取时，背包可存放的最大价值】和【当前背包size下，如果当前物品可取时，背包可存放的最大价值】</span><br><span class="line">            &#x2F;&#x2F; 哪个大就选择哪个值作为当前阶段的解。</span><br><span class="line">            values[itemIdx][bagIdx] &#x3D; Math.max(maxValueWithoutThisItem,maxValueIncludeThisItem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return values[itemsNum-1][bagSize-1];</span><br><span class="line">&#125;</span><br><span class="line">private int getCachedValue(int i,int j,int[][] values)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return values[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-最长公共子串"><a href="#2-2-最长公共子串" class="headerlink" title="2.2 最长公共子串"></a>2.2 最长公共子串</h2><h3 id="2-2-1-题目"><a href="#2-2-1-题目" class="headerlink" title="2.2.1 题目"></a>2.2.1 题目</h3><p>【描述】：给出两个字符串，找到最长公共子串，并返回其长度。</p>
<ul>
<li><code>子串的字符应该连续的出现在原字符串中，这与子序列有所不同。</code></li>
</ul>
<p>【样例 1】:</p>
<ul>
<li>输入:  “hish” and “fish”</li>
<li>输出:  3</li>
<li>解释: 最长公共子串是 “ish”</li>
</ul>
<p>【样例 2】:</p>
<ul>
<li>输入: “hish” and “vista”</li>
<li>输出: 2</li>
<li>解释: 最长公共子串是 ‘is’</li>
</ul>
<h3 id="2-2-2-题解"><a href="#2-2-2-题解" class="headerlink" title="2.2.2 题解"></a>2.2.2 题解</h3><p>将两个单词的字母分列为横纵轴，如下图所示。</p>
<p>因为公共子串有顺序和连续的要求（如is和si就不是一个公共子串，ios和is不是一个共同子串，只有is和is才是。），所以在矩阵当中，两个相邻的对角线的单元格都为1的时候，才是公共子串出现的时候。</p>
<p>那我们把两个相邻的成对角线的单元格都赋值1可以吗？不行，还记得我们动态规划状态的定义吗？状态是过去阶段的总结！</p>
<p>所以，我们应该用右下角的单元格来存储目前已出现的这个公共子串的长度，而不是单纯的赋值1。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-15876d948b7646fe660df2f8f4c0a2e7002.png" alt=""></p>
<p>对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。</p>
<h3 id="2-2-3-代码"><a href="#2-2-3-代码" class="headerlink" title="2.2.3 代码"></a>2.2.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 最长公共子串</span><br><span class="line"> * @param Str1: Str1 string</span><br><span class="line"> * @param str2: str2 string</span><br><span class="line"> * @return: the length of the longest common substring</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int longestCommonSubstring(String str1, String str2) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    if (str1.isEmpty()|| str2.isEmpty())&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组，存放已计算过的结果，填表法。</span><br><span class="line">    int[][] values &#x3D; new int[str1.length()][str2.length()];</span><br><span class="line">    for (int i &#x3D; 0;i&lt;str1.length();i++)&#123;</span><br><span class="line">        for (int j &#x3D; 0;j&lt;str2.length();j++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 状态转移方程为：当两个字母相等时，当前值取左上角的单元格的值+1</span><br><span class="line">            if (str1.charAt(i) &#x3D;&#x3D; str2.charAt(j))&#123;</span><br><span class="line">                values[i][j] &#x3D; getCachedValue(i-1,j-1,values)+1;</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; Math.max(result,values[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private int getCachedValue(int i,int j,int[][] values)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; values.length || j &gt;&#x3D;values[0].length)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return values[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-最长公共子串"><a href="#2-3-最长公共子串" class="headerlink" title="2.3 最长公共子串"></a>2.3 最长公共子串</h2><h3 id="2-3-1-题目"><a href="#2-3-1-题目" class="headerlink" title="2.3.1 题目"></a>2.3.1 题目</h3><p>【描述】：给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>
<p>最长公共子序列的定义：</p>
<ul>
<li>最长公共子序列问题是在一组序列（通常2个）中找到最长公共子序列（注意：不同于子串，LCS不需要是连续的子串）。该问题是典型的计算机科学问题，是文件差异比较程序的基础，在生物信息学中也有所应用。</li>
</ul>
<p>【样例 1】:</p>
<ul>
<li>输入:  “fosh” and “fort”</li>
<li>输出:  2</li>
<li>解释: 最长公共子序列是 “f”,”o”</li>
</ul>
<p>【样例 2】:</p>
<ul>
<li>输入: “fosh” and “fish”</li>
<li>输出: 3</li>
<li>解释: 最长公共子序列是 “f”,”s”,”h”</li>
</ul>
<h3 id="2-3-2-题解"><a href="#2-3-2-题解" class="headerlink" title="2.3.2 题解"></a>2.3.2 题解</h3><p>将两个单词的字母分列为横纵轴，如下图所示。</p>
<p>因为公共子序列有顺序的要求，但是没有连续的要求（如is和si就不是一个公共子序列，但ios和is中的is是公共子序列），所以在矩阵当中，某个字母相等的单元格的左上部分存在另一个字母相等的单元格，才是公共子序列出现的时候。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5ce30f61ba85ff4958b92a5ff78c1fe8a45.png" alt=""></p>
<p>但因为公共子序列没有连续的要求，故而两个1，可能离得有点远，没法像最长公共子串那一题一样直接根据左上相邻单元格来判断，所以在该题状态转移方程中，我们要注意将1一直传递下去。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-d671671532f7c420a05c31da74ec67b099c.png" alt=""></p>
<p>所以我们得到状态转移方程：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6ce7c95efa043dec4651f7da63b41745970.png" alt=""></p>
<h3 id="2-3-3-代码"><a href="#2-3-3-代码" class="headerlink" title="2.3.3 代码"></a>2.3.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 最长公共子序列</span><br><span class="line"> * @param Str1: Str1 string</span><br><span class="line"> * @param str2: Str1 string</span><br><span class="line"> * @return: The length of longest common subsequence of Str1 and str2</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int longestCommonSubsequence(String Str1, String str2) &#123;</span><br><span class="line">    int result &#x3D; 0;</span><br><span class="line">    if (Str1.isEmpty()|| str2.isEmpty())&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 创建一个数组，存放已计算过的结果，填表法。</span><br><span class="line">    int[][] values &#x3D; new int[Str1.length()][str2.length()];</span><br><span class="line">    for (int i &#x3D; 0;i&lt;Str1.length();i++)&#123;</span><br><span class="line">        for (int j &#x3D; 0;j&lt;str2.length();j++)&#123;</span><br><span class="line">            &#x2F;&#x2F; 状态转移方程为：</span><br><span class="line">            &#x2F;&#x2F; 1. 当两个字母相等时，当前值取左上角的单元格的值+1</span><br><span class="line">            &#x2F;&#x2F; 2. 当两个字母不等时，当前值取左方和上方两个单元格中最大的值</span><br><span class="line">            if (Str1.charAt(i) &#x3D;&#x3D; str2.charAt(j))&#123;</span><br><span class="line">                values[i][j] &#x3D; getCachedValue(i-1,j-1,values)+1;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                values[i][j] &#x3D; Math.max(getCachedValue(i,j-1,values),getCachedValue(i-1,j,values));</span><br><span class="line">            &#125;</span><br><span class="line">            result &#x3D; Math.max(result,values[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private int getCachedValue(int i,int j,int[][] values)&#123;</span><br><span class="line">    if (i &lt; 0 || j &lt; 0)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return values[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%92%8C%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%92%8C%E6%95%B4%E7%90%86/" itemprop="url">排序算法汇总和整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-23T23:16:23+08:00">
                2020-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/12/23/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB%E5%92%8C%E6%95%B4%E7%90%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/12/23/排序算法汇总和整理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  8.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  33
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>排序算法可以分为两大类：</p>
<ol>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/up-beed8280c979c6aa1de039bba09260c558e.png" alt=""></p>
<p>其中这些算法的复杂度如下表格：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>时间复杂度（最好）</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
<td></td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(nlogn)</td>
<td>O(logn)~O(n)</td>
<td>不稳定</td>
<td>O(logn)~O(n)分别表示最好情况和最坏情况</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.3)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
<td></td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>稳定</td>
<td>k为元素值范围差，或者说元素值的数量</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+nlogn-nlogk)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>O(n+k)</td>
<td>稳定</td>
<td>k表示桶个数</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(d(n+r))</td>
<td>O(n+r)</td>
<td>稳定</td>
<td>d表示最大数字的位数，r表示基数，数字固定是10</td>
</tr>
</tbody></table>
<blockquote>
<p>稳定性：如果a原本在b前面，而a=b，排序之后a仍然在b的前面，则表示该算法是稳定的排序算法。</p>
</blockquote>
<h1 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1 冒泡排序（Bubble Sort）"></a>1 冒泡排序（Bubble Sort）</h1><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的数列，每一次比较两个元素，如果它们的顺序错误就把它们交换过来。</p>
<p>遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>
<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><strong>1.1 算法描述</strong></p>
<p>冒泡排序的算法步骤如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，直到排序完成。</li>
</ol>
<p><strong>1.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-dfb064de1152d2a9bf4e14aa204d13262a0.gif" alt=""></p>
<p><strong>1.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort() &#123;</span><br><span class="line">	int[] arr &#x3D; new int[]&#123;-12, 3, 2, 34, 5, 8, 1&#125;;</span><br><span class="line">	&#x2F;&#x2F; 冒泡排序，外层循环确定“冒泡”的次数，一共要进行n次冒泡</span><br><span class="line">	&#x2F;&#x2F; 每次冒泡完成，都会将当前数列的最大值推到数列尾端</span><br><span class="line">	for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">		&#x2F;&#x2F; 这一层循环是控制单次“冒泡”的，每次“冒泡”的遍历范围是未排序的部分数列</span><br><span class="line">		&#x2F;&#x2F; 所以j值小于arr.length-1-i，因为第i轮“冒泡”，数列的尾端就有i位已经排好序了。</span><br><span class="line">		for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">			&#x2F;&#x2F; 随着j的增大，泡沫逐渐上浮，如果相邻的两项顺序不是我们希望的，那么要交换顺序</span><br><span class="line">			if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">				&#x2F;&#x2F; 交换顺序</span><br><span class="line">				int temp &#x3D; arr[j];</span><br><span class="line">				arr[j] &#x3D; arr[j + 1];</span><br><span class="line">				arr[j + 1] &#x3D; temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由代码可见，冒泡排序的时间复杂度是O(n^2)，不过值得注意的是，在最好的情况下（即当前数列已经是我们想要的顺序了），它的时间复杂度是O(n)。要想得到线性的时间复杂度，我们需要改造一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort() &#123;</span><br><span class="line">	int[] arr &#x3D; &#123;1,3,2,45,65,33,12&#125;;</span><br><span class="line">	&#x2F;&#x2F; 添加一个变量来标记是否进行了交换操作</span><br><span class="line">	boolean didSwap &#x3D; false;</span><br><span class="line">	&#x2F;&#x2F; 冒泡排序，外层循环确定“冒泡”的次数，一共要进行n次冒泡</span><br><span class="line">	&#x2F;&#x2F; 每次冒泡完成，都会将当前数列的最大值推到数列尾端</span><br><span class="line">	for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">		&#x2F;&#x2F; 这一层循环是控制单次“冒泡”的，每次“冒泡”的遍历范围是未排序的部分数列</span><br><span class="line">		&#x2F;&#x2F; 所以j值小于arr.length-1-i，因为第i轮“冒泡”，数列的尾端就有i位已经排好序了。</span><br><span class="line">		for (int j &#x3D; 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">			&#x2F;&#x2F; 随着j的增大，泡沫逐渐上浮，如果相邻的两项顺序不是我们希望的，那么要交换顺序</span><br><span class="line">			if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">				&#x2F;&#x2F; 交换顺序</span><br><span class="line">				int temp &#x3D; arr[j];</span><br><span class="line">				arr[j] &#x3D; arr[j + 1];</span><br><span class="line">				arr[j + 1] &#x3D; temp;</span><br><span class="line">				didSwap &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; 如果一次冒泡过程中，一次交换操作都没执行，那说明数列已经有序了，直接返回</span><br><span class="line">		if(didSwap &#x3D;&#x3D; false) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-选择排序（Selection-Sort）"><a href="#2-选择排序（Selection-Sort）" class="headerlink" title="2 选择排序（Selection Sort）"></a>2 选择排序（Selection Sort）</h1><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<p><strong>2.1 算法描述</strong></p>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li>初始状态：无序区为<code>R[1,n]</code>，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为<code>R[1,i-1]</code>和<code>R(i,n）</code>。该趟排序从当前无序区中选出关键字最小的记录 <code>R[k]</code>，将它与无序区的第1个记录R交换，使<code>R[1,i]</code>和<code>R[i+1,n)</code>分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟选择，排序完成。</li>
</ol>
<p><strong>2.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-af80fe9d723b1f2ad1979e1b2a6fcb60940.gif" alt=""></p>
<p><strong>2.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void selectionSort() &#123;</span><br><span class="line">	int[] arr &#x3D; &#123;1,3,2,45,65,33,12&#125;;</span><br><span class="line">	&#x2F;&#x2F; 做第i趟选择排序，[0,i)是有序区</span><br><span class="line">	for(int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">		int minValIdx &#x3D; i;</span><br><span class="line">		&#x2F;&#x2F; 遍历无序区[i,n]</span><br><span class="line">		for(int j &#x3D; minValIdx + 1; j &lt; arr.length; j++)&#123;</span><br><span class="line">			if(arr[j] &lt; arr[minValIdx])&#123;</span><br><span class="line">				&#x2F;&#x2F;记下目前找到的最小值所在的位置</span><br><span class="line">				minValIdx &#x3D; j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span><br><span class="line">		if(i !&#x3D; minValIdx)&#123;</span><br><span class="line">			&#x2F;&#x2F;交换a[i]和a[minValIdx]</span><br><span class="line">			int temp &#x3D; arr[i];</span><br><span class="line">			arr[i] &#x3D; arr[minValIdx];</span><br><span class="line">			arr[minValIdx] &#x3D; temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.4 算法总结</strong></p>
<p>选择排序是表现最稳定的排序算法之一，因为无论什么数据进去都是O(n^2)的时间复杂度，所以用到它的时候，数据规模越小越好。</p>
<p>同时值得注意的是，它还是不稳定的，如何理解选择排序是不稳定的呢？</p>
<p>举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<p>唯一的好处可能就是不占用额外的内存空间。选择排序也是一般人想到的最多的排序方法，它的排序思路非常的常规。</p>
<h1 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3 插入排序（Insertion Sort）"></a>3 插入排序（Insertion Sort）</h1><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p><strong>3.1 算法描述</strong></p>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的有序区间中从后向前扫描；</li>
<li>如果当前被扫描的元素（已排序）大于新元素，将该元素移到下一位置，即将它的空间让出来；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置；</li>
<li>重复步骤2~5。</li>
</ol>
<p><strong>3.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-da58c3f1d442fe72549dc2e08c286732249.gif" alt=""></p>
<p><strong>3.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void insertionSort()&#123;</span><br><span class="line">	int[] arr &#x3D; &#123;1,3,2,45,65,33,12&#125;;</span><br><span class="line">	&#x2F;&#x2F; i控制有序区[0,i),i从1开始，说明arr[0]一开始默认有序</span><br><span class="line">	&#x2F;&#x2F; 同时arr[i]即为这一趟排序，要被用来插入的值</span><br><span class="line">	for(int i&#x3D;1; i&lt;arr.length; i++)&#123;</span><br><span class="line">		int val &#x3D; arr[i];</span><br><span class="line">		&#x2F;&#x2F; j是在有序区[0,i)之间从前向后遍历的指针</span><br><span class="line">		for(int j&#x3D;i-1; j&gt;0; j--)&#123;</span><br><span class="line">			&#x2F;&#x2F; 如果j的值比val大，那么j向后挪一个位置</span><br><span class="line">			if(arr[j] &gt; val)&#123;</span><br><span class="line">				arr[j+1] &#x3D; arr[j];</span><br><span class="line">			&#125; else &#123;&#x2F;&#x2F; 否则，说明找到了val应该在的位置</span><br><span class="line">				arr[j+1] &#x3D; val;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.4 算法总结</strong></p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>值得注意的是，插入排序最好情况（数列本身已经有序）的时间复杂度是O(n)，也就是说，每一趟的插入操作，都是第一步就找到了插入的位置，这样的时间复杂度是线性的。</p>
<h1 id="4-快速排序（Quick-Sort）"><a href="#4-快速排序（Quick-Sort）" class="headerlink" title="4 快速排序（Quick Sort）"></a>4 快速排序（Quick Sort）</h1><p>快速排序是采用分治法的思路：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><strong>4.1 算法描述</strong></p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；一般都采用当前数列的第一个元素作为pivot。</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列，重复步骤1-2进行递归排序，直到所有子数列都有序为止。</li>
</ol>
<p><strong>4.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5cf2b1b31e71659b0e7518866bfc86e666a.gif" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-08ed33c9ac31e8e749f25e81cddde9b605e.gif" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6e51fb60e5fe3cb98438e420bfc296fd9e4.gif" alt="quick sort" title="quick sort"></p>
<p><strong>4.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param arr        待排序列</span><br><span class="line"> * @param start  待排序列起始位置</span><br><span class="line"> * @param end 待排序列结束位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static void quickSort(int[] arr, int start, int end) &#123;</span><br><span class="line">	if (start &gt;&#x3D; end) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	int left &#x3D; start;</span><br><span class="line">	int right &#x3D; end;</span><br><span class="line">	&#x2F;&#x2F;待排序的第一个元素作为基准值</span><br><span class="line">	int pivot &#x3D; arr[left];</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;从左右两边交替扫描，直到left &#x3D; right</span><br><span class="line">	while (left &lt; right) &#123;</span><br><span class="line">		while (right &gt; left &amp;&amp; arr[right] &gt;&#x3D; pivot) &#123;</span><br><span class="line">			&#x2F;&#x2F;从右往左扫描，找到第一个比基准值小的元素</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;找到这种元素将arr[right]放入arr[left]中</span><br><span class="line">		arr[left] &#x3D; arr[right];</span><br><span class="line"></span><br><span class="line">		while (left &lt; right &amp;&amp; arr[left] &lt;&#x3D; pivot) &#123;</span><br><span class="line">			&#x2F;&#x2F;从左往右扫描，找到第一个比基准值大的元素</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;找到这种元素将arr[left]放入arr[right]中</span><br><span class="line">		arr[right] &#x3D; arr[left];</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;基准值归位</span><br><span class="line">	arr[left] &#x3D; pivot;</span><br><span class="line">	&#x2F;&#x2F;对基准值左边的元素进行递归排序</span><br><span class="line">	quickSort(arr, start, left - 1);</span><br><span class="line">	&#x2F;&#x2F;对基准值右边的元素进行递归排序。</span><br><span class="line">	quickSort(arr, right + 1, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.4 算法总结</strong></p>
<p>快速排序顾名思义，它的性能可以达到比较类排序算法最高的O(nlogn)级别。不过由于分治法主要采用递归实现，所以它也是有额外的递归造成的栈空间的使用。因为一般情况下，快排会递归logn次，所以他的空间复杂度是O(logn)。</p>
<p>可惜的是，由于关键字的比较和交换是跳跃进行的，因此，<strong>快速排序是一种不稳定的排序方法</strong>。</p>
<p>快排的最坏情况，是每次分隔，生成的两个subList都有一个是空集合，也就是每次选取的pivot是当前数列的最小值或者最大值，无法达到二分的效果。这种情况下，它的时间复杂度是O(n^2)，空间复杂度是O(n)。</p>
<h1 id="5-希尔排序（Shell’s-Sort）"><a href="#5-希尔排序（Shell’s-Sort）" class="headerlink" title="5 希尔排序（Shell’s Sort）"></a>5 希尔排序（Shell’s Sort）</h1><p>希尔排序(Shell’s Sort)是插入排序的一种，又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本，它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>
<p>希尔排序是非稳定排序算法，也是第一个突破O(n2)的排序算法。</p>
<p>该方法因 D.L.Shell 于 1959 年提出而得名。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>因为插入排序每次遍历一遍完整数组，只能将一个元素移动到已排序区间的正确位置。当n值很大时，为了找到移动一个元素到正确位置的时间太长了，所以插入排序一般来说是低效的算法。</li>
</ol>
<p>基于插入排序上述的这两点性质，希尔排序通过分组，达到了如下三个目的：</p>
<ol>
<li>通过分组，使得每个子序列的长度减少，使得每一次遍历，能较快的将一个元素确定位置。虽然这时确定的只是改元素在分组内的位置，可能并非整个序列的正确位置，但此时已经接近于它们排序后的最终位置了。</li>
<li>通过分组，使得只要完整遍历一次整个序列的时间，就可以使每个分组内都有一个元素确定大概的位置，相比于插入排序的一次完整遍历只能确定一个元素的正确位置，性能提升非常明显。</li>
<li>通过分组进行插入排序，使得希尔排序在进行最后一次全序列的插入排序时，基本上每个元素所在的位置已经接近于它排序后正确的位置了，面对这样的情况，插入排序的性能可以达到接近线性时间，即O(n)。</li>
</ol>
<p><strong>5.1 算法描述</strong></p>
<p>先将整个待排序的序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li>选择一个增量gap，一般默认初始为length/2。</li>
<li>确定了gap后，则可以得到如下gap个分组，每个分组最多有length/gap个元素，如gap=length/2时分组如：<code>{arr[0],arr[gap]}，{arr[1],arr[gap+1]}.....{arr[gap-1],arr[length-1]}</code></li>
<li>对每个分组，执行插入排序。</li>
<li>再确定一个新的gap，一般为再缩小一倍，gap=gap/2</li>
<li>重复步骤2、3、4，直到gap=1为止，这时不存在其他分组了，最后执行一次对整个序列的插入排序，算法结束。</li>
</ol>
<p><strong>5.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bec5b473f7795fd8b71884b45b484570a06.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-347588d22829aca9eecc3516801abe00a02.gif" alt=""></p>
<p><strong>5.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static void shellSort(int[] arr, int start, int end) &#123;</span><br><span class="line">    int[] array&#x3D;&#123;49,38,65,97,76,13,27,49,78,34,12,64,1&#125;;</span><br><span class="line">    &#x2F;&#x2F;希尔排序</span><br><span class="line">    int gap &#x3D; array.length;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        gap &#x2F;&#x3D; 2;   &#x2F;&#x2F;增量每次减半</span><br><span class="line">        for (int i &#x3D; 0; i &lt; gap; i++) &#123;&#x2F;&#x2F; i控制分组，</span><br><span class="line">            for (int j &#x3D; i + gap; j &lt; array.length; j +&#x3D; gap) &#123;&#x2F;&#x2F;这个循环里其实就是一个插入排序</span><br><span class="line">                int k &#x3D; j - gap;&#x2F;&#x2F; k是组内元素的index</span><br><span class="line">                while (k &gt;&#x3D; 0 &amp;&amp; array[k] &gt; array[k+gap]) &#123;</span><br><span class="line">                    int temp &#x3D; array[k];</span><br><span class="line">                    array[k] &#x3D; array[k+gap];</span><br><span class="line">                    array[k + gap] &#x3D; temp;</span><br><span class="line">                    k -&#x3D; gap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (gap &#x3D;&#x3D; 1)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5.4 算法总结</strong></p>
<p>希尔排序的时间的平均时间复杂度为O(n^1.3)，希尔排序时间复杂度最快的是O(nlog(2n))，没有快速排序算法O(n(logn))快，因此希尔排序在中等大小规模时表现良好，但对规模非常大的数据排序不是最优选择。</p>
<p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的。</p>
<p>希尔排序非常容易实现，算法代码短而简单。 此外，希尔算法在最坏的情况下和平均情况下执行效率相差不是很多，一般来说，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法。</p>
<h1 id="6-归并排序（Merge-Sort）"><a href="#6-归并排序（Merge-Sort）" class="headerlink" title="6 归并排序（Merge Sort）"></a>6 归并排序（Merge Sort）</h1><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列</p>
<p><strong>6.1 算法描述</strong></p>
<ol>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序，再进行对半分，一直分到子序列的长度为1为止。</li>
<li>将两个排序好的子序列合并，递归回溯，最后归并成一个最终的排序序列。</li>
</ol>
<p><strong>6.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-c881994adeb171e99e6be71f3ee732ec044.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-28613ef2f194bd421ca494db2cc9bcef9a9.gif" alt=""></p>
<p><strong>6.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] nums &#x3D; new int[] &#123; 9, 8, 7, 6, 5, 4, 3, 2, 10,7,21,15,9,7,42 &#125;;</span><br><span class="line">    int[] newNums &#x3D; new int[nums.length];</span><br><span class="line">    mergeSort(nums,newNums, 0, nums.length - 1);</span><br><span class="line">    for (int x : newNums) &#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void mergeSort(int[] nums,int[] newNums, int left, int right) &#123;</span><br><span class="line">    if (left &#x3D;&#x3D; right)</span><br><span class="line">        return;</span><br><span class="line">    &#x2F;&#x2F; 归并排序就是不断的在nums和newNums之间相互倒腾数据，每次递归都发生两次倒腾。</span><br><span class="line">    int mid &#x3D; left + (right - left) &#x2F; 2;</span><br><span class="line">    int leftArrIdx &#x3D; left, rightArrIdx &#x3D; mid + 1;</span><br><span class="line">    mergeSort(nums,newNums, leftArrIdx, mid); &#x2F;&#x2F;左有序数组</span><br><span class="line">    mergeSort(nums,newNums, rightArrIdx, right); &#x2F;&#x2F;右有序数组</span><br><span class="line"></span><br><span class="line">    int newArrIdx &#x3D; leftArrIdx;</span><br><span class="line">    &#x2F;&#x2F; 此时，leftArr &#x3D; nums的[leftArrIdx,mid]区间，rightArr &#x3D; nums的[rightArrIdx,right]区间</span><br><span class="line">    &#x2F;&#x2F; leftArr和rightArr都有序了，接下来进行第一次倒腾。</span><br><span class="line">    &#x2F;&#x2F; 三个指针控制，在把leftArr和rightArr的数组搬运到newNums对应位置的期间顺便进行合并（再排序）</span><br><span class="line">    &#x2F;&#x2F; 每次循环，leftArr和rightArr中，两个被指针指向的元素，较小的那个才会加入newNums</span><br><span class="line">    while (leftArrIdx &lt;&#x3D; mid &amp;&amp; rightArrIdx &lt;&#x3D; right) &#123;</span><br><span class="line">        newNums[newArrIdx++] &#x3D; nums[leftArrIdx] &lt; nums[rightArrIdx] ? nums[leftArrIdx++] : nums[rightArrIdx++];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果rightArr都加入newNum了，leftArr还有剩余，则把leftArr一股脑加进去</span><br><span class="line">    while (leftArrIdx &lt;&#x3D; mid)</span><br><span class="line">        newNums[newArrIdx++] &#x3D; nums[leftArrIdx++];</span><br><span class="line">    &#x2F;&#x2F; 如果leftArr都加入newNum了，rightArr还有剩余，则把rightArr一股脑加进去</span><br><span class="line">    while (rightArrIdx &lt;&#x3D; right)</span><br><span class="line">        newNums[newArrIdx++] &#x3D; nums[rightArrIdx++];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 到这里为止，newNums的[letf,right]已经是有序的了。</span><br><span class="line">    &#x2F;&#x2F; 但nums的[letf,right]区间还是无序的，还是分成了[left,mid]和[mid+1,right]这两个有序区间</span><br><span class="line">    &#x2F;&#x2F; 这时用newNums的顺序覆盖nums，这一步不是多余的，因为递归出栈后，逻辑是从nums里面拿排序好的数据</span><br><span class="line">    &#x2F;&#x2F; 所以进行第二次倒腾，第二次倒腾是为了递归出栈后的第一次倒腾有意义。</span><br><span class="line">    for(int i&#x3D;left;i &lt;&#x3D; right;i++)&#123;</span><br><span class="line">        nums[i] &#x3D; newNums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6.4 算法总结</strong></p>
<p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>
<p>速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p>
<h1 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7 堆排序（Heap Sort）"></a>7 堆排序（Heap Sort）</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>7.1 算法描述</strong></p>
<ol>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。</li>
<li>不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ol>
<p><strong>7.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b4a555766505348b187cf66d4519789ced4.gif" alt=""></p>
<p><strong>7.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    int[] arr &#x3D; &#123;1, 4, 6, 8, 2, 5, 3, 7, 9&#125;;</span><br><span class="line">    heapSort(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public static void heapSort(int[] arr) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 首先我们要明确下，用数组表示堆&#x2F;二叉树的时候，有如下公式：</span><br><span class="line">    &#x2F;&#x2F; 1. arr[0]到arr[length&#x2F;2],都是非叶子节点</span><br><span class="line">    &#x2F;&#x2F; 2. 对于某个节点arr[i]，则可知它的左子结点是arr[2i+1]，右子结点是arr[2i+2]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 循环建立初始堆，大顶堆</span><br><span class="line">    &#x2F;&#x2F; parentIdx从后往前遍历，说明进行上滤操作，调整是从下而上的</span><br><span class="line">    &#x2F;&#x2F; 创建初始堆之所以要从下而上，是因为现在整个堆都是无序的</span><br><span class="line">    for (int parentIdx &#x3D; arr.length &#x2F; 2; parentIdx &gt;&#x3D; 0; parentIdx--) &#123;</span><br><span class="line">        heapAdjust(arr, parentIdx, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; lastUnsorted，指向未排序区间的最后一个元素</span><br><span class="line">    for (int lastUnsorted &#x3D; arr.length - 1; lastUnsorted &gt; 0; lastUnsorted--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将 堆顶元素 和 未排序区间的最后一个元素 进行交换</span><br><span class="line">        int temp &#x3D; arr[lastUnsorted];</span><br><span class="line">        arr[lastUnsorted] &#x3D; arr[0];</span><br><span class="line">        arr[0] &#x3D; temp;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 重新调整堆，此时要从上而下调整，进行下滤操作，</span><br><span class="line">        &#x2F;&#x2F; 因为此时除了堆顶，其他节点都有序了，这种情况下滤操作更快</span><br><span class="line">        heapAdjust(arr, 0, lastUnsorted);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void heapAdjust(int[] arr, int parent, int length) &#123;</span><br><span class="line">    int left &#x3D; 2 * parent + 1; &#x2F;&#x2F; 左孩子</span><br><span class="line">    int right &#x3D; 2 * parent + 2; &#x2F;&#x2F; 右孩子</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果左子结点大于父节点，交换</span><br><span class="line">    if (left &lt; length &amp;&amp; arr[left] &gt; arr[parent]) &#123;</span><br><span class="line">        swap(arr,parent,left);</span><br><span class="line">        heapAdjust(arr, left,length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果右子结点大于父节点，交换</span><br><span class="line">    if (right &lt; length &amp;&amp; arr[right] &gt; arr[parent]) &#123;</span><br><span class="line">        swap(arr,parent,right);</span><br><span class="line">        heapAdjust(arr, right,length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] arr, int i, int j) &#123;</span><br><span class="line">    int temp &#x3D; arr[i];</span><br><span class="line">    arr[i] &#x3D; arr[j];</span><br><span class="line">    arr[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>7.4 算法总结</strong></p>
<p>堆排序是一种不稳定的选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。</p>
<p>所以堆排序时间复杂度一般认为就是O(nlogn)级。时间复杂度很稳定，都是O(nlogn)。</p>
<h1 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8 计数排序（Counting Sort）"></a>8 计数排序（Counting Sort）</h1><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p><strong>8.1 算法描述</strong></p>
<ol>
<li>找出待排序的数组A中最大元素值max和最小元素值min，并创建一个长度为max-min的数组C。</li>
<li>统计数组A中每个值为i的元素出现的次数，存入数组C的第i-min项；</li>
<li>数组C从小到大填充原数组A，数组C从第0项开始，每一项i输出C[i]次，输出的值是i+min。</li>
</ol>
<p><strong>8.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-3a45777ec71d4b68fb8282cd8fdbd2f0ba0.gif" alt=""></p>
<p><strong>8.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void countingSort(int[] arr) &#123;</span><br><span class="line">    int min&#x3D;Integer.MAX_VALUE,max&#x3D;Integer.MIN_VALUE;</span><br><span class="line">    for (int val : arr)&#123;</span><br><span class="line">        max &#x3D; Math.max(max, val);</span><br><span class="line">        min &#x3D; Math.min(min, val);</span><br><span class="line">    &#125;</span><br><span class="line">    int[] bucket &#x3D; new int[max-min+1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int val : arr) &#123;</span><br><span class="line">        bucket[val-min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sortedIndex&#x3D;0;</span><br><span class="line">    for (int i &#x3D; 0;i &lt; bucket.length;i++) &#123;</span><br><span class="line">        while(bucket[i] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] &#x3D; i+min;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>8.4 算法总结</strong></p>
<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个范围差为k的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h1 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9 桶排序（Bucket Sort）"></a>9 桶排序（Bucket Sort）</h1><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（一般使用快排），最后把每个桶里排好序的数据拼接起来。</p>
<p>算法思想和散列中的开散列法差不多，当冲突时放入同一个桶中；可应用于数据量分布比较均匀，或比较侧重于区间数量时。</p>
<p>桶排序利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>我们用k表示桶的个数，那假设数据是均匀分布的，则每个桶的元素平均个数为n/k，那么桶排序的时间复杂度是O(n+nlog(n/k))=O(n+nlogn-nlogk)。</p>
<p>故而我们可以很明显的看出，O(n+nlogn-nlogk)，为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量，即k越大越好。当然，做到这一点很不容易，数据量巨大的情况下，映射函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中，使得每个桶内的排序性能接近。（试想一下极端情况，所有元素都在一个桶内，那时间复杂度就是快排的O(nlogn)了）</li>
</ol>
<p><strong>9.1 算法描述</strong></p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。 </li>
</ol>
<p><strong>9.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-5d7b7a7414e2c3e0b8661b7f06898fdecbd.png" alt=""></p>
<p><strong>9.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static void bucketSort(int[] arr,int bucketNum)&#123;</span><br><span class="line">    int max &#x3D; Integer.MIN_VALUE;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        max &#x3D; Math.max(max, arr[i]);</span><br><span class="line">        min &#x3D; Math.min(min, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;桶数</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr &#x3D; new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将每个元素放入桶</span><br><span class="line">    for(int i &#x3D; 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        int idx &#x3D; (arr[i]-min)&#x2F;(((max-min)&#x2F;bucketNum)+1);</span><br><span class="line">        bucketArr.get(idx).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(new Gson().toJson(bucketArr));</span><br><span class="line">    &#x2F;&#x2F;对每个桶进行排序</span><br><span class="line">    for(int i &#x3D; 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">        Collections.sort(bucketArr.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将桶内数据填回原数组</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (ArrayList&lt;Integer&gt; bucket : bucketArr)&#123;</span><br><span class="line">        if (bucket.isEmpty())&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int val : bucket)&#123;</span><br><span class="line">            arr[i++] &#x3D; val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9.4 算法总结</strong></p>
<p>桶排序在最优情况下（数组内的元素均匀分布，可以使得分桶后，每个桶内的元素数量差异不大），可以达到接近线性的时间复杂度，因为它不是比较排序算法，所以可以突破O(nlogn)的极限。</p>
<p>桶排序最坏的时间复杂度是O(nlogn)，也就是所有元素都在同一个桶内，这样相当于对整个列表使用了快排。</p>
<p>不过桶排序是稳定的排序算法。</p>
<h1 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10 基数排序（Radix Sort）"></a>10 基数排序（Radix Sort）</h1><p>基数排序是按照低位先排序，然后收集；再按照次低位排序，然后再收集；依次类推，直到最高位。</p>
<p>有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p>比如一系列两位数数字组成的序列，他们比大小，十位上的数字肯定优先级更高，个位上的数字优先级较低。我们先按照个位上的数字排序，再按照十位上的数字排序，那么就可以得到十位&gt;个位标准下的有序。</p>
<blockquote>
<p>换句话说，如果对于数字大小的评价标准是个位&gt;十位，那基数排序先判断十位再判断个位即可。</p>
</blockquote>
<p>在十进制数中，<strong>基数</strong>r就等于10，即表示最大有10种可能，最多需要10个桶来映射数组元素。</p>
<p><strong>10.1 算法描述</strong></p>
<ol>
<li>取得数组中的最大数，并取得位数，这就确定了我们最多要判断多少位。</li>
<li>将待排元素按照个位进行分桶；然后将这些桶中的元素按桶的编号重新串接起来，得到以个位排序完成的序列。</li>
<li>再对序列按照十位进行分桶，然后将这些桶中的元素按桶的编号重新串接起来，得到以十位排序完成的序列。</li>
<li>以此类推，一直到最高位进行分桶并且重新串接，最后得到完整排序的序列。</li>
</ol>
<p><strong>10.2 动图演示</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6274e50d68d284bd678d050abbd15001cf9.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-44175898186bf61ec2cc5b1dcb7b978ff25.gif" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-026bcce647bc3e389c8b4d002c7a2317123.gif" alt=""></p>
<p><strong>10.3 代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private static void radixsSort(int[] array) &#123;</span><br><span class="line">    &#x2F;&#x2F; 找到最大数</span><br><span class="line">    int max &#x3D; 0;</span><br><span class="line">    for (int i : array) &#123;</span><br><span class="line">        max &#x3D; Math.max(max,i);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 判断位数</span><br><span class="line">    int d &#x3D; 0;</span><br><span class="line">    while (max &gt; 0) &#123;</span><br><span class="line">        max &#x3D; max &#x2F; 10;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 数字的基数都是10，所以建立十个队列</span><br><span class="line">    List&lt;ArrayList&gt; bucket &#x3D; new ArrayList&lt;ArrayList&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ArrayList queue &#x3D; new ArrayList();</span><br><span class="line">        bucket.add(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 进行times次分配和收集</span><br><span class="line">    for (int i &#x3D; 0; i &lt; d; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 分配</span><br><span class="line">        for (int j &#x3D; 0; j &lt; array.length; j++) &#123;</span><br><span class="line">            int x &#x3D; array[j] % (int) Math.pow(10, i + 1) &#x2F; (int) Math.pow(10, i);</span><br><span class="line">            ArrayList queue &#x3D; bucket.get(x);</span><br><span class="line">            queue.add(array[j]);</span><br><span class="line">            bucket.set(x, queue);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 收集</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; 10; j++) &#123;</span><br><span class="line">            while (bucket.get(j).size() &gt; 0) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; queue &#x3D; bucket.get(j);</span><br><span class="line">                array[count] &#x3D; queue.get(0);</span><br><span class="line">                queue.remove(0);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>10.4 算法总结</strong></p>
<p>假设待排序的数组<code>R[1..n]</code>，数组中最大的数是d位数，基数为r。那么每处理一位数，就需要将数组元素映射到r个桶中，映射完成后还需要收集，相当于遍历一遍桶+遍历一遍数组，最多元素数为n，则处理一位数的时间复杂度为O(n+r)。处理d位数的总的时间复杂度为O(d*(n+r))。</p>
<p>基数排序的空间复杂度为O(n+r)，n表示n个指针，用来给桶内的元素做后驱指向，r则是开辟了长度为r的队列，用来当做r个桶。</p>
<p>基数排序基于分别排序，分别收集，所以是稳定的。</p>
<p>基数排序算法适用于位数不多，待排序列最大位数不是特别大，每一位数的范围不大的情况下（当然对于数字排序，每一位的范围都是<code>[0,9]</code>）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/07/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/07/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" itemprop="url">通俗易懂的二叉树的前中后序遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-07T22:04:56+08:00">
                2020-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91-%E5%A0%86/" itemprop="url" rel="index">
                    <span itemprop="name">树/堆</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/12/07/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/12/07/通俗易懂的二叉树的前中后序遍历/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  656
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>二叉树的遍历是指不重复地访问二叉树中所有结点，主要指非空二叉树，对于空二叉树则结束返回。二叉树的遍历主要包括前序遍历、中序遍历、后序遍历。</p>
<p>一棵二叉树由根结点、左子树和右子树三部分组成，若规定 D、L、R 分别代表遍历根结点、遍历左子树、遍历右子树，则二叉树的遍历方式有 6 种：DLR、DRL、LDR、LRD、RDL、RLD。由于先遍历左子树和先遍历右子树在算法设计上没有本质区别，所以默认都是先左后右，故而只讨论三种方式：</p>
<ul>
<li>DLR–前序遍历（根在前，从左往右，首先访问根结点，然后遍历左子树，最后遍历右子树，根-&gt;左-&gt;右）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-fe3d871ce8395fd6f34ee6645e1459ad9c0.png" alt=""></li>
</ul>
</li>
<li>LDR–中序遍历（根在中，从左往右，首先遍历左子树，然后访问根节点，最后遍历右子树，左-&gt;根-&gt;右）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-593f727f19cff095d4b280abe91a5d27f11.png" alt=""></li>
</ul>
</li>
<li>LRD–后序遍历（根在后，从左往右，首先遍历左子树，然后遍历右子树，最后访问根节点，左-&gt;右-&gt;根）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-f966df848db3ced6fdab494c8f42b1f5e83.png" alt=""></li>
</ul>
</li>
<li>层序遍历（除此之外，还有一种层序遍历，层序遍历嘛，就是按层，从上到下，从左到右遍历，这个没啥好说的）<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-714abe2c67cb4d4b9a07d258b045892b3c3.png" alt=""></li>
</ul>
</li>
</ul>
<blockquote>
<p>所以前中后序遍历的前/中/后，指的是根节点在前/中/后输出的意思，因此这三种遍历也称为先根遍历，中根遍历，后根遍历。</p>
</blockquote>
<p>本文就不掉书袋再复述前序/中序/后序遍历的教科书方法了。我们这里介绍一种易记的方法。</p>
<h1 id="1-先序遍历"><a href="#1-先序遍历" class="headerlink" title="1 先序遍历"></a>1 先序遍历</h1><p>先序遍历可以想象成，<strong>小人从树根开始绕着整棵树的外围转一圈，经过结点的顺序就是先序遍历的顺序</strong></p>
<p>先序遍历结果：ABDHIEJCFKG</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9b4a9d62bf8d228f2d211436db7a344cc99.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-78a1f955007b10af3e0f85fa67a66688ed6.gif" alt=""></p>
<h1 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2 中序遍历"></a>2 中序遍历</h1><p>中序遍历可以想象成，按树画好的左右位置<strong>投影</strong>下来就可以了</p>
<p>中序遍历结果：HDIBEJAFKCG</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-bdae9f8ceb4d9808fce19eb1464f3e7cef6.gif" alt=""></p>
<h1 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3 后序遍历"></a>3 后序遍历</h1><p>后序遍历就像是剪葡萄，我们要把一串葡萄剪成一颗一颗的。还记得我们先序遍历绕圈的路线么？就是<strong>围着树的外围绕一圈</strong>，如果发现一剪刀就能剪下的一颗葡萄（<strong>注意必须是一颗葡萄</strong>），就把它剪下来，组成的就是后序遍历了。</p>
<p>后序遍历结果：HIDJEBKFGCA</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f1147b85157f8610b3e2e7526ff416a3e2f.gif" alt=""></p>
<h1 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4 层序遍历"></a>4 层序遍历</h1><p>层序遍历太简单了，就是按照一层一层的顺序，从左到右写下来就行了。</p>
<p>后序遍历结果：ABCDEFGHIJK</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4ed54e9cad9b2c712408fa19d45b1b0d425.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-hand-o-right" aria-label="accessibility.next_page"></i></a>
  </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">425.4k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
