<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JAVA,JVM,class文件," />










<meta name="description" content="1 class文件结构 Class文件结构是了解虚拟机的重要基础之一，如果想深入的了解虚拟机，Class文件结构是不能不了解的。  Class文件是一组以8位字节为基础单位的二进制流，各项数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，如果是超过8位字节以上空间的数据项，则会按照高位在前的方式（Big-Endian）分割成若干个8位字节进行存储。（Big-Endian模">
<meta property="og:type" content="article">
<meta property="og:title" content="Class文件和类加载机制">
<meta property="og:url" content="http://yoursite.com/2019/12/03/Class%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="1 class文件结构 Class文件结构是了解虚拟机的重要基础之一，如果想深入的了解虚拟机，Class文件结构是不能不了解的。  Class文件是一组以8位字节为基础单位的二进制流，各项数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，如果是超过8位字节以上空间的数据项，则会按照高位在前的方式（Big-Endian）分割成若干个8位字节进行存储。（Big-Endian模">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-4ba7398c95ae3265cf9332d9761b6160b9a.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-30ad9cf600f13a0f540843512252923e335.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-5a1dc07d76e9c0a28e062301b28727fe654.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-49edc6b667c3b7b848c539852736ab72b9c.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-578f90a99345cf296903932a1c26223202d.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-cf8c4d9d9963e0af80de6ec7f744e3a6cc3.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-9df277841bf95f2056917158b5becf38812.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-6bc20666d6f49db2c6069a6a040fb8899e9.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-b35f5e3bca8690a449ea15aaad29418860d.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-49563d3e5f1385282014a4de040f188d14e.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-ef3a3608c87b67b9e8a868b39fcc8c8c4bb.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-7a9b0f82f5daae316c14588e6ff88472bed.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-fb5d03169ec70161436339635bb6852bdf2.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-aecdf06ebdaf14cd2c4aae8bf8ff82917fe.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-b2a280abbfbb65133ba325367f48302bb26.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-9fa65bd813bf963ab289294e91e4999f4e1.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-f4bc87d6a053a2e25007351ed3086f13570.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-18972444f8c9359ed0dfa0b2feb46ea0dda.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-257e2c34636c8652be0f226ddada6202aad.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-e528b6e0fce95406fef545eb9d0df2282e0.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-a8fc433e06919ce8b5789af9ce6ee5c6934.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/up-de58eeaf1c8e7d2b3a81cd80af628b1e537.png">
<meta property="article:published_time" content="2019-12-03T14:59:01.000Z">
<meta property="article:modified_time" content="2020-03-09T14:37:34.187Z">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="class文件">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oscimg.oschina.net/oscnet/up-4ba7398c95ae3265cf9332d9761b6160b9a.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/12/03/Class文件和类加载机制/"/>





  <title>Class文件和类加载机制 | cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/03/Class%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Class文件和类加载机制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-03T22:59:01+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA-JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/03/Class%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/12/03/Class文件和类加载机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  11.3k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  40
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-class文件结构"><a href="#1-class文件结构" class="headerlink" title="1 class文件结构"></a>1 class文件结构</h1><ul>
<li><p>Class文件结构是了解虚拟机的重要基础之一，如果想深入的了解虚拟机，Class文件结构是不能不了解的。</p>
</li>
<li><p>Class文件是一组以8位字节为基础单位的二进制流，各项数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，如果是超过8位字节以上空间的数据项，则会按照高位在前的方式（Big-Endian）分割成若干个8位字节进行存储。（Big-Endian模式具体可见<a href="https://blog.csdn.net/zhangpinghao/article/details/14031857" target="_blank" rel="noopener" title="详解大端模式和小端模式">详解大端模式和小端模式</a>）</p>
</li>
<li><p>Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。</p>
</li>
<li><p>Class文件格式只有两种数据类型：无符号数和表。</p>
<ul>
<li>无符号数属于基本的数据类型，以u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节和8个字节的无符号数；可用来描述数字，索引引用，数量值或者按照UTF-8编码构成的字符串值。</li>
<li>表是由<strong>多个无符号数或者其他表作为数据项构成的复合数据类型</strong>，所有表都习惯性地以“_info”结尾。表用于描述由层次关系的复合结构的数据。</li>
</ul>
</li>
<li><p>整个Class文件本质上就是一张表</p>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/up-4ba7398c95ae3265cf9332d9761b6160b9a.png" alt=""></p>
<blockquote>
<p>class文件的内容中没有任何的分隔符号，所以在上表中的数据项，无论是顺序还是数量，都是被严格限定的，哪个字节代表什么含义，长度多少，先后顺序如何，都不允许改变。</p>
</blockquote>
<h2 id="1-1-魔数和class文件的版本"><a href="#1-1-魔数和class文件的版本" class="headerlink" title="1.1 魔数和class文件的版本"></a>1.1 魔数和class文件的版本</h2><ul>
<li><p>Class文件的头4个字节成为魔数（Magic Number），它唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件，他是一个固定的值： 0XCAFEBABE（咖啡宝贝）。如果开头四个字节不是0XCAFEBABE， 那么就说明它不是class文件， 不能被JVM识别</p>
<ul>
<li>文件存储标准中都使用魔数来进行身份识别，比如图片格式，gif和JPEG等文件头中都存有魔数。使用魔数而非拓展名来识别身份，主要是基于安全方面的考虑，因为文件拓展名可以随意修改。</li>
</ul>
</li>
<li><p>紧接着魔数的4个字节是Class文件的版本号：第5,6字节是<strong>次版本号</strong>（Minor Version）,第7,8字节是<strong>主版本号</strong>（Major Version）。</p>
<ul>
<li>java版本号从45开始，jdk1.1以后每个jdk大版本发布，<strong>主版本</strong>号向上加1。（jdk1.0<del>1.1使用了45.0</del>45.3的版本号）</li>
<li>一般情况下， 高版本的JVM能识别低版本的javac编译器编译的class文件， 而低版本的JVM不能识别高版本的javac编译器编译的class文件。 如果使用低版本的JVM执行高版本的class文件， JVM会抛出java.lang.UnsupportedClassVersionError 。</li>
<li>下图为jdk1.1到jdk1.7，主流jdk编译器输出的默认和可支持的class文件版本号：</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-30ad9cf600f13a0f540843512252923e335.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="1-2-常量池"><a href="#1-2-常量池" class="headerlink" title="1.2 常量池"></a>1.2 常量池</h2><ul>
<li>紧接着主次版本号之后是常量池入口，由于常量池中<strong>常量的数量</strong>是不固定的，所以在常量池的入口需要放置一个常量池容量计数值（constant_pool_count）,这个容量计数是从1而不是0开始的，设计者这样设计的目的是为了满足后面某些指向常量池的索引值的数据在特殊情况下需要表达“不引用任何一个常量池项目”的含义。（所以上表中常量的数量为（constant_pool_count-1），因为第一项是计数器不，不是常量项）</li>
</ul>
<ul>
<li><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用。</p>
<ul>
<li>字面量接近Java语言层面的常量概念，如文本字符串、声明为final的常量值等。</li>
<li>符号引用属于编译原理的概念，包括三类常量：<ol>
<li>类和接口的全限定名；</li>
<li>字段的名称和描述符；</li>
<li>方法的名称和描述符。</li>
</ol>
</li>
<li><blockquote>
<p>符号引用 ：符号引用以一组符号来描述所引用的目标。符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和虚拟机的布局无关。可以理解为：在编译的时候虚拟机并不知道引用对象的直接地址，多以就用符号引用来代替，而在解析阶段，就是为了把这个符号引用转化成为真正的地址的阶段。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>常量池中每一项常量都是一个表，在JDK1.7之后共有14种表结构（有14种不代表每个类的常量池都有全部的14种）。它们有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag，取值见下表），代表当前这个常量属于哪种常量类型。</p>
</li>
<li><p><img src="https://oscimg.oschina.net/oscnet/up-5a1dc07d76e9c0a28e062301b28727fe654.png" alt=""></p>
</li>
<li><p>这14种常量类型各自有自己的结构，下面列出每个常量项的结构及含义</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-49edc6b667c3b7b848c539852736ab72b9c.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="1-3-访问标志"><a href="#1-3-访问标志" class="headerlink" title="1.3 访问标志"></a>1.3 访问标志</h2><ul>
<li><p>紧接着常量池之后的2个字节代表访问标志（access_flags），用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口、是否为public类型、是否为abstract类型、类是否声明为final等。标志位及其含义如下表</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-578f90a99345cf296903932a1c26223202d.png" alt=""></li>
</ul>
</li>
<li><p>假设一个类为普通java类，不是接口，不是枚举或者注解，被public修士但没有被声明为final和abstract，那么它的ACC_PUBLIC标志应该为真（即为1），而ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT等标志位都应该为假。</p>
</li>
<li><p>access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没用使用到的标志位要求一律为0。</p>
</li>
</ul>
<h2 id="1-4-类索引、父类索引与接口索引集合"><a href="#1-4-类索引、父类索引与接口索引集合" class="headerlink" title="1.4 类索引、父类索引与接口索引集合"></a>1.4 类索引、父类索引与接口索引集合</h2><ul>
<li><p>Class文件中由 索引、父类索引与接口索引集合 这三项数据来确定这个类的继承关系。</p>
</li>
<li><p>访问标志之后顺序排列类索引、父类索引、接口索引集合。</p>
</li>
<li><p>类索引两个字节，用于确定这个类的全限定名。</p>
</li>
<li><p>父类索引两个字节，用于确定这个类的父类的全限定名。因为java不允许多继承，所以只有一个父类索引，除了Object类以外，所有的类都有父类索引。Object的父类索引值为0；</p>
</li>
<li><p>类索引和父类索引的值都指向了一个类型为CONSTANT_Class_info的类描述符常量，通过前文我们知道通过CONSTANT_Class_info类型中的index值可以定位到一个CONSTANT_Utf8_info类型的常量，该常量中有全限定名字符串。下图展示了其索引过程：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-cf8c4d9d9963e0af80de6ec7f744e3a6cc3.png" alt=""></li>
</ul>
</li>
<li><p>接口索引集合大小不确定，用来描述这个类实现了哪些接口。接口索引集合入口第一项是u2类型的接口计数器（interfaces_count）表示索引表的容量（即实现了几个接口）。如果该类没用实现任何接口，则计数器值为0，后面的接口索引表不再占用任何字节。否则，接口索引集合的内容也是为指向CONSTANT_Class_info类型的索引值。</p>
</li>
</ul>
<h2 id="1-5-字段表集合"><a href="#1-5-字段表集合" class="headerlink" title="1.5 字段表集合"></a>1.5 字段表集合</h2><p>排在接口索引集合后边的是字段计数器：用于标识有多少个字段；</p>
<p>接着就是字段表集合。字段表（field_info）用于描述接口或者类中声明的变量。字段包括类级变量以及实例级变量(不包括方法内声明的局部变量)。可以包括的信息有：</p>
<ol>
<li>字段的作用域（public、private、protected修饰符）</li>
<li>实例变量还是类变量（static修饰符）</li>
<li>可变性（final）</li>
<li>并发可见性（volatile）</li>
<li>可否被序列化（transient）</li>
<li>字段数据类型（基本类型，对象，数组）</li>
<li>字段名称</li>
</ol>
<p>我们来看下字段表集合的结构：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9df277841bf95f2056917158b5becf38812.png" alt=""></p>
<ul>
<li><p>access_flags：其中public、private、protected、static、final、volatile、transient这些修饰符都是用access_flags字段来表示的，和上面讲述的类的access_flags类似，即如果一个字段是public的，那么public对应的标志位应该为真（1），以此类推，这些修饰符对应的标志位如下图：</p>
<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-6bc20666d6f49db2c6069a6a040fb8899e9.png" alt=""></li>
</ul>
</li>
<li><p>name_index和descriptor_index:这两个index都是<strong>对常量池的引用</strong>，分别代表着字段的“简单名称”和“字段和方法的描述符”；</p>
<ul>
<li>全限定名：就是类名全称,例如:org/xxx/class/testClass，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</li>
<li>简单名称：即没有类型和参数修饰的字段或者方法名称，例如方法test()的简单名称就是test，m字段的简单名称就是m。</li>
<li>描述符：描述符的作用是描述字段的数据类型、方法的参数列表（包括数量、类型及顺序）和返回值。根据描述符的规则，基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名表示，见下表<ul>
<li><img src="https://oscimg.oschina.net/oscnet/up-b35f5e3bca8690a449ea15aaad29418860d.png" alt=""></li>
<li>对于数组类型，每一维度将使用一个前置的“[”字符来描述，如“String[][]”,会被记录为”[[Ljava/lang/String”，”int[]”被记录为“[I”。</li>
<li>描述符描述方法时，按照先参数列表，后返回值的顺序描述。参数列表按照参数的严格顺序放置一组小括号“()”内，如<ul>
<li>“void inc()” 的描述符为“()V”</li>
<li>“viod main(String[] args)” 的描述符为“([Ljava/lang/String;)V”</li>
<li>“int indexOf(char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex)” 的描述符为“([CII[CIII)I”。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字段表集合中不会列出从超类或者父类接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段。</p>
</li>
<li><p>在descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。对于本例中的字段m，他的属性表计数器为0，也就是说没有需要额外描述的信息，但是，如果将字段m的声明改为“int m=123”，那就可能会存在一项名称为ConstantValue的属性，其值指向常量123。</p>
</li>
</ul>
<h3 id="1-5-1-字段表集合demo"><a href="#1-5-1-字段表集合demo" class="headerlink" title="1.5.1 字段表集合demo"></a>1.5.1 字段表集合demo</h3><p>举例：假设对于一个TestClass.class文件来说，字段表集合从地址0x000000F*开始</p>
<ul>
<li>第一个u2类型的数据为容量计数器fields_count，如下图所示，其值为0x0001，说明这个类只有一个字段表数据。</li>
<li>接下来紧跟着容量计数器的是access_flags标志，值为0x0002，代表private修饰符的ACC_PRIVATE标志位为真（ACC_PRIVATE标志的值为0x0002），其他修饰符为假。</li>
<li>代表字段名称的name_index的值为0x0005，从常量表中可查的第5项常量是一个CONSTANT_UTF8_info类型的字符串，其值为“m”</li>
<li>代表字符描述符的descriptor_index的值为0x0006，指向常量池的字符串“I”，根据这些信息，我们可以推断出原代码定义的字段为：“private int m;”。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-49563d3e5f1385282014a4de040f188d14e.png" alt=""><h2 id="1-6-方法表集合"><a href="#1-6-方法表集合" class="headerlink" title="1.6 方法表集合"></a>1.6 方法表集合</h2></li>
</ul>
<p>排在后边的是方法计数器：用于标识有多少个方法；</p>
<p>Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表结合（attributes）几项，见下表。这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。<br><img src="https://oscimg.oschina.net/oscnet/up-ef3a3608c87b67b9e8a868b39fcc8c8c4bb.png" alt=""></p>
<ul>
<li><p>access_flags</p>
<ul>
<li>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。</li>
<li>与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。</li>
<li>对于方法表，所有标志位及其取值可参考下表。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-7a9b0f82f5daae316c14588e6ff88472bed.png" alt=""></li>
</ul>
</li>
<li><p>代码：方法的定义可以通过访问标志、名称索引、描述符索引表达清楚，但方法里面的代码去哪里了？方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，我们将在下一内容进行介绍。</p>
</li>
<li><p>与字段表集合相对应的，如果父类方法在子类汇总没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“&lt;clinit&gt;”方法和实例构造器“&lt;init&gt;”方法。</p>
<h3 id="1-6-1-方法表集合demo"><a href="#1-6-1-方法表集合demo" class="headerlink" title="1.6.1 方法表集合demo"></a>1.6.1 方法表集合demo</h3></li>
</ul>
<p>举例：假设有一个Class文件，对方法表集合进行分析。</p>
<ul>
<li>如下图所示，方法表集合的入口地址为：0x00000101，第一个u2类型的数据（即是计数器容量）的值为0x0002，代表集合中有两个方法（这两个方法为编译器添加的实例构造器&lt;int&gt;和源码中的方法inc()）。</li>
<li>第一个方法的访问标志值为0x001，也就是说只有ACC_PUBLIC标志为真，名称索引值为0x0007，查<strong>常量池</strong>得方法名为“&lt;init&gt;”，描述符索引值为0x0008，对应常量为“( ) V”。</li>
<li>属性表计数器attributes_count的值为0x0001就表示此方法的<strong>属性表集合</strong>有一项属性，属性名称索引为0x0009，对应常量为“Code”，说明此属性是方法的字节码描述。</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-fb5d03169ec70161436339635bb6852bdf2.png" alt=""></li>
</ul>
<h2 id="1-7-属性表集合"><a href="#1-7-属性表集合" class="headerlink" title="1.7 属性表集合"></a>1.7 属性表集合</h2><p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表具有严格顺序.</p>
<p>并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉他不认识的属性。</p>
<p>为了能正确解析Class文件，《java虚拟机规范》预定义21项虚拟机实现应当能识别的属性，具体内容见下表。下文中将对其中一些属性中的关键常用的部分进行讲解。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-aecdf06ebdaf14cd2c4aae8bf8ff82917fe.png" alt=""></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b2a280abbfbb65133ba325367f48302bb26.png" alt=""></p>
<p>对于单个属性来说，他的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足下表所定义的结构。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-9fa65bd813bf963ab289294e91e4999f4e1.png" alt=""></p>
<p>下面我们来介绍重要的，虚拟机规范预定义的属性——code属性。</p>
<h3 id="1-7-1-code属性"><a href="#1-7-1-code属性" class="headerlink" title="1.7.1 code属性"></a>1.7.1 code属性</h3><p>Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。<strong>Code属性出现在方法表的属性集合之中</strong>，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么Code属性的结构将如下表所示。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-f4bc87d6a053a2e25007351ed3086f13570.png" alt=""></p>
<ul>
<li><p>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”，他代表了该属性的属性名称，</p>
</li>
<li><p>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的内容长度固定为整个属性表长度减6个字节。</p>
</li>
<li><p>max_stack代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值分配栈帧（Stack Frame）中的操作帧深度。</p>
</li>
<li><p>max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是Slot，Slot是虚拟机为局部变量分配内存所使用的最小单位。</p>
<ul>
<li>对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。</li>
<li>方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放。</li>
<li>另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。</li>
</ul>
</li>
<li><p>code_length和code用来存储java源程序编译后生成的字节码指令。</p>
<ul>
<li>code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。</li>
<li>既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。我们知道一个u1数据类型的取值范围为0x00<del>0xFF，对应十进制的0</del>255，也就是一共可以表达256条指令，目前，Java虚拟机规范已经定义了其中约200条编码值对应的指令含义。</li>
<li>关于code_length，有一件值得注意的事情，虽然他是一个u4类型的长度值，理论上最大值可以达到2的32次方减1，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，即他实际只使用了u2的长度，如果超过这个限制，Javac编译器也会拒绝编译。</li>
</ul>
</li>
<li><p>exception_table_length和exception_table表示这个方法的显示异常处理表（下文简称异常表）集合，异常表对于Code属性来说并不是必须存在的</p>
<ul>
<li>异常表的格式如下表所示</li>
<li><img src="https://oscimg.oschina.net/oscnet/up-18972444f8c9359ed0dfa0b2feb46ea0dda.png" alt=""></li>
<li>他包含4个字段，这些字段的含义为：如果当字节码在第start_pc行到end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。<strong>当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc处进行处理</strong>。</li>
</ul>
</li>
</ul>
<p>Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。</p>
<h3 id="1-7-2-code属性demo"><a href="#1-7-2-code属性demo" class="headerlink" title="1.7.2 code属性demo"></a>1.7.2 code属性demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    private int m;</span><br><span class="line"></span><br><span class="line">    public int inc() &#123;</span><br><span class="line">        return m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上面代码的TestClass.class文件为例</p>
<ul>
<li><p>如下图所示。这时实例构造器“&lt;init&gt;”方法的Code属性。</p>
<ul>
<li><p><img src="https://oscimg.oschina.net/oscnet/up-257e2c34636c8652be0f226ddada6202aad.png" alt=""></p>
</li>
<li><p>他的操作数栈的最大深度和本地变量表的容量都为0x0001</p>
</li>
<li><p>字节码区域所占空间的长度为0x0005。</p>
</li>
<li><p>虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的5个字节，并根据字节码指令翻译出所对应的字节码指令。翻译“2A B7 00 0A B1”的过程中：</p>
<ol>
<li>读入2A，查表得0x2A对应的指令为aload_0，这个指令的含义是将第0个Slot中为reference类型的本地变量推送到操作数栈顶。</li>
<li>读入B7，查表得0xB7对应的指令为invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者他的父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，他指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的方法符号引用。</li>
<li>读入000A，这时invokespecial的参数，查常量吃得0x000A对应的常量为实例构造器“&lt;init&gt;”方法的符号引用。</li>
<li>读入B1，查表得0xB1对应的指令为return，含义是返回此方法，并且返回值为void。这条指令执行后，当前方法结束。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="2-类加载机制"><a href="#2-类加载机制" class="headerlink" title="2 类加载机制"></a>2 类加载机制</h1><p>上一节我们已经知道了类文件结构，在class文件中描述的各种信息最终都需要加载到虚拟机中之后才能运行和使用。那么虚拟机是如加载这些class文件呢？class文件中的信息进入到虚拟机后会发生什么变化？</p>
<blockquote>
<p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化。最终形成可以被虚拟机最直接使用的java类型的过程就是虚拟机的类加载机制。</p>
</blockquote>
<p>另外需要注意的很重要的一点是：java语言中类型的加载连接以及初始化过程都是在程序运行期间完成的，这种策略虽然会使类加载时稍微增加一些性能开销，但是会为java应用程序提供高度的灵活性。java里天生就可以动态扩展语言特性就是依赖运行期间动态加载和动态连接这个特点实现的。比如，如果编写一个面向接口的程序，可以等到运行时再指定其具体实现类。</p>
<h2 id="2-1-类的生命周期"><a href="#2-1-类的生命周期" class="headerlink" title="2.1 类的生命周期"></a>2.1 类的生命周期</h2><p>类从被加载到虚拟机内存到卸出内存为止，它的整个生命周期包括：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e528b6e0fce95406fef545eb9d0df2282e0.png" alt=""></p>
<blockquote>
<p>加载，样子，准备，初始化和卸载五个阶段的顺序是确定的，而解析阶段则不一定，他在有些情况下可以在初始化阶段后再开始。</p>
</blockquote>
<h2 id="2-2-类加载的时机"><a href="#2-2-类加载的时机" class="headerlink" title="2.2 类加载的时机"></a>2.2 类加载的时机</h2><p>什么时候需要开始类加载的第一个阶段：加载？</p>
<p>虚拟机规范严格规定了<strong>有且只有</strong>五种情况必须立即对类进行“初始化”：</p>
<ol>
<li>使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。<ul>
<li>而对于接口，当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口时（如引用父接口中定义的常量）才会初始化。</li>
</ul>
</li>
<li>当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类；</li>
<li>使用Jdk1.7动态语言支持的时候的一些情况。如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<p>这5种场景中的行为称为对一个类进行主动引用。还有就是被动引用：所有引用类的方式都不会触发初始化。</p>
<h3 id="2-2-1-被动引用demo"><a href="#2-2-1-被动引用demo" class="headerlink" title="2.2.1 被动引用demo"></a>2.2.1 被动引用demo</h3><p>下面是3个被动引用的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 被动使用类字段演示一：</span><br><span class="line"> * 通过子类引用父类的静态字段，不会导致子类初始化</span><br><span class="line"> **&#x2F;</span><br><span class="line">public class SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SuperClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static int value &#x3D; 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubClass extends SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;SubClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 非主动使用类字段演示</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NotInitialization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码只会输出”SuperClass init”和”123”。对于静态字段，只有直接定义这个字段的类才会被初始化。因此通过其子类来引用父类定义的静态字段，只会触发父类的初始化。至于是否要触发子类的加载和验证，取决于虚拟机的具体实现。对于Sun HotSpot虚拟机来说，可通过-XX:+TraceClassLoading参数会导致子类的加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 被动使用类字段演示二：通过数组定义引用类，不会触发此类的初始化</span><br><span class="line"> *&#x2F;</span><br><span class="line">class NotInitialization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SuperClass[] sc &#x3D; new SuperClass[10];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码没有触发初始化，但里面触发了另外一个名为”[LSuperClass”类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是由虚拟机自动生成的、直接继承与java.lang.Object的子类，创建动作由字节码指令newarray触发。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 被动使用类字段演示三：</span><br><span class="line"> * 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ConstClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;ConstClass init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static final String HELLOWORLD &#x3D; &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br><span class="line">class NotInitialization &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码也没有输出”ConstClass init”，因为Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值”hello world”存储到了NotInitialization类的常量池中。所以在NotInitialization对ConstClass.HELLOWORLD的引用实际上是对自身常量池的引用。</p>
<h2 id="2-3-类加载的过程"><a href="#2-3-类加载的过程" class="headerlink" title="2.3 类加载的过程"></a>2.3 类加载的过程</h2><h3 id="2-3-1-加载"><a href="#2-3-1-加载" class="headerlink" title="2.3.1 加载"></a>2.3.1 加载</h3><p>“加载” 是 “类加载” 过程的一个阶段，切不可将二者混淆。</p>
<p>加载”是”类加载”过程的一个阶段，虚拟机需要完成3件事情：</p>
<ol>
<li><p>通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<ul>
<li>没有指明从哪里获取、怎样获取，可以说一个非常开放的平台了。</li>
<li>目前可以从zip包获取，即jar，ear，war格式的基础。</li>
<li>从网络获取，即applet实现。</li>
<li>运行时计算生成，典型如动态代理。</li>
<li>由其他文件生成，典型如JSP应用，即为JSP文件生成的class类。</li>
<li>从数据库中读取，这种较少见。</li>
</ul>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<ul>
<li>方法区的数据存储格式由各种虚拟机实现自行定义，并无明确规范。</li>
</ul>
</li>
<li><p>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<ul>
<li>并没有明确存放于要在堆中，实际上它虽然是对象，但是HotSpot虚拟机仍将其存放在方法区中。</li>
</ul>
</li>
</ol>
<p>对于非数组类的加载阶段(准确的说是加载阶段中获取类的二进制字节流的动作)是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器完成，也可以由用户自定义的类加载器完成（即重写一个类加载器的loadClass（）方法）。</p>
<p>对于数组，数组类本身不通过类加载器创建，是由Java虚拟机直接创建的。但数组类与类加载器也有密切关系，因为数组类的元素类型(String[]的元素类型即为String)，最终要靠类加载器创建。</p>
<h3 id="2-3-2-验证"><a href="#2-3-2-验证" class="headerlink" title="2.3.2 验证"></a>2.3.2 验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>虚拟机如果不检查输入的字节流，并对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。这个阶段是否严谨，直接决定了java虚拟机是否能承受恶意代码的攻击。</p>
<p>从整体上看，验证阶段大致上会完成4个阶段的校验工作：文件格式、元数据、字节码、符号引用。</p>
<ol>
<li><p>文件格式验证：验证字节流是否符合Class文件格式的规范。</p>
<ul>
<li>是否以魔数0xCAFEBABE开头。</li>
<li>主、次版本号是否在当前虚拟机处理范围之内。</li>
<li>常量池的常量是否有不被支持的常量类型(检查常量tag标志)。</li>
<li>…</li>
</ul>
</li>
<li><p>元数据验证：字节码描述的信息是否符合Java语言规范。</p>
<ul>
<li>这个类是否有父类。</li>
<li>这个类的父类是否继承了不允许被继承的类。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。</li>
<li>…</li>
</ul>
</li>
<li><p>字节码验证：通过数据流和控制流分析，确定程序语义是合法、符合逻辑的。</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现：在操作栈放置了int类型的数据，使用时按long类型加载入本地变量表中。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>保证类型转换是有效的。</li>
<li>…</li>
</ul>
</li>
<li><p>符号引用验证：对类自身以外(常量池中各种符号引用)的信息进行匹配性校验。</p>
<ul>
<li>符号引用中通过字符串描述的全限定是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li>符号引用的类、字段、方法的访问性是否可以被当前类访问。</li>
<li>…</li>
</ul>
</li>
</ol>
<h3 id="2-3-3-准备"><a href="#2-3-3-准备" class="headerlink" title="2.3.3 准备"></a>2.3.3 准备</h3><p>正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p>
<blockquote>
<p>注意：这时进行内存分配的仅包括类变量(static修饰)，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中；</p>
</blockquote>
<blockquote>
<p>注意：初始值通常是数据类型的零值：对于：public static int value = 123;，那么变量value在准备阶段过后的初始值为0而不是123，这时候尚未开始执行任何java方法，把value赋值为123的动作将在初始化阶段才会被执行。</p>
</blockquote>
<blockquote>
<p>注意：对于：public static final int value = 123;编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p>
</blockquote>
<p>基本数据类型的零值：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a8fc433e06919ce8b5789af9ce6ee5c6934.png" alt=""></p>
<h3 id="2-3-4-解析"><a href="#2-3-4-解析" class="headerlink" title="2.3.4 解析"></a>2.3.4 解析</h3><p>虚拟机将常量池内的<strong>符号引用替换为直接引用</strong>的过程。（如果不理解这句话的意思，可以参考R大的答案：<a href="https://www.zhihu.com/question/30300585）" target="_blank" rel="noopener">https://www.zhihu.com/question/30300585）</a></p>
<ul>
<li><p>符号引用：上面我们介绍过符号引用，这里再重申一遍，以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存和布局无关，引用的目标并不一定已经加载到内存中了。</p>
</li>
<li><p>直接引用：直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存布局有关，引用的目标必定已经在内存中了。</p>
</li>
</ul>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。分别对应常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info、CONSTANT_InvokeDynamic_info。(先只说前4种)</p>
<p>下面假设我们要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用。</p>
<ul>
<li><p>类或接口的解析：假设当前代码所处的类为D，那么有3个步骤：</p>
<ul>
<li><p>如果目标类C不是数组类型，虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。</p>
</li>
<li><p>如果目标类C是一个数组类型，并且数组的元素类型为对象，N的描述符会是类似”[Ljava/lang/Integer”的形式，将会按照第1点的规则加载数组元素类型。即需要加载的元素类型是”java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。</p>
</li>
<li><p>如果上面没有异常，解析完成前会进行符号引用验证，确认D是否具备C的访问权限（public，private，protected这些）。如果没有权限，将抛出java.lang.IllegalAccessError异常。</p>
</li>
</ul>
</li>
<li><p>字段解析</p>
<ul>
<li>首先将字段表内class_index中索引的CONSTANT_Class_info符号引用解析(就是字段所属的类或接口的符号引用)。如果解析完成，会有以下步骤：</li>
<li>如果C已经包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个引用。</li>
<li>否则，如果C实现了接口，将会按继承关系从下往上递归搜索各个接口和它的父接口，如果找到则返回。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果找到则返回。</li>
<li>否则，查找失败，抛出”java.lang.NoSuchFieldError”异常。</li>
<li>如果成功返回了引用，将会对字段进行权限认证。如果发现没有权限抛出”java.lang.IllegalAccessError”异常。</li>
</ul>
</li>
<li><p>类方法解析</p>
<ul>
<li><p>先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，解析成功后，有以下几个步骤：</p>
</li>
<li><p>类方法和接口方法符号引用的常量类型定义是分开的，如果方法表中发现class_index中索引的C是个接口，直接抛出”java.lang.IncompatibleClassChangeError”异常。</p>
</li>
<li><p>在类C查找是否有简单名称和描述符与目标匹配的方法，如果有则返回。</p>
</li>
<li><p>否则，在类C的父类中递归查找是否有与目标匹配的方法，如有有则返回。</p>
</li>
<li><p>否则，在类C实现的接口列表及它们的父接口中递归查找是否有与目标匹配的方法，如果有说明C是抽象类，查找结束，抛出”java.lang.AbstractMethodError”异常。</p>
</li>
<li><p>否则，方法查找失败，抛出”java.lang.NoSuchMethodError”异常。</p>
</li>
<li><p>如果查找成功，返回直接引用。会对这个方法进行权限认证，如果没有权限，抛出”java.lang.IllegalAccessError”异常。</p>
</li>
</ul>
</li>
<li><p>接口方法解析</p>
<ul>
<li><p>同样，解析接口方法表class_index中索引对方法所属对类或接口的符号引用，如果解析成功，会执行以下步骤：</p>
</li>
<li><p>如果接口方法表中发现class_index中的索引C是个类，直接抛出”java.lang.IncompatibleClassChangeError”异常。</p>
</li>
<li><p>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。</p>
</li>
<li><p>否则，在接口C的父接口中递归查找，直到java.lang.Object类，查找是否有简单名称和描述符与目标相匹配的方法，如果有则返回。</p>
</li>
<li><p>否则，方法查找失败，抛出”java.lang.NoSuchMehtodError”异常。</p>
</li>
<li><p>接口所有方法默认都是public，没有访问权限问题。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-5-初始化"><a href="#2-3-5-初始化" class="headerlink" title="2.3.5 初始化"></a>2.3.5 初始化</h3><p>这个阶段才真正开始执行类中定义的Java程序代码。(字节码)</p>
<p>准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序的主观计划初始化类变量和其他资源。或者说，<strong>初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程</strong>。</p>
<p>对于类构造器&lt;clinit&gt;()，有如下几个要点：</p>
<ul>
<li>类构造器&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，<strong>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句快可以赋值，但是不能访问</strong>。（否则提示非法向前引用）</li>
</ul>
<ul>
<li><p>类构造器&lt;clinit&gt;()方法与类的构造函数(实例构造函数&lt;init&gt;()方法)不同，它不需要显式调用父类构造，虚拟机会保证在子类&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在虚拟机中的第一个执行的&lt;clinit&gt;()方法的类肯定是java.lang.Object。</p>
</li>
<li><p>由于父类的&lt;clinit&gt;()方法先执行，也就意味着父类中定义的静态语句快要优先于子类的变量赋值操作。</p>
</li>
<li><p>&lt;clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句，也没有变量赋值的操作，<strong>那么编译器可以不为这个类生成&lt;clinit&gt;()方法</strong>。</p>
</li>
<li><p>接口中不能使用静态语句块，但接口与类不太一样的是，<strong>执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法</strong>。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，<strong>接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法</strong>。</p>
</li>
<li><p>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果一个类的&lt;clinit&gt;()方法中有耗时很长的操作，那就可能造成多个进程阻塞。</p>
</li>
</ul>
<h1 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3 类加载器"></a>3 类加载器</h1><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<p>对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的<strong>唯一性</strong>。也就是说，只有两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等（这里的相等包括equals方法，isAssignableFrom方法，isInstance方法等判断，包括instanceOf关键字所做出的的对象所属判断）。<strong>否则，即便是两个同名的类，甚至是来自一个class文件的类，不同的加载器加载，他们也不会是同一个类。</strong></p>
<h2 id="3-1-类加载器种类"><a href="#3-1-类加载器种类" class="headerlink" title="3.1 类加载器种类"></a>3.1 类加载器种类</h2><p>从虚拟机的角度来说，只存在两种不同的类加载器：</p>
<ul>
<li>一种是<strong>启动类加载器（Bootstrap ClassLoader）</strong>，该类加载器使用C++语言实现，属于虚拟机自身的一部分。</li>
<li>另外一种就是<strong>所有其它的类加载器</strong>，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。</li>
</ul>
<p>从Java开发人员的角度来看，类加载器会分的更加细致，大部分Java程序一般会使用到以下三种系统提供的类加载器：</p>
<ol>
<li><p>启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM内存中（如rt.jar），如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\ext目录中，或者被 java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器；</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）：这个类加载器由 sun.misc.Launcher$App-ClassLoader 实现。getSystemClassLoader() 方法返回的就是这个类加载器，因此也被称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ol>
<h2 id="3-2-双亲委派模型"><a href="#3-2-双亲委派模型" class="headerlink" title="3.2 双亲委派模型"></a>3.2 双亲委派模型</h2><p>我们的应用程序都是由上述这3种类加载器互相配合进行加载的，在必要时还可以自己定义类加载器。它们的关系如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-de58eeaf1c8e7d2b3a81cd80af628b1e537.png" alt=""></p>
<p><strong>上图中所呈现出的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器以外，其余的类加载器都应当有自己的父类加载器。</strong></p>
<p>双亲委派模型的工作过程是这样的：</p>
<ul>
<li>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。</li>
<li>每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。</li>
<li>只有当父类加载器反馈自己无法完成这个类加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</li>
</ul>
<blockquote>
<p>这样做的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如 java.lang.Object，它放在 rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载器来加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。<br>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基本的行为也就无法保证了。</p>
</blockquote>
<p>双亲委派模型对于保证 Java 程序运行的稳定性很重要，但它的实现很简单，实现双亲委派模型的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法中，逻辑很清晰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException &#123;</span><br><span class="line">    &#x2F;&#x2F; 首先，检查请求的类是不是已经被加载过</span><br><span class="line">    Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">    if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (parent !&#x3D; null) &#123;&#x2F;&#x2F;若没有则调用父类加载器的loadClass()方法</span><br><span class="line">                c &#x3D; parent.loadClass(name, false);</span><br><span class="line">            &#125; else &#123;&#x2F;&#x2F;若父加载器为空则默认使用启动类加载器作为父加载器</span><br><span class="line">                c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果父类抛出ClassNotFoundException说明父类加载器无法完成加载</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果父类加载器无法加载，则调用自己的findClass方法来进行类加载</span><br><span class="line">            c &#x3D; findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
            <a href="/tags/class%E6%96%87%E4%BB%B6/" rel="tag"># class文件</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/03/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%AF%BB/" rel="next" title="文章导读">
                <i class="fa fa-chevron-left"></i> 文章导读
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/19/Redis%E7%9A%848%E7%A7%8D%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="prev" title="Redis的8种底层数据结构">
                Redis的8种底层数据结构 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2019/12/03/Class文件和类加载机制/"
           data-title="Class文件和类加载机制" data-url="http://yoursite.com/2019/12/03/Class%E6%96%87%E4%BB%B6%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">96</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-class文件结构"><span class="nav-text">1 class文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-魔数和class文件的版本"><span class="nav-text">1.1 魔数和class文件的版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-常量池"><span class="nav-text">1.2 常量池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-访问标志"><span class="nav-text">1.3 访问标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-类索引、父类索引与接口索引集合"><span class="nav-text">1.4 类索引、父类索引与接口索引集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-字段表集合"><span class="nav-text">1.5 字段表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-字段表集合demo"><span class="nav-text">1.5.1 字段表集合demo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-方法表集合"><span class="nav-text">1.6 方法表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-方法表集合demo"><span class="nav-text">1.6.1 方法表集合demo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-属性表集合"><span class="nav-text">1.7 属性表集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-code属性"><span class="nav-text">1.7.1 code属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-code属性demo"><span class="nav-text">1.7.2 code属性demo</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-类加载机制"><span class="nav-text">2 类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-类的生命周期"><span class="nav-text">2.1 类的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-类加载的时机"><span class="nav-text">2.2 类加载的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-被动引用demo"><span class="nav-text">2.2.1 被动引用demo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-类加载的过程"><span class="nav-text">2.3 类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-加载"><span class="nav-text">2.3.1 加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-验证"><span class="nav-text">2.3.2 验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-准备"><span class="nav-text">2.3.3 准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-解析"><span class="nav-text">2.3.4 解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-初始化"><span class="nav-text">2.3.5 初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-类加载器"><span class="nav-text">3 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-类加载器种类"><span class="nav-text">3.1 类加载器种类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-双亲委派模型"><span class="nav-text">3.2 双亲委派模型</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">380k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
