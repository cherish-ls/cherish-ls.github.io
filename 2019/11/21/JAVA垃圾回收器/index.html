<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JAVA,JVM,gc,CMS,G1,STW," />










<meta name="description" content="前言java内存运行时区域的各个部分，其中的程序计数器，虚拟机栈，本地方法栈三个区域是随线程而生、随线程而亡的； 栈中的栈帧是随着方法的进入和退出而执行入栈和出栈的。每个栈帧中分配的内存在类结构确定下来时就是已知的，因此这几个区域的内存分配和回收都是确定的，方法结束和线程结束时，内存自然就回收了。 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA垃圾回收器">
<meta property="og:url" content="http://yoursite.com/2019/11/21/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="前言java内存运行时区域的各个部分，其中的程序计数器，虚拟机栈，本地方法栈三个区域是随线程而生、随线程而亡的； 栈中的栈帧是随着方法的进入和退出而执行入栈和出栈的。每个栈帧中分配的内存在类结构确定下来时就是已知的，因此这几个区域的内存分配和回收都是确定的，方法结束和线程结束时，内存自然就回收了。 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/d6249ffd6b925c4d76f9884bb9e2d1439d7.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/307291672aaad50b723465c56a901fcdded.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/4f884849df9cda6a0c38b20e78d2428dc06.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/d1f66984f417d019a3eba91276c6c0e2cb6.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/0ffbb89b57bb4885b3ca3854536ab80a691.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/4d99d32625cd2bcdd3a32cd978cea4592ee.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/13cf838ac2071b9871818127bbf7134ea75.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/b4b25c2752edb839b6b9e185e6ab3093dd4.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/4e335c54c634db7a57ee286044f08f27713.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/a9cecff7a47d3a0d0678e22246c1e687f8c.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/91717af3b0ca9a874a1156120718eb3bcd1.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/ca047a2e3c46111f468435d4d84ae52a966.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/c50fbe36521473afe764d707d913ab58295.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/8f49f16ec62cca1671507fd60ae71648bed.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/143e8c4013e811b881e3083163b22b7980d.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/9049e04d540dd52600d14c6f22b099cfb16.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/cfc951a4c4d9dff97f49be46a44c5506500.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/b7d7d251525f0241d39159394b6e6d221c5.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/74ab428c55bb760a80c4b8bfe635d14c039.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/12be353e898117fbd49072763bacd0b6693.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/8c27fb72fcfb8af79455ab653c422135cad.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/0859ebbd57f3dd299d9602d4f03ab22645d.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/2e1c898dbbc8d7a5a96651d7b827ff4d9cc.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/037553f08aafc012c4088cd376f61b6f53e.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/4b9dc302e676f69ad2eceeecb56ff856c45.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/7cc36319d43b695bd537e77d06b10923894.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/e806b69f5e601a8e108870a056d005b5357.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/ca718b9f0b421c46434f7fcccf43b5a1f49.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/f5894fef49569a1c2124fc8af3cd901c095.png">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/46fa2d0f05b19bd564bb69547c375bf24c2.png">
<meta property="article:published_time" content="2019-11-21T14:24:02.000Z">
<meta property="article:modified_time" content="2020-03-09T15:19:30.997Z">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="gc">
<meta property="article:tag" content="CMS">
<meta property="article:tag" content="G1">
<meta property="article:tag" content="STW">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oscimg.oschina.net/oscnet/d6249ffd6b925c4d76f9884bb9e2d1439d7.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/21/JAVA垃圾回收器/"/>





  <title>JAVA垃圾回收器 | cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/21/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JAVA垃圾回收器</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-21T22:24:02+08:00">
                2019-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA-JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA JVM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/11/21/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/11/21/JAVA垃圾回收器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  16.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  57
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java内存运行时区域的各个部分，其中的程序计数器，虚拟机栈，本地方法栈三个区域是随线程而生、随线程而亡的；</p>
<p>栈中的栈帧是随着方法的进入和退出而执行入栈和出栈的。每个栈帧中分配的内存在类结构确定下来时就是已知的，因此这几个区域的内存分配和回收都是确定的，方法结束和线程结束时，内存自然就回收了。</p>
<p>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期间才能知道要创建哪些对象，这部分内存分配和回收是动态的，也就是说这部分内存的回收是要干预的。<strong>后续我们参与讨论的“内存”分配与回收也仅指这一部分内存</strong></p>
<h1 id="1-判断对象死亡与否"><a href="#1-判断对象死亡与否" class="headerlink" title="1.判断对象死亡与否"></a>1.判断对象死亡与否</h1><p>java堆里存放着几乎所有的对象实例，在进行GC前，我们必须要弄清楚那些对象还活着（即不可被回收），哪些对象已经死了（可以被回收了）。</p>
<p>我们有如下的方法来判断对象存活与否；</p>
<h2 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h2><blockquote>
<p> 给对象添加一个引用计数器，每当有一个地方引用它时，计数值就加1；当引用失效时计数器值就减1；任何时刻当一个对象的计数器值为0时就是不再被使用的，即就是要被回收的。</p>
</blockquote>
<p>这种算法实现简单，判定效率也很高，在多数情况下它是一个不错的算法，但是在java语言中没有选取这种方法来管理内存，因为它无法解决对象之间互相循环引用的问题：</p>
<ul>
<li>比如对象A和对象B都有字段instance</li>
<li>令A.instance = B及B.instance = A，除此之外这两个对象再无其他任何引用。</li>
</ul>
<p>实际上这两个对象是要被回收的对象，但是他们之间存在着互相引用，导致计数器的值不为0，引用计数算法就不能回收他们（回收条件计数器值为0）。</p>
<h2 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h2><p>主流的商用程序语言（JAVA/C#等）的主流实现都是通过可达性分析来判定对象是否存活。</p>
<blockquote>
<p>通过“GC Roots”的对象作为起始点，从这个起始点向下搜索，搜索所走过的路径成为引用链，当一个对象没有与任何引用链相连（即从GC Roots不可达），此时说明这个对象是不可用的。</p>
</blockquote>
<p>如下图，obj5，obj6，obj7虽然相互有关联，但是他们到GC Root是不可达的，会被判定为可回收的对象。<br><img src="https://oscimg.oschina.net/oscnet/d6249ffd6b925c4d76f9884bb9e2d1439d7.jpg" alt=""></p>
<p>在java语言中，可作为GC Roots的对象包含以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的native方法）的引用的对象</li>
</ul>
<h1 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h1><p>传统的引用的定义（如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，那它就是引用）无法满足gc的需要。</p>
<p>在实际中我们希望能有这样的对象：当内存空间足够时保存在内存中，当内存紧张时，则可以抛弃这些对象。</p>
<p>故而在JDK1.2之后，java将引用的概念进行了扩充，将引用分为：强引用，软引用，弱引用，虚引用四种，这四种的引用强度依次逐渐减弱。</p>
<ul>
<li><p>强引用在代码中普遍存在，如Object obj = new Object() 这样的引用就是强引用，只要这个对象的引用还存在，垃圾回收器就永远不会回收它。（在通常对静态属性赋值时一定要各位注意，它的生命周期会贯穿整个app的生命周期）</p>
</li>
<li><p>软引用用来描述一些还有用，但是并非必须的对象，正常gc时不会回收它，只有在系统即将发生内存溢出之前，会将这些对象进行回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
</li>
<li><p>弱引用是用来描述非必须对象的，他比软引用更更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收收集之前。当GC时无论当前内存是否足够，都会回收掉只被弱引用关联的对象（注意是只被弱引用关联的对象，如果一个对象即被强引用引用也被弱引用引用，GC时是不会回收的）</p>
</li>
<li><p>虚引用也称为幽灵引用或幻影引用，它是最弱的一种引用关系。一个对象是否有有虚引用，完全不会影响它的生存周期周期，也无法通过一个虚引用获得一个对象。为一个对象设置为虚引用关联的唯一目的就是希望能在这个对象被回收时收到一个系统通知。</p>
</li>
</ul>
<h1 id="3-finalize方法"><a href="#3-finalize方法" class="headerlink" title="3. finalize方法"></a>3. finalize方法</h1><p>即使是被可达性分析算法不可达的对象，也不是非死不可，这时候它处于“缓刑”状态，finalize()是它完成自救的最后机会</p>
<p>finalize()是Object中的方法,当垃圾回收器将要回收对象所占内存之前被调用，其过程为：</p>
<ul>
<li>某个对象被判断为不可达，被第一次标记。判断该对象是否有必要执行finalize()<ul>
<li>如果对象没有重新该方法，或者该方法已经被虚拟机调用过（所以finalize()最多只能执行一次），它将第二次被标记，基本上在劫难逃了。</li>
<li>否则，则会将该对象放置在一个叫做F-Queue的队列中，并在稍后由一条虚拟机自动建立的，低优先级的Finalizer线程去执行（调用finalize（）方法），但并不承诺会等待它运行结束<ul>
<li>finalize（）方法是对象逃离死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象在finalize（）中成功拯救了自己（重新与引用链建立关联），那在第二次标记时它将被移除出即将回收的集合；</li>
<li>否则，第二次标记没躲掉，它基本上也在劫难逃了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>不承诺执行完finalize（）的原因是：如果一个对象的finalize（）方法执行缓慢或者发生死循环等极端情况，将会导致F-Queue队列永久处于等待zhua状态，甚至导致整个GC系统的崩溃。</p>
</blockquote>
<blockquote>
<p>在java中不建议使用finalize方法。</p>
</blockquote>
<h1 id="4-方法区的回收"><a href="#4-方法区的回收" class="headerlink" title="4. 方法区的回收"></a>4. 方法区的回收</h1><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾回收的，java虚拟机规范确实说过不要求虚拟机在方法区实现垃圾回收，而且在方法区进行垃圾回收的性价比比较低：在堆中，尤其是在新生代中，常规的应用进行一次垃圾回收一般能回收70%~95%的空间，而永久代代的垃圾回收效率远低于此。</p>
<p>其实永久代的垃圾回收主要回收两部分内容</p>
<ul>
<li><p>废弃常量</p>
<ul>
<li>回收废弃常量与回收java堆中的对象非常类似，比如常量池字面量‘abc’，如果此时没有一个String对象值为‘abc’，即没有任何String对象引用‘abc’常量，那么发生gc时，其将被清出常量池。常量池中的其他类、接口、方法、字段的符号引用也类似。</li>
</ul>
</li>
<li><p>无用的类</p>
<ul>
<li><p>相比判断废弃常量，判断无用的类条件比较苛刻，需要同时满足以下三个条件。</p>
<ul>
<li><p>该对象的所有实例都已经被回收，也就是堆中不存在该类的任何实例。</p>
</li>
<li><p>加载该类的ClassLoader也已经被回收</p>
</li>
<li><p>该类对应的java.lang.Class对象没有在任何地方被引用，也无法在任何地方通过反射来访问该类的方法</p>
</li>
</ul>
</li>
<li><p>虚拟机可以对这样的无用的类进行回收，但也局限于可以，而不是必然。Hotspot虚拟机提供了-Xnoclass参数进行控制。</p>
</li>
</ul>
</li>
</ul>
<h1 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4. 垃圾回收算法"></a>4. 垃圾回收算法</h1><h2 id="4-1-标记-清除算法"><a href="#4-1-标记-清除算法" class="headerlink" title="4.1 标记-清除算法"></a>4.1 标记-清除算法</h2><p>（Mark-sweep）这是最基础的垃圾回收算法，顾名思义，分为标记和清除两个阶段。它这里的标记就是指介绍finalize方法时提到的第二次标记。</p>
<blockquote>
<p>首先标记出所有需要回收的对象，在标记完成后统一回收掉被标记的对象。它主要有两个缺点：一个是效率问题，标记和清理过程效率都不高；另一个问题是空间问题，在清除后会产生大量不连续的内存碎片，当空间碎片太多时会导致，当程序以后运行需要分配较大对象时无法找到足够的连续内存而不得不提前触发下一次GC动作。</p>
</blockquote>
<p><img src="https://oscimg.oschina.net/oscnet/307291672aaad50b723465c56a901fcdded.jpg" alt=""></p>
<h2 id="4-2-复制算法"><a href="#4-2-复制算法" class="headerlink" title="4.2 复制算法"></a>4.2 复制算法</h2><p>为了解决效率问题，复制算法应运而生。</p>
<blockquote>
<p>它将内存按容量划分为大小相等的两块，每次使用其中的一块。当这一块用完时就将还存活的对象复制到令一块上，然后将已使用过的这一块内存清理掉。这样分配时就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行效率高。</p>
</blockquote>
<p><strong>但是缺点也是显而易见的：内存利用率只有一半。</strong></p>
<p><img src="https://oscimg.oschina.net/oscnet/4f884849df9cda6a0c38b20e78d2428dc06.jpg" alt=""></p>
<h3 id="4-2-1-新生代的回收"><a href="#4-2-1-新生代的回收" class="headerlink" title="4.2.1 新生代的回收"></a>4.2.1 新生代的回收</h3><p>现在的商业虚拟机都采用这种算法来收集新生代，IBM的专门研究表明，新生代的对象98%都是朝生夕死的，所以并不需要按1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块SuSurvivor。</p>
<p>回收时，将Eden和刚才刚才用过的Survivor的空间中还活着的对象一次拷贝到令外一块Survivor空间上，最后清理掉Eden和刚才刚才使用过的Survivor的空间。</p>
<p>虚拟机默认Eden区和Survivor区的大小比例是8:1，也就是每次新生代中可用空间为整个新生代容量的90%。</p>
<p>当然我们没办法保证每次回收时，都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他的内存（这里指老年代）进行分配担保。（稍后详解）</p>
<h2 id="4-3-标记-整理算法"><a href="#4-3-标记-整理算法" class="headerlink" title="4.3 标记-整理算法"></a>4.3 标记-整理算法</h2><p>如果内存中对象的存活率比较高的话，那么复制算法需要执行较多的复制操作，效率会变低，更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了“标记–整理”算法，标记过程仍与“标记–清除”算法一样，但是后续步骤不是直接对可回收的对象进行清理，而是让<strong>所有存活的对象</strong>都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="https://oscimg.oschina.net/oscnet/d1f66984f417d019a3eba91276c6c0e2cb6.jpg" alt=""></p>
<h2 id="4-4-分代收集算法"><a href="#4-4-分代收集算法" class="headerlink" title="4.4 分代收集算法"></a>4.4 分代收集算法</h2><p>当前商业虚拟机的垃圾回收都是采用的“分代收集”算法，根据对象的存货周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的垃圾回收算法。在新生代中，每次垃圾每次垃圾回收都发现大批对象死去，只有少量存活，<strong>那就使用复制算法</strong>。而老年代中因为对象存活率较高，没有额外的空间对它进行分配担保，<strong>就必须使用“标记–清理‘’或者‘标记–整理’‘算法来进行回收</strong>。</p>
<h1 id="5-HotSpot虚拟机的算法实现"><a href="#5-HotSpot虚拟机的算法实现" class="headerlink" title="5 HotSpot虚拟机的算法实现"></a>5 HotSpot虚拟机的算法实现</h1><p>上述的这些对象存货判断算法和垃圾收集算法，在hotspot虚拟机上，会为了达到更高的效率，而做一些优化或者变动。这些优化有：</p>
<h2 id="5-1-枚举根节点"><a href="#5-1-枚举根节点" class="headerlink" title="5.1 枚举根节点"></a>5.1 枚举根节点</h2><p>可达性分析算法目前有两个主要的局限：</p>
<ul>
<li><p>可达性分析需要从GC root节点开始寻找引用链，而GC root主要在全局性的引用（常量和静态变量）和执行的上下文（栈帧的本地变量）中，这类数据日臻庞大，如果要逐个检查，那么必然消耗很多时间。</p>
</li>
<li><p>可达性分析需要等待GC停顿，即一个整个系统类似被冻结的时间节点（停顿所有执行线程），因为可达性分析无法在引用关系还在不断变化的情况下准确分析。</p>
</li>
</ul>
<p>目前主流的java虚拟机都采用准确式GC，所以当gc停顿后，并不需要一个不漏的检查所有上下文和全局的引用。在HotSpot的实现中，有一组成为OopMap的数据结构，类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知哪些地方存放着对象引用。</p>
<blockquote>
<p>准确式内存管理：即虚拟机可以知道内存中某个位置的数据具体是什么类型。譬如内存中有一个32位的整数123456，它到底是一个reference类型指向的123456的内存地址还是一个数值为123456的整数，虚拟机将有能力分辨出来，这样才能在GC的时候准确判断对上的数据是否还可能被使用。</p>
</blockquote>
<p>保守式GC,半保守式GC和准确式GC，以及OopMap，推荐可以拓展看该篇文章<a href="https://my.oschina.net/lscherish/blog/3128494" target="_blank" rel="noopener" title="JVM中的OopMap">JVM中的OopMap</a></p>
<h2 id="5-2-安全点Safe-Point"><a href="#5-2-安全点Safe-Point" class="headerlink" title="5.2 安全点Safe Point"></a>5.2 安全点Safe Point</h2><p> 有了OopMap，HotSpot可以快速准确完成GC Roots枚举。但是另一个问题来了，我们要在什么地方创建OopMap？程序运行期间，引用的变化在不断发生，如果每一条指令都生成OopMap，那占用空间就太大了。为了解决这个问题，我们引入了安全点（Safe Point）—— 只在安全点进行GC停顿，只要保证引用变化的记录完成于GC停顿之前就可以。</p>
<blockquote>
<p>可以理解为OopMap表示的是一个班级的座位表，上面记录每个同学都在xx行xx列，分别是男是女。假设班上的同学一直在不停的变换位置，如果我们每一次变换都要创建一张新的座位表，那太繁琐，占用空间也多。<br>为了解决这个问题，我们加入了一个暂停（安全点）的概念，即某个时刻，所有同学的移动停止，我们只会在暂停的时候发生gc，那么也只需要在每次暂停之前生成座位表即可。因为座位表是给gc用的，gc又只会发生在安全点，所以这样是可行的。</p>
</blockquote>
<p>安全点选定太少，GC等待时间就太长，选的太多，GC就过于频繁。选定原则是”具有让程序长时间执行的特征“，也就是在这个时刻现有的指令是可以复用的。一般选在方法调用、循环跳转、抛出异常的位置。</p>
<p>现在的问题是在Safe Point让线程们以怎样的机制中断，方案有两种：抢先式中断、主动式中断。</p>
<ul>
<li>抢先式中断：GC发生时，中断所有线程，如果发现有线程不再安全点上，就恢复线程让它运行到安全点上。现在几乎不用这种方案。</li>
<li>主动式中断：设置一个标志，和安全点重合，再加上创建对象分配内存的地方。各个线程主动轮询这个标志，发现中断标志为真就挂起自己。HotSpot使用主动式中断。</li>
</ul>
<h2 id="5-3-安全区域safe-region"><a href="#5-3-安全区域safe-region" class="headerlink" title="5.3 安全区域safe region"></a>5.3 安全区域safe region</h2><p>貌似引入安全点，再加上OopMap，就可以完美解决GC的性能问题了，但实际上，我们还考虑漏了一种情况。即有些程序此时处于无法响应jvm中断请求的状态（比如线程sleep或者block），这样程序不会走到安全点了。</p>
<blockquote>
<p>类比的话就是移动过程中，有些同学睡着了，听不到暂停的指令（中断请求），他可能睡醒后回过神来，自顾自的去下一个座位，全然不顾班上其他同学已经暂停了。</p>
</blockquote>
<p>为了解决这个问题，hotSpot还引入了安全区域的概念。</p>
<p>安全区域是指在一段代码片段中，引用关系不会发生变化，在该区域的任何地方发生GC都是安全的。当代码执行到安全区域时，首先标识自己已经进入了安全区域，那样如果在这段时间里JVM发起GC，就不用管标示自己在安全区域的那些线程了，<strong>在线程离开安全区域时，会检查系统是否正在执行GC，如果是，就等到GC完成后再离开安全区域</strong>。</p>
<blockquote>
<p>类比为：所有睡着的同学，你们睡着可以，但是要给自己做个标记，这样我暂停排座位表（OopMap）的时候，我就忽略你们了。但是为了防止你们在暂停的时候突然醒来，然后后知后觉的到处乱闯，我只好跟你们约法三章：睡醒的时候，问一下周围现在是不是在暂停中，如果是的话，你们就不要动弹，等暂停结束了再走。</p>
</blockquote>
<h1 id="6-垃圾收集器"><a href="#6-垃圾收集器" class="headerlink" title="6 垃圾收集器"></a>6 垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<p>以下是hotspot虚拟机中的7中作用于不同分代的垃圾收集器，连线表示垃圾收集器可以配合使用。</p>
<p><img src="https://oscimg.oschina.net/oscnet/0ffbb89b57bb4885b3ca3854536ab80a691.jpg" alt=""></p>
<blockquote>
<p>现在来说，目前并不存在一个万能的收集器，具体应用或者具体场景，都有不同的适用的收集器。</p>
</blockquote>
<blockquote>
<p>关于收集器，我们常会用到并行与并发来做描述，他们的区别是：<br>      <strong>并行（parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。<br>      <strong>并发（concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户线程在继续运行，而垃圾手机程序运行在另一个cpu上。</p>
</blockquote>
<h2 id="6-1-serial收集器"><a href="#6-1-serial收集器" class="headerlink" title="6.1 serial收集器"></a>6.1 serial收集器</h2><p>该收集器是最基本，最悠久的收集器，曾经在jdk1.3.1之前是虚拟机新生代收集的唯一选择。</p>
<p>它是单线程的收集器，不仅意味着只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，<strong>必须暂停所有其他工作线程，往往造成过长的等待时间</strong>。</p>
<p><strong>serial收集器的新生代采用复制算法，老年代采取标记整理算法</strong>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/4d99d32625cd2bcdd3a32cd978cea4592ee.jpg" alt=""></p>
<p>虽然经过长久的发展，为了减少停顿，开发团队设计和实现了许多更优秀更复杂的收集器，但不意味着serial老而无用。它目前仍然是虚拟机运行在client模式下的默认新生代收集器。它的优点是<strong>简单高效</strong>，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p>
<p>在 Client 应用场景中，分配给虚拟机管理的内存一般来说不会很大，该收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p>
<h2 id="6-2-ParNew-收集器"><a href="#6-2-ParNew-收集器" class="headerlink" title="6.2 ParNew 收集器"></a>6.2 ParNew 收集器</h2><p><strong>它是 Serial 收集器的多线程版本。</strong>除了使用多线程进行垃圾收集之外，其余行为包括serial收集器可用的控制参数、收集算法、stop the world、对象分配规则、回收策略等都和serial收集器完全一样。实际上二者也共用了相当多的代码。</p>
<p><img src="https://oscimg.oschina.net/oscnet/13cf838ac2071b9871818127bbf7134ea75.jpg" alt=""></p>
<p>虽然并无太多创新之处，但它是许多运行在Server模式下的虚拟机首选的新生代收集器，除了性能原因外，主要是因为除了serial收集器，只有它能与CMS收集器配合工作。</p>
<p>默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>
<blockquote>
<p>CMS收集器在jdk1.5中横空出世，其并发收集的特性具有划时代意义，但它作为老年代收集器，却只能和parnew和serial配合工作。parnew因为性能原因，是在使用cms时默认的新生代收集器。</p>
</blockquote>
<h2 id="6-3-parallel-scavenge收集器"><a href="#6-3-parallel-scavenge收集器" class="headerlink" title="6.3 parallel scavenge收集器"></a>6.3 parallel scavenge收集器</h2><p>新生代收集器，<strong>复制算法</strong>，并行的多线程收集器。看起来和parnew收集器类似，但它的特点是它的关注点和其他收集器不同。CMS等收集器的关注点是尽可能的缩短垃圾收集时的停顿时间，而parallel scavenge收集器的目的是达到一个可控制的吞吐量。它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。（比如虚拟机运行了100分钟，垃圾回收花掉1分钟，则吞吐量是99%）</p>
<blockquote>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。<br>而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
</blockquote>
<p>parallel scavenge提供了下列参数用于精确控制吞吐量:</p>
<ul>
<li>控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数，值为大于0的毫秒数，收集器尽可能保证内存回收花费的时间不超过该值。</li>
<li>直接设置吞吐量大小的 -XX:GCTimeRatio 参数，值为大于 0 且小于 100 的整数，它的值是吞吐量的倒数。</li>
<li>开关参数 -XX:+UseAdaptiveSizePolicy。打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。</li>
</ul>
<blockquote>
<p>不要以为把XX:MaxGCPauseMillis 设置得小一些就能使垃圾回收更快，GC停顿时间缩短是牺牲吞吐量和新生代空间换来的。不说别的，调小这个值，一般会导致gc触发更加频繁，吞吐量反而下降。</p>
</blockquote>
<h2 id="6-4-Serial-Old收集器"><a href="#6-4-Serial-Old收集器" class="headerlink" title="6.4 Serial Old收集器"></a>6.4 Serial Old收集器</h2><p>老年代收集器，串行的单线程收集器，使用<strong>标记整理算法</strong>。是serial收集器的老年代版本。</p>
<p>Serial Old是Serial收集器的老年代版本，是个单线程收集器，也是给Client模式下的虚拟机使用。如果用在Server模式下，它有两大用途：</p>
<ul>
<li>在JDK 1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/b4b25c2752edb839b6b9e185e6ab3093dd4.jpg" alt=""></p>
<h2 id="6-5-Parallel-Old收集器"><a href="#6-5-Parallel-Old收集器" class="headerlink" title="6.5 Parallel Old收集器"></a>6.5 Parallel Old收集器</h2><p>老年代收集器，并行的多线程收集器，标记整理算法。是Parallel Scavenge收集器的老年代版本，吞吐量优先的垃圾回收器。</p>
<p>在注重吞吐量以及CPU资源敏感的场合（服务端应用），都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<p><img src="https://oscimg.oschina.net/oscnet/4e335c54c634db7a57ee286044f08f27713.jpg" alt=""></p>
<h2 id="6-6-CMS收集器（详细介绍）"><a href="#6-6-CMS收集器（详细介绍）" class="headerlink" title="6.6 CMS收集器（详细介绍）"></a>6.6 CMS收集器（详细介绍）</h2><p>老年代收集器，并行的多线程收集器，使用<strong>标记整理</strong>算法。是一种以获取最短回收停顿时间为目标的收集器。目前大部分java应用集中在互联网网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短。</p>
<p>CMS牺牲了系统的吞吐量来追求收集速度，适合追求垃圾收集速度的服务器上。</p>
<h3 id="6-6-1-优缺点"><a href="#6-6-1-优缺点" class="headerlink" title="6.6.1 优缺点"></a>6.6.1 优缺点</h3><p>特点：</p>
<ul>
<li><p>并发收集</p>
</li>
<li><p>低停顿。<br>缺点：</p>
</li>
<li><p>对CPU资源敏感。因为并发阶段虽然用户线程不停顿，但会占用CPU资源导致用户线程变慢，吞吐量降低。CMS默认启动的回收线程数是 (CPU 数量 + 3) / 4。</p>
<ul>
<li>当CPU&gt;4时，并发线程&gt;25%的CPU资源。且随CPU数量增加而下降。</li>
<li>当CPU&lt;4时（假设为2），并发线程&gt;50%的CPU资源，很影响用户体验。</li>
</ul>
</li>
<li><p>无法处理浮动垃圾。</p>
<ul>
<li>浮动垃圾：由于并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留到下一次 GC 时再清理掉，这一部分垃圾就被称为“浮动垃圾”。</li>
<li>也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此它不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li>
<li>可以使用 -XX:CMSInitiatingOccupancyFraction 的值来改变触发收集器工作的内存占用百分比，JDK 1.5默认设置下该值为68，JDK1.6默认设置下该值为92，也就是当老年代使用了68%(92%)的空间之后会触发收集器工作。</li>
<li>如果-XX:CMSInitiatingOccupancyFraction 设置的太高，导致浮动垃圾无法保存，那么就会出现Concurrent Mode Failure，此时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集。</li>
</ul>
</li>
<li><p>标记 - 标记清除算法会导致大量空间碎片，给大对象分配带来很大的麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次Full GC。</p>
</li>
</ul>
<h3 id="6-6-2-触发条件"><a href="#6-6-2-触发条件" class="headerlink" title="6.6.2 触发条件"></a>6.6.2 触发条件</h3><p>CMS垃圾收集器的触发条件有以下几个：</p>
<ol>
<li>如果没有设置-XX:+UseCMSInitiatingOccupancyOnly，虚拟机会根据收集的数据决定是否触发（建议带上这个参数）。</li>
<li>老年代使用率达到阈值 CMSInitiatingOccupancyFraction，默认68%，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。前提是配置了第一个参数。</li>
<li>永久代的使用率达到阈值 CMSInitiatingPermOccupancyFraction，默认92%，前提是开启 CMSClassUnloadingEnabled并且配置了第一个参数。</li>
<li>新生代的晋升担保失败。老年代有足够的空间，但是由于碎片化严重，无法容纳新生代中晋升的对象，发生晋升失败。</li>
</ol>
<h3 id="6-6-3-收集过程"><a href="#6-6-3-收集过程" class="headerlink" title="6.6.3 收集过程"></a>6.6.3 收集过程</h3><p>采用“标记-清理”算法对老年代进行回收，过程可以说很简单，标记出存活对象，清理掉垃圾对象，但是为了实现整个过程的低延迟，实际算法远远没这么简单，整个过程分为如下几个部分：</p>
<ul>
<li>初始标记(CMS-initial-mark) ，仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，<strong>需要停顿</strong>。</li>
<li>并发标记(CMS-concurrent-mark)，与用户线程同时运行，进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，。</li>
<li>预清理（CMS-concurrent-preclean），与用户线程同时运行；</li>
<li>可被终止的预清理（CMS-concurrent-abortable-preclean） 与用户线程同时运行；</li>
<li>并发重新标记(CMS-remark) ，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，<strong>需要停顿</strong>。</li>
<li>并发清除(CMS-concurrent-sweep)，与用户线程同时运行。</li>
<li>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/a9cecff7a47d3a0d0678e22246c1e687f8c.jpg" alt=""></p>
<h4 id="6-6-3-1-初始标记"><a href="#6-6-3-1-初始标记" class="headerlink" title="6.6.3.1 初始标记"></a>6.6.3.1 初始标记</h4><p>这是CMS中两次stop-the-world事件中的第一次。该阶段的工作是：标记<strong>存活的对象</strong>，主要有两种对象：</p>
<ol>
<li>标记老年代中所有的GC Roots对象，如下图节点1；</li>
<li>标记年轻代中活着的对象（GC Roots可达）引用到的老年代的对象（指的是年轻带中还存活的引用类型对象，引用指向老年代中的对象）如下图节点2、3；</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/91717af3b0ca9a874a1156120718eb3bcd1.jpg" alt=""></p>
<blockquote>
<p>为了加快此阶段处理速度，减少停顿时间，可以开启初始标记并行化，-XX:+CMSParallelInitialMarkEnabled，同时调大并行标记的线程数，线程数不要超过cpu的核数。</p>
</blockquote>
<h4 id="6-6-3-2-并发标记"><a href="#6-6-3-2-并发标记" class="headerlink" title="6.6.3.2 并发标记"></a>6.6.3.2 并发标记</h4><p>该阶段的工作是：<br>    - 从”初始标记”阶段标记的对象开始找出所有存活的对象;<br>    - 有变更的对象作重新标记<br>        - 因为是并发运行的，在运行期间会发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。<br>        - 为了提高重新标记的效率，该阶段会把上述对象所在的Card标识为Dirty，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代；</p>
<blockquote>
<p>CMS将老年代的空间分成大小为512bytes的块，并维护一个叫做card table的数组（每个位置存的是一个byte），card table中的每个元素对应着一个块。并发标记时，如果某个对象的引用发生了变化，就标记该对象所在的块为dirty card。</p>
</blockquote>
<p>如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/ca047a2e3c46111f468435d4d84ae52a966.jpg" alt=""></p>
<p>先从”初始标记”阶段标记的对象开始找出所有存活的对象，即我们从节点1、2、3找到了节点4、5。</p>
<p>但在找到4/5节点的过程中，因为我们是并发执行的，所以可能会有一些引用发生了变更，比如节点3引用了另外一个对象，如下图：<br><img src="https://oscimg.oschina.net/oscnet/c50fbe36521473afe764d707d913ab58295.jpg" alt=""></p>
<p>这个时候，jvm会将节点3所在的card标记为dirty，但只做标记，不做处理。</p>
<h4 id="6-6-3-3-预清理阶段"><a href="#6-6-3-3-预清理阶段" class="headerlink" title="6.6.3.3 预清理阶段"></a>6.6.3.3 预清理阶段</h4><p>这个阶段就是用来处理前一个阶段因为引用关系改变导致没有标记到的存活对象的，它会扫描所有标记为Dirty的Card，然后将之前没有标记到的存活对象也标记上。</p>
<p>如下图，节点3引用的节点6也被标记上了，标记完成，并且将节点3的card的dirty状态清除。</p>
<p><img src="https://oscimg.oschina.net/oscnet/8f49f16ec62cca1671507fd60ae71648bed.jpg" alt=""></p>
<blockquote>
<p>通过参数CMSPrecleaningEnabled可以选择关闭该阶段，默认启用</p>
</blockquote>
<h4 id="6-6-3-4-可中断的预清理"><a href="#6-6-3-4-可中断的预清理" class="headerlink" title="6.6.3.4 可中断的预清理"></a>6.6.3.4 可中断的预清理</h4><p>该阶段发生的前提是，新生代Eden区的内存使用量大于参数CMSScheduleRemarkEdenSizeThreshold 设置的值，默认是2M，如果新生代的对象太少，就没有必要执行该阶段，直接执行重新标记阶段。</p>
<p><strong>为什么需要这个阶段，存在的价值是什么？</strong></p>
<p>其实这个阶段，是为了后面即将进行的“并发重新标记”环节能少一些工作量而设置的，“并发重新标记”我们还没讲到，这里简单说下：“并发重新标记”会扫描并且标记整个年老代的所有的存活对象，包括<strong>被新生代中的对象引用的老年代对象，即使新生代的对象已经不可达了，也将其引用的老年代对象视为存活</strong></p>
<p>因此，如果进入“并发重新标记”时，新生代的对象有很多，那么一个个检查过去他们是否引用老年代对象的过程也必然很长（所以该阶段触发前提是新生代内存大于CMSScheduleRemarkEdenSizeThreshold的值）</p>
<p>为了进入“并发重新标记”阶段时新生代对象尽可能少，“可中断的预清理”阶段会做两件工作：</p>
<ol>
<li>处理From和To区的对象，标记可达的老年代对象</li>
<li>和上一个阶段一样，扫描处理Dirty Card中的对象</li>
</ol>
<p>然而你会发现：</p>
<ul>
<li>工作1不就是“并发重新标记”的其中一项工作么，现在做和后续做，有什么区别吗？</li>
<li>工作2与其说是“可中断的预清理”的工作，还不如说cms收集器在并发过程中就一直会在标记这些dirty card，并不是该阶段独有的工作。</li>
</ul>
<p>如此看来，“可中断的预清理”阶段岂不是形同鸡肋？</p>
<p>其实，该阶段的目的在于：<strong>期待在该阶段的过程中，能够迎来一次young gc</strong>；</p>
<p>我们知道，新生代的对象大部分朝生暮死，每次young gc都会清理大量的新生代对象，如果在进入“并发重新标记”阶段前能够执行一次young gc，那“并发重新标记”阶段的扫描岂不是会轻松很多？</p>
<p>而且本身“可中断的预清理”阶段的触发前提就是新生代内存使用量超过一定阈值，虽然gc是JVM自动调度的，什么时候进行young gc我们控制不了，但既然能够满足“新生代内存使用量超过一定阈值”的前提，并进入“可中断的预清理”阶段，那么理论上离下一次的young gc应该也不远了。</p>
<p>所以，“可中断的预清理”阶段的核心就是：一直重复 “处理From和To区的对象，标记可达的老年代对象” 和 “扫描处理Dirty Card中的对象” 这两项工作，以期待在期间引来一次young gc</p>
<p>注意，是一直重复上述两项工作，直到：</p>
<ul>
<li>可以设置最多循环的次数 CMSMaxAbortablePrecleanLoops，默认是0，意思没有循环次数的限制。</li>
<li>如果执行这个逻辑的时间达到了阈值CMSMaxAbortablePrecleanTime，默认是5s，会退出循环。</li>
<li>如果新生代Eden区的内存使用率达到了阈值CMSScheduleRemarkEdenPenetration，默认50%，会退出循环。（这个条件能够成立的前提是，在进行Precleaning时，Eden区的使用率小于十分之一）</li>
</ul>
<h4 id="6-6-3-5-并发重新标记"><a href="#6-6-3-5-并发重新标记" class="headerlink" title="6.6.3.5 并发重新标记"></a>6.6.3.5 并发重新标记</h4><p>该阶段并发执行，在之前的并行阶段（GC线程和应用线程同时执行，好比你妈在打扫房间，你还在扔纸屑），可能产生新的引用关系如下：</p>
<ol>
<li>老年代的新对象被GC Roots引用</li>
<li>老年代的未标记对象被新生代对象引用</li>
<li>老年代已标记的对象增加新引用指向老年代其它对象</li>
<li>新生代对象指向老年代引用被删除</li>
<li>也许还有其它情况..<br>上述对象中可能有一些已经在Precleaning阶段和AbortablePreclean阶段被处理过，但总存在没来得及处理的，所以还有进行如下的处理：</li>
<li>遍历新生代对象和老年代对象，并重新标记存活的老年代对象，包括前文所说的<strong>新生代对象引用的老年代对象</strong>，即便新生代对象不可达了。</li>
<li>根据GC Roots，重新标记</li>
<li>遍历老年代的Dirty Card，重新标记，这里的Dirty Card大部分已经在clean阶段处理过，这里处理最近新生成的。</li>
</ol>
<p>在第一步骤中，需要遍历新生代的全部对象，如果新生代的使用率很高，需要遍历处理的对象也很多，这对于这个阶段的总耗时来说，是个灾难（因为可能大量的对象是暂时存活的，而且这些对象也可能引用大量的老年代对象，造成很多应该回收的老年代对象而没有被回收，遍历递归的次数也增加不少），如果在“可中断的预清理”阶段中能够恰好的发生一次young gc，这样就可以避免扫描无效的对象。</p>
<p>如果在AbortablePreclean阶段没来得及执行一次young gc，怎么办？</p>
<p>CMS算法中提供了一个参数：CMSScavengeBeforeRemark，默认并没有开启，如果开启该参数，在执行该阶段之前，会强制触发一次YGC，可以减少新生代对象的遍历时间，回收的也更彻底一点。</p>
<p>不过，这种参数有利有弊，利是降低了Remark阶段的停顿时间，弊的是在新生代对象很少的情况下也多了一次YGC，最可怜的是在AbortablePreclean阶段已经发生了一次YGC，然后在该阶段又傻傻的触发一次。</p>
<p>所以利弊需要把握。</p>
<h4 id="6-6-3-6-并发清理"><a href="#6-6-3-6-并发清理" class="headerlink" title="6.6.3.6 并发清理"></a>6.6.3.6 并发清理</h4><p>通过以上5个阶段的标记，老年代所有存活的对象已经被标记并且现在要通过Garbage Collector采用清扫的方式回收那些不能用的对象了。</p>
<p><strong>这个阶段主要是清除那些没有标记的对象并且回收空间</strong>；</p>
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<h2 id="6-7-G1收集器"><a href="#6-7-G1收集器" class="headerlink" title="6.7 G1收集器"></a>6.7 G1收集器</h2><p>G1 GC，全称Garbage-First Garbage Collector，通过-XX:+UseG1GC参数来启用，作为体验版随着JDK 6u14版本面世，在JDK 7u4版本发行时被正式推出，相信熟悉JVM的同学们都不会对它感到陌生。在JDK 9中，G1被提议设置为默认垃圾收集器（JEP 248）。</p>
<p>G1（Garbage First）垃圾收集器也是以关注延迟为目标、服务器端应用的垃圾收集器，被HotSpot团队寄予取代CMS的使命，也是一个非常具有调优潜力的垃圾收集器。</p>
<p>它是专门针对以下应用场景设计的:</p>
<ul>
<li>像CMS收集器一样，能与应用程序线程并发执行。</li>
<li>整理空闲空间更快。</li>
<li>需要GC停顿时间更好预测。</li>
<li>不希望牺牲大量的吞吐性能。</li>
</ul>
<p>它的特点有：</p>
<ol>
<li>的设计原则是”垃圾优先? 不是，是优先处理那些垃圾多的内存块(Garbage First)”。因此，G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。同时G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；</li>
<li>G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；</li>
<li>G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；</li>
<li>G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</li>
<li>G1整体采用标记-整理算法，局部是通过是通过复制算法，不会产生很多内存碎片。</li>
</ol>
<h3 id="6-7-1-G1的内存模型"><a href="#6-7-1-G1的内存模型" class="headerlink" title="6.7.1 G1的内存模型"></a>6.7.1 G1的内存模型</h3><h4 id="6-7-1-1-region分区"><a href="#6-7-1-1-region分区" class="headerlink" title="6.7.1.1 region分区"></a>6.7.1.1 region分区</h4><p>G1将新生代，老年代的物理空间划分模糊化了。取而代之的是，G1算法将堆划分为若干个大小相等的内存区域（Region）。</p>
<ul>
<li><p>每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；</p>
</li>
<li><p>启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code>可指定region大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个region。</p>
</li>
<li><p>它仍然属于分代收集器，仍然会分为新生代（Eden和survivor）和老年代，只不过此时的内存单位是region，即某些region为新生代服务（如下图的E和S），某些region为老年代服务（下图的O），<strong>新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间</strong>。</p>
</li>
<li><p>每个region也不会确定地只为某个代服务，可以按需在年轻代和老年代之间切换。（但在特定时刻，它要么为新生代服务，要么为老年代服务）。年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲region加入到年轻代空间。</p>
</li>
<li><p>整个年轻代内存会在初始空间<code>-XX:G1NewSizePercent</code>(默认整堆5%)与最大空间<code>-XX:G1MaxNewSizePercent</code>(默认60%)之间动态变化，且由参数目标暂停时间<code>-XX:MaxGCPauseMillis</code>(默认200ms)、需要扩缩容的大小以及分区的已记忆集合(RSet)计算得到。当然，G1依然可以设置固定的年轻代大小(参数<code>-XX:NewRatio、-Xmn</code>)，但同时暂停目标将失去意义。</p>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/143e8c4013e811b881e3083163b22b7980d.png" alt=""></p>
<h4 id="6-7-1-2-Card"><a href="#6-7-1-2-Card" class="headerlink" title="6.7.1.2 Card"></a>6.7.1.2 Card</h4><p>在cms收集器的介绍中我们提到过card，这里的card也类似，是比region更小的一个内存单位。</p>
<p>G1启用后，jvm会在每个分区内部分配了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度。所有分区的卡片都会记录在卡片表(Card Table)中。</p>
<p>分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时，便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理。</p>
<p><img src="https://oscimg.oschina.net/oscnet/9049e04d540dd52600d14c6f22b099cfb16.png" alt=""></p>
<h4 id="6-7-1-3-本地分配缓冲（LAB）"><a href="#6-7-1-3-本地分配缓冲（LAB）" class="headerlink" title="6.7.1.3 本地分配缓冲（LAB）"></a>6.7.1.3 本地分配缓冲（LAB）</h4><p>本地分配缓冲 Local allocation buffer 简称Lab</p>
<p>我们知道TLAB是在eden区分配的一个线程私有的本地缓冲，当我们启用G1收集器的时候，TLAB的内存单位，也相应的改为了region，即：</p>
<ul>
<li><p>每个线程均可以”认领”某个region用于线程本地的内存分配，而不需要顾及region是否连续。</p>
</li>
<li><p>TLAB大部分都会落入Eden区域(巨型对象或分配失败除外)，因此TLAB的分区属于Eden空间；</p>
</li>
<li><p>而每次垃圾收集时，每个GC线程同样可以独占一个本地缓冲区(GCLAB)用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；对于从Eden/Survivor空间晋升(Promotion)到Survivor/老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(PLAB)。</p>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/cfc951a4c4d9dff97f49be46a44c5506500.png" alt=""></p>
<h4 id="6-7-1-4-Humongous区域"><a href="#6-7-1-4-Humongous区域" class="headerlink" title="6.7.1.4 Humongous区域"></a>6.7.1.4 Humongous区域</h4><p>在G1中，还有一种特殊的区域，叫Humongous区域。 如果一个对象占用的空间超过了region容量50%以上，G1收集器就认为这是一个巨型对象。</p>
<p>当线程为巨型分配空间时，不能简单在TLAB进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。</p>
<p>因此这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象。</p>
<p>如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。<strong>为了能找到连续的H区，有时候不得不启动Full GC</strong>。</p>
<p>巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为开始巨型(StartsHumongous)，相邻连续分区被标记为连续巨型(ContinuesHumongous)。由于无法享受Lab带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象。</p>
<h4 id="6-7-1-5-Remember-Set"><a href="#6-7-1-5-Remember-Set" class="headerlink" title="6.7.1.5 Remember Set"></a>6.7.1.5 Remember Set</h4><p>在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中（即存活）。然而G1为了避免STW式的整堆扫描，在每个region内部记录了一个已记忆集合(RSet)，这个RSet是个point-into思路（谁引用了我的对象）的产物，用来记录“引用了RSet所在region内的对象的卡片索引”。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内对象的对象是否存活，进而确定本分区内的对象存活情况。</p>
<p>事实上，并非所有的引用都需要记录在RSet中，G1 GC每次都会对年轻代进行整体收集，因此引用来源于年轻代的对象（新生代对象引用新年代对象，或者老年代引用新生代对象），也不需要在RSet中记录（即无需记录哪些老年代对象引用了我）。只需要记录新生代引用老年代对象这种跨代引用。</p>
<p>鉴于RSet是个point-into思路（谁引用了我的对象）的产物，故而最后只有老年代的region可能会有RSet记录（记录哪些新生代对象引用了我），这些分区称为拥有RSet分区(an RSet’s owning region)。</p>
<p>下图表示了RSet、Card和Region的关系</p>
<p><img src="https://oscimg.oschina.net/oscnet/b7d7d251525f0241d39159394b6e6d221c5.png" alt=""></p>
<p>上图中有三个Region，每个Region被分成了多个Card，在不同Region中的Card会相互引用，Region1中的Card中的对象引用了Region2中的Card中的对象，蓝色实线表示的就是points-out的关系，而在Region2的RSet中，记录了Region1的Card，即红色虚线表示的关系，就是points-into。</p>
<h4 id="6-7-1-6-收集集合-CSet"><a href="#6-7-1-6-收集集合-CSet" class="headerlink" title="6.7.1.6 收集集合 (CSet)"></a>6.7.1.6 收集集合 (CSet)</h4><p>收集集合(Collection Set 简称CSet)是每次G1 GC暂停时回收的目标region的集合。在任意一次收集暂停中，CSet内的所有region都会被释放，内部存活的对象都会被转移到分配的空闲region中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集CSet只容纳年轻代region，而混合收集会通过启发式算法，在老年代候选回收region中，筛选出回收收益最高的region添加到CSet中。</p>
<p>哪些老年代Region会被选入CSet，由一系列参数控制，后续详解。</p>
<p>由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。</p>
<h3 id="6-7-2-G1如何保证在并发标记的正确性"><a href="#6-7-2-G1如何保证在并发标记的正确性" class="headerlink" title="6.7.2 G1如何保证在并发标记的正确性"></a>6.7.2 G1如何保证在并发标记的正确性</h3><p>SATB的全称（Snapshot At The Beginning）字面意思是开始GC前存活对象的一个快照。SATB的作用是保证在并发标记阶段的正确性。如何理解这句话？</p>
<h4 id="6-7-2-1-三色标记法"><a href="#6-7-2-1-三色标记法" class="headerlink" title="6.7.2.1 三色标记法"></a>6.7.2.1 三色标记法</h4><p>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。</p>
<ul>
<li>黑色:根对象，或者该对象与它的子对象都被扫描</li>
<li>灰色:对象本身被扫描,但还没扫描完该对象中的子对象</li>
<li>白色:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</li>
</ul>
<p>当GC开始扫描对象时，按照如下图步骤进行对象的扫描：<br>根对象被置为黑色，子对象被置为灰色。</p>
<p><img src="https://oscimg.oschina.net/oscnet/74ab428c55bb760a80c4b8bfe635d14c039.png" alt=""></p>
<p>继续由灰色遍历,将已扫描了子对象的对象置为黑色。</p>
<p><img src="https://oscimg.oschina.net/oscnet/12be353e898117fbd49072763bacd0b6693.png" alt=""></p>
<p>遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。</p>
<p><img src="https://oscimg.oschina.net/oscnet/8c27fb72fcfb8af79455ab653c422135cad.png" alt=""></p>
<p>这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p>
<p>我们看下面一种情况，当垃圾收集器扫描到下面情况时：</p>
<p><img src="https://oscimg.oschina.net/oscnet/0859ebbd57f3dd299d9602d4f03ab22645d.png" alt=""></p>
<p>这时候应用程序执行了以下操作：</p>
<ol>
<li><p>c=C</p>
</li>
<li><p>c=null</p>
</li>
</ol>
<p>这样，对象的状态图变成如下情形：</p>
<p><img src="https://oscimg.oschina.net/oscnet/2e1c898dbbc8d7a5a96651d7b827ff4d9cc.png" alt=""></p>
<p>这时候垃圾收集器再标记扫描的时候就会下图成这样（因为不会扫描黑色对象的子对象，所以C不会被再标记）：</p>
<p><img src="https://oscimg.oschina.net/oscnet/037553f08aafc012c4088cd376f61b6f53e.png" alt=""></p>
<p>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：</p>
<ul>
<li>在删除的时候记录对象</li>
<li>在插入的时候记录对象</li>
</ul>
<p>这里，就需要讲到barrier了</p>
<h4 id="6-7-2-2-barrier"><a href="#6-7-2-2-barrier" class="headerlink" title="6.7.2.2 barrier"></a>6.7.2.2 barrier</h4><p>我们首先介绍一下栅栏(Barrier)的概念。栅栏是指在原生代码片段中，当某些语句被执行时，栅栏代码也会被执行。栅栏代码分为写前栅栏(Pre-Write Barrrier)和写后栅栏(Post-Write Barrrier)。事实上，写栅栏的指令序列开销非常昂贵，应用吞吐量也会根据栅栏复杂度而降低。</p>
<p><img src="https://oscimg.oschina.net/oscnet/4b9dc302e676f69ad2eceeecb56ff856c45.png" alt=""></p>
<p><strong>写前栅栏 Pre-Write Barrrier</strong></p>
<ul>
<li>即将执行一段赋值语句a=b时，原来a所指向的对象假设为A将丢失一个引用。类比G1的场景，即a不再指向A，那么A所在region将因此丧失一个引用。</li>
<li>那么JVM就需要在赋值语句生效之前，记录丧失引用的对象在更新日志缓冲区。JVM并不会立即维护RSet，而是后面找个时机批量处理，在将来对RSet进行更新。</li>
</ul>
<p><strong>写后栅栏 Post-Write Barrrier</strong></p>
<ul>
<li>当执行一段赋值语句a=b后，等式右侧对象，即b引用指向的对象B，获取了左侧对象a的引用。类比G1的场景，那么B所在分区的RSet也应该得到更新。同样为了降低开销，写后栅栏发生后，RSet也不会立即更新，同样只是记录此次更新日志，在将来批量处理(见Concurrence Refinement Threads)。</li>
</ul>
<h4 id="6-7-2-3-SATB"><a href="#6-7-2-3-SATB" class="headerlink" title="6.7.2.3 SATB"></a>6.7.2.3 SATB</h4><p>结合我们之前说的GC标记的对象不丢失的方法</p>
<ul>
<li>在删除的时候记录对象（写前栅栏 Pre-Write Barrrier）</li>
<li>在插入的时候记录对象（写后栅栏 Post-Write Barrrier）</li>
</ul>
<p>刚好这对应CMS和G1的2种不同实现方式：</p>
<ul>
<li><p>在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。(写后栅栏)</p>
</li>
<li><p>在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象(写前栅栏)，它有如下步骤：</p>
<ol>
<li><p>在开始标记的时候生成一个快照图标记存活对象（通过可达性分析得到）</p>
</li>
<li><p>在并发标记阶段，当引用关系发生变化的时候，通过pre-write barrier函数会把这种这种变化记录下来，记录方式如下：</p>
<ul>
<li>找到该引用字段所在的位置(Card)，并设置为dirty_card</li>
<li>如果当前是应用线程，每个Java线程有一个dirty card queue，把该card插入队列</li>
<li>除了每个线程自带的dirty card queue，还有一个全局共享的queue</li>
</ul>
</li>
<li><p>接下来的RSet更新操作交由多个ConcurrentG1RefineThread（）并发完成，每当全局队列集合超过一定阈值后，ConcurrentG1RefineThread会取出若干个队列，遍历每个队列中记录的card，并进行处理，大概实现逻辑如下：</p>
<ul>
<li>根据card的地址，计算出card所在的Region</li>
<li>如果Region不存在，或者Region是Young区，或者该Region在回收集合中，则不进行处理</li>
<li>否则，更新对应的RSet</li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>并发优化线程(Concurrence Refinement Threads)，只专注扫描日志缓冲区记录的卡片来维护更新RSet，线程最大数目可通过<code>-XX:G1ConcRefinementThreads</code>(默认等于-XX:ParellelGCThreads)设置。</p>
</blockquote>
<blockquote>
<p>并发优化线程永远是活跃的，一旦发现全局列表有记录存在，就开始并发处理。如果记录增长很快或者来不及处理，那么通过阈值<code>-X:G1ConcRefinementGreenZone/-XX:G1ConcRefinementYellowZone/-XX:G1ConcRefinementRedZone</code>，G1会用分层的方式调度，使更多的线程处理全局列表。</p>
</blockquote>
<blockquote>
<p>如果并发优化线程也不能跟上缓冲区数量，则Mutator线程(Java应用线程)会挂起应用并被加进来帮助处理，直到全部处理完。因此，必须避免此类场景出现。</p>
</blockquote>
<p>SATB的方式记录活对象，因为是快照形式，故而也就是那一时刻对象的snapshot，这时会有两类对象需要特殊处理。</p>
<ul>
<li><p>在GC过程中变成垃圾的对象，这些叫做浮动垃圾（floating garbage），浮动垃圾只能等到下一次收集回收掉。</p>
</li>
<li><p>在GC过程中新分配的对象，G1的策略是将其都当做是活的，其他不可达的对象就是死的。</p>
</li>
</ul>
<p>如何知道哪些对象是GC开始之后新分配的呢？</p>
<p>原来Region包含了5个指针，分别是bottom、previous TAMS、next TAMS、top和end。其中top是该region的当前分配指针，[bottom, top)是当前该region已用（used）的部分，[top, end)是尚未使用的可分配空间（unused）。</p>
<p><img src="https://oscimg.oschina.net/oscnet/7cc36319d43b695bd537e77d06b10923894.png" alt=""></p>
<p>其previous TAMS、next TAMS是前后两次发生并发标记时的位置，全称top-at-mark-start，他们会发生如下变动：</p>
<ol>
<li><p>假设第n轮并发标记开始，将该Region当前的top指针赋值给next TAMS，在并发标记标记期间，分配的对象都在[next TAMS, top]之间，SATB能够确保这部分的对象都会被标记，默认都是存活的</p>
</li>
<li><p>当并发标记结束时，将next TAMS所在的地址赋值给previous TAMS，SATB给 [bottom, previous TAMS] 之间的对象创建一个快照，所有垃圾对象能通过快照被识别出来</p>
</li>
<li><p>第n+1轮并发标记开始，过程和第n轮一样</p>
</li>
</ol>
<h3 id="6-7-3-停顿预测模型"><a href="#6-7-3-停顿预测模型" class="headerlink" title="6.7.3 停顿预测模型"></a>6.7.3 停顿预测模型</h3><p>G1 GC是一个响应时间优先的GC算法，它与CMS最大的不同是，用户可以设定整个GC过程的期望停顿时间，参数<code>-XX:MaxGCPauseMillis</code>指定一个G1收集过程目标停顿时间，默认值200ms，不过它不是硬性条件，只是期望值。</p>
<p>那么G1怎么满足用户的期望呢？就需要这个停顿预测模型了。G1根据这个模型统计计算出来的历史数据来预测本次收集需要选择的Region数量(即CSet大小)，从而尽量满足用户设定的目标停顿时间。</p>
<p>关于停顿时间的设置并不是越短越好。设置的时间越短意味着每次收集的CSet越小，导致垃圾逐步积累变多，最终不得不退化成Serial GC（Full GC）；停顿时间设置的过长，那么会导致每次都会产生长时间的停顿，影响了程序对外的响应时间。</p>
<h3 id="6-7-4-G1回收的过程"><a href="#6-7-4-G1回收的过程" class="headerlink" title="6.7.4 G1回收的过程"></a>6.7.4 G1回收的过程</h3><p>G1提供了两种GC模式，Young GC和Mixed GC，两种都是完全Stop The World的。</p>
<ol>
<li><p>Young GC：选定<strong>所有</strong>年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。</p>
</li>
<li><p>Mixed GC：选定<strong>所有</strong>年轻代里的Region，外加根据global concurrent marking(全局并发标记)统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。</p>
</li>
</ol>
<p>由上面的描述可知，Mixed GC不是full GC，它只能回收部分老年代的Region，如果mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。</p>
<h4 id="6-7-4-1-Young-GC"><a href="#6-7-4-1-Young-GC" class="headerlink" title="6.7.4.1 Young GC"></a>6.7.4.1 Young GC</h4><p>Young GC 回收的是所有年轻代的Region。当E区不能再分配新的对象时就会触发。E区的对象会移动到S区，当S区空间不够的时候，E区的对象会直接晋升到O区，同时S区的数据移动到新的S区，如果S区的部分对象到达一定年龄，会晋升到O区。</p>
<p>Yung GC过程示意图如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/e806b69f5e601a8e108870a056d005b5357.png" alt=""></p>
<h4 id="6-7-4-2-Mixed-GC"><a href="#6-7-4-2-Mixed-GC" class="headerlink" title="6.7.4.2 Mixed GC"></a>6.7.4.2 Mixed GC</h4><p>Mixed GC 翻译过来叫混合回收。之所以叫混合是因为回收<strong>所有的</strong>年轻代的Region+<strong>部分</strong>老年代的Region。</p>
<p>Mixed GC的触发也是由<code>-XX:InitiatingHeapOccupancyPercent</code>控制，这个值叫做IHOP阈值，表示老年代占整个堆大小的百分比，默认值是45%，达到该阈值就会触发一次Mixed GC。</p>
<p>Mixed GC分为两个阶段：</p>
<ol>
<li>全局并发标记阶段(Global Concurrent marking)</li>
<li>拷贝存活对象阶段(evacuation)</li>
</ol>
<h5 id="6-7-4-2-1-全局并发标记阶段"><a href="#6-7-4-2-1-全局并发标记阶段" class="headerlink" title="6.7.4.2.1 全局并发标记阶段"></a>6.7.4.2.1 全局并发标记阶段</h5><pre><code>全局并发标记阶段是基于SATB的，与CMS有些类似，但是也有不同的地方，主要的几个阶段如下：</code></pre><ul>
<li><p>初始标记 Initial Mark</p>
<ul>
<li>该阶段会STW</li>
<li>负责标记所有能被直接可达的根对象(原生栈对象、全局对象、JNI对象)，根是对象图的起点，因此初始标记需要将Mutator线程(Java应用线程)暂停掉，也就是需要一个STW的时间段。</li>
<li>事实上，当达到IHOP阈值时，G1并不会立即进入<strong>并发标记</strong>阶段，而是等待下一次年轻代收集，利用年轻代收集的STW时间段，完成初始标记，这种方式称为借道(Piggybacking)。在初始标记暂停中，分区的NTAMS都被设置到分区顶部Top，初始标记是并发执行，直到所有的分区处理完。</li>
</ul>
</li>
<li><p>根分区扫描 Root Region Scanning</p>
<ul>
<li>在初始标记暂停结束后，年轻代收集也完成将对象复制到Survivor的工作，应用线程开始活跃起来。</li>
<li>此时为了保证标记算法的正确性，所有新复制到Survivor分区的对象，都需要被扫描并标记成根，这个过程称为根分区扫描</li>
<li>同时扫描的Suvivor分区也被称为根分区(Root Region)。根分区扫描必须在下一次年轻代垃圾收集启动前完成(并发标记的过程中，可能会被若干次年轻代垃圾收集打断)，因为每次GC会产生新的存活对象集合。</li>
</ul>
</li>
</ul>
<ul>
<li><p>并发标记 Concurrent Marking</p>
<ul>
<li>和应用线程并发执行，专门司职并发标记的<strong>并发标记线程</strong>在并发标记阶段启动，可由参数<code>-XX:ConcGCThreads(默认GC线程数的1/4，即-XX:ParallelGCThreads/4)</code>控制并发标记线程启动数量。</li>
<li><strong>每个线程每次只扫描一个region分区，根据RSet收集各个Region的存活对象信息</strong>。在这一阶段会处理Previous/Next标记位图，扫描标记对象的引用字段。同时，并发标记线程还会定期检查和处理STAB全局缓冲区列表的记录（即SATB write barrier所记录下的引用），更新对象引用信息。</li>
</ul>
</li>
<li><p>最终标记 Remark</p>
<ul>
<li>该阶段会STW</li>
<li>是最后一个标记阶段。在该阶段中，G1需要一个暂停的时间，去处理剩下的SATB日志缓冲区和所有更新，找出所有未被访问的存活对象，同时安全完成存活数据计算。</li>
<li>这个阶段也是并行（注意不是并发，否则也不需要STW）执行的，通过参数<code>-XX:ParallelGCThread</code>可设置GC暂停时可用的GC线程数。</li>
<li>同时，引用处理也是重新标记阶段的一部分，所有重度使用引用对象(弱引用、软引用、虚引用、最终引用)的应用都会在引用处理上产生开销。</li>
</ul>
</li>
<li><p>清理 Cleanup</p>
<ul>
<li>该阶段会STW</li>
<li>清点和重置标记状态。这个阶段有点像mark-sweep中的sweep阶段，这个阶段并不会实际上去做垃圾的收集，只是整理堆分区，为混合收集周期识别回收收益高(基于释放空间和暂停目标)的老年代分区集合，去根据停顿模型来预测出CSet，等待evacuation（拷贝存活对象）阶段来回收。</li>
<li>preview TAMS/next TAMS 会在清除阶段交换角色</li>
<li>如果发现完全没有活对象的region就会将其整体回收到可分配region列表中。 清除空Region。</li>
</ul>
</li>
</ul>
<h5 id="6-7-4-2-2-拷贝存活对象"><a href="#6-7-4-2-2-拷贝存活对象" class="headerlink" title="6.7.4.2.2 拷贝存活对象"></a>6.7.4.2.2 拷贝存活对象</h5><p>Evacuation阶段是全暂停的。它负责把CSet里面的region里的活对象拷贝到空region里去（并行拷贝），然后回收原本的region的空间（加入空闲分区列表，清除空Region）。</p>
<p>Mixed GC的清理过程示意图如下：</p>
<p><img src="https://oscimg.oschina.net/oscnet/ca718b9f0b421c46434f7fcccf43b5a1f49.png" alt=""></p>
<p>但Evacuation是可能失败的：</p>
<p>转移失败(Evacuation Failure)是指当G1无法在堆空间中申请新的分区时，G1便会触发担保机制，执行一次STW式的、单线程的Full GC。Full GC会对整堆做标记清除和压缩，最后将只包含纯粹的存活对象。参数<code>-XX:G1ReservePercent(默认10%)</code>可以设置保留空间，来应对晋升模式下的异常情况，最大占用整堆50%，更大也无意义。</p>
<p>G1在以下场景中会触发Full GC，同时会在日志中记录to-space-exhausted以及Evacuation Failure：</p>
<ol>
<li>从年轻代分区拷贝存活对象时，无法找到可用的空闲分区</li>
<li>从老年代分区转移存活对象时，无法找到可用的空闲分区</li>
<li>分配巨型对象时在老年代无法找到足够的连续分区<br>由于G1的应用场合往往堆内存都比较大，所以Full GC的收集代价非常昂贵，应该避免Full GC的发生。</li>
</ol>
<h1 id="7-垃圾回收相关的参数"><a href="#7-垃圾回收相关的参数" class="headerlink" title="7 垃圾回收相关的参数"></a>7 垃圾回收相关的参数</h1><p><img src="https://oscimg.oschina.net/oscnet/f5894fef49569a1c2124fc8af3cd901c095.png" alt=""></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://oscimg.oschina.net/oscnet/46fa2d0f05b19bd564bb69547c375bf24c2.png" alt=""></h2><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://www.jianshu.com/p/870abddaba41" target="_blank" rel="noopener" title="G1垃圾收集器之RSet">G1垃圾收集器之RSet</a><br><a href="https://blog.csdn.net/coderlius/article/details/79272773" target="_blank" rel="noopener" title="详解 JVM Garbage First(G1) 垃圾收集器">详解 JVM Garbage First(G1) 垃圾收集器</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
            <a href="/tags/gc/" rel="tag"># gc</a>
          
            <a href="/tags/CMS/" rel="tag"># CMS</a>
          
            <a href="/tags/G1/" rel="tag"># G1</a>
          
            <a href="/tags/STW/" rel="tag"># STW</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/23/JAVA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="next" title="JAVA内存结构和内存管理">
                <i class="fa fa-chevron-left"></i> JAVA内存结构和内存管理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/25/JAVA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" rel="prev" title="JAVA对象的创建和内存分配策略">
                JAVA对象的创建和内存分配策略 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2019/11/21/JAVA垃圾回收器/"
           data-title="JAVA垃圾回收器" data-url="http://yoursite.com/2019/11/21/JAVA%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">98</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-判断对象死亡与否"><span class="nav-text">1.判断对象死亡与否</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-引用计数法"><span class="nav-text">1.1 引用计数法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-可达性分析算法"><span class="nav-text">1.2 可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-引用"><span class="nav-text">2. 引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-finalize方法"><span class="nav-text">3. finalize方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-方法区的回收"><span class="nav-text">4. 方法区的回收</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-垃圾回收算法"><span class="nav-text">4. 垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-标记-清除算法"><span class="nav-text">4.1 标记-清除算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-复制算法"><span class="nav-text">4.2 复制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-新生代的回收"><span class="nav-text">4.2.1 新生代的回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-标记-整理算法"><span class="nav-text">4.3 标记-整理算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-分代收集算法"><span class="nav-text">4.4 分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-HotSpot虚拟机的算法实现"><span class="nav-text">5 HotSpot虚拟机的算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-枚举根节点"><span class="nav-text">5.1 枚举根节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-安全点Safe-Point"><span class="nav-text">5.2 安全点Safe Point</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-安全区域safe-region"><span class="nav-text">5.3 安全区域safe region</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-垃圾收集器"><span class="nav-text">6 垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-serial收集器"><span class="nav-text">6.1 serial收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-ParNew-收集器"><span class="nav-text">6.2 ParNew 收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-parallel-scavenge收集器"><span class="nav-text">6.3 parallel scavenge收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-Serial-Old收集器"><span class="nav-text">6.4 Serial Old收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-Parallel-Old收集器"><span class="nav-text">6.5 Parallel Old收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-CMS收集器（详细介绍）"><span class="nav-text">6.6 CMS收集器（详细介绍）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-优缺点"><span class="nav-text">6.6.1 优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-触发条件"><span class="nav-text">6.6.2 触发条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3-收集过程"><span class="nav-text">6.6.3 收集过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-3-1-初始标记"><span class="nav-text">6.6.3.1 初始标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-3-2-并发标记"><span class="nav-text">6.6.3.2 并发标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-3-3-预清理阶段"><span class="nav-text">6.6.3.3 预清理阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-3-4-可中断的预清理"><span class="nav-text">6.6.3.4 可中断的预清理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-3-5-并发重新标记"><span class="nav-text">6.6.3.5 并发重新标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-3-6-并发清理"><span class="nav-text">6.6.3.6 并发清理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-G1收集器"><span class="nav-text">6.7 G1收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-1-G1的内存模型"><span class="nav-text">6.7.1 G1的内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-1-region分区"><span class="nav-text">6.7.1.1 region分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-2-Card"><span class="nav-text">6.7.1.2 Card</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-3-本地分配缓冲（LAB）"><span class="nav-text">6.7.1.3 本地分配缓冲（LAB）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-4-Humongous区域"><span class="nav-text">6.7.1.4 Humongous区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-5-Remember-Set"><span class="nav-text">6.7.1.5 Remember Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-6-收集集合-CSet"><span class="nav-text">6.7.1.6 收集集合 (CSet)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-2-G1如何保证在并发标记的正确性"><span class="nav-text">6.7.2 G1如何保证在并发标记的正确性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-2-1-三色标记法"><span class="nav-text">6.7.2.1 三色标记法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-2-2-barrier"><span class="nav-text">6.7.2.2 barrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-2-3-SATB"><span class="nav-text">6.7.2.3 SATB</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-3-停顿预测模型"><span class="nav-text">6.7.3 停顿预测模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-4-G1回收的过程"><span class="nav-text">6.7.4 G1回收的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-4-1-Young-GC"><span class="nav-text">6.7.4.1 Young GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-4-2-Mixed-GC"><span class="nav-text">6.7.4.2 Mixed GC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-7-4-2-1-全局并发标记阶段"><span class="nav-text">6.7.4.2.1 全局并发标记阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-7-4-2-2-拷贝存活对象"><span class="nav-text">6.7.4.2.2 拷贝存活对象</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-垃圾回收相关的参数"><span class="nav-text">7 垃圾回收相关的参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#"><span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料："><span class="nav-text">参考资料：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">411.3k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
