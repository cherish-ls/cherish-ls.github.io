<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JAVA,并发编程,synchronized,JAVA锁," />










<meta name="description" content="1 前置知识点要了解锁优化策略中的轻量级锁与偏向锁的原理和运作过程，需要先了解java的锁和Hotspot虚拟机的对象头部分的内存布局。 1.1 Java 2种主要加锁机制 synchronized 关键字  123synchronized(lockObject)&amp;#123;   &#x2F;&#x2F;代码&amp;#125;   或  123public synchornized void test(">
<meta property="og:type" content="article">
<meta property="og:title" content="synchronized原理和锁优化策略(偏向&#x2F;轻量级&#x2F;重量级)">
<meta property="og:url" content="http://yoursite.com/2019/10/15/synchronized%E5%8E%9F%E7%90%86%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5-%E5%81%8F%E5%90%91-%E8%BD%BB%E9%87%8F%E7%BA%A7-%E9%87%8D%E9%87%8F%E7%BA%A7/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="1 前置知识点要了解锁优化策略中的轻量级锁与偏向锁的原理和运作过程，需要先了解java的锁和Hotspot虚拟机的对象头部分的内存布局。 1.1 Java 2种主要加锁机制 synchronized 关键字  123synchronized(lockObject)&amp;#123;   &#x2F;&#x2F;代码&amp;#125;   或  123public synchornized void test(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/45faa337be07947b41004663094960791fb.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/b49317becbed190b2bb4a88f231b63f8225.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/4fffc64c5ea2afb461a898cd9cd0a6362a9.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/974fd4bcecb7e1f489507bad8d5c6c41a55.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/fe7dc360d7663526fea22041f7bdb08e47a.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/aa3cdfbad95d1848b00cce7637e3011894b.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/0411afacd65d115f375df2d5c193eb09266.jpg">
<meta property="article:published_time" content="2019-10-15T14:14:22.000Z">
<meta property="article:modified_time" content="2020-03-09T15:17:57.376Z">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="synchronized">
<meta property="article:tag" content="JAVA锁">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oscimg.oschina.net/oscnet/45faa337be07947b41004663094960791fb.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/10/15/synchronized原理和锁优化策略-偏向-轻量级-重量级/"/>





  <title>synchronized原理和锁优化策略(偏向/轻量级/重量级) | cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/15/synchronized%E5%8E%9F%E7%90%86%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5-%E5%81%8F%E5%90%91-%E8%BD%BB%E9%87%8F%E7%BA%A7-%E9%87%8D%E9%87%8F%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">synchronized原理和锁优化策略(偏向/轻量级/重量级)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-15T22:14:22+08:00">
                2019-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA线程与并发控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/15/synchronized%E5%8E%9F%E7%90%86%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5-%E5%81%8F%E5%90%91-%E8%BD%BB%E9%87%8F%E7%BA%A7-%E9%87%8D%E9%87%8F%E7%BA%A7/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/10/15/synchronized原理和锁优化策略-偏向-轻量级-重量级/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  6.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  22
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-前置知识点"><a href="#1-前置知识点" class="headerlink" title="1 前置知识点"></a>1 前置知识点</h1><p>要了解锁优化策略中的轻量级锁与偏向锁的原理和运作过程，需要先了解java的锁和Hotspot虚拟机的对象头部分的内存布局。</p>
<h2 id="1-1-Java-2种主要加锁机制"><a href="#1-1-Java-2种主要加锁机制" class="headerlink" title="1.1 Java 2种主要加锁机制"></a>1.1 Java 2种主要加锁机制</h2><ul>
<li>synchronized 关键字  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(lockObject)&#123;</span><br><span class="line">   &#x2F;&#x2F;代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  或  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchornized void test()&#123;</span><br><span class="line">	&#x2F;&#x2F;代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这里需要指出的是，无论是对一个对象进行加锁还是对一个方法进行加锁，实际上，都是对对象进行加锁。对于synchornized方法，实际上虚拟机会根据synchronized修饰的是实例方法还是静态方法，去取对应的实例对象或者Class对象来进行加锁。</p>
</blockquote>
</li>
<li>java.util.concurrent.Lock （Lock是一个接口，ReentrantLock是该接口一个很常用的实现）</li>
</ul>
<p>这两种机制的底层原理存在一定的差别</p>
<ul>
<li>java.util.concurrent.Lock 通过 Java 代码搭配sun.misc.Unsafe 中的native调用实现的</li>
<li>synchronized 关键字通过一对字节码指令 monitorenter/monitorexit 实现， 这对指令被 JVM 规范所描述。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。  </li>
</ul>
<h2 id="1-2-字宽和对象头"><a href="#1-2-字宽和对象头" class="headerlink" title="1.2 字宽和对象头"></a>1.2 字宽和对象头</h2><ul>
<li><p>字宽（Word）: 内存大小的单位概念， 对于 32 位处理器 1 Word = 4 Bytes， 64 位处理器 1 Word = 8 Bytes</p>
</li>
<li><p>对象头信息是与对象自身定义的数据无关的额外存储成本，每一个 Java 对象都至少占用 2 个字宽的内存(数组类型占用3个字宽)。</p>
<ul>
<li><p><strong>第一个字宽</strong>，也被称为对象头Mark Word，用来存储对象自身的运行时数据 如：哈希吗（HashCode）、GC分代年龄(Generational GC Age)等。</p>
</li>
<li><p><strong>第二个字宽</strong>用于存储指向方法区对象类型数据的指针。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://oscimg.oschina.net/oscnet/45faa337be07947b41004663094960791fb.jpg" alt=""></p>
<blockquote>
<p>当偏向机制被禁用时，被分配出来的对象初始的MarkWord状态为无锁状态</p>
</blockquote>
<blockquote>
<p>偏向机制被启用时，分配出来的对象的初始状态是 ThreadId|Epoch|age|1|01, ThreadId 为空时标识对象尚未偏向于任何一个线程， ThreadId 不为空时， 对象既可能处于偏向特定线程的状态， 也有可能处于已经被特定线程占用完毕释放的状态， 需结合 Epoch 和其他信息判断对象是否允许再偏向（rebias）。</p>
</blockquote>
<h2 id="1-3-锁记录"><a href="#1-3-锁记录" class="headerlink" title="1.3 锁记录"></a>1.3 锁记录</h2><p>锁记录lock Record，在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在<strong>当前线程</strong>的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁记录目前的Mark Word的拷贝（称为Displaced Mark Word）以及记录锁对象的指针owner。</p>
<p>其数据结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A BasicObjectLock associates a specific Java object with a BasicLock.</span><br><span class="line">&#x2F;&#x2F; It is currently embedded in an interpreter frame.</span><br><span class="line">class BasicObjectLock VALUE_OBJ_CLASS_SPEC &#123;</span><br><span class="line"> private:</span><br><span class="line">  BasicLock _lock;                        &#x2F;&#x2F; the lock, must be double word aligned</span><br><span class="line">  oop       _obj;                         &#x2F;&#x2F; object holds the lock;</span><br><span class="line">&#125;;</span><br><span class="line">class BasicLock VALUE_OBJ_CLASS_SPEC &#123;</span><br><span class="line"> private:</span><br><span class="line">  volatile markOop _displaced_header;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>《Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing》一文的说法是：当字节码解释器执行monitorenter字节码轻度锁住一个对象时，就会在获取锁的线程的栈上显式或者隐式分配一个lock record。lock record在线程的Interpretered Frame上(解释帧)分配</p>
</blockquote>
<h1 id="2-synchronized-关键字之锁的升级"><a href="#2-synchronized-关键字之锁的升级" class="headerlink" title="2 synchronized 关键字之锁的升级"></a>2 synchronized 关键字之锁的升级</h1><p>synchronized 代码块是由一对 monitorenter/moniterexit 字节码指令实现， monitor 是其同步实现的基础， Java SE1.6 为了改善性能，减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，</p>
<p>所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。在几乎无竞争的条件下， 会使用偏向锁， 在轻度竞争的条件下， 会由偏向锁升级为轻量级锁， 在重度竞争的情况下， 会升级到重量级锁。</p>
<p><strong>锁可以升级但不能降级</strong>，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p>
<p>这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。</p>
<blockquote>
<p>偏向锁——&gt;轻量级锁——&gt;重量级锁</p>
</blockquote>
<p>下图展现了一个对象在创建（allocate）后，根据偏向锁机制是否打开，对象 MarkWord 状态以不同方式转换的过程</p>
<p><img src="https://oscimg.oschina.net/oscnet/b49317becbed190b2bb4a88f231b63f8225.jpg" alt=""></p>
<h2 id="2-1-偏向锁"><a href="#2-1-偏向锁" class="headerlink" title="2.1 偏向锁"></a>2.1 偏向锁</h2><p>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，<strong>而且总是由同一线程多次获得</strong>，为了让线程获得锁的<strong>代价更低</strong>而引入了偏向锁。</p>
<p>在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。<strong>轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</strong></p>
<h3 id="2-1-1-偏向锁配置"><a href="#2-1-1-偏向锁配置" class="headerlink" title="2.1.1 偏向锁配置"></a>2.1.1 偏向锁配置</h3><p>偏向锁在Java 6和Java 7里是默认启用的，可以使用下列语句关闭偏向机制</p>
<ul>
<li>-XX:-UseBiasedLocking=false  关闭偏向锁  </li>
</ul>
<p>偏向锁机制默认开启，但是它在应用程序启动几秒钟之后才会激活，如有必要可以使用JVM的BiasedLockingStartupDelay参数来关闭延迟</p>
<ul>
<li>-XX：BiasedLockingStartupDelay = 0  关闭延迟  </li>
</ul>
<h3 id="InstanceKlass"><a href="#InstanceKlass" class="headerlink" title="InstanceKlass"></a>InstanceKlass</h3><ul>
<li><p>HotSpot为所有加载的类型，在class元数据——InstanceKlass中保留了一个MarkWord原型——mark_prototype。这个值的bias位域决定了该类型的对象是否允许被偏向锁定。</p>
</li>
<li><p>与此同时，当前的epoch位（用来标识对象的偏向锁是否还有效，批量重偏向时细说，先知道它表示有效期即可）也被保留在prototype中。这意味着，对应class的新对象可以简单地直接拷贝这个原型值，而不必在后面进行修正。</p>
</li>
<li><p>在批量重偏向(bulk rebias)的操作中，prototype的epoch位将会被更新；</p>
</li>
<li><p>在批量撤销(bulk revoke)的操作中，prototype将会被置成不可偏向的状态——bias位被置0。</p>
</li>
</ul>
<h3 id="2-1-2偏向锁的获取"><a href="#2-1-2偏向锁的获取" class="headerlink" title="2.1.2偏向锁的获取"></a>2.1.2偏向锁的获取</h3><p>偏向锁的获取方式是将对象头的MarkWord部分中，标记上线程ID，以表示哪一个线程获得了偏向锁。具体的赋值逻辑如下</p>
<ol>
<li><p>首先读取锁对象的MarkWord, 判断是否处于可偏向的状态</p>
</li>
<li><p>验证对象所属InstanceKlass的prototype的bias位和epoch位</p>
<ul>
<li>确认prototype的epoch位是否被设置为1。如果没有设置，则<strong>该类所有对象</strong>全部不允许被偏向锁定。</li>
<li>确认prototype的bias位是否被设置为1。如果没有设置，则<strong>该类所有对象</strong>全部不允许被偏向锁定。</li>
</ul>
</li>
<li><p>首先检查对象头Mark Word中记录的Thread Id是否是当前线程ID并且epoch位和InstanceKlass对象的epoch位是否相等（表示偏向锁未过期）</p>
<ul>
<li><p>如果是，则表明当前线程已经获得对象锁，以后该线程进入同步块时，不需要CAS进行加锁。</p>
</li>
<li><p>否则，<strong>如果偏向模式关闭</strong>，则尝试撤销偏向锁</p>
</li>
<li><p>否则，<strong>如果epoch位和InstanceKlass对象的epoch位不相等，并且jvm参数允许重偏向</strong>，那么</p>
<ul>
<li>重偏向，就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id 改成当前线程Id。</li>
<li>如果这里失败，说明存在竞争，进行锁升级。</li>
</ul>
</li>
<li><p>再else一次，能走到这里，这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程），这时候通过一个CAS（期望值为0）尝试将自己的ThreadID放置到Mark Word中Thread ID。</p>
<ul>
<li><p>如果CAS操作成功，则代表当前是匿名偏向，没有锁竞争，锁对象继续保持biasable可偏向状态，ThreadID字段被设置成了偏向锁所有者的ID（即当前线程ID），然后执行同步代码。</p>
</li>
<li><p>如果CAS操作失败，表示在该锁对象上存在竞争并且这个时候有另外一个线程Thread B抢先获取了偏向锁，这种状态说明该对象的竞争比较激烈， 此时需要撤销 Thread B 获得的偏向锁，将 Thread B 持有的锁升级为轻量级锁。</p>
<blockquote>
<p>每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record（判断Lock Record是否空闲的依据是其obj字段是否为null），并将其obj设置为偏向线程ID；每次解锁（即执行monitorexit）的时候都会从最低的一个Lock Record移除。先进后出，作为重入的计数器。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，即一个线程在执行完同步代码块以后，并不会尝试将MarkWord中的thread ID赋回原值。这样做的好处是：如果该线程需要再次对这个对象加锁，而这个对象之前一直没有被其他线程尝试获取过锁，依旧停留在可偏向的状态下，即可在不修改对象头的情况下，直接认为偏向成功。</p>
</blockquote>
<h3 id="2-1-3偏向锁的撤销"><a href="#2-1-3偏向锁的撤销" class="headerlink" title="2.1.3偏向锁的撤销"></a>2.1.3偏向锁的撤销</h3><p> 偏向锁的撤销（Revoke） 操作并不是将对象恢复到无锁可偏向的状态，而是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态；释放是指退出同步块时的过程，即将内存最低的对应的lock Record的obj置为null，<strong>需要注意撤销与释放的区别。</strong> 偏向锁的撤销，是轻量级锁的前提。</p>
<p>我们之前说过偏向锁使用了一种等到竞争出现才释放锁的机制，所以偏向锁撤销很多时候发生在如下情况：偏向锁偏向的线程是线程B，线程A来争锁，发现有竞争，从而触发了。</p>
<ul>
<li><p>如果要撤销的锁偏向的是当前线程，则直接撤销偏向锁，否则会将该操作push到VM Thread中等到safepoint的时候再执行。</p>
<blockquote>
<p>在JVM中有个专门的VM Thread，该线程会源源不断的从VMOperationQueue中取出请求，比如GC请求。对于需要safepoint的操作（VM_Operationevaluate_at_safepoint返回true）必须要等到所有的Java线程进入到safepoint才开始执行。</p>
</blockquote>
</li>
<li><p>当到达全局安全点（safepoint，在这个时间点上没有字节码正在执行）时，首先将拥有偏向锁的线程挂起</p>
</li>
<li><p>通过Mark Word拿到偏向的线程ID，查看该ID的线程是否存活，如果已经不存活了，则直接撤销偏向锁。</p>
<blockquote>
<p>JVM维护了一个集合存放所有存活的线程，通过遍历该集合判断是否有线程的ID等于偏向线程ID，有的话表示存活。</p>
</blockquote>
</li>
<li><p>偏向的线程是否还在同步块中，如果不在了，则撤销偏向锁，升级为轻量级锁，继续往下执行同步代码。</p>
<blockquote>
<p>我们回顾一下偏向锁的加锁流程：每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record，将其obj字段指向锁对象。每次解锁（即执行monitorexit）的时候都会将最低的一个相关Lock Record移除掉。所以可以通过遍历线程栈中的Lock Record来判断线程是否还在同步块中</p>
</blockquote>
</li>
</ul>
<h3 id="2-1-4批量重偏向和批量撤销"><a href="#2-1-4批量重偏向和批量撤销" class="headerlink" title="2.1.4批量重偏向和批量撤销"></a>2.1.4批量重偏向和批量撤销</h3><p>从上文偏向锁的加锁解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safe point时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。safe point这个词我们在GC中经常会提到，其代表了一个状态，在该状态下所有线程都是暂停的。总之，偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</p>
<p>存在如下两种情况：</p>
<ol>
<li><p>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</p>
</li>
<li><p>存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。<br>批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。</p>
</li>
</ol>
<p>其做法是：以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20，jvm参数BiasedLockingBulkRebiasThreshold控制）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。</p>
<p>当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40，jvm参数BiasedLockingBulkRevokeThreshold控制），JVM就认为该class的使用场景存在多线程竞争，执行批量撤销，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</p>
<p>BiasedLockingDecayTime是开启一次新的批量重偏向距离上次批量重偏向的后的延迟时间，默认25000。也就是开启批量重偏向后，如果经过了一段较长的时间（&gt;=BiasedLockingDecayTime），撤销计数器才超过阈值，那我们会重置计数器。</p>
<h4 id="2-1-4-1批量重偏向"><a href="#2-1-4-1批量重偏向" class="headerlink" title="2.1.4.1批量重偏向"></a>2.1.4.1批量重偏向</h4><p>介绍完偏向，我们发现如果锁先偏向了线程B，那么等另外任何一个线程来竞争的时候，都会导致进入偏向锁的撤销流程，在撤销流程里，才会判断线程B是否还活着，如果已经不活动了，则重偏向。</p>
<p>但偏向锁的撤销流程需要等到全局安全点，这是一个极大的消耗，为了能够让许多本应该重偏向的偏向锁无须等到全局安全点时才被重偏向，jvm引入了批量重偏向的逻辑。</p>
<p>该机制的主要工作原理如下：</p>
<ul>
<li>引入一个概念epoch，其本质是一个时间戳，代表了偏向锁的有效性，epoch存储在可偏向对象的MarkWord中。除了对象中的epoch,对象所属的类class信息中，也会保存一个epoch值</li>
<li>每当遇到一个全局安全点时，比如要对class C 进行批量再偏向，则首先对 class C中保存的epoch进行增加操作，得到一个新的epoch_new</li>
<li>然后扫描所有持有 class C 实例的线程栈，根据线程栈的信息判断出该线程是否锁定了该对象，仅将epoch_new的值赋给被锁定的对象中。（也就是现在偏向锁还在被使用的对象才会被赋值epoch_new）</li>
<li>退出安全点后，当有线程需要尝试获取偏向锁时，直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等，则说明该对象的偏向锁已经无效了，可以尝试对此对象重新进行偏向操作。</li>
</ul>
<h4 id="2-1-4-2批量撤销"><a href="#2-1-4-2批量撤销" class="headerlink" title="2.1.4.2批量撤销"></a>2.1.4.2批量撤销</h4><ul>
<li>将类的偏向标记关闭，之后当该类已存在的实例获得锁时，就会升级为轻量级锁；该类新分配的对象的mark word则是无锁模式。</li>
<li>处理当前正在被使用的锁对象，通过遍历所有存活线程的栈，找到所有正在使用的偏向锁对象，然后撤销偏向锁。</li>
</ul>
<hr>
<h2 id="2-2-轻量级锁"><a href="#2-2-轻量级锁" class="headerlink" title="2.2 轻量级锁"></a>2.2 轻量级锁</h2><p>JVM的开发者发现在很多情况下，在Java程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此JVM引入了轻量级锁的概念。</p>
<p>轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁；</p>
<h3 id="2-2-2-加锁过程"><a href="#2-2-2-加锁过程" class="headerlink" title="2.2.2 加锁过程"></a>2.2.2 加锁过程</h3><ol>
<li><p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在<strong>当前线程的栈帧中</strong>建立一个名为锁记录（Lock Record）的空间，用于存储锁记录目前的Mark Word的拷贝（称为Displaced Mark Word）以及记录锁对象的指针（即obj（即下图的Object reference）字段指向锁对象）。  </p>
<ul>
<li>下图右边的部分就是一个Lock Record。左边部分是锁对象。<br><img src="https://oscimg.oschina.net/oscnet/4fffc64c5ea2afb461a898cd9cd0a6362a9.jpg" alt=""></li>
</ul>
</li>
<li><p>当一个线程来获取这个锁，虚拟机将使用CAS操作尝试<strong>将锁对象的Mark Word更新为指向Lock Record的指针</strong>。</p>
<ul>
<li><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2bit）将转变为“00”，即表示此对象处于轻量级锁定状态</p>
</li>
<li><p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否<strong>已经</strong>指向当前线程的栈帧。</p>
<ul>
<li>如果已经指向当前线程的栈帧，说明当前线程已经拥有了这个对象的锁，现在是重入状态，那么<ul>
<li>设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。</li>
<li>下图为重入三次时的lock record示意图，左边为锁对象，右边为当前线程的栈帧<br><img src="https://oscimg.oschina.net/oscnet/974fd4bcecb7e1f489507bad8d5c6c41a55.jpg" alt=""></li>
<li>然后结束。就可以直接进入同步块继续执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>为什么JVM选择在线程栈中添加Displaced Mark word为null的Lock Record来表示重入计数呢？首先锁重入次数是一定要记录下来的，因为每次解锁都需要对应一次加锁，解锁次数等于加锁次数时，该锁才真正的被释放，也就是在解锁时需要用到说锁重入次数的。一个简单的方案是将锁重入次数记录在对象头的mark word中，但mark word的大小是有限的，已经存放不下该信息了。另一个方案是只创建一个Lock Record并在其中记录重入次数，Hotspot没有这样做的原因我猜是考虑到效率有影响：每次重入获得锁都需要遍历该线程的栈找到对应的Lock Record，然后修改它的值。所以最终Hotspot选择每次获得锁都添加一个Lock Record来表示锁的重入。</p>
</blockquote>
<pre><code>- 如果已经指向别的线程的栈帧，说明这个锁对象已经被其他线程抢占了。那么

    - 它就会自旋等待锁，一定次数后仍未获得锁对象，说明发生了竞争，需要膨胀为重量级锁。</code></pre><h3 id="2-2-3-解锁过程"><a href="#2-2-3-解锁过程" class="headerlink" title="2.2.3 解锁过程"></a>2.2.3 解锁过程</h3><ol>
<li><p>遍历当前线程栈,找到所有obj字段等于当前锁对象的Lock Record。</p>
</li>
<li><p>如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将obj设置为null后continue（即一次解锁结束）。</p>
</li>
<li><p>如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为Displaced Mark Word。如果成功，则continue（即一次解锁结束），否则膨胀为重量级锁。</p>
</li>
</ol>
<h2 id="2-3-重量级锁"><a href="#2-3-重量级锁" class="headerlink" title="2.3 重量级锁"></a>2.3 重量级锁</h2><p>重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。</p>
<p>重量级锁的状态下，锁对象的mark word为指向一个堆中monitor对象的指针。</p>
<p>一个monitor对象包括这么几个关键字段：cxq（下图中的ContentionList），EntryList ，WaitSet，owner。</p>
<p>其中cxq ，EntryList ，WaitSet都是由ObjectWaiter的链表结构，owner指向持有锁的线程。</p>
<p><img src="https://oscimg.oschina.net/oscnet/fe7dc360d7663526fea22041f7bdb08e47a.jpg" alt=""></p>
<h3 id="2-3-1-加锁过程"><a href="#2-3-1-加锁过程" class="headerlink" title="2.3.1 加锁过程"></a>2.3.1 加锁过程</h3><h4 id="2-3-1-1-轻量级锁膨胀为重量级锁"><a href="#2-3-1-1-轻量级锁膨胀为重量级锁" class="headerlink" title="2.3.1.1 轻量级锁膨胀为重量级锁"></a>2.3.1.1 轻量级锁膨胀为重量级锁</h4><ol>
<li><p>调用omAlloc分配一个ObjectMonitor对象(以下简称monitor)，在omAlloc方法中会先从线程私有的monitor集合omFreeList中分配对象，如果omFreeList中已经没有monitor对象，则从JVM全局的gFreeList中分配一批monitor到omFreeList中。</p>
</li>
<li><p>初始化monitor对象</p>
</li>
<li><p>将状态设置为膨胀中（INFLATING）状态</p>
</li>
<li><p>设置monitor的header字段为displaced mark word，owner字段为Lock Record，obj字段为锁对象</p>
</li>
<li><p>设置锁对象头的mark word为重量级锁状态（锁标志位为10），并指向第一步分配的monitor对象</p>
</li>
<li><p>进入2.3.1.3 获取锁流程</p>
</li>
</ol>
<h4 id="2-3-1-2-无锁状态膨胀为重量级锁"><a href="#2-3-1-2-无锁状态膨胀为重量级锁" class="headerlink" title="2.3.1.2 无锁状态膨胀为重量级锁"></a>2.3.1.2 无锁状态膨胀为重量级锁</h4><ol>
<li><p>调用omAlloc分配一个ObjectMonitor对象(以下简称monitor)</p>
</li>
<li><p>初始化monitor对象</p>
</li>
<li><p>设置monitor的header字段为mark word，owner字段为null，obj字段为锁对象</p>
</li>
<li><p>设置锁对象头的mark word为重量级锁状态，指向第一步分配的monitor对象</p>
</li>
<li><p>进入2.3.1.3 获取锁流程</p>
</li>
</ol>
<h4 id="2-3-1-3-获取锁流程"><a href="#2-3-1-3-获取锁流程" class="headerlink" title="2.3.1.3 获取锁流程"></a>2.3.1.3 获取锁流程</h4><ol>
<li><p>如果当前是无锁状态、锁重入、当前线程是之前持有轻量级锁的线程则进行简单操作后返回。</p>
</li>
<li><p>先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销<br><img src="https://oscimg.oschina.net/oscnet/aa3cdfbad95d1848b00cce7637e3011894b.jpg" alt=""></p>
</li>
<li><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列的队首，然后调用park函数挂起当前线程。在linux系统上，park函数底层调用的是gclib库的pthread_cond_wait，JDK的ReentrantLock底层也是用该方法挂起线程的。</p>
</li>
<li><p>当线程释放锁时，会从cxq或EntryList中挑选一个线程唤醒，被选中的线程叫做Heir presumptive即假定继承人（应该是这样翻译），就是图中的Ready Thread，假定继承人被唤醒后会尝试获得锁，但synchronized是非公平的，所以假定继承人不一定能获得锁（这也是它叫”假定”继承人的原因）。</p>
</li>
<li><p>如果线程获得锁后调用Object#wait方法，则会将线程加入到WaitSet中，当被Object#notify唤醒后，会将线程从WaitSet移动到cxq或EntryList中去。需要注意的是，当调用一个锁对象的wait或notify方法时，如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁。</p>
</li>
</ol>
<blockquote>
<p>synchronized的monitor锁机制和JDK的ReentrantLock与Condition是很相似的，ReentrantLock也有一个存放等待获取锁线程的链表，Condition也有一个类似WaitSet的集合用来存放调用了await的线程。如果你之前对ReentrantLock有深入了解，那理解起monitor应该是很简单。</p>
</blockquote>
<h3 id="2-3-2-释放锁过程"><a href="#2-3-2-释放锁过程" class="headerlink" title="2.3.2 释放锁过程"></a>2.3.2 释放锁过程</h3><p>在进行必要的锁重入判断以及自旋优化后，</p>
<ol>
<li>设置owner为null，即释放锁，这个时刻其他的线程能获取到锁。这里是一个非公平锁的优化；</li>
<li>如果当前没有等待的线程则直接返回就好了，因为不需要唤醒其他线程。</li>
<li>如果EntryList的首元素非空，就取出来调用ExitEpilog方法，该方法会唤醒ObjectWaiter对象的线程，然后立即返回；</li>
<li>如果EntryList的首元素为空，就将cxq的所有元素放入到EntryList中，然后再从EntryList中取出来队首元素执行ExitEpilog方法，然后立即返回；</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/0411afacd65d115f375df2d5c193eb09266.jpg" alt=""></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>Evaluating and improving biased locking in the HotSpot virtual machine<br><a href="https://cloud.tencent.com/developer/article/1100047" target="_blank" rel="noopener" title="锁机制-java面试">锁机制-java面试</a><br><a href="https://blog.csdn.net/lengxiao1993/article/details/81568130" target="_blank" rel="noopener" title="Java中的偏向锁，轻量级锁， 重量级锁解析">Java中的偏向锁，轻量级锁， 重量级锁解析</a><br><a href="https://baijiahao.baidu.com/s?id=1630535202760061296&wfr=spider&for=pc" target="_blank" rel="noopener" title="偏向锁到底是怎么个回事">偏向锁到底是怎么个回事</a><br><a href="https://www.jianshu.com/p/4758852cbff4" target="_blank" rel="noopener" title="死磕Synchronized底层实现--偏向锁">死磕Synchronized底层实现–偏向锁</a><br><a href="https://github.com/farmerjohngit/myblog/issues/15" target="_blank" rel="noopener" title="死磕Synchronized底层实现--重量级锁">死磕Synchronized底层实现–重量级锁</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          
            <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># 并发编程</a>
          
            <a href="/tags/synchronized/" rel="tag"># synchronized</a>
          
            <a href="/tags/JAVA%E9%94%81/" rel="tag"># JAVA锁</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/26/AQS%E5%AE%9E%E7%8E%B0%E4%B9%8BCountDownLatch-Semaphore-CyclicBarrier/" rel="next" title="AQS实现之CountDownLatch/Semaphore/CyclicBarrier">
                <i class="fa fa-chevron-left"></i> AQS实现之CountDownLatch/Semaphore/CyclicBarrier
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/17/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="prev" title="JAVA内存模型">
                JAVA内存模型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2019/10/15/synchronized原理和锁优化策略-偏向-轻量级-重量级/"
           data-title="synchronized原理和锁优化策略(偏向/轻量级/重量级)" data-url="http://yoursite.com/2019/10/15/synchronized%E5%8E%9F%E7%90%86%E5%92%8C%E9%94%81%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5-%E5%81%8F%E5%90%91-%E8%BD%BB%E9%87%8F%E7%BA%A7-%E9%87%8D%E9%87%8F%E7%BA%A7/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">96</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-前置知识点"><span class="nav-text">1 前置知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Java-2种主要加锁机制"><span class="nav-text">1.1 Java 2种主要加锁机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-字宽和对象头"><span class="nav-text">1.2 字宽和对象头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-锁记录"><span class="nav-text">1.3 锁记录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-synchronized-关键字之锁的升级"><span class="nav-text">2 synchronized 关键字之锁的升级</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-偏向锁"><span class="nav-text">2.1 偏向锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-偏向锁配置"><span class="nav-text">2.1.1 偏向锁配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InstanceKlass"><span class="nav-text">InstanceKlass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2偏向锁的获取"><span class="nav-text">2.1.2偏向锁的获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3偏向锁的撤销"><span class="nav-text">2.1.3偏向锁的撤销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4批量重偏向和批量撤销"><span class="nav-text">2.1.4批量重偏向和批量撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-1批量重偏向"><span class="nav-text">2.1.4.1批量重偏向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-2批量撤销"><span class="nav-text">2.1.4.2批量撤销</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-轻量级锁"><span class="nav-text">2.2 轻量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-加锁过程"><span class="nav-text">2.2.2 加锁过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-解锁过程"><span class="nav-text">2.2.3 解锁过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-重量级锁"><span class="nav-text">2.3 重量级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-加锁过程"><span class="nav-text">2.3.1 加锁过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-1-轻量级锁膨胀为重量级锁"><span class="nav-text">2.3.1.1 轻量级锁膨胀为重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-2-无锁状态膨胀为重量级锁"><span class="nav-text">2.3.1.2 无锁状态膨胀为重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-3-获取锁流程"><span class="nav-text">2.3.1.3 获取锁流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-释放锁过程"><span class="nav-text">2.3.2 释放锁过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文章"><span class="nav-text">参考文章</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">380k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
