<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="shell,Linux," />










<meta name="description" content="导航栏位于右侧，只收录常用命令，按字母表排序 Aalias-设置指令的别名 简介：  别名就是一种便捷方式，可以为用户省去输入一长串命令序列的麻烦。Linux alias命令用于设置指令的别名。用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.bashrc中设定指令的别名">
<meta property="og:type" content="article">
<meta property="og:title" content="常用shell命令导航">
<meta property="og:url" content="http://yoursite.com/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="导航栏位于右侧，只收录常用命令，按字母表排序 Aalias-设置指令的别名 简介：  别名就是一种便捷方式，可以为用户省去输入一长串命令序列的麻烦。Linux alias命令用于设置指令的别名。用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.bashrc中设定指令的别名">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/69fc8c9ccaff98a782091232365f03a9898.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/8cf56f84669c53afd935f5ee1def0b64841.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/15e07e85dcfeca736889def8b923fd05a0f.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/4d13470cc8c44cb148b7e75722332757ea9.jpg">
<meta property="article:published_time" content="2019-07-21T15:46:16.000Z">
<meta property="article:modified_time" content="2020-09-01T14:11:18.826Z">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="shell">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oscimg.oschina.net/oscnet/69fc8c9ccaff98a782091232365f03a9898.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/07/21/常用shell命令导航/"/>





  <title>常用shell命令导航 | cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">常用shell命令导航</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-21T23:46:16+08:00">
                2019-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">计算机协议和技术</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF/Linux%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index">
                    <span itemprop="name">Linux相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/07/21/常用shell命令导航/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  25.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  102
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>导航栏位于右侧，只收录常用命令，按字母表排序</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="alias-设置指令的别名"><a href="#alias-设置指令的别名" class="headerlink" title="alias-设置指令的别名"></a>alias-设置指令的别名</h2><ul>
<li><p>简介：</p>
</li>
<li><p>别名就是一种便捷方式，可以为用户省去输入一长串命令序列的麻烦。Linux alias命令用于设置指令的别名。用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.bashrc中设定指令的别名。</p>
</li>
<li><p>语法：</p>
</li>
<li><p><code>alias[别名]=[指令名称]</code></p>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;为apt-get install创建别名。</span><br><span class="line">$ alias install&#x3D;&#39;sudo apt-get install&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;alias命令的效果只是暂时的。一旦关闭当前终端，所有设置过的别名就失效了。</span><br><span class="line">&#x2F;&#x2F;为了使别名在所有的shell中都可用，可以将其定义放入~&#x2F;.bashrc文件中。</span><br><span class="line">&#x2F;&#x2F;每当一个新的交互式shell进程生成时，都会执行 ~&#x2F;.bashrc中的命令。</span><br><span class="line">$ echo &#39;alias cmd&#x3D;&quot;command seq&quot;&#39; &gt;&gt; ~&#x2F;.bashrc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们可以创建一个别名rm，它能够删除原始文件，同时在backup目录中保留副本。</span><br><span class="line">$ alias rm&#x3D;&#39;cp $@ ~&#x2F;backup &amp;&amp; rm $@&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>alias命令若不加任何参数，则列出目前所有的别名设置。</p>
</blockquote>
<blockquote>
<p> 如果需要删除别名，只需将其对应的定义（如果有的话）从~/.bashrc中删除，或者使用unalias命令。也可以使用alias example=，这会取消别名example。</p>
</blockquote>
<blockquote>
<p>创建别名时，如果已经有同名的别名存在，那么原有的别名设置将被新的<br>设置取代。</p>
</blockquote>
<blockquote>
<p>如果我们遇到别名和原生命令同名的情况，我们可以转义要使用的命令，忽略当前定义的别名：<br>$ \command<br>字符\可以转义命令，从而执行原本的命令。</p>
</blockquote>
<blockquote>
<p>在不可信环境下执行特权命令时，在命令前加上\来忽略可能存在的别名总是一种良好的安全实践。这是因为攻击者可能已经将一些别有用心的命令利用别名伪装成了特权命令，借此来盗取用户输入的重要信息。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="awk——把文件逐行的读入，以分隔符将其切片，再进行处理。"><a href="#awk——把文件逐行的读入，以分隔符将其切片，再进行处理。" class="headerlink" title="awk——把文件逐行的读入，以分隔符将其切片，再进行处理。"></a>awk——把文件逐行的读入，以分隔符将其切片，再进行处理。</h2><ul>
<li><p>简介：</p>
<ul>
<li>awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</li>
<li>awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。</li>
<li>之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>awk [选项参数] &#39;{pattern + action}&#39; {filenames}</code></li>
<li>尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</li>
<li>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</li>
<li>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-F fs or –field-separator fs</strong></p>
<ul>
<li>指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式。在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。</li>
</ul>
</li>
<li><p><strong>-v var=value or –asign var=value</strong></p>
<ul>
<li>赋值一个用户定义变量。</li>
</ul>
</li>
<li><p><strong>-f scripfile or –file scriptfile</strong></p>
<ul>
<li>从脚本文件中读取awk命令。</li>
</ul>
</li>
<li><p><strong>-mf nnn and -mr nnn</strong></p>
<ul>
<li>对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li>
</ul>
</li>
<li><p><strong>-W compact or –compat, -W traditional or –traditional</strong></p>
<ul>
<li>在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</li>
</ul>
</li>
<li><p><strong>-W copyleft or –copyleft, -W copyright or –copyright</strong></p>
<ul>
<li>打印简短的版权信息。</li>
</ul>
</li>
<li><p><strong>-W help or –help, -W usage or –usage</strong></p>
<ul>
<li>打印全部awk选项和每个选项的简短说明。</li>
</ul>
</li>
<li><p><strong>-W lint or –lint</strong></p>
<ul>
<li>打印不能向传统unix平台移植的结构的警告。</li>
</ul>
</li>
<li><p><strong>-W lint-old or –lint-old</strong></p>
<ul>
<li>打印关于不能向传统unix平台移植的结构的警告。</li>
</ul>
</li>
</ul>
</li>
<li><p>内建变量</p>
<p>  如下变量在awk中具有特定含义。</p>
<ul>
<li>$n    当前记录的第n个字段，字段间由FS分隔</li>
<li>$0    完整的输入记录</li>
<li>ARGC    命令行参数的数目</li>
<li>ARGIND    命令行中当前文件的位置(从0开始算)</li>
<li>ARGV    包含命令行参数的数组</li>
<li>CONVFMT    数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</li>
<li>ERRNO    最后一个系统错误的描述</li>
<li>FIELDWIDTHS    字段宽度列表(用空格键分隔)</li>
<li>FILENAME    当前文件名</li>
<li>FNR    各文件分别计数的行号</li>
<li>IGNORECASE    如果为真，则进行忽略大小写的匹配</li>
<li>NF    一条记录的字段的数目</li>
<li>NR    已经读出的记录数，就是行号，从1开始</li>
<li>OFMT    数字的输出格式(默认值是%.6g)</li>
<li>OFS    输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</li>
<li>ORS    输出记录分隔符(默认值是一个换行符)</li>
<li>RLENGTH    由match函数所匹配的字符串的长度</li>
<li>RS    记录分隔符(默认是一个换行符)</li>
<li>RSTART    由match函数所匹配的字符串的第一个位置</li>
<li>SUBSEP    数组下标分隔符(默认值是/034)</li>
</ul>
</li>
<li><p>代码示例</p>
<blockquote>
<p>awk工作流程是这样的：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推。</p>
</blockquote>
<ul>
<li><p>action的使用示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假设last -n 5的输出如下</span><br><span class="line">$ last -n 5 &lt;&#x3D;&#x3D;仅取出前五行</span><br><span class="line">&gt; root     pts&#x2F;1   192.168.1.100  Tue Feb 10 11:21   still logged in</span><br><span class="line">&gt; root     pts&#x2F;1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)</span><br><span class="line">&gt; root     pts&#x2F;1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)</span><br><span class="line">&gt; dmtsai   pts&#x2F;1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)</span><br><span class="line">&gt; root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用awk显示最近登录的5个帐号</span><br><span class="line">$ last -n 5 | awk  &#39;&#123;print $1&#125;&#39;</span><br><span class="line">&gt; root</span><br><span class="line">&gt; root</span><br><span class="line">&gt; root</span><br><span class="line">&gt; dmtsai</span><br><span class="line">&gt; root</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果只是显示&#x2F;etc&#x2F;passwd文件中的账户信息</span><br><span class="line">$ awk  -F &#39;:&#39;  &#39;&#123;print $1&#125;&#39;  &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root</span><br><span class="line">&gt; daemon</span><br><span class="line">&gt; bin</span><br><span class="line">&gt; sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示&#x2F;etc&#x2F;passwd文件中的账户和账户对应的shell信息,而账户与shell之间以tab键分割</span><br><span class="line">$ awk  -F &#39;:&#39;  &#39;&#123;print $1&quot;\t&quot;$7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root    &#x2F;bin&#x2F;bash</span><br><span class="line">&gt; daemon  &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; bin     &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; sys     &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;格式化输出</span><br><span class="line">$ awk &#39;&#123;printf &quot;%-8s %-10s\n&quot;,$1,$7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root       &#x2F;bin&#x2F;bash</span><br><span class="line">&gt; daemon     &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; bin        &#x2F;bin&#x2F;sh</span><br><span class="line">&gt; sys        &#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示&#x2F;etc&#x2F;passwd的账户和账户对应的shell,而账户与shell之间以逗号分割</span><br><span class="line">&#x2F;&#x2F;而且在所有行添加列名name,shell,在最后一行添加&quot;blue,&#x2F;bin&#x2F;nosh&quot;。</span><br><span class="line">&#x2F;&#x2F; 遇到BEGIN和END关键字，则二者分别在 读取文件之前 和 所有记录读完之后 执行</span><br><span class="line">$ awk  -F &#39;:&#39;  &#39;BEGIN &#123;print &quot;name,shell&quot;&#125;  &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,&#x2F;bin&#x2F;nosh&quot;&#125;&#39; &#x2F;etc&#x2F;passwd </span><br><span class="line">&gt; name,shell</span><br><span class="line">&gt; root,&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; daemon,&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; bin,&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; sys,&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; blue,&#x2F;bin&#x2F;nosh</span><br></pre></td></tr></table></figure></li>
<li><p>pattern使用示例 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 搜索&#x2F;etc&#x2F;passwd有root关键字的所有行,</span><br><span class="line">$ awk -F: &#39;&#x2F;root&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;&#x2F; 匹配了pattern(这里是root)的行才会执行action(本例未指定action，默认输出每行的内容，即$0，下例指定action)。</span><br><span class="line">&#x2F;&#x2F; 搜索支持正则，例如找root开头的: awk -F: &#39;&#x2F;^root&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定action&#123;print $7&#125;。搜索&#x2F;etc&#x2F;passwd有root关键字的所有行，并显示对应的shell</span><br><span class="line">$ awk -F: &#39;&#x2F;root&#x2F;&#123;print $7&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列大于2的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1&gt;2&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列等于2的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1&#x3D;2&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列大于2并且第二列等于&#39;Are&#39;的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1&gt;2 &amp;&amp; $2&#x3D;&#x3D;&quot;Are&quot;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列包含 &quot;th&quot;的行(action就不指定了)</span><br><span class="line">$ awk &#39;$1 ~ &#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列包含 &quot;th&quot;的行,忽略大小写(action就不指定了)</span><br><span class="line">$ awk &#39;BEGIN&#123;IGNORECASE&#x3D;1&#125; $1 ~ &#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤第一列不包含 &quot;th&quot;的行,忽略大小写(action就不指定了)</span><br><span class="line">$ awk &#39;BEGIN&#123;IGNORECASE&#x3D;1&#125; $1 !~ &#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;过滤整行不包含 &quot;th&quot;的行,忽略大小写(action就不指定了)</span><br><span class="line">$ awk &#39;BEGIN&#123;IGNORECASE&#x3D;1&#125; !&#x2F;th&#x2F;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure></li>
<li><p>变量赋值和使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 内建变量赋值。使用BEGIN替代-F,其中FS是awk内建变量</span><br><span class="line">$ awk  &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125; &#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; root</span><br><span class="line">&gt; daemon</span><br><span class="line">&gt; bin</span><br><span class="line">&gt; sys</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 内建变量使用。使用BEGIN替代-F,其中FS是awk内建变量，并且打印文件名，使用FILENAME内建变量</span><br><span class="line">$ awk  &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125; &#123;print FILENAME,$1&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd root</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd daemon</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd bin</span><br><span class="line">&gt; &#x2F;etc&#x2F;passwd sys</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-v变量赋值用法</span><br><span class="line">$ awk -F: -va&#x3D;1 -vb&#x3D;s &#39;&#x2F;root&#x2F;&#123;print $7,$7+a,$7b&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;bash 1 &#x2F;bin&#x2F;bashs</span><br><span class="line">&gt; &#x2F;bin&#x2F;false 1 &#x2F;bin&#x2F;falses</span><br><span class="line">&#x2F;&#x2F;BEGIN同理</span><br><span class="line">$ awk -F: &#39;BEGIN &#123;a&#x3D;1;b&#x3D;s&#125; &#x2F;root&#x2F;&#123;print $7,$7+a,$7b&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;bash 1 &#x2F;bin&#x2F;bashs</span><br><span class="line">&gt; &#x2F;bin&#x2F;false 1 &#x2F;bin&#x2F;falses</span><br></pre></td></tr></table></figure></li>
<li><p>其他一些实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;计算文件大小</span><br><span class="line">$ ls -l *.txt | awk &#39;&#123;sum+&#x3D;$6&#125; END &#123;print sum&#125;&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从文件中找出长度大于80的行</span><br><span class="line">$ awk &#39;length&gt;80&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure>
<blockquote>
<p>awk还支持条件语句和循环，使用较少，本文不再展开。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="cat-连接文件或标准输入至标准输出"><a href="#cat-连接文件或标准输入至标准输出" class="headerlink" title="cat-连接文件或标准输入至标准输出"></a>cat-连接文件或标准输入至标准输出</h2><ul>
<li><p>简介：</p>
</li>
<li><p>cat命令是linux下的一个文本输出命令，其功能是连接文件或标准输入至标准输出，常用于显示文件内容 。cat是concatenate(串联)的缩写。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>cat [选项参数] [--help] [--version] fileName</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-n 或 –number</strong></p>
<ul>
<li>由 1 开始对所有输出的行数编号。</li>
</ul>
</li>
<li><p><strong>-b 或 –number-nonblank</strong></p>
<ul>
<li>和 -n 相似，只不过对于空白行不编号。</li>
</ul>
</li>
<li><p><strong>-s 或 –squeeze-blank</strong></p>
<ul>
<li>当遇到有连续两行以上的空白行，就代换为一行的空白行。</li>
</ul>
</li>
<li><p><strong>-v 或 –show-nonprinting</strong></p>
<ul>
<li>以^和M-显示不可打印字符，除LFD与TAB </li>
</ul>
</li>
<li><p><strong>-E 或 –show-ends</strong></p>
<ul>
<li>在每行结束处显示 $。</li>
</ul>
</li>
<li><p><strong>-T 或 –show-tabs</strong></p>
<ul>
<li>将 TAB 字符显示为 ^I。这有助于排查缩进错误。</li>
</ul>
</li>
<li><p><strong>-A, –show-all</strong></p>
<ul>
<li>等价于-vET显示所有，以$结尾。</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
<ul>
<li>在每行行尾添加$,用以标记</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>等价于”-vT”选项；</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//打印多个文件的内容</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat one.txt two.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> This line is from one.txt</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> This line is from two.txt</span></span><br><span class="line"></span><br><span class="line">//将stdin和另一个文件中的数据组合在一起，其中-被作为stdin文本的文件名。</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'Text through stdin'</span> | cat - file.txt</span></span><br><span class="line"></span><br><span class="line">//把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat -n textfile1 &gt; textfile2</span></span><br><span class="line"></span><br><span class="line">//把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat -b textfile1 textfile2 &gt;&gt; textfile3</span></span><br><span class="line"></span><br><span class="line">//有时候，我们只希望抓取文件中感兴趣的关键字</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat fileName | grep keyword</span></span><br><span class="line"></span><br><span class="line">//清空某个文件内容</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /dev/null &gt; /test.txt</span></span><br><span class="line"></span><br><span class="line">//创建文件，并把标准输入输出到filename文件中</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat&gt;filename，</span></span><br><span class="line"></span><br><span class="line">//以EOF作为输入结束，将输入流重定向覆盖filename文件，可用于创建文件，追加使用&gt;&gt;</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat&gt;filename&lt;&lt;EOF</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>现在我们知道cat &lt;&lt; EOF语句表示 打印以EOF输入字符为标准输入结束的流内容，EOF是“end of file”，        表示文本结束符。用在这里起到什么作用？首先必须要说明的是EOF在这里没有特殊的含义，你可以使用FOE或        OOO等（当然也不限制在三个字符或大写字符）可以把EOF替换成其他东西。cat &lt;&lt; OOF的含义即为打印以OOF输入字符为标准输入结束的流内容，代码如下图<br><img src="https://oscimg.oschina.net/oscnet/69fc8c9ccaff98a782091232365f03a9898.jpg" alt=""></p>
</blockquote>
<blockquote>
<p>cat&gt;filename，创建文件，并把标准输入输出到filename文件中，以ctrl+d作为输入结束。</p>
</blockquote>
<blockquote>
<p>cat&gt;filename&lt;&lt;EOF等价于cat&lt;<EOF>filename,执行顺序固定是输入早于输出<br><img src="https://oscimg.oschina.net/oscnet/8cf56f84669c53afd935f5ee1def0b64841.jpg" alt=""></p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="cd——切换当前工作目录"><a href="#cd——切换当前工作目录" class="headerlink" title="cd——切换当前工作目录"></a>cd——切换当前工作目录</h2><ul>
<li><p>简介：</p>
<ul>
<li>Linux cd命令用于切换当前工作目录至 dirName(目录参数)。</li>
<li>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</li>
<li>另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录；”-“表示上次所在目录</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>cd [dirName]</code></li>
<li>dirName：要切换的目标目录。</li>
</ul>
</li>
<li><p>选项值：</p>
</li>
</ul>
<ul>
<li>代码示例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;跳到 &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">$ cd &#x2F;usr&#x2F;bin</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳到自己的 home 目录</span><br><span class="line">$ cd ~</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳到目前目录的上层</span><br><span class="line">$ cd ..</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;跳到目前目录的上上两层</span><br><span class="line">$ cd ..&#x2F;..</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回之前的目录</span><br><span class="line">$ cd -</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="chmod-设置文件权限"><a href="#chmod-设置文件权限" class="headerlink" title="chmod-设置文件权限"></a>chmod-设置文件权限</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux/Unix 的文件调用权限分为三级：用户，用户组，其他用户。利用 chmod 可以藉以控制文件如何被他人所调用。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>chmod [选项参数]  mode filename</code></li>
<li>其中mode为权限设定字串，格式如下<code>[ugoa...][[+-=][rwxX]...][,...]</code><ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个用户组(group)者，o 表示其他用户，a 表示这三者皆是。</li>
<li>+表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li>
<li>x 权限的位置上还可能出现t表示文件有执行权限并设置了粘滞位权限、T表示文件没有执行权限并设置了粘滞位权限、S表示setuid（S）的特殊权限，setuid权限允许可执行文件以其拥有者的权限来执行，即使这个可执行文件是由其他用户运行的。</li>
<li>同时，mode也可以使用3位八进制数来表示，每一位按顺序分别对应用户、用户组和其他用户。其中r=4，w=2，x=1。所以：<ul>
<li>rwx属性：4+2+1=7；</li>
<li>rw-属性：4+2=6；</li>
<li>r-x属性：4+1=5；</li>
<li>以此类推…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-c</strong></p>
<ul>
<li>若该文件权限确实已经更改，才显示其更改动作</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>若该文件权限无法被更改也不要显示错误讯息</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>显示权限变更的详细资料</li>
</ul>
</li>
<li><p><strong>-R</strong></p>
<ul>
<li>对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助说明</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将文件 file1.txt 设为所有人皆可读取</span><br><span class="line">$ chmod ugo+r file1.txt</span><br><span class="line">或</span><br><span class="line">$ chmod a+r file1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 file1.txt 设定为只有该文件拥有者可以执行 :</span><br><span class="line">$ chmod u+x file1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一用户组的用户可写入，但其他以外的人则不可写入 </span><br><span class="line">$ chmod ug+w,o-w file1.txt file2.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将目前目录下的所有文件与子目录皆设为任何人可读取 :</span><br><span class="line">$ chmod -R a&#x3D;rwx *</span><br><span class="line">或</span><br><span class="line">$ chmod 777 . -R</span><br><span class="line">或</span><br><span class="line">$  chmod 777 &quot;$(pwd)&quot; -R</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给所有用户赋值读写执行权限</span><br><span class="line">$ chmod a&#x3D;rwx file</span><br><span class="line">或</span><br><span class="line">$ chmod 777 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给文件拥有用户和其相同用户组用户读写执行权限，其他用户可执行权限。</span><br><span class="line">$ chmod ug&#x3D;rwx,o&#x3D;x file</span><br><span class="line">或</span><br><span class="line">$ chmod 771 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给特定目录加粘滞位权限（设置粘滞位后，只有目录的所有者才能够删除目录中的文件，即使其他人有该目录的写权限也无法执行删除操作。）</span><br><span class="line">$ chmod a+t directoryName</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>chmod 4755 filename 使此程序具有root的权限</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="chown-更改文件或目录的所有权"><a href="#chown-更改文件或目录的所有权" class="headerlink" title="chown-更改文件或目录的所有权"></a>chown-更改文件或目录的所有权</h2><ul>
<li>简介：<ul>
<li>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。</li>
</ul>
</li>
</ul>
<pre><code>- 一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。</code></pre><ul>
<li><p>语法：</p>
<ul>
<li><code>chown [选项参数] [--help] [--version] user[:group] file...</code></li>
<li>其中user表示新的文件拥有者的使用者 ID。group表示新的文件拥有者的使用者组(group)</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-c</strong></p>
<ul>
<li>显示更改的部分的信息</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>忽略错误信息</li>
</ul>
</li>
<li><p><strong>-h</strong></p>
<ul>
<li>修复符号链接</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>显示详细的处理信息</li>
</ul>
</li>
<li><p><strong>-R</strong></p>
<ul>
<li>处理指定目录以及其子目录下的所有文件</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助说明</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将文件 file1.txt 的拥有者设为 runoob，群体的使用者 runoobgroup :</span><br><span class="line">$ chown runoob:runoobgroup file1.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将目前目录下的所有文件与子目录的拥有者皆设为 runoob，群体的使用者 runoobgroup:</span><br><span class="line">$ chown -R runoob:runoobgroup *</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="cp-于复制文件或目录"><a href="#cp-于复制文件或目录" class="headerlink" title="cp-于复制文件或目录"></a>cp-于复制文件或目录</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux cp命令主要用于复制文件或目录。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>cp [options] source dest 或 cp [options] source... directory</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li>
</ul>
</li>
<li><p><strong>-d</strong></p>
<ul>
<li>复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>覆盖已经存在的目标文件而不给出提示。</li>
</ul>
</li>
<li><p><strong>-i</strong></p>
<ul>
<li>与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>不复制文件，只是生成链接文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用指令&quot;cp&quot;将当前目录&quot;test&#x2F;&quot;下的所有文件复制到新目录&quot;newtest&quot;下</span><br><span class="line">$ cp –r test&#x2F; newtest</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>用户使用该指令复制目录时，必须使用参数”-r”或者”-R”。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="curl——发送各种HTTP请求"><a href="#curl——发送各种HTTP请求" class="headerlink" title="curl——发送各种HTTP请求"></a>curl——发送各种HTTP请求</h2><ul>
<li><p>简介：</p>
<ul>
<li>curl命令的用途广泛，其功能包括下载、发送各种HTTP请求以及指定HTTP头部。</li>
<li>cURL默认会将下载文件输出到stdout，将进度信息输出到stderr。如果不想显示进度信息，可以使用–silent选项</li>
<li>cURL可以使用HTTP、HTTPS、FTP协议在客户端与服务器之间传递数据。它支持POST、cookie、认证、从指定偏移处下载部分文件、参照页（referer）、用户代理字符串、扩展头部、限速、文件大小限制、进度条等特性。cURL可用于网站维护、数据检索以及服务器配置核对。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>curl [选项] url</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>–silent</strong></p>
<ul>
<li>不显示进度信息</li>
</ul>
</li>
<li><p><strong>-O</strong></p>
<ul>
<li>指明将下载数据写入文件，采用从URL中解析出的文件名。注意，其中的URL必须是完整的，不能仅是站点的域名</li>
<li><code>$ curl www.knopper.net/index.htm -O</code></li>
</ul>
</li>
<li><p><strong>-o</strong></p>
<ul>
<li>指明将下载数据写入文件，可以指定输出文件名。如果使用了该选项，只需要写明站点的域名就可以下载其主页了</li>
<li><code>$ curl www.knopper.net -o knoppix_index.html</code></li>
</ul>
</li>
<li><p><strong>–progress</strong></p>
<ul>
<li>在下载过程中显示形如#的进度条</li>
<li><code>$ curl http://knopper.net -o index.html --progress</code><br>################################## 100.0%</li>
</ul>
</li>
<li><p><strong>-C</strong></p>
<ul>
<li>够从特定的文件偏移处继续下载，偏移量是以字节为单位的整数。</li>
<li><code>$ curl URL/file -C offset</code></li>
<li>如果只是想断点续传，那么cURL不需要指定准确的字节偏移。要是你希望cURL推断出正确的续传位置，请使用选项-C -。cURL会自动计算出应该从哪里开始续传</li>
<li><code>$ curl -C - www.xxx.com</code></li>
</ul>
</li>
<li><p><strong>–referer</strong></p>
<ul>
<li>指定参照页字符串。参照页（referer）①是位于HTTP头部中的一个字符串，用来标识用户是从哪个页面到达当前页面的。如果用户通过点击页面A中的某个链接跳转到了页面B，那么页面B头部的参照页字符串就会包含页面A的URL。</li>
<li>一些动态页面会在返回HTML数据前检测参照页字符串。例如，如果用户是通过Google搜索来到了当前页面，那么页面上就可以显示一个Google的logo；</li>
<li><code>$ curl --referer Referer_URL target_URL 如 $ curl --referer http://google.com http://knopper.org</code></li>
</ul>
</li>
<li><p><strong>–cookie</strong></p>
<ul>
<li>指定储HTTP操作过程中使用到的cookie，cookies需要以name=value的形式来给出。多个cookie之间使用分号分隔</li>
<li><code>$ curl http://example.com --cookie &quot;user=username;pass=hack&quot;</code></li>
</ul>
</li>
<li><p><strong>–cookie-jar</strong></p>
<ul>
<li>可以将cookie另存为文件</li>
<li><code>$ curl URL --cookie-jar cookie_file</code></li>
</ul>
</li>
<li><p><strong>-b <filename></strong></p>
<ul>
<li>指定以一个存储了Cookie值的本地文件内容作为cookie</li>
<li><code>$ curl -b stored_cookies_in_file www.baidu.com</code></li>
</ul>
</li>
<li><p><strong>–user-agent或-A</strong></p>
<ul>
<li>设置用户代理字符串,如果不指定用户代理（user agent），一些需要检验用户代理的页面就无法显示。例如，有些旧网站只能在Internet Explorer（IE）下正常工作。如果使用其他浏览器，则会提示只能用IE访问。这是因为这些网站检查了用户代理。</li>
<li><code>$ curl URL --user-agent &quot;Mozilla/5.0&quot;</code></li>
</ul>
</li>
<li><p><strong>-H</strong></p>
<ul>
<li>发送HTTP头部信息</li>
<li><code>$ curl -H &quot;Host: www.knopper.net&quot; -H &quot;Accept-language: en&quot; URL</code></li>
</ul>
</li>
<li><p><strong>–limit-rate</strong></p>
<ul>
<li>如果多个用户共享带宽有限，我们可以用–limit-rate限制cURL的下载速度。在命令中用k（千字节）和m（兆字节）指定下载速度限制</li>
<li><code>$ curl URL --limit-rate 20k</code></li>
</ul>
</li>
<li><p><strong>–max-filesize</strong></p>
<ul>
<li>指定可下载的最大文件大小。如果文件大小超出限制，命令返回一个非0的退出码。如果文件下载成功，则返回0。</li>
<li><code>$ curl URL --max-filesize bytes</code></li>
</ul>
</li>
<li><p><strong>-u</strong></p>
<ul>
<li>指定用户名和密码完成HTTP或FTP认证</li>
<li><code>$ curl -u user:pass http://test_auth.com</code></li>
<li>如果你喜欢经提示后输入密码，只需要使用用户名即可</li>
<li><code>$ curl -u user http://test_auth.com</code></li>
</ul>
</li>
<li><p><strong>-I 或–head</strong></p>
<ul>
<li>只打印HTTP头部信息，无须下载远程文件。只检查头部信息就足以完成很多检查或统计。例如，如果要检查某个页面是否能够打开，并不需要下载整个页面内容。只读取HTTP响应头部就足够了。</li>
<li><code>$ curl -I http://knopper.net</code></li>
</ul>
</li>
<li><p><strong>-E或–cert</strong></p>
<ul>
<li>指定本地证书</li>
<li><code>$ curl -E mycert.pem https:/itbilu.com</code></li>
</ul>
</li>
<li><p><strong>-T 或–upload-file</strong></p>
<ul>
<li>上传文件</li>
<li><code>$ curl -T ./index.html www.uploadhttp.com/receive.cgi</code></li>
</ul>
</li>
<li><p><strong>-d 或–data</strong></p>
<ul>
<li>POST提交表单数据</li>
<li><code>$ curl -X POST --data &#39;keyword=linux&#39; itbilu.com</code></li>
</ul>
</li>
<li><p><strong>-X</strong></p>
<ul>
<li>拓展http请求方法，使curl支持put，delete等</li>
<li><code>$ curl -X DELETE itbilu.com/examlple.html</code></li>
<li><code>$ curl -X PUT --data &#39;keyword=linux&#39; itbilu.com</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;访问一个网页时，可以使用curl命令后加上要访问的网址</span><br><span class="line">$ curl www.baidu.com</span><br><span class="line">&gt; &lt;!DOCTYPE html&gt;</span><br><span class="line">&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv&#x3D;content-type content&#x3D;text&#x2F;html;...</span><br><span class="line">&#x2F;&#x2F;我们就看到所访问网址的页面源码。</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="cut——按列切分文件"><a href="#cut——按列切分文件" class="headerlink" title="cut——按列切分文件"></a>cut——按列切分文件</h2><ul>
<li><p>简介：</p>
<ul>
<li>cut命令能够提取指定位置或列之间的字符。你可以指定每列的分隔符。在cut的术语中，每列被称为一个字段。</li>
<li>cut命令可以按列，而不是按行来切分文件。该命令可用于处理使用固定宽度字段的文件、CSV文件或是由空格分隔的文件（例如标准日志文件）。</li>
<li>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>cut  [选项参数] [file]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-b <range></strong></p>
<ul>
<li>以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。</li>
<li>range可以为如下格式，如cut -b 2-5 file<ul>
<li>N-：从第N个字节、字符、字段到结尾；</li>
<li>N-M：从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段；</li>
<li>-M：从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>-c <range></strong></p>
<ul>
<li>以字符为单位进行分割。</li>
<li>range可以为如下格式，如cut -c 2-5 file<ul>
<li>N-：从第N个字节、字符、字段到结尾；</li>
<li>N-M：从第N个字节、字符、字段到第M个（包括M在内）字节、字符、字段；</li>
<li>-M：从第1个字节、字符、字段到第M个（包括M在内）字节、字符、字段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>-d</strong></p>
<ul>
<li>自定义分隔符，默认为制表符。</li>
</ul>
</li>
<li><p><strong>-f <FIELD_LIST></strong></p>
<ul>
<li>指定要提取的列。FIELD_LIST是需要显示的列。它由列号组成，彼此之间用逗号分隔。</li>
</ul>
</li>
<li><p><strong>-n</strong></p>
<ul>
<li>取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除</li>
</ul>
</li>
<li><p><strong>–complement</strong></p>
<ul>
<li>显示出没有被-f指定的那些字段。</li>
</ul>
</li>
<li><p><strong>–output-delimiter</strong></p>
<ul>
<li>指定输出分隔符。在显示多组数据时，该选项尤为有用</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从使用制表符作为分隔符的文件中提取列</span><br><span class="line">$ cat student_data.txt </span><br><span class="line">&gt; No Name Mark Percent </span><br><span class="line">&gt; 1 Sarath 45 90 </span><br><span class="line">&gt; 2 Alex 49 98 </span><br><span class="line">&gt; 3 Anu 45 90</span><br><span class="line">$ cut -f 1 student_data.txt</span><br><span class="line">&gt; No </span><br><span class="line">&gt; 1 </span><br><span class="line">&gt; 2 </span><br><span class="line">&gt; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;要想提取多个字段，就得给出由逗号分隔的多个字段编号</span><br><span class="line">$ cut -f 2,4 student_data.txt </span><br><span class="line">&gt; Name Percent </span><br><span class="line">&gt; Sarath 90 </span><br><span class="line">&gt; Alex 98 </span><br><span class="line">&gt; Anu 90</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用cut处理由分号分隔的字段</span><br><span class="line">$ cat delimited_data.txt</span><br><span class="line">&gt; No;Name;Mark;Percent </span><br><span class="line">&gt; 1;Sarath;45;90 </span><br><span class="line">&gt; 2;Alex;49;98 </span><br><span class="line">&gt; 3;Anu;45;90</span><br><span class="line">$ cut -f2 -d&quot;;&quot; delimited_data.txt</span><br><span class="line">&gt; Name </span><br><span class="line">&gt; Sarath </span><br><span class="line">&gt; Alex </span><br><span class="line">&gt; Anu</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印第2个到第5个字符</span><br><span class="line">$ cat range_fields.txt</span><br><span class="line">&gt; abcdefghijklmnopqrstuvwxyz </span><br><span class="line">&gt; abcdefghijklmnopqrstuvwxyz </span><br><span class="line">&gt; abcdefghijklmnopqrstuvwxyz</span><br><span class="line">&#x2F;&#x2F;打印第2个到第5个字符</span><br><span class="line">$ cut -c2-5 range_fields.txt</span><br><span class="line">&gt; ab </span><br><span class="line">&gt; ab </span><br><span class="line">&gt; ab </span><br><span class="line">&#x2F;&#x2F;--output-delimiter指定输出分隔符</span><br><span class="line">$ cut range_fields.txt -c1-3,6-9 --output-delimiter &quot;,&quot;</span><br><span class="line">&gt; abc,fghi </span><br><span class="line">&gt; abc,fghi </span><br><span class="line">&gt; abc,fghi</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="date-显示或设定系统的日期与时间"><a href="#date-显示或设定系统的日期与时间" class="headerlink" title="date-显示或设定系统的日期与时间"></a>date-显示或设定系统的日期与时间</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>date [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help] [--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-d datestr</strong></p>
<ul>
<li>显示 datestr 中所设定的时间 (非系统时间)</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助讯息</li>
</ul>
</li>
<li><p><strong>-s datestr 或 –set</strong></p>
<ul>
<li>将系统时间设为 datestr 中所设定的时间</li>
</ul>
</li>
<li><p><strong>-u 或 –utc</strong></p>
<ul>
<li>显示目前的格林威治时间</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本编号</li>
</ul>
</li>
<li><p><strong>–date</strong></p>
<ul>
<li>显示该选项指定的输入日期所设定的时间</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>格式字段datestr必须以+号开头</p>
</blockquote>
<blockquote>
<p>当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。</p>
</blockquote>
<blockquote>
<p>date命令的最小精度是秒</p>
</blockquote>
<blockquote>
<p>只有取得权限者(比如说 root)才能设定系统时间。当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。</p>
</blockquote>
<blockquote>
<p>datestr的值有如下这些可选：</p>
</blockquote>
<ul>
<li><p><strong>%</strong></p>
<ul>
<li>印出 %</li>
</ul>
</li>
<li><p><strong>%n</strong></p>
<ul>
<li>下一行</li>
</ul>
</li>
<li><p><strong>%t</strong></p>
<ul>
<li>跳格，一个tab</li>
</ul>
</li>
<li><p><strong>%H</strong></p>
<ul>
<li>小时(00-23)</li>
</ul>
</li>
<li><p><strong>%I</strong></p>
<ul>
<li>小时(01-12)</li>
</ul>
</li>
<li><p><strong>%k</strong></p>
<ul>
<li>小时(0-23)</li>
</ul>
</li>
<li><p><strong>%l</strong></p>
<ul>
<li>小时(1-12)</li>
</ul>
</li>
<li><p><strong>%M</strong></p>
<ul>
<li>分钟(00-59)</li>
</ul>
</li>
<li><p><strong>%p</strong></p>
<ul>
<li>显示本地 AM 或 PM</li>
</ul>
</li>
<li><p><strong>%S</strong></p>
<ul>
<li>秒(00-61)</li>
</ul>
</li>
<li><p><strong>%T</strong></p>
<ul>
<li>直接显示时间 (24 小时制)</li>
</ul>
</li>
<li><p><strong>%Z</strong></p>
<ul>
<li>显示时区</li>
</ul>
</li>
<li><p><strong>%a</strong></p>
<ul>
<li>星期几 (Sun-Sat)</li>
</ul>
</li>
<li><p><strong>%A</strong></p>
<ul>
<li>星期几 (Sunday-Saturday)</li>
</ul>
</li>
<li><p><strong>%b</strong></p>
<ul>
<li>月份 (Jan-Dec)</li>
</ul>
</li>
<li><p><strong>%B</strong></p>
<ul>
<li>月份 (January-December)</li>
</ul>
</li>
<li><p><strong>%c</strong></p>
<ul>
<li>直接显示日期与时间</li>
</ul>
</li>
<li><p><strong>%d</strong></p>
<ul>
<li>日 (01-31)</li>
</ul>
</li>
<li><p><strong>%D</strong></p>
<ul>
<li>直接显示日期 (mm/dd/yy)</li>
</ul>
</li>
<li><p><strong>%h</strong></p>
<ul>
<li>同 %b</li>
</ul>
</li>
<li><p><strong>%j</strong></p>
<ul>
<li>一年中的第几天 (001-366)</li>
</ul>
</li>
<li><p><strong>%m</strong></p>
<ul>
<li>月份 (01-12)</li>
</ul>
</li>
<li><p><strong>%U</strong></p>
<ul>
<li>一年中的第几周 (00-53) (以 Sunday 为一周的第一天的情形)</li>
</ul>
</li>
<li><p><strong>%w</strong></p>
<ul>
<li>一周中的第几天 (0-6)</li>
</ul>
</li>
<li><p><strong>%W</strong></p>
<ul>
<li>一年中的第几周 (00-53) (以 Monday 为一周的第一天的情形)</li>
</ul>
</li>
<li><p><strong>%x</strong></p>
<ul>
<li>直接显示日期 (mm/dd/yy)</li>
</ul>
</li>
<li><p><strong>%y</strong></p>
<ul>
<li>年份的最后两位数字 (00-99)</li>
</ul>
</li>
<li><p><strong>%Y</strong></p>
<ul>
<li>完整年份 (0000-9999)</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>代码示例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;读取当前时间</span><br><span class="line">$ date</span><br><span class="line">&gt; Thu May 20 23:09:04 IST 2010</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印unix时间</span><br><span class="line">$ date +%s</span><br><span class="line">&gt; 1290047248</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将输入的时间转换成unix时间</span><br><span class="line">$ date --date &quot;Wed mar 15 08:09:16 EDT 2017&quot; +%s</span><br><span class="line">&gt; 1489579718</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取当前时间</span><br><span class="line">$ date &quot;+%d %B %Y&quot;</span><br><span class="line">&gt; 20 May 2010</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置日期和时间</span><br><span class="line">$ date -s &quot;21 June 2009 11:01:22&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示时间后换行，再显示目前日期</span><br><span class="line">$ date &#39;+%T%n%D&#39;</span><br><span class="line">&gt;23:09:00</span><br><span class="line">&gt;07&#x2F;09&#x2F;19</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;按自己的格式输出</span><br><span class="line">$ date &#39;+usr_time: $1:%M %P -hey&#39;</span><br><span class="line">&gt; usr_time: $1:16 下午 -hey</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><h2 id="echo-打印内容"><a href="#echo-打印内容" class="headerlink" title="echo-打印内容"></a>echo-打印内容</h2><ul>
<li><p>简介：</p>
</li>
<li><p>echo命令是linux中最基础的命令,也是很常用的命令,功能说明用以显示文字。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>echo [-ne][字符串]或 echo [--help][--version]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-n</strong></p>
<ul>
<li>echo会在输出文本的尾部追加一个换行符。可以使用选项-n来禁止这种行为。</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">激活转义字符。使用-e选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：</span><br><span class="line">\a 发出警告声；</span><br><span class="line">\b 删除前一个字符；</span><br><span class="line">\c 最后不加上换行符号；</span><br><span class="line">\f 换行但光标仍旧停留在原来的位置；</span><br><span class="line">\n 换行且光标移至行首；</span><br><span class="line">\r 光标移至行首，但不换行；</span><br><span class="line">\t 插入tab；</span><br><span class="line">\v 与\f相同；</span><br><span class="line">\\ 插入\字符；</span><br><span class="line">\e 打印彩色文本 </span><br><span class="line">	文本颜色是由对应的色彩码来描述的。其中包括：重置&#x3D;0，黑色&#x3D;30，红色&#x3D;31，绿色&#x3D;32，黄色&#x3D;33，蓝色&#x3D;34，洋红&#x3D;35，青色&#x3D;36，白色&#x3D;37。</span><br><span class="line">	对于彩色背景，经常使用的颜色码是：重置&#x3D;0，黑色&#x3D;40，红色&#x3D;41，绿色&#x3D;42，黄色&#x3D;43，蓝色&#x3D;44，洋红&#x3D;45，青色&#x3D;46，白色&#x3D;47。</span><br><span class="line">	用法：echo -e &quot;\e[1;31m This is red text \e[0m&quot; </span><br><span class="line">	其中\e[1;31m是一个转义字符串，可以将颜色设为红色，\e[0m将颜色重新置回。</span><br><span class="line">\nnn 插入nnn（八进制）所代表的ASCII字符；</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>echo的单引号不会解释文本中的特殊字符，双引号会。</p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ a&#x3D;1;</span><br><span class="line">- echo &#39;$a+1&#39;</span><br><span class="line">&gt; a+1</span><br><span class="line">$ echo &quot;$a+1&quot;</span><br><span class="line">&gt; 1+1</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h2 id="find-查找文件"><a href="#find-查找文件" class="headerlink" title="find-查找文件"></a>find-查找文件</h2><ul>
<li><p>简介：</p>
<ul>
<li>find命令的工作方式如下：沿着文件层次结构向下遍历，匹配符合条件的文件，执行相应<br>的操作。默认的操作是打印出文件和目录，这也可以使用-print选项来指定。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-mount或 -xdev</strong></p>
<ul>
<li>只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</li>
</ul>
</li>
<li><p><strong>-newer file</strong></p>
<ul>
<li>找出比file文件更新的（更近的修改时间）所有文件。</li>
</ul>
</li>
<li><p><strong>-anewer file</strong></p>
<ul>
<li>查找比文件 file 更晚被读取过的文件</li>
</ul>
</li>
<li><p><strong>-cnewer file</strong></p>
<ul>
<li>查找比文件 file 更新的文件</li>
</ul>
</li>
<li><p><strong>-amin n</strong></p>
<ul>
<li>根据用户最近一次访问文件的时间查找，查找在过去 n 分钟内被读取过的文件,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-atime n</strong></p>
<ul>
<li>根据用户最近一次访问文件的时间查找，查找在过去 n 天内被读取过的文件,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-cmin n</strong></p>
<ul>
<li>根据文件元数据（例如权限或所有权）最后一次改变的时间查找，查找在过去 n 分钟内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-ctime n</strong></p>
<ul>
<li>根据文件元数据（例如权限或所有权）最后一次改变的时间查找，查找在过去 n 天内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-mtime n</strong></p>
<ul>
<li>根据文件内容最后一次被修改的时间查找，查找在过去 n 分钟内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-mmin n</strong></p>
<ul>
<li>根据文件内容最后一次被修改的时间查找，查找在过去 n 天内被修改过,数字n前面可以加上-或+。-表示小于，+表示大于。</li>
</ul>
</li>
<li><p><strong>-ipath p, -path p</strong></p>
<ul>
<li>查找路径名称符合 p 的文件，ipath 会忽略大小写。p一般可以为通配符如’<em>/slynux/</em>‘</li>
</ul>
</li>
<li><p><strong>-regex r,-iregex r</strong></p>
<ul>
<li>查找路径名称符合 r 的文件。r 一般可以为正则表达式</li>
</ul>
</li>
<li><p><strong>-name name, -iname name</strong></p>
<ul>
<li>查找文件名称符合 name 的文件。iname 会忽略大小写。这个模式可以是通配符，也可以是正则表达式。如’*.txt’能够匹配所有名字以.txt结尾的文件或目录</li>
</ul>
</li>
<li><p><strong>-size n</strong></p>
<ul>
<li>可以根据文件的大小展开搜索，n可以为+2k，数字前面可以加上-或+。-表示小于，+表示大于。单位取值可以为<ul>
<li>b：块（512字节）。</li>
<li>c：字节。</li>
<li>w：字（2字节）。</li>
<li>k：千字节（1024字节）。</li>
<li>M：兆字节（1024K字节）。</li>
<li>G：吉字节（1024M字节）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>-maxdepth n,–mindepth n</strong></p>
<ul>
<li>-maxdepth和–mindepth选项可以限制find命令遍历的目录深度。这可以避免find命令没完没了地查找。</li>
</ul>
</li>
<li><p><strong>–user USER</strong></p>
<ul>
<li>找出由某个特定用户权限下所拥有的文件。参数USER可以是用户名或UID。</li>
</ul>
</li>
<li><p><strong>-prune n</strong></p>
<ul>
<li>在搜索时排除某些文件或目录,一般与其他选项一起使用，如.git目录应该被排除在外：<br><code>$ find devel/source_path -name &#39;.git&#39; -prune -o -type f -print</code></li>
</ul>
</li>
<li><p><strong>-perm n</strong></p>
<ul>
<li>指明find应该只匹配具有特定权限值的文件。n为文件权限<br><code>$ find devel/source_path -name &#39;.git&#39; -prune -o -type f -print</code></li>
</ul>
</li>
<li><p><strong>pid n</strong></p>
<ul>
<li>process id 是 n 的文件</li>
</ul>
</li>
<li><p><strong>-type t</strong></p>
<ul>
<li><p>类Unix系统将一切都视为文件。文件具有不同的类型，例如普通文件、目录、字符设备、块<br>设备、符号链接、硬链接、套接字以及FIFO等。可以使用-type选项对文件搜索进行过滤。借助这个选项，我们可以告诉find命令只匹配指定类型的文件。t的取值可以是</p>
<ul>
<li><p>d：目录</p>
</li>
<li><p>c: 字符设备</p>
</li>
<li><p>b: 块设备</p>
</li>
<li><p>p: FIFO具名贮列</p>
</li>
<li><p>f: 一般文件</p>
</li>
<li><p>l: 符号链接</p>
</li>
<li><p>s: socket套接字</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;列出给定目录下所有的文件和子目录 find base_path</span><br><span class="line">$ find . -print</span><br><span class="line">&gt; .history </span><br><span class="line">&gt; Downloads</span><br><span class="line">&gt; Downloads&#x2F;tcl.fossil </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;够匹配所有名字以.txt结尾的文件或目录。</span><br><span class="line">$ find &#x2F;home&#x2F;slynux -name &#39;*.txt&#39; -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;find命令支持逻辑操作符。-a和-and选项可以执行逻辑与（AND）操作，-o和-or选项可以执行逻辑或（OR）操作。</span><br><span class="line">$ find . \( -name &#39;*.txt&#39; -o -name &#39;*.pdf&#39; \) -print </span><br><span class="line">&gt; .&#x2F;text.pdf </span><br><span class="line">&gt; .&#x2F;new.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用-and操作符选择名字以s开头且其中包含e的文件</span><br><span class="line">$ find . \( -name &#39;*e*&#39; -and -name &#39;s*&#39; \)</span><br><span class="line">&gt; .&#x2F;some.jpg</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匹配.py或.sh文件</span><br><span class="line">$ find . -regex &#39;.*\.(py\|sh\)$&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;find也可以用!排除匹配到的模式,匹配所有不以.txt结尾的文件</span><br><span class="line">$ find . ! -name &quot;*.txt&quot; -print</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印出在最近7天内被访问过的所有文件</span><br><span class="line">$ find . -type f -atime -7 -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印出访问时间超过7天的所有文件。</span><br><span class="line">$ find . -type f -atime +7 -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;找出比file.txt修改时间更近的所有文件</span><br><span class="line">$ find . -type f -newer file.txt -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印出用户slynux拥有的所有文件</span><br><span class="line">$ find . -type f -user slynux -print</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;利用find执行相应操作</span><br><span class="line">&#x2F;&#x2F;删除匹配的文件</span><br><span class="line">&#x2F;&#x2F;find命令的-delete选项可以删除所匹配到的文件。下面的命令能够从当前目录中删除.swp文件：</span><br><span class="line">$ find . -type f -name &quot;*.swp&quot; -delete</span><br><span class="line"></span><br><span class="line">&#x2F;利用find执行相应操作</span><br><span class="line">&#x2F;&#x2F;执行命令,利用-exec选项，find命令可以结合其他命令使用。</span><br><span class="line">&#x2F;&#x2F;将某位用户（比如root）所拥有的全部文件的所有权更改成另一位用户（比如用户www-data）</span><br><span class="line">&#x2F;&#x2F;那么可以用-user找出root拥有的所有文件，然后用-exec更改所有权。</span><br><span class="line">&#x2F;&#x2F;在下面的例子中，对于每一个匹配的文件，find命令会将&#123;&#125;替换成相应的文件名并更改该文件的所有权。</span><br><span class="line">$ find . -type f -user root -exec chown slynux &#123;&#125; \;</span><br><span class="line">&#x2F;&#x2F;find命令使用一对花括号&#123;&#125;代表文件名。</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>注意 find . -type f -user root -exec chown slynux {} ; 该命令结尾的;。必须对分号进行转义，否则shell会将其视为find命令的结束，而非chown命令的结束。</p>
</blockquote>
<blockquote>
<p>为每个匹配到的文件调用命令可是个不小的开销。如果指定的命令接受多个参数（如chown），你可以换用加号（+）作为命令的结尾。这样find会生成一份包含所有搜索结果的列表，然后将其作为指定命令的参数，一次性执行。</p>
</blockquote>
<blockquote>
<p>我们无法在-exec选项中直接使用多个命令。该选项只能够接受单个命令，不过我们可以耍一个小花招。把多个命令写到一个 shell脚本中（例如command.sh），然后在-exec中使用这个脚本：<br>-exec ./commands.sh {} ;</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="ftp-lftp——使用ftp协议共享文件"><a href="#ftp-lftp——使用ftp协议共享文件" class="headerlink" title="ftp/lftp——使用ftp协议共享文件"></a>ftp/lftp——使用ftp协议共享文件</h2><ul>
<li><p>简介：</p>
<ul>
<li>文件传输协议（File Transfer Protocol，FTP）是一个古老的协议，在很多公共站点上用于文件共享。</li>
<li>FTP服务器通常运行在端口21上。远程主机上必须安装并运行FTP服务器才能使用FTP。</li>
<li>我们可以使用传统的ftp命令或更新的lftp命令访问FTP服务器。两者都支持下面要讲到的命令。很多公共网站都是用FTP共享文件</li>
</ul>
</li>
<li><p>使用步骤</p>
<ol>
<li>要连接FTP服务器传输文件，可以使用<ul>
<li><code>$ lftp username@ftphost</code></li>
<li>它会提示你输入密码，然后显示一个像下面这样的登录提示符<br><code>lftp username@ftphost:~&gt;</code></li>
</ul>
</li>
<li>你可以在提示符后输入各种命令，如下所示<ul>
<li>cd directory：更改远程主机目录。</li>
<li>lcd：更改本地主机目录。</li>
<li>mkdir：在远程主机上创建目录。</li>
<li>ls：列出远程主机当前目录下的文件。</li>
<li>get FILENAME：将文件下载到本地主机的当前目录中。<ul>
<li><code>lftp username@ftphost:~&gt; get filename</code></li>
</ul>
</li>
<li>put filename：将文件从当前目录上传到远程主机。<ul>
<li><code>lftp username@ftphost:~&gt; put filename</code></li>
</ul>
</li>
<li>quit命令可以退出lftp会话</li>
</ul>
</li>
</ol>
</li>
<li><p>注意事项</p>
<blockquote>
<p>lftp提示符支持命令自动补全。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><h2 id="grep——在文件中搜索文本"><a href="#grep——在文件中搜索文本" class="headerlink" title="grep——在文件中搜索文本"></a>grep——在文件中搜索文本</h2><ul>
<li><p>简介：</p>
<ul>
<li><p>Linux grep命令用于查找文件里符合条件的字符串。</p>
</li>
<li><p>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一行显示出来。</p>
</li>
<li><p>若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。</p>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>grep [选项参数][范本样式][文件或目录...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a 或 –text</strong></p>
<ul>
<li>不要忽略二进制的数据。</li>
</ul>
</li>
<li><p><strong>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt;</strong></p>
<ul>
<li>除了显示符合范本样式的那一行之外，并显示该行之后的内容。</li>
</ul>
</li>
<li><p><strong>-b 或 –byte-offset</strong></p>
<ul>
<li>可以打印出匹配出现在行中的偏移。字符在行中的偏移是从0开始计数，不是1。</li>
</ul>
</li>
<li><p><strong>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt;</strong></p>
<ul>
<li>除了显示符合样式的那一行之外，并显示该行之前的内容。</li>
</ul>
</li>
<li><p><strong>-c 或 –count</strong></p>
<ul>
<li>计算符合样式的行数。需要注意的是-c只是统计匹配行的数量，并不是匹配的次数</li>
</ul>
</li>
<li><p><strong>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong></p>
<ul>
<li>除了显示符合样式的那一行之外，并显示该行之前和之后的内容。</li>
</ul>
</li>
<li><p><strong>-d &lt;动作&gt; 或 –directories=&lt;动作&gt;</strong></p>
<ul>
<li>当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li>
</ul>
</li>
<li><p><strong>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt;</strong></p>
<ul>
<li>指定字符串做为查找文件内容的样式。可以指定多个匹配模式。</li>
</ul>
</li>
<li><p><strong>-E 或 –extended-regexp</strong></p>
<ul>
<li>将样式为延伸的普通表示法来使用。grep命令默认使用基础正则表达式。这是先前描述的正则表达式的一个子集。选项-E可以使grep使用扩展正则表达式。也可以使用默认启用扩展正则表达式的egrep命令。</li>
</ul>
</li>
<li><p><strong>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt;</strong></p>
<ul>
<li>指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li>
</ul>
</li>
<li><p><strong>-F 或 –fixed-regexp</strong></p>
<ul>
<li>将样式视为固定字符串的列表。</li>
</ul>
</li>
<li><p><strong>-G 或 –basic-regexp</strong></p>
<ul>
<li>将样式视为普通的表示法来使用。</li>
</ul>
</li>
<li><p><strong>-h 或 –no-filename</strong></p>
<ul>
<li>在显示符合样式的那一行之前，不标示该行所属的文件名称。</li>
</ul>
</li>
<li><p><strong>-H 或 –with-filename</strong></p>
<ul>
<li>在显示符合样式的那一行之前，表示该行所属的文件名称。</li>
</ul>
</li>
<li><p><strong>-i 或 –ignore-case</strong></p>
<ul>
<li>忽略字符大小写的差别。</li>
</ul>
</li>
<li><p><strong>-l 或 –file-with-matches</strong></p>
<ul>
<li>列出文件内容符合指定的样式的文件名称。</li>
</ul>
</li>
<li><p><strong>-L 或 –files-without-match</strong></p>
<ul>
<li>列出文件内容不符合指定的样式的文件名称。</li>
</ul>
</li>
<li><p><strong>-n 或 –line-number</strong></p>
<ul>
<li>在显示符合样式的那一行之前，标示出该行的列数编号。</li>
</ul>
</li>
<li><p><strong>-o 或 –only-matching</strong></p>
<ul>
<li>只显示匹配PATTERN 部分。</li>
</ul>
</li>
<li><p><strong>-q 或 –quiet或–silent</strong></p>
<ul>
<li>不显示任何信息。</li>
</ul>
</li>
<li><p><strong>-r 或 –recursive</strong></p>
<ul>
<li>此参数的效果和指定”-d recurse”参数相同。</li>
</ul>
</li>
<li><p><strong>-s 或 –no-messages</strong></p>
<ul>
<li>不显示错误信息。</li>
</ul>
</li>
<li><p><strong>-v 或 –revert-match</strong></p>
<ul>
<li>显示不包含匹配文本的所有行。</li>
</ul>
</li>
<li><p><strong>-V 或 –version</strong></p>
<ul>
<li>显示版本信息。</li>
</ul>
</li>
<li><p><strong>-w 或 –word-regexp</strong></p>
<ul>
<li>只显示全字符合的列。</li>
</ul>
</li>
<li><p><strong>-x –line-regexp</strong></p>
<ul>
<li>只显示全列符合的列。</li>
</ul>
</li>
<li><p><strong>-y</strong></p>
<ul>
<li>此参数的效果和指定”-i”参数相同。</li>
</ul>
</li>
<li><p><strong>–color</strong></p>
<ul>
<li>在输出行中着重标记出匹配到的模式，一般为–color=auto。</li>
</ul>
</li>
<li><p><strong>–include</strong></p>
<ul>
<li>在搜索过程中使用通配符指定（include）某些文件</li>
</ul>
</li>
<li><p><strong>–exclude</strong></p>
<ul>
<li>在搜索过程中使用通配符排除（exclude）某些文件</li>
</ul>
</li>
<li><p><strong>–exclude-dir</strong></p>
<ul>
<li>在搜索过程中使用通配符以排除目录</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在当前目录中，查找有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。</span><br><span class="line">$ grep test *file* </span><br><span class="line">&gt; file1:This a Linux testfile! #列出file1 文件中包含test字符的行  </span><br><span class="line">&gt; file_2:This is a linux testfile! #列出file_2 文件中包含test字符的行  </span><br><span class="line">&gt; file_2:Linux test #列出file_2 文件中包含test字符的行 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以递归的方式查找符合条件的文件。</span><br><span class="line">&#x2F;&#x2F;例如，查找指定目录&#x2F;etc&#x2F;acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串&quot;update&quot;的文件</span><br><span class="line">&#x2F;&#x2F;并打印出该字符串所在行的内容</span><br><span class="line">$ grep -r update &#x2F;etc&#x2F;acpi </span><br><span class="line">&gt; &#x2F;etc&#x2F;acpi&#x2F;ac.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.)  Rather than  </span><br><span class="line">&gt; &#x2F;etc&#x2F;acpi&#x2F;resume.d&#x2F;85-anacron.sh:# (Things like the slocate updatedb cause a lot of IO.) Rather than  </span><br><span class="line">&gt; &#x2F;etc&#x2F;acpi&#x2F;events&#x2F;thinkpad-cmos: action&#x3D;&#x2F;usr&#x2F;sbin&#x2F;thinkpad-keys--update </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;反向查找。前面各个例子是查找并打印出符合条件的行，通过&quot;-v&quot;参数可以打印出不符合条件行的内容。</span><br><span class="line">&#x2F;&#x2F;查找文件名中包含 file 的文件中不包含test 的行，</span><br><span class="line">$ grep -v test *file*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在stdin中搜索匹配特定模式的文本行</span><br><span class="line">$ $ echo -e &quot;this is a word \n next line&quot; | grep word</span><br><span class="line">&gt; this is a word</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用扩展正则，只输出匹配到的文本，</span><br><span class="line">$ echo this is a line. | grep -o -E &quot;[a-z]+\.&quot;</span><br><span class="line">&gt; line</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计出匹配模式的文本行数，-c只是统计匹配行的数量，并不是匹配的次数</span><br><span class="line">$ grep -c &quot;text&quot; filename</span><br><span class="line">&gt; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;统计文件中匹配项的数量，可以使用下面的技巧</span><br><span class="line">$ echo -e &quot;1 2 3 4\nhello\n5 6&quot; | egrep -o &quot;[0-9]&quot; | wc -l</span><br><span class="line">&gt; 6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印多个文件包含Linux的行，输出行号</span><br><span class="line">$ grep linux -n sample1.txt sample2.txt</span><br><span class="line">&gt; sample1.txt:2:linux is fun </span><br><span class="line">&gt; sample2.txt:2:planetlinux</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选项-b可以打印出匹配出现在行中的偏移。配合选项-o可以打印出匹配所在的字符或字节偏移</span><br><span class="line">$ echo gnu is not unix | grep -b -o &quot;not&quot;</span><br><span class="line">&gt; 7:not</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出匹配模式所在的文件</span><br><span class="line">$ grep -l linux sample1.txt sample2.txt</span><br><span class="line">&gt; sample1.txt </span><br><span class="line">&gt; sample2.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对当前目录中对文本进行递归搜索</span><br><span class="line">$  grep &quot;text&quot; . -R -n</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在匹配模式时不考虑字符的大小写</span><br><span class="line">$ echo hello world | grep -i &quot;HELLO&quot;</span><br><span class="line">&gt; hello</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用-e指定多个匹配模式，打印出匹配任意一种模式的行，每个匹配对应一行输出。</span><br><span class="line">$  echo this is a line of text | grep -o -e &quot;this&quot; -e &quot;line&quot;</span><br><span class="line">&gt; this </span><br><span class="line">&gt; line</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以将多个模式定义在文件中。选项-f可以读取文件并使用其中的模式（一个模式一行）</span><br><span class="line">$ cat pat_file </span><br><span class="line">&gt; hello </span><br><span class="line">&gt; cool</span><br><span class="line">$ echo hello this is cool | grep -f pat_file</span><br><span class="line">&gt; hello this is cool</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用--include选项在目录中递归搜索所有的 .c和 .cpp文件。</span><br><span class="line">&#x2F;&#x2F;注意，some&#123;string1,string2,string3&#125;会被扩展成somestring1 somestring2 somestring3。</span><br><span class="line">$ grep &quot;main()&quot; . -r --include *.&#123;c,cpp&#125;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用选项--exclude在搜索过程中排除所有的README文件</span><br><span class="line">$ grep &quot;main()&quot; . -r --exclude &quot;README&quot;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选项--exclude-dir可以排除目录：</span><br><span class="line">$ grep main . -r -exclude-dir CVS</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;grep的静默输出。可以通过设置grep的静默选项（-q）来实现。</span><br><span class="line">&#x2F;&#x2F;在静默模式中，grep命令不会输出任何内容。它仅是运行命令，然后根据命令执行成功与否返回退出状态。</span><br><span class="line">&#x2F;&#x2F;0表示匹配成功，非0表示匹配失败。</span><br><span class="line">$ grep -q word file</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h2 id="head-打印文件的前n行"><a href="#head-打印文件的前n行" class="headerlink" title="head-打印文件的前n行"></a>head-打印文件的前n行</h2><ul>
<li><p>简介：</p>
</li>
<li><p>head命令用于显示文件的开头的内容。在默认情况下，head命令显示文件的头10行内容。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>head [选项] fileName</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-n&lt;数字&gt;</strong></p>
<ul>
<li>指定显示头部内容的行数,负数时表示倒数n行</li>
</ul>
</li>
<li><p><strong>-c&lt;字符数&gt;</strong></p>
<ul>
<li>指定显示头部内容的字符数；</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>总是显示文件名的头信息；</li>
</ul>
</li>
<li><p><strong>-q</strong></p>
<ul>
<li>不显示文件名的头信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示 test.log 文件中前 20 行</span><br><span class="line">$ head -n 20 test.log</span><br><span class="line">&#x2F;&#x2F;显示 test.log 文件中前 20 字节</span><br><span class="line">$ head -c 20 test.log</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示 test.log 文件中除了最后20行之外的所有行</span><br><span class="line">$ head -n -20 test.log</span><br></pre></td></tr></table></figure>
<p>  <img src="https://oscimg.oschina.net/oscnet/15e07e85dcfeca736889def8b923fd05a0f.jpg" alt=""></p>
</li>
</ul>
<hr>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><h2 id="ifconfig——配置和展示网络信息"><a href="#ifconfig——配置和展示网络信息" class="headerlink" title="ifconfig——配置和展示网络信息"></a>ifconfig——配置和展示网络信息</h2><ul>
<li><p>简介：</p>
</li>
<li><p>ifconfig可设置网络设备的状态，或是显示目前的设置。注意和Windows的命令ipconfig区分。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>ifconfig [选项参数]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>add&lt;地址&gt;</strong></p>
<ul>
<li>设置网络设备IPv6的IP地址。</li>
</ul>
</li>
<li><p><strong>del&lt;地址&gt;</strong></p>
<ul>
<li>删除网络设备IPv6的IP地址。</li>
</ul>
</li>
<li><p><strong>down</strong></p>
<ul>
<li>关闭指定的网络设备。</li>
</ul>
</li>
<li><p><strong>&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;</strong></p>
<ul>
<li>设置网络设备的类型与硬件地址。</li>
</ul>
</li>
<li><p><strong>io_addr&lt;I/O地址&gt;</strong></p>
<ul>
<li>设置网络设备的I/O地址。</li>
</ul>
</li>
<li><p><strong>irq&lt;IRQ地址&gt;</strong></p>
<ul>
<li>设置网络设备的IRQ。</li>
</ul>
</li>
<li><p><strong>media&lt;网络媒介类型&gt;</strong></p>
<ul>
<li>设置网络设备的媒介类型。</li>
</ul>
</li>
<li><p><strong>mem_start&lt;内存地址&gt;</strong></p>
<ul>
<li>设置网络设备在主内存所占用的起始地址。</li>
</ul>
</li>
<li><p><strong>metric&lt;数目&gt;</strong></p>
<ul>
<li>指定在计算数据包的转送次数时，所要加上的数目。</li>
</ul>
</li>
<li><p><strong>mtu&lt;字节&gt;</strong></p>
<ul>
<li>设置网络设备的MTU。</li>
</ul>
</li>
<li><p><strong>netmask&lt;子网掩码&gt;</strong></p>
<ul>
<li>设置网络设备的子网掩码。</li>
</ul>
</li>
<li><p><strong>tunnel&lt;地址&gt;</strong></p>
<ul>
<li>建立IPv4与IPv6之间的隧道通信地址。</li>
</ul>
</li>
<li><p><strong>up</strong></p>
<ul>
<li>启动指定的网络设备。</li>
</ul>
</li>
<li><p><strong>-broadcast&lt;地址&gt;</strong></p>
<ul>
<li>将要送往指定地址的数据包当成广播数据包来处理。</li>
</ul>
</li>
<li><p><strong>-pointopoint&lt;地址&gt;</strong></p>
<ul>
<li>与指定地址的网络设备建立直接连线，此模式具有保密功能。</li>
</ul>
</li>
<li><p><strong>-promisc</strong></p>
<ul>
<li>关闭或启动指定网络设备的promiscuous模式。</li>
</ul>
</li>
<li><p><strong>[IP地址]</strong></p>
<ul>
<li>指定网络设备的IP地址。</li>
</ul>
</li>
<li><p><strong>[网络设备]</strong></p>
<ul>
<li>指定网络设备的名称。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示网络设备信息，ifconfig输出的最左边一列是网络接口名，右边的若干列显示对应的网络接口的详细信息。</span><br><span class="line">$ ifconfig</span><br><span class="line">&gt; eth0   Link encap:Ethernet HWaddr 00:50:56:0A:0B:0C </span><br><span class="line">&gt; .....以下省略</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ifconfig会显示系统中所有活动网络接口的详细信息。不过，我们可以限制它只显示某个特定接口的信息</span><br><span class="line">$ ifconfig  wlan0</span><br><span class="line">&gt; wlan0 Link encap:EthernetHWaddr 00:1c:bf:87:25:d2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置网络接口的IP地址</span><br><span class="line">$ ifconfig wlan0 192.168.0.80</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置此IP地址的子网掩码</span><br><span class="line">$ ifconfig wlan0 192.168.0.80 netmask 255.255.252.0</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><h2 id="less——对文件或其它输出进行分页显示"><a href="#less——对文件或其它输出进行分页显示" class="headerlink" title="less——对文件或其它输出进行分页显示"></a>less——对文件或其它输出进行分页显示</h2><ul>
<li><p>简介：</p>
<ul>
<li>对文件或其它输出进行分页显示。缓冲加载。</li>
<li>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>less [参数] 文件</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-e</strong></p>
<ul>
<li>当文件显示结束后，自动离开</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>强迫打开特殊文件，例如外围设备代号、目录和二进制文件</li>
</ul>
</li>
<li><p><strong>-g</strong></p>
<ul>
<li>只标志最后搜索的关键词</li>
</ul>
</li>
<li><p><strong>-i</strong></p>
<ul>
<li>忽略搜索时的大小写</li>
</ul>
</li>
<li><p><strong>-m</strong></p>
<ul>
<li>显示类似more命令的百分比</li>
</ul>
</li>
<li><p><strong>-N</strong></p>
<ul>
<li>显示每行的行号</li>
</ul>
</li>
<li><p><strong>-Q</strong></p>
<ul>
<li>不使用警告音</li>
</ul>
</li>
<li><p><strong>-s</strong></p>
<ul>
<li>显示连续空行为一行</li>
</ul>
</li>
<li><p><strong>-S</strong></p>
<ul>
<li>行过长时间将超出部分舍弃</li>
</ul>
</li>
</ul>
</li>
<li><p>快捷键</p>
<ul>
<li><p><strong>/&lt;字符串&gt;</strong></p>
<ul>
<li>向下搜索”字符串”的功能</li>
</ul>
</li>
<li><p><strong>?&lt;字符串&gt;</strong></p>
<ul>
<li>向上搜索”字符串”的功能</li>
</ul>
</li>
<li><p><strong>n</strong></p>
<ul>
<li>针对 / 或 ?的结果，重复前一个搜索</li>
</ul>
</li>
<li><p><strong>N</strong></p>
<ul>
<li>针对 / 或 ?的结果，反向重复前一个搜索</li>
</ul>
</li>
<li><p><strong>b</strong></p>
<ul>
<li>向后翻一页</li>
</ul>
</li>
<li><p><strong>d</strong></p>
<ul>
<li>向后翻半页</li>
</ul>
</li>
<li><p><strong>h</strong></p>
<ul>
<li>显示帮助界面</li>
</ul>
</li>
<li><p><strong>u</strong></p>
<ul>
<li>向前滚动半页</li>
</ul>
</li>
<li><p><strong>y</strong></p>
<ul>
<li>向前滚动一行</li>
</ul>
</li>
<li><p><strong>空格键</strong></p>
<ul>
<li>滚动一页</li>
</ul>
</li>
<li><p><strong>回车键</strong></p>
<ul>
<li>滚动一行</li>
</ul>
</li>
<li><p><strong>q / ZZ</strong></p>
<ul>
<li>退出 less 命令</li>
</ul>
</li>
<li><p><strong>v</strong></p>
<ul>
<li>使用配置的编辑器编辑当前文件</li>
<li>对于提示的^X等操作，^X即为CTRL+X。</li>
</ul>
</li>
<li><p><strong>h</strong></p>
<ul>
<li>显示 less 的帮助文档</li>
</ul>
</li>
<li><p><strong>F</strong></p>
<ul>
<li>类似 tail -f 的效果，读取写入文件的最新内容， 按 ctrl+C 停止。</li>
</ul>
</li>
<li><p><strong>&amp;</strong></p>
<ul>
<li>开启模式匹配模式，可继续键入正则匹配，使得less仅显示匹配模式的行，而不是整个文件</li>
</ul>
</li>
<li><p><strong>m</strong></p>
<ul>
<li>mark的意思，开启mark模式,让你键入一个字符，比如我们键入了a，那么less会使用 a 标记文本的当前位置。当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置</li>
</ul>
</li>
<li><p><strong>‘</strong></p>
<ul>
<li>单引号，开启goto mark模式，让你键入一个字符，到达你键入字符标记的位置，比如你键入啊，那么导航到你标记的 a 处</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;查看文件</span><br><span class="line">$ less log.log</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ps查看进程信息并通过less分页显示</span><br><span class="line">$ ps -ef |less</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查看命令历史使用记录并通过less分页显示</span><br><span class="line">$ history | less</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;浏览多个文件，输入 &quot;:n&quot; (n&#x3D;next) 后，切换到 log2.log;输入&quot;:p&quot; (p&#x3D;preview)后，切换到log1.log</span><br><span class="line">$ less log1.log log2.log</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="ls———显示指定工作目录下之内容"><a href="#ls———显示指定工作目录下之内容" class="headerlink" title="ls———显示指定工作目录下之内容"></a>ls———显示指定工作目录下之内容</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。它是list的简写。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>ls [选项参数] [name...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>显示所有文件及目录(ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>将文件以相反次序显示(原定依英文字母次序)</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>将文件依建立时间之先后次序列出</li>
</ul>
</li>
<li><p><strong>-A</strong></p>
<ul>
<li>同-a，但不列出”.”(目前目录)及”..”(父目录)</li>
</ul>
</li>
<li><p><strong>-R</strong></p>
<ul>
<li>若目录下有文件，则以下之文件亦皆依序列出</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;列出目前工作目录下所有名称是 s 开头的文件，越新的排越后面 </span><br><span class="line">$ ls -ltr s*</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;bin 目录以下所有目录及文件详细资料列出 </span><br><span class="line">$ ls -lR &#x2F;bin</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出目前工作目录下所有文件及目录；目录于名称后加 &quot;&#x2F;&quot;, 可执行档于名称后加 &quot;*&quot; </span><br><span class="line">$ ls -AF</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><h1 id="N"><a href="#N" class="headerlink" title="N"></a>N</h1><h1 id="O"><a href="#O" class="headerlink" title="O"></a>O</h1><h1 id="P"><a href="#P" class="headerlink" title="P"></a>P</h1><h2 id="paste——合并文件的列"><a href="#paste——合并文件的列" class="headerlink" title="paste——合并文件的列"></a>paste——合并文件的列</h2><ul>
<li><p>简介：</p>
</li>
<li><p>paste指令会把每个文件以列对列的方式，一列列地加以合并。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>paste [选项参数][文件...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-d&lt;间隔字符&gt;或–delimiters=&lt;间隔字符&gt;</strong></p>
<ul>
<li>用指定的间隔字符取代跳格字符。</li>
</ul>
</li>
<li><p><strong>-s或–serial</strong></p>
<ul>
<li>串列进行而非平行处理。</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>在线帮助。</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示帮助信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;合并file1.txt 和file2.txt，先看看这两个文件的内容</span><br><span class="line">$ cat file1.txt </span><br><span class="line">&gt; 1 </span><br><span class="line">&gt; 2 </span><br><span class="line">&gt; 3 </span><br><span class="line">&gt; 4 </span><br><span class="line">&gt; 5 </span><br><span class="line">$ cat file2.txt </span><br><span class="line">&gt; slynux </span><br><span class="line">&gt; gnu </span><br><span class="line">&gt; bash </span><br><span class="line">&gt; hack</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用paste合并</span><br><span class="line">$ paste file1.txt file2.txt </span><br><span class="line">&gt; 1 slynux </span><br><span class="line">&gt; 2 gnu </span><br><span class="line">&gt; 3 bash </span><br><span class="line">&gt; 4 hack </span><br><span class="line">&gt; 5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认的分隔符是制表符，也可以用-d指定分隔符</span><br><span class="line">$ paste file1.txt file2.txt -d &quot;,&quot; </span><br><span class="line">&gt; 1,slynux </span><br><span class="line">&gt; 2,gnu </span><br><span class="line">&gt; 3,bash </span><br><span class="line">&gt; 4,hack </span><br><span class="line">&gt; 5,</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若使用paste指令的参数&quot;-s&quot;，则可以将一个文件中的多行数据合并为一行进行显示。</span><br><span class="line">&#x2F;&#x2F;例如，将文件&quot;file&quot;中的3行数据合并为一行数据进行显示，输入如下命令</span><br><span class="line">$ paste -s file </span><br><span class="line">&gt; xiongdan 200 lihaihui 233 lymlrl 231</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>参数”-s”只是将testfile文件的内容调整显示方式，并不会改变原文件的内容格式。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="printf-打印内容"><a href="#printf-打印内容" class="headerlink" title="printf-打印内容"></a>printf-打印内容</h2><ul>
<li><p>简介：</p>
<ul>
<li>printf命令接受<strong>引用文本或由空格分隔的参数</strong>。我们可以在printf中使用格式化字符串来指定字符串的宽度、左右对齐方式等。</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">"%-5s %-10s %-4s\n"</span> No Name Mark ;</span></span><br><span class="line">- printf "%-5s %-10s %-4.2f\n" 1 Sarath 80.3456 11 ;</span><br><span class="line">- printf "%-5s %-10s %-4.2f\n" 2 James 90.9989 ;</span><br><span class="line">- printf "%-5s %-10s %-4.2f\n" 3 Jeff 77.564</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> No Name Mark </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 1 Sarath 80.35 </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2 James 91.00 14 </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 3 Jeff 77.56</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<ul>
<li><p>%s、%c、%d和%f都是格式替换符（format substitution character），它们定义了该如何打印后续参数。%-5s指明了一个格式为左对齐且宽度为5的字符串替换（-表示左对齐）。如果不指明-，字符串就采用右对齐形式。</p>
</li>
<li><p>宽度指定了保留给某个字符串的字符数量。对Name而言，其保留宽度是10。因此，任何Name字段的内容都会被显示在10字符宽的保留区域内，如果内容不足10个字符，余下的则以空格填充。</p>
</li>
<li><p>对于浮点数，可以使用其他参数对小数部分进行舍入（round off）。 对于Mark字段，我们将其格式化为%-4.2f，其中.2指定保留两位小数。注意，在每行的格式字符串后都有一个换行符（\n）。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h1><h1 id="R"><a href="#R" class="headerlink" title="R"></a>R</h1><h2 id="read-从键盘或标准输入中读取文本"><a href="#read-从键盘或标准输入中读取文本" class="headerlink" title="read-从键盘或标准输入中读取文本"></a>read-从键盘或标准输入中读取文本</h2><ul>
<li><p>简介：</p>
<ul>
<li><p>我们可以使用read以交互的形式读取用户输入，不过read能做的可远不止这些。编程语言的大多数输入库都是从键盘读取输入，当回车键按下的时候，标志着输入完毕。</p>
</li>
<li><p>但有时候是没法按回车键的，输入结束与否是由读取到的字符数或某个特定字符来决定的。例如在交互式游戏中，当按下 + 键时，小球就会向上移动。那么若每次都要按下 + 键，然后再按回车键来确认已经按过 + 键，这就显然太低效了。</p>
</li>
<li><p>read命令提供了一种不需要按回车键就能够搞定这个任务的方法。</p>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><strong>-a</strong></li>
</ul>
</li>
<li><p>后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。</p>
<ul>
<li><p><strong>-d</strong></p>
<ul>
<li>用特定的定界符delim_char作为输入行的结束,结果存入var变量（不包括边界符）：<code>read -d delim_char var</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	$ read -d &quot;:&quot; var</span><br><span class="line">$ hello:</span><br><span class="line">	</span><br><span class="line">	$ echo $var</span><br><span class="line">	&gt; hello</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>后面跟提示信息，即在输入前打印提示信息。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -p &quot;输入网站名:&quot; website</span><br><span class="line">echo &quot;你输入的网站名是 $website&quot; </span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 输入网站名:www.cherish.com</span><br><span class="line">&gt; 你输入的网站名是 www.cherish.com</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
<ul>
<li>在输入的时候可以使用命令补全功能。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;以下实例输入字符 a 后按下 Tab 键就会输出相关的文件名(该目录存在的)：</span><br><span class="line">$ read -e -p &quot;输入文件名:&quot; str</span><br><span class="line">$ 输入文件名:a</span><br><span class="line">a.out    a.py     a.pyc    abc.txt  </span><br><span class="line">&gt; 输入文件名:a</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-n</strong></p>
<ul>
<li>后跟一个数字，定义输入文本的长度，很实用。<br>例如：下面的语句从输入中读取n个字符并存入变量variable_name：<br><code>read -n number_of_chars variable_name</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">read -n 2 -p &quot;请随便输入两个字符: &quot; any</span><br><span class="line">echo &quot;\n您输入的两个字符是:$any&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ 请随便输入两个字符: 12</span><br><span class="line">&gt; 您输入的两个字符是:12</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-s</strong></p>
</li>
<li><p>安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。</p>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li><p>后面跟秒数，定义输入字符的等待时间。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">if read -t 5 -p &quot;输入网站名:&quot; website</span><br><span class="line">then</span><br><span class="line">	echo &quot;你输入的网站名是 $website&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;\n抱歉，你输入超时了。&quot;</span><br><span class="line">fi</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;执行程序不输入，等待 5 秒后：</span><br><span class="line">$ 输入网站名:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>抱歉，你输入超时了</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>-u</strong></p>
<ul>
<li>后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#这里默认会换行  </span><br><span class="line">echo &quot;输入网站名: &quot;  </span><br><span class="line">#读取从键盘的输入  </span><br><span class="line">read website  </span><br><span class="line">echo &quot;你输入的网站名是 $website&quot;  </span><br><span class="line">exit 0  #退出</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;常规用法</span><br><span class="line">$ .&#x2F;testcat.sh</span><br><span class="line">&gt; 输入网站名:</span><br><span class="line">$ www.baidu.com</span><br><span class="line">&gt; 你输入的网站名是 www.baidu.com</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="rm-删除一个文件或者目录"><a href="#rm-删除一个文件或者目录" class="headerlink" title="rm-删除一个文件或者目录"></a>rm-删除一个文件或者目录</h2><ul>
<li><p>简介：</p>
</li>
<li><p>rm [options] filename…</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>Linux rm命令用于删除一个文件或者目录。</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-i</strong></p>
<ul>
<li>删除前逐一询问确认。</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>即使原档案属性设为只读，亦直接删除，无需逐一确认。</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>将目录及以下之档案逐一删除。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除文件可以直接使用rm命令，若删除目录则必须配合选项&quot;-r&quot;</span><br><span class="line">$ rm  test.txt </span><br><span class="line">&#x2F;&#x2F;删除当前目录下的所有文件及目录</span><br><span class="line">$ rm  -r  *</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="rsync——数据远程同步工具"><a href="#rsync——数据远程同步工具" class="headerlink" title="rsync——数据远程同步工具"></a>rsync——数据远程同步工具</h2><ul>
<li><p>简介：</p>
<ul>
<li>rsync命令广泛用于网络文件复制以及备份。</li>
<li>rsync可以在最小化数据传输量同时，同步不同位置上的文件和目录。</li>
<li>相较于cp命令，rsync的优势在于比较文件修改日期，仅复制较新的文件。另外，它还支持远程数据传输以及压缩和加密。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>rsync [选项参数] [源文件路径] [目标文件路径]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>进行归档操作</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>表示在stdout上打印出细节信息或进度</li>
</ul>
</li>
<li><p><strong>-z</strong></p>
<ul>
<li>指定在传输时压缩数据</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>强制rsync以递归方式复制目录中所有的内容</li>
</ul>
</li>
<li><p><strong>–exclude</strong></p>
<ul>
<li>指定不需要传输的文件，可以使用通配符指定需要排除的文件</li>
<li><code>$ rsync -avz /home/code/app /mnt/disk/backup/code --exclude &quot;*.o&quot;</code></li>
</ul>
</li>
<li><p><strong>–exclude-from</strong></p>
<ul>
<li>我们也可以通过一个列表文件指定需要排除的文件</li>
<li><code>$ rsync -avz /home/code/app /mnt/disk/backup/code --exclude-from FILEPATH</code></li>
</ul>
</li>
<li><p><strong>–delete</strong></p>
<ul>
<li>在更新rsync备份时，删除不存在的文件。默认情况下，rsync并不会在目的端删除那些在源端已不存在的文件。如果要删除这类文件，可以使用rsync的–delete选项：</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将源目录（本地路径）复制到目的路径(远程路径)</span><br><span class="line">$ rsync -av &#x2F;home&#x2F;slynux&#x2F;data  slynux@192.168.0.6:&#x2F;home&#x2F;backups&#x2F;data</span><br><span class="line">&#x2F;&#x2F; 上面的命令会以递归的方式将所有的文件从源路径复制到目的路径。源路径和目的路径既可以是远程路径，也可以是本地路径。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以将远程主机上的数据恢复到本地</span><br><span class="line">$ rsync -av slynux@192.168.0.6:&#x2F;home&#x2F;backups&#x2F;data &#x2F;home&#x2F;slynux&#x2F;data</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将一个目录中的内容同步到另一个目录，这条命令将源目录（&#x2F;home&#x2F;test）中的内容（不包括目录本身）复制到现有的backups目录中。</span><br><span class="line">$  rsync -av &#x2F;home&#x2F;test&#x2F; &#x2F;home&#x2F;backups</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将包括目录本身在内的内容复制到另一个目录中，将包括源目录本身（&#x2F;home&#x2F;test）在内的内容复制到新的backups目录中</span><br><span class="line">$ rsync -av &#x2F;home&#x2F;test &#x2F;home&#x2F;backups</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>rsync命令用SSH连接远程主机，因此必须使用username<a href="https://my.oschina.net/u/116016" target="_blank" rel="noopener">@host</a>:PATH 这种形式设定远程主机的地址，其中user代表用户名，host代表远程主机的IP地址或主机名。而PATH指定了远程主机中待复制数据所在的路径。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="S"><a href="#S" class="headerlink" title="S"></a>S</h1><h2 id="scp——安全复制工具"><a href="#scp——安全复制工具" class="headerlink" title="scp——安全复制工具"></a>scp——安全复制工具</h2><ul>
<li><p>简介：</p>
<ul>
<li>SCP是一个安全的文件复制命令，和旧式的、不安全的远程复制命令rcp类似。文件均通过SSH加密通道进行传输。</li>
<li>因为是基于ssh，远程地址格式同样为<code>username@host:/path</code></li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>scp [选项参数] [源文件路径] [目标文件路径]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-oPort=PORTNO</strong></p>
<ul>
<li>SSH服务器有时候并不在默认的端口22上运行。如果它在其他端口运行，我们可以在scp中用选项-oPort=PORTNO来指定端口号。</li>
</ul>
</li>
<li><p><strong>-1</strong></p>
<ul>
<li>强制scp命令使用协议ssh1</li>
</ul>
</li>
<li><p><strong>-2</strong></p>
<ul>
<li>强制scp命令使用协议ssh2</li>
</ul>
</li>
<li><p><strong>-4</strong></p>
<ul>
<li>强制scp命令只使用IPv4寻址</li>
</ul>
</li>
<li><p><strong>-6</strong></p>
<ul>
<li>强制scp命令只使用IPv6寻址</li>
</ul>
</li>
<li><p><strong>-B</strong></p>
<ul>
<li>使用批处理模式（传输过程中不询问传输口令或短语）</li>
</ul>
</li>
<li><p><strong>-C</strong></p>
<ul>
<li>允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>保留原文件的修改时间，访问时间和访问权限。</li>
</ul>
</li>
<li><p><strong>-q</strong></p>
<ul>
<li>不显示传输进度条。</li>
</ul>
</li>
<li><p><strong>-r</strong></p>
<ul>
<li>递归复制整个目录。</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</li>
</ul>
</li>
<li><p><strong>-c cipher</strong></p>
<ul>
<li>以cipher将数据传输进行加密，这个选项将直接传递给ssh。</li>
</ul>
</li>
<li><p><strong>-F ssh_config</strong></p>
<ul>
<li>指定一个替代的ssh配置文件，此参数直接传递给ssh。</li>
</ul>
</li>
<li><p><strong>-i identity_file</strong></p>
<ul>
<li>从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</li>
</ul>
</li>
<li><p><strong>-l limit</strong></p>
<ul>
<li>限定用户所能使用的带宽，以Kbit/s为单位。</li>
</ul>
</li>
<li><p><strong>-o ssh_option</strong></p>
<ul>
<li>如果习惯于使用ssh_config(5)中的参数传递方式，</li>
</ul>
</li>
<li><p><strong>-P port</strong></p>
<ul>
<li>注意是大写的P, port是指定数据传输用到的端口号</li>
</ul>
</li>
<li><p><strong>-S program</strong></p>
<ul>
<li>指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将远程主机中的文件复制到当前目录并使用给定的文件名</span><br><span class="line">$ scp user@remotehost:&#x2F;home&#x2F;path&#x2F;filename filename</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="sed——对文本进行编辑"><a href="#sed——对文本进行编辑" class="headerlink" title="sed——对文本进行编辑"></a>sed——对文本进行编辑</h2><ul>
<li><p>简介：</p>
</li>
<li><p>sed是stream editor（流编辑器）的缩写。sed 可依照脚本的指令来处理、编辑文本文件。主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>sed [选项参数][文本文件]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-e<action>或–expression=<action></strong></p>
<ul>
<li><p>以选项中指定的action动作来处理输入的文本文件。-e可省略，sed默认为该模式</p>
</li>
<li><p>action动作包括：</p>
<ul>
<li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li>
<li>c ：取代行， c 的后面可以接字串，这些字串可以取代指定的行！</li>
<li>d ：删除，因为是删除啊，所以 d 后面通常不接任何字符</li>
<li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li>
<li>s ：取代部分数据，可以直接进行取代的工作！通常s的动作可以搭配正规表示法！例如 1,20s/old/new/g</li>
</ul>
<blockquote>
<p>注意动作符号后面，需要使用\符号分隔开动作与字符</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>-f&lt;script文件&gt;或–file=&lt;script文件&gt;</strong></p>
</li>
<li><p>以选项中指定的script文件(文件内容为action)来处理输入的文本文件。</p>
</li>
</ul>
</li>
<li><p><strong>-h或–help</strong></p>
<ul>
<li><p>显示帮助。</p>
</li>
<li><p><strong>-n或–quiet或–silent</strong></p>
</li>
<li><p>仅显示script处理后的结果。</p>
</li>
<li><p><strong>-V或–version</strong></p>
<ul>
<li>显示版本信息。</li>
</ul>
</li>
<li><p><strong>-i</strong></p>
<ul>
<li>in place的意思，在参数为文件时，选项-i会使得sed用修改后的数据替换原始文件，相当于直接修改文件<br><code>$ sed -i &#39;s/text/replace/&#39; file</code><br>直接修改文件十分危险，我们可以使用如下命令，这时的sed不仅替换文件内容，还会创建一个名为file.bak的文件，其中包含着原始文件内容的副本。<br><code>sed -i.bak &#39;s/text/replace/&#39; file</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
<ul>
<li><p>a 添加</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在testfile文件的第一行后添加一行，并将结果输出到标准输出</span><br><span class="line">$ cat testfile #查看testfile 中的内容  </span><br><span class="line">&gt; HELLO LINUX!  </span><br><span class="line">&gt; Linux is a free unix-type opterating system.</span><br><span class="line"></span><br><span class="line">$ sed -e 1a\newLine testfile </span><br><span class="line">或</span><br><span class="line">$ sed -e &#39;1a newLine&#39; testfile </span><br><span class="line">&gt; HELLO LINUX! #testfile文件原有的内容  </span><br><span class="line">&gt; newline </span><br><span class="line">&gt; Linux is a free unix-type opterating system.</span><br></pre></td></tr></table></figure>
</li>
<li><p>d 添加</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出，同时，请将第 2~5 行删除！(nl命令，给文本内容添加行号)</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;2,5d&#39;</span><br><span class="line">&gt; 1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; 6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">&gt; 7 shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown</span><br><span class="line">&gt; .....(后面省略).....</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出，同时，请将第 2 行删除！</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;2d&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出，同时，要删除第 3 到最后一行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;3,$d&#39; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 &#x2F;etc&#x2F;passwd 的内容列出,要在第二行前加上drink tea</span><br><span class="line">$ cat &#x2F;etc&#x2F;passwd | sed &#39;2i drink tea&#39; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除&#x2F;etc&#x2F;passwd所有包含root的行，其他行输出</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed  &#39;&#x2F;root&#x2F;d&#39;</span><br><span class="line">&gt; 2  daemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; 3  bin:x:2:2:bin:&#x2F;bin:&#x2F;bin&#x2F;sh</span><br><span class="line">&gt; ....下面忽略,第一行的匹配root已经删除了</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除空行</span><br><span class="line">$ sed &#39;&#x2F;^$&#x2F;d&#39; file</span><br></pre></td></tr></table></figure>
</li>
<li><p>c 替换</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将第2-5行的内容取代成为No 2-5 number</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed &#39;2,5c No 2-5 number&#39;</span><br><span class="line">&gt; 1 root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">&gt; No 2-5 number</span><br><span class="line">&gt; 6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">&gt; .....(后面省略).....</span><br></pre></td></tr></table></figure></li>
<li><p>p 打印</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;仅列出 &#x2F;etc&#x2F;passwd 文件内的第 5-7 行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed -n &#39;5,7p&#39;</span><br><span class="line">&gt; 5 lp:x:4:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;sbin&#x2F;nologin</span><br><span class="line">&gt; 6 sync:x:5:0:sync:&#x2F;sbin:&#x2F;bin&#x2F;sync</span><br><span class="line">&gt; 7 shutdown:x:6:0:shutdown:&#x2F;sbin:&#x2F;sbin&#x2F;shutdown</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;搜索 &#x2F;etc&#x2F;passwd有root关键字的行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed -n &#39;&#x2F;root&#x2F;p&#39;</span><br><span class="line">&gt; 1  root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li>
<li><p>s 取代（语法：<code>sed &#39;s/正则表达式/新的字串/&#39;</code>）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;替换第一个出现的this</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;&#39;</span><br><span class="line">&gt; THISthisthisthis</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;g标记可以使sed执行全局替换。</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;g&#39;</span><br><span class="line">&gt; THISTHISTHISTHIS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;#g标记可以使sed替换第N次起出现的匹配</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;2g&#39;</span><br><span class="line">&gt; thisTHISTHISTHIS</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;3g&#39;</span><br><span class="line">&gt; thisthisTHISTHIS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;g标记可以使sed执行全局替换。</span><br><span class="line">$ echo thisthisthisthis | sed &#39;s&#x2F;this&#x2F;THIS&#x2F;g&#39;</span><br><span class="line">&gt; THISTHISTHISTHIS</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;搜索&#x2F;etc&#x2F;passwd,找到root对应的行，执行后面花括号中的一组命令。</span><br><span class="line">&#x2F;&#x2F;每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行</span><br><span class="line">$ nl &#x2F;etc&#x2F;passwd | sed -n &#39;&#x2F;root&#x2F;&#123;s&#x2F;bash&#x2F;blueshell&#x2F;;p;q&#125;&#39; #s为替换，p为打印，最后的q是退出。</span><br><span class="line">&gt; 1  root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;blueshell</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sed命令会将s之后的字符视为命令分隔符。这允许我们更改默认的分隔符&#x2F;：</span><br><span class="line">$ sed &#39;s:text:replace:g&#39; #此时分隔符是：</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果作为分隔符的字符出现在模式中，必须使用\对其进行转义。\|是出现在模式中被转义的分隔符</span><br><span class="line">$ sed &#39;s|te\|xt|replace|g&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在sed中，我们可以用&amp;指代模式所匹配到的字符串，这样就能够在替换字符串时使用已匹配的内容</span><br><span class="line">&#x2F;&#x2F;在这个例子中，正则表达式\w\+匹配每一个单词，然后我们用[&amp;]替换它。&amp;对应于之前所匹配到的单词。</span><br><span class="line">$ echo this is an example | sed &#39;s&#x2F;\w\+&#x2F;[&amp;]&#x2F;g&#39;</span><br><span class="line">&gt; [this] [is] [an] [example]</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>注意事项</p>
<blockquote>
<p>可以利用管道组合多个sed命令，多个模式之间可以用分号分隔，或是使用选项-e PATTERN ;如下命令都是等价的：<br><code>sed &#39;expression&#39; | sed &#39;expression&#39;</code><br><code>sed &#39;expression; expression&#39;</code><br><code>sed -e &#39;expression&#39; -e &#39;expression&#39;</code></p>
</blockquote>
<blockquote>
<p>如果想在sed表达式中使用变量，双引号就能派上用场了。<br>$ text=hello<br>$ echo hello world | sed “s/$text/HELLO/“<br>HELLO world</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="set-调试执行命令"><a href="#set-调试执行命令" class="headerlink" title="set-调试执行命令"></a>set-调试执行命令</h2><ul>
<li><p>简介：</p>
</li>
<li><p>set命令能设置所使用shell的执行方式，可依照不同的需求来做设置。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>set [+-abCdefhHklmnpPtuvx]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a</strong></p>
<ul>
<li>　标示已修改的变量，以供输出至环境变量。</li>
</ul>
</li>
<li><p><strong>-b</strong></p>
<ul>
<li>　使被中止的后台程序立刻回报执行状态。</li>
</ul>
</li>
<li><p><strong>-C</strong></p>
<ul>
<li>　转向所产生的文件无法覆盖已存在的文件。</li>
</ul>
</li>
<li><p><strong>-d</strong></p>
<ul>
<li>　Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。</li>
</ul>
</li>
<li><p><strong>-e</strong></p>
<ul>
<li>　若指令传回值不等于0，则立即退出shell。</li>
</ul>
</li>
<li><p><strong>-f</strong></p>
<ul>
<li>　取消使用通配符。</li>
</ul>
</li>
<li><p><strong>-h</strong></p>
<ul>
<li>　自动记录函数的所在位置。</li>
</ul>
</li>
<li><p><strong>-k</strong></p>
<ul>
<li>　指令所给的参数都会被视为此指令的环境变量。</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>　记录for循环的变量名称。</li>
</ul>
</li>
<li><p><strong>-m</strong></p>
<ul>
<li>　使用监视模式。</li>
</ul>
</li>
<li><p><strong>-n</strong></p>
<ul>
<li>　只读取指令，而不实际执行。</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>　启动优先顺序模式。</li>
</ul>
</li>
<li><p><strong>-P</strong></p>
<ul>
<li>　启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>　执行完随后的指令，即退出shell。</li>
</ul>
</li>
<li><p><strong>-u</strong></p>
<ul>
<li>　当执行时使用到未定义过的变量，则显示错误信息。</li>
</ul>
</li>
<li><p><strong>-v</strong></p>
<ul>
<li>　显示shell所读取的输入值。</li>
</ul>
</li>
<li><p><strong>-x</strong></p>
<ul>
<li>　执行指令后，会先显示该指令及参数。</li>
</ul>
</li>
<li><p><strong>+&lt;参数&gt;</strong></p>
<ul>
<li>　取消某个set曾启动的参数。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>+&lt;参数&gt;:取消某个set曾启动的参数。</p>
</blockquote>
<blockquote>
<p>set命令不带任何参数时，为打印所有环境变量</p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;执行指令后，会先显示该指令及参数。</span><br><span class="line">$ #!&#x2F;bin&#x2F;bash </span><br><span class="line">- #文件名: debug.sh </span><br><span class="line">- for i in &#123;1..2&#125;; </span><br><span class="line">- do</span><br></pre></td></tr></table></figure>
<ul>
<li><p>set -x </p>
</li>
<li><p>echo $i </p>
<ul>
<li>set +x </li>
<li>done </li>
</ul>
<blockquote>
<ul>
<li>echo 1<br>1</li>
<li>set +x</li>
<li>echo 2<br>2</li>
<li>set +x</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">	</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统"><a href="#sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统" class="headerlink" title="sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统"></a>sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统</h2><ul>
<li><p>简介：</p>
<ul>
<li>它不需要远端运行FTP服务器来进行文件传输，但必须要有SSH服务器。sftp是一个交互式命令，提供了命令提示符。</li>
<li>sftp支持与ftp和lftp相同的命令。不赘述。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>xxxxxxxxxxxxxxxxx</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><strong>-oPort=PORTNO</strong><ul>
<li>SSH服务器有时候并不在默认的端口22上运行。如果它在其他端口运行，我们可以在sftp中用选项-oPort=PORTNO来指定端口号。  </li>
<li><code>$ sftp -oPort=422 user@slynux.org</code></li>
<li>-oPort应该作为sftp命令的第一个参数。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动sftp会话</span><br><span class="line">$ sftp user@domainname</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h2 id="sleep-命令延迟一段时间执行。"><a href="#sleep-命令延迟一段时间执行。" class="headerlink" title="sleep-命令延迟一段时间执行。"></a>sleep-命令延迟一段时间执行。</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux sleep命令可以用来将目前动作延迟一段时间。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>sleep [--help] [--version] number[smhd]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>–help</strong></p>
<ul>
<li>显示辅助讯息</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本编号</li>
</ul>
</li>
<li><p><strong>number</strong></p>
<ul>
<li>时间长度，后面可接 s、m、h 或 d。其中 s 为秒，m 为 分钟，h 为小时，d 为日数</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示目前时间后延迟 1 分钟，之后再次显示时间</span><br><span class="line">$ date;sleep 1m;date</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="ssh——远程连接工具"><a href="#ssh——远程连接工具" class="headerlink" title="ssh——远程连接工具"></a>ssh——远程连接工具</h2><ul>
<li><p>简介：</p>
<ul>
<li>SSH代表的是Secure Shell（安全shell）。它使用加密隧道连接两台计算机。</li>
<li>SSH能够让你访问远程计算机上的shell，从而在其上执行交互命令并接收结果，或是启动交互会话。</li>
<li>GNU/Linux发布版中默认并不包含SSH，需要使用软件包管理器安装openssh-server和openssh-client。SSH服务默认运行在端口22之上。</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>ssh [选项参数] [user@]hostname] [command]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-p  &lt;端口号&gt;</strong></p>
<ul>
<li>SSH服务器默认在端口22上运行。但有些SSH服务器并没有使用这个端口。针对这种情况，可以用ssh命令的-p &lt;端口号&gt;来指定端口</li>
<li><code>ssh user@locahost -p 422</code></li>
</ul>
</li>
<li><p><strong>- -C</strong></p>
<ul>
<li>SSH协议也支持对数据进行压缩传输。当带宽有限时，这一功能很方便。</li>
<li><code>ssh -C user@hostname COMMANDS</code></li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;连接运行了SSH服务器的远程主机</span><br><span class="line">$  ssh mec@192.168.0.1</span><br><span class="line">&#x2F;&#x2F;mec是远程主机上的用户,192.168.0.1是IP地址,这里也可以是域名</span><br><span class="line">&#x2F;&#x2F;SSH会询问用户密码，一旦认证成功，就会连接到远程主机上的登录shell</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在远程执行命令whoami</span><br><span class="line">$ ssh mec@192.168.0.1 &#39;whoami&#39;</span><br><span class="line">&gt; mec</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以输入多条命令，命令之间用分号分隔</span><br><span class="line">$ ssh mec@192.168.0.1 &quot;echo user: $(whoami);echo OS: $(uname)&quot;</span><br><span class="line">&gt; user: mec </span><br><span class="line">&gt; OS: Linux</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将数据重定向至远程shell命令的stdin</span><br><span class="line">$  echo &#39;text&#39; | ssh user@remote_host &#39;echo&#39;</span><br><span class="line">&gt; text</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将本地主机上的tar存档文件传给远程主机</span><br><span class="line">$ &gt; tar -czf - LOCALFOLDER | ssh &#39;tar -xzvf-&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>
<h1 id="T"><a href="#T" class="headerlink" title="T"></a>T</h1><h2 id="tar——归档或者压缩，解压文件"><a href="#tar——归档或者压缩，解压文件" class="headerlink" title="tar——归档或者压缩，解压文件"></a>tar——归档或者压缩，解压文件</h2><ul>
<li><p>简介：</p>
</li>
<li><p>tar命令可以归档文件。它最初是设计用来将数据存储在磁带上，因此其名字也来源于TapeARchive。tar可以将多个文件和文件夹打包为单个文件，同时还能保留所有的文件属性，如所有者、权限等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>tar [选项参数]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-A或–catenate</strong></p>
<ul>
<li>新增文件到已存在的备份文件。</li>
</ul>
</li>
<li><p><strong>-b&lt;区块数目&gt;或–blocking-factor=&lt;区块数目&gt;</strong></p>
<ul>
<li>设置每笔记录的区块数目，每个区块大小为12Bytes。</li>
</ul>
</li>
<li><p><strong>-B或–read-full-records</strong></p>
<ul>
<li>读取数据时重设区块大小。</li>
</ul>
</li>
<li><p><strong>-c或–create</strong></p>
<ul>
<li>建立新的备份文件。</li>
</ul>
</li>
<li><p><strong>-C&lt;目的目录&gt;或–directory=&lt;目的目录&gt;</strong></p>
<ul>
<li>切换到指定的目录。</li>
</ul>
</li>
<li><p><strong>-d或–diff或–compare</strong></p>
<ul>
<li>对比备份文件内和文件系统上的文件的差异。</li>
</ul>
</li>
<li><p><strong>-f&lt;备份文件&gt;或–file=&lt;备份文件&gt;</strong></p>
<ul>
<li>指定备份文件。</li>
</ul>
</li>
<li><p><strong>-F&lt;Script文件&gt;或–info-script=&lt;Script文件&gt;</strong></p>
<ul>
<li>每次更换磁带时，就执行指定的Script文件。</li>
</ul>
</li>
<li><p><strong>-g或–listed-incremental</strong></p>
<ul>
<li>处理GNU格式的大量备份。</li>
</ul>
</li>
<li><p><strong>-G或–incremental</strong></p>
<ul>
<li>处理旧的GNU格式的大量备份。</li>
</ul>
</li>
<li><p><strong>-h或–dereference</strong></p>
<ul>
<li>不建立符号连接，直接复制该连接所指向的原始文件。</li>
</ul>
</li>
<li><p><strong>-i或–ignore-zeros</strong></p>
<ul>
<li>忽略备份文件中的0 Byte区块，也就是EOF。</li>
</ul>
</li>
<li><p><strong>-k或–keep-old-files</strong></p>
<ul>
<li>解开备份文件时，不覆盖已有的文件。</li>
</ul>
</li>
<li><p><strong>-K&lt;文件&gt;或–starting-file=&lt;文件&gt;</strong></p>
<ul>
<li>从指定的文件开始还原。</li>
</ul>
</li>
<li><p><strong>-l或–one-file-system</strong></p>
<ul>
<li>复制的文件或目录存放的文件系统，必须与tar指令执行时所处的文件系统相同，否则不予复制。</li>
</ul>
</li>
<li><p><strong>-m或–modification-time</strong></p>
<ul>
<li>还原文件时，不变更文件的更改时间。</li>
</ul>
</li>
<li><p><strong>-M或–multi-volume</strong></p>
<ul>
<li>在建立，还原备份文件或列出其中的内容时，采用多卷册模式。</li>
</ul>
</li>
<li><p><strong>-N&lt;日期格式&gt;或–newer=&lt;日期时间&gt;</strong></p>
<ul>
<li>只将较指定日期更新的文件保存到备份文件里。</li>
</ul>
</li>
<li><p><strong>-o或–old-archive或–portability</strong></p>
<ul>
<li>将资料写入备份文件时使用V7格式。</li>
</ul>
</li>
<li><p><strong>-O或–stdout</strong></p>
<ul>
<li>把从备份文件里还原的文件输出到标准输出设备。</li>
</ul>
</li>
<li><p><strong>-p或–same-permissions</strong></p>
<ul>
<li>用原来的文件权限还原文件。</li>
</ul>
</li>
<li><p><strong>-P或–absolute-names</strong></p>
<ul>
<li>文件名使用绝对名称，不移除文件名称前的”/“号。</li>
</ul>
</li>
<li><p><strong>-r或–append</strong></p>
<ul>
<li>新增文件到已存在的备份文件的结尾部分。</li>
</ul>
</li>
<li><p><strong>-R或–block-number</strong></p>
<ul>
<li>列出每个信息在备份文件中的区块编号。</li>
</ul>
</li>
<li><p><strong>-s或–same-order</strong></p>
<ul>
<li>还原文件的顺序和备份文件内的存放顺序相同。</li>
</ul>
</li>
<li><p><strong>-S或–sparse</strong></p>
<ul>
<li>倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。</li>
</ul>
</li>
<li><p><strong>-t或–list</strong></p>
<ul>
<li>列出备份文件的内容。</li>
</ul>
</li>
<li><p><strong>-T&lt;范本文件&gt;或–files-from=&lt;范本文件&gt;</strong></p>
<ul>
<li>指定范本文件，其内含有一个或多个范本样式，让tar解开或建立符合设置条件的文件。</li>
</ul>
</li>
<li><p><strong>-u或–update</strong></p>
<ul>
<li><p>仅置换较备份文件内的文件更新的文件。追加选项（-r）可以将指定的任意文件加入到归档文件中。如果同名文件已经存在，那么归档文件中就会包含两个名字一样的文件。我们可以用更新选项-u指明：只添加比归档文件中的同<br>名文件更新（newer）的文件。</p>
</li>
<li><p><code>$ tar -uf archive.tar filea</code>  #如果两个filea的时间戳相同，则什么都不会发生。</p>
</li>
</ul>
</li>
<li><p><strong>-U或–unlink-first</strong></p>
<ul>
<li>解开压缩文件还原文件之前，先解除文件的连接。</li>
</ul>
</li>
<li><p><strong>-v或–verbose</strong></p>
<ul>
<li>显示指令执行过程。</li>
</ul>
</li>
<li><p><strong>-V&lt;卷册名称&gt;或–label=&lt;卷册名称&gt;</strong></p>
<ul>
<li>建立使用指定的卷册名称的备份文件。</li>
</ul>
</li>
<li><p><strong>-w或–interactive</strong></p>
<ul>
<li>遭遇问题时先询问用户。</li>
</ul>
</li>
<li><p><strong>-W或–verify</strong></p>
<ul>
<li>写入备份文件后，确认文件正确无误。</li>
</ul>
</li>
<li><p><strong>-x或–extract或–get</strong></p>
<ul>
<li>从备份文件中还原文件。</li>
</ul>
</li>
<li><p><strong>-X&lt;范本文件&gt;或–exclude-from=&lt;范本文件&gt;</strong></p>
<ul>
<li>指定范本文件，其内含有一个或多个范本样式，让ar排除符合设置条件的文件。</li>
</ul>
</li>
<li><p><strong>-z或–gzip或–ungzip</strong></p>
<ul>
<li>通过gzip指令处理备份文件。</li>
</ul>
</li>
<li><p><strong>-Z或–compress或–uncompress</strong></p>
<ul>
<li>通过compress指令处理备份文件。</li>
</ul>
</li>
<li><p><strong>-&lt;设备编号&gt;&lt;存储密度&gt;</strong></p>
<ul>
<li>设置备份用的外围设备编号及存放数据的密度。</li>
</ul>
</li>
<li><p><strong>–after-date=&lt;日期时间&gt;</strong></p>
<ul>
<li>此参数的效果和指定”-N”参数相同。</li>
</ul>
</li>
<li><p><strong>–atime-preserve</strong></p>
<ul>
<li>不变更文件的存取时间。</li>
</ul>
</li>
<li><p><strong>–backup=&lt;备份方式&gt;或–backup</strong></p>
<ul>
<li>移除文件前先进行备份。</li>
</ul>
</li>
<li><p><strong>–checkpoint</strong></p>
<ul>
<li>读取备份文件时列出目录名称。</li>
</ul>
</li>
<li><p><strong>–concatenate</strong></p>
<ul>
<li>此参数的效果和指定”-A”参数相同。</li>
</ul>
</li>
<li><p><strong>–confirmation</strong></p>
<ul>
<li>此参数的效果和指定”-w”参数相同。</li>
</ul>
</li>
<li><p><strong>–delete</strong></p>
<ul>
<li>从备份文件中删除指定的文件。</li>
</ul>
</li>
<li><p><strong>–exclude=&lt;范本样式&gt;</strong></p>
<ul>
<li>排除符合范本样式的文件。</li>
</ul>
</li>
<li><p><strong>–group=&lt;群组名称&gt;</strong></p>
<ul>
<li>把加入设备文件中的文件的所属群组设成指定的群组。</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>在线帮助。</li>
</ul>
</li>
<li><p><strong>–ignore-failed-read</strong></p>
<ul>
<li>忽略数据读取错误，不中断程序的执行。</li>
</ul>
</li>
<li><p><strong>–new-volume-script=&lt;Script文件&gt;</strong></p>
<ul>
<li>此参数的效果和指定”-F”参数相同。</li>
</ul>
</li>
<li><p><strong>–newer-mtime</strong></p>
<ul>
<li>只保存更改过的文件。</li>
</ul>
</li>
<li><p><strong>–no-recursion</strong></p>
<ul>
<li>不做递归处理，也就是指定目录下的所有文件及子目录不予处理。</li>
</ul>
</li>
<li><p><strong>–null</strong></p>
<ul>
<li>从null设备读取文件名称。</li>
</ul>
</li>
<li><p><strong>–numeric-owner</strong></p>
<ul>
<li>以用户识别码及群组识别码取代用户名称和群组名称。</li>
</ul>
</li>
<li><p><strong>–owner=&lt;用户名称&gt;</strong></p>
<ul>
<li>把加入备份文件中的文件的拥有者设成指定的用户。</li>
</ul>
</li>
<li><p><strong>–posix</strong></p>
<ul>
<li>将数据写入备份文件时使用POSIX格式。</li>
</ul>
</li>
<li><p><strong>–preserve</strong></p>
<ul>
<li>此参数的效果和指定”-ps”参数相同。</li>
</ul>
</li>
<li><p><strong>–preserve-order</strong></p>
<ul>
<li>此参数的效果和指定”-A”参数相同。</li>
</ul>
</li>
<li><p><strong>–preserve-permissions</strong></p>
<ul>
<li>此参数的效果和指定”-p”参数相同。</li>
</ul>
</li>
<li><p><strong>–record-size=&lt;区块数目&gt;</strong></p>
<ul>
<li>此参数的效果和指定”-b”参数相同。</li>
</ul>
</li>
<li><p><strong>–recursive-unlink</strong></p>
<ul>
<li>解开压缩文件还原目录之前，先解除整个目录下所有文件的连接。</li>
</ul>
</li>
<li><p><strong>–remove-files</strong></p>
<ul>
<li>文件加入备份文件后，就将其删除。</li>
</ul>
</li>
<li><p><strong>–rsh-command=&lt;执行指令&gt;</strong></p>
<ul>
<li>设置要在远端主机上执行的指令，以取代rsh指令。</li>
</ul>
</li>
<li><p><strong>–same-owner</strong></p>
<ul>
<li>尝试以相同的文件拥有者还原文件。</li>
</ul>
</li>
<li><p><strong>–suffix=&lt;备份字尾字符串&gt;</strong></p>
<ul>
<li>移除文件前先行备份。</li>
</ul>
</li>
<li><p><strong>–totals</strong></p>
<ul>
<li>备份文件建立后，列出文件大小。</li>
</ul>
</li>
<li><p><strong>–use-compress-program=&lt;执行指令&gt;</strong></p>
<ul>
<li>通过指定的指令处理备份文件。</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示版本信息。</li>
</ul>
</li>
<li><p><strong>–volno-file=&lt;编号文件&gt;</strong></p>
<ul>
<li>使用指定文件内的编号取代预设的卷册编号。</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
<blockquote>
<p>tar命令默认只归档文件，并不对其进行压缩。不过tar支持用于压缩的相关选项。我们日常理解的tar能压缩，其实都并非其命令的本意。压缩能够显著减少文件的体积。<br>归档文件通常被压缩成下列格式之一。<br>gzip格式：file.tar.gz或file.tgz。<br>bzip2格式：file.tar.bz2。<br>Lempel-Ziv-Markov格式：file.tar.lzma。  </p>
</blockquote>
<blockquote>
<p>不同的tar选项可以用来指定不同的压缩格式<br> -j 指定bunzip2格式；<br> -z 指定gzip格式；<br> –lzma 指定lzma格式。  </p>
</blockquote>
<blockquote>
<p>不明确指定上面那些特定的选项也可以使用压缩功能。tar能够基于输出或输入文件的扩展名来进行压缩。为了让tar支持根据扩展名自动选择压缩算法，使用-a或–auto-compress选项<br> <code>$ tar -acvf archive.tar.gz filea fileb filec</code></p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;归档文件，选项-c表示创建新的归档文件。选项-f表示归档文件名，该选项后面必须跟一个或多个文件</span><br><span class="line">$ tar -cf output.tar file</span><br><span class="line">$ $ tar -cf archive.tar file1 file2 file3 folder1 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出归档文件内容</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">&gt; file1 </span><br><span class="line">&gt; file2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;列出压缩文件内容,而且还要展示更多的细节，使用v选项表示冗长模式，vv为非常冗长模式；</span><br><span class="line">$ tar -tvf archive.tar</span><br><span class="line">&gt; -rw-rw-r-- shaan&#x2F;shaan 0 2013-04-08 21:34 file1 </span><br><span class="line">&gt; -rw-rw-r-- shaan&#x2F;shaan 0 2013-04-08 21:34 file2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向归档文件中追加文件,选项-r可以将新文件追加到已有的归档文件末尾</span><br><span class="line">$ tar -tf archive.tar</span><br><span class="line">&gt; hello.txt </span><br><span class="line">$ tar -rf archive.tar world.txt </span><br><span class="line">$ tar -tf archive.tar </span><br><span class="line">&gt; hello.txt </span><br><span class="line">&gt; world.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提取文件，-x可以将归档文件的内容提取到当前目录</span><br><span class="line">$ tar -xf archive.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解压文件</span><br><span class="line">$ tar -xzf archive.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们也可以用选项-C来指定将文件提取到哪个目录：</span><br><span class="line">$ tar -xf archive.tar -C &#x2F;path&#x2F;to&#x2F;extraction_directory</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;上述命令将归档文件的内容提取到指定目录中。它提取的是归档文件中的全部内容。</span><br><span class="line">&#x2F;&#x2F;我们可以通过将文件名作为命令行参数来提取特定的文件，下述命令只提取file1和file4，忽略其他文件</span><br><span class="line">$ tar -xvf file.tar file1 file4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在归档时，我们可以将stdout指定为输出文件，这样另一个命令就可以通过管道来读取（作为stdin）并进行其他处理。</span><br><span class="line">&#x2F;&#x2F;当通过安全shell（Secure Shell，SSH）传输数据时，这招很管用。</span><br><span class="line">$ tar cvf - files&#x2F; | ssh user@example.com &quot;tar xv -C Documents&#x2F;&quot;</span><br><span class="line">&#x2F;&#x2F;在上面的例子中，对files目录中的内容进行了归档并将其输出到stdout（由-指明），然后提取到远程系统中的Documents目录中。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们可以用选项-A合并多个tar文件。</span><br><span class="line">&#x2F;&#x2F;假设我们现在有两个tar文件：file1.tar和file2.tar。下面的命令可以将file2.tar的内容合并到file1.tar中</span><br><span class="line">$ tar -Af file1.tar file2.tar</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从归档中删除文件</span><br><span class="line">$ tar -f archive.tar --delete file1 file2</span><br><span class="line">或</span><br><span class="line">$ tar --delete --file archive.tar [FILE LIST]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在归档过程中排除部分文件</span><br><span class="line">&#x2F;&#x2F;选项--exclude [PATTERN]可以将匹配通配符模式的文件排除在归档过程之外。例如，排除所有的.txt文件</span><br><span class="line">&#x2F;&#x2F;注意，模式应该使用双引号来引用，避免shell对其进行扩展。</span><br><span class="line">$ tar -cf arch.tar * --exclude &quot;*.txt&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以配合选项-X将需要排除的文件列表放入文件中</span><br><span class="line">$ cat list </span><br><span class="line">&gt; filea </span><br><span class="line">&gt; fileb</span><br><span class="line">$ tar -cf arch.tar * -X list</span><br><span class="line">&#x2F;&#x2F;这样就把filea和fileb排除了。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="tail–打印文件尾部内容"><a href="#tail–打印文件尾部内容" class="headerlink" title="tail–打印文件尾部内容"></a>tail–打印文件尾部内容</h2><ul>
<li><p>简介：</p>
</li>
<li><p>tail命令用于输入文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行。如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题。<strong>如果没有指定文件或者文件名为“-”，则读取标准输入。</strong></p>
</li>
<li><p>语法：</p>
<ul>
<li><code>tail [选项][参数]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>–retry</strong></p>
<ul>
<li>即是在tail命令启动时，文件不可访问或者文件稍后变得不可访问，都始终尝试打开文件。使用此选项时需要与选项“——follow=name”连用；</li>
</ul>
</li>
<li><p><strong>-c <N>或–bytes=N</strong></p>
<ul>
<li>输出文件尾部的N（N为整数）个字节内容；N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。N值后面可以有后缀：b表示512，k表示1024，m表示1 048576(1M)。</li>
</ul>
</li>
<li><p><strong>-f &lt;name/descriptor&gt;或；–follow &lt;name/descript&gt;</strong></p>
<ul>
<li>显示文件最新追加的内容。“name”表示以文件名的方式监视文件的变化。“-f”与“-fdescriptor”等效；</li>
</ul>
</li>
<li><p><strong>-F</strong></p>
<ul>
<li>与选项“-follow=name”和“–retry”连用时功能相同；</li>
</ul>
</li>
<li><p><strong>-n<N>或–line=N</strong></p>
<ul>
<li>输出文件的尾部N（N位数字）行内容。N值之前有一个”+”号，则从文件开头的第N项开始显示，而不是显示文件的最后N项。</li>
</ul>
</li>
<li><p><strong>–pid=&lt;进程号&gt;</strong></p>
<ul>
<li>与“-f”选项连用，当指定的进程号的进程终止后，自动退出tail命令；</li>
</ul>
</li>
<li><p><strong>-q或–quiet或–silent</strong></p>
<ul>
<li>当有多个文件参数时，不输出各个文件名；</li>
</ul>
</li>
<li><p><strong>-s&lt;秒数&gt;或–sleep-interal=&lt;秒数&gt;</strong></p>
<ul>
<li>与“-f”选项连用，指定监视文件变化时间隔的秒数；</li>
</ul>
</li>
<li><p><strong>-v或–verbose</strong></p>
<ul>
<li>当有多个文件参数时，总是输出各个文件名；</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示指令的帮助信息；</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示指令的版本信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;显示文件file的最后10行</span><br><span class="line">$ tail file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示文件file的内容，从第20行至文件末尾</span><br><span class="line">$ tail +20 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;显示文件file的最后10个字符</span><br><span class="line">$ tail -c 10 file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实时查看file追加的内容</span><br><span class="line">$ tail -f file</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;间隔五秒刷新file追加的内容</span><br><span class="line">$ tail -f -s 5 file</span><br></pre></td></tr></table></figure>
<p>  <img src="https://oscimg.oschina.net/oscnet/4d13470cc8c44cb148b7e75722332757ea9.jpg" alt=""></p>
</li>
</ul>
<hr>
<h2 id="time-量测命令执行消耗的时间"><a href="#time-量测命令执行消耗的时间" class="headerlink" title="time-量测命令执行消耗的时间"></a>time-量测命令执行消耗的时间</h2><ul>
<li><p>简介：</p>
</li>
<li><p>Linux time命令的用途，在于量测特定指令执行时所需消耗的时间及系统资源等资讯。例如 CPU 时间、记忆体、输入输出等等。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>time [options] COMMAND [arguments]</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-o 或 –output=FILE</strong></p>
<ul>
<li>设定结果输出档。这个选项会将 time 的输出写入 所指定的档案中。如果档案已经存在，系统将覆写其内容。</li>
</ul>
</li>
<li><p><strong>-a 或 –append</strong></p>
<ul>
<li>配合 -o 使用，会将结果写到档案的末端，而不会覆盖掉原来的内容。</li>
</ul>
</li>
<li><p><strong>-f <FORMAT> 或 –format=FORMAT</strong></p>
<ul>
<li>以 FORMAT 字串设定显示方式。当这个选项没有被设定的时候，会用系统预设的格式。不过你可以用环境变数 time 来设定这个格式，如此一来就不必每次登入系统都要设定一次。</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;检测date命令运行时间和资源</span><br><span class="line">$ time date</span><br><span class="line">&gt; real    0m0.136s</span><br><span class="line">&gt; user    0m0.010s</span><br><span class="line">&gt; sys     0m0.070s</span><br><span class="line">&#x2F;&#x2F;在以上实例中，执行命令&quot;time date&quot;。系统先执行命令&quot;date&quot;，第2行为命令&quot;date&quot;的执行结果。</span><br><span class="line">&#x2F;&#x2F;第3-6行为执行命令&quot;date&quot;的时间统计结果，其中第4行&quot;real&quot;为实际时间，</span><br><span class="line">&#x2F;&#x2F;第5行&quot;user&quot;为用户CPU时间，第6行&quot;sys&quot;为系统CPU时间。以上三种时间的显示格式均为MMmNN[.FFF]s。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="tr-转换或删除文件中的字符。"><a href="#tr-转换或删除文件中的字符。" class="headerlink" title="tr-转换或删除文件中的字符。"></a>tr-转换或删除文件中的字符。</h2><ul>
<li><p>简介：</p>
</li>
<li><p>tr 可以对来自标准输入的内容进行字符替换、字符删除以及重复字符压缩，将结果输出到标准输出设备。tr是translate（转换）的简写，因为它可以将一组字符转换成另一组字符。</p>
</li>
<li><p>语法：</p>
<ul>
<li><p><code>tr [选项参数][--help][--version][第一字符集][第二字符集]   或 tr [OPTION] SET1[SET2]</code></p>
<blockquote>
<p>来自stdin的输入字符会按照位置从set1映射到set2（set1中的第一个字符映射到set2中的第一个字符，以此类推），然后将输出写入stdout（标准输出）。</p>
</blockquote>
<blockquote>
<p>set1和set2是字符类或字符组。如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-c, –complement</strong></p>
<ul>
<li>反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换</li>
</ul>
</li>
<li><p><strong>-d, –delete</strong></p>
<ul>
<li>删除指令字符</li>
</ul>
</li>
<li><p><strong>-s, –squeeze-repeats</strong></p>
<ul>
<li>缩减连续重复的字符成指定的单个字符</li>
</ul>
</li>
<li><p><strong>-t, –truncate-set1</strong></p>
<ul>
<li>削减 SET1 指定范围，使之与 SET2 设定长度相等</li>
</ul>
</li>
<li><p><strong>–help</strong></p>
<ul>
<li>显示程序用法信息</li>
</ul>
</li>
<li><p><strong>–version</strong></p>
<ul>
<li>显示程序本身的版本信息</li>
</ul>
</li>
</ul>
</li>
<li><p>字符集合的范围</p>
<ul>
<li><p><strong>\NNN</strong></p>
<ul>
<li>八进制值的字符 NNN (1 to 3 为八进制值的字符)</li>
</ul>
</li>
<li><p><strong>\a Ctrl-G</strong></p>
<ul>
<li>铃声</li>
</ul>
</li>
<li><p><strong>\b Ctrl-H</strong></p>
<ul>
<li>退格符</li>
</ul>
</li>
<li><p><strong>\f Ctrl-L</strong></p>
<ul>
<li>走行换页</li>
</ul>
</li>
<li><p><strong>\n Ctrl-J</strong></p>
<ul>
<li>新行</li>
</ul>
</li>
<li><p><strong>\r Ctrl-M</strong></p>
<ul>
<li>回车</li>
</ul>
</li>
<li><p><strong>\t Ctrl-I</strong></p>
<ul>
<li>tab键</li>
</ul>
</li>
<li><p><strong>\v Ctrl-X</strong></p>
<ul>
<li>水平制表符</li>
</ul>
</li>
<li><p><strong>CHAR1-CHAR2</strong></p>
<ul>
<li>字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。<br>‘ABD-}’、’aA.,’、’a-ce-x’以及’a-c0-9’等均是合法的集合。<br>定义集合也很简单，不需要书写一长串连续的字符序列，只需要使用“起始字符-终止字符”这种格式就行了。</li>
</ul>
</li>
<li><p><strong>[CHAR*]</strong></p>
<ul>
<li>这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止</li>
</ul>
</li>
<li><p><strong>[CHAR*REPEAT]</strong></p>
<ul>
<li>这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)</li>
</ul>
</li>
<li><p><strong>[:alnum:]</strong></p>
<ul>
<li>所有字母字符与数字</li>
</ul>
</li>
<li><p><strong>[:alpha:]</strong></p>
<ul>
<li>所有字母字符</li>
</ul>
</li>
<li><p><strong>[:blank:]</strong></p>
<ul>
<li>所有水平空格</li>
</ul>
</li>
<li><p><strong>[:cntrl:]</strong></p>
<ul>
<li>所有控制（非打印）字符</li>
</ul>
</li>
<li><p><strong>[:digit:]</strong></p>
<ul>
<li>所有数字</li>
</ul>
</li>
<li><p><strong>[:graph:]</strong></p>
<ul>
<li>所有可打印的字符(不包含空格符)</li>
</ul>
</li>
<li><p><strong>[:lower:]</strong></p>
<ul>
<li>所有小写字母</li>
</ul>
</li>
<li><p><strong>[:print:]</strong></p>
<ul>
<li>所有可打印的字符(包含空格符)</li>
</ul>
</li>
<li><p><strong>[:punct:]</strong></p>
<ul>
<li>所有标点字符</li>
</ul>
</li>
<li><p><strong>[:space:]</strong></p>
<ul>
<li>所有水平与垂直空格符</li>
</ul>
</li>
<li><p><strong>[:upper:]</strong></p>
<ul>
<li>所有大写字母</li>
</ul>
</li>
<li><p><strong>[:xdigit:]</strong></p>
<ul>
<li>所有 16 进位制的数字</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;文件testfile中的小写字母全部转换成大写字母，然后输出</span><br><span class="line">$ cat testfile |tr a-z A-Z</span><br><span class="line">或反过来</span><br><span class="line">$ echo &quot;HELLO WHO IS THIS&quot; |tr [:upper:] [:lower:]</span><br><span class="line">&gt; hello who is this</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用tr进行数字加密和解密</span><br><span class="line">&#x2F;&#x2F;加密</span><br><span class="line">$ echo 12345 | tr &#39;0-9&#39; &#39;9876543210&#39;</span><br><span class="line">&gt; 87654 # 已加密</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;解密</span><br><span class="line">$  echo 87654 | tr &#39;9876543210&#39; &#39;0-9&#39;</span><br><span class="line">&gt; 12345 # 已解密</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将制表符转换成单个空格</span><br><span class="line">$ tr &#39;\t&#39; &#39; &#39; &lt; file.txt</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用tr删除字符，语法上只使用set1，不使用set2</span><br><span class="line">&#x2F;&#x2F;将stdin中的数字删除并打印删除后的结果</span><br><span class="line">$ echo &quot;Hello 123 world 456&quot; | tr -d &#39;0-9&#39;</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从输入文本中删除不在补集中的所有字符</span><br><span class="line">$ echo hello 1 char 2 next 4 | tr -d -c &#39;0-9 \n&#39;</span><br><span class="line">&gt; 124</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将不在set1中的字符替换成空格</span><br><span class="line">$ echo hello 1 char 2 next 4 | tr -c &#39;0-9&#39; &#39; &#39;</span><br><span class="line">&gt;  1 2 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果你习惯在点号后面放置两个空格，你需要在不删除重复字母的情况下去掉多余的空格（-s 缩减连续重复的字符成指定的单个字符）</span><br><span class="line">$  echo &quot;GNU is not UNIX. Recursive right ?&quot; | tr -s &#39; &#39;</span><br><span class="line">&gt; GNU is not UNIX. Recursive right ?</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件中的数字进行相加,先删除字母，再将&#39; &#39;替换成+号，得到 $[ 1+2+3+4+5 ]，$[ operation ]执行算术运算，得出结果</span><br><span class="line">$ cat test.txt | tr -d [a-z] | echo &quot;total: $[$(tr &#39; &#39; &#39;+&#39;)]&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>tr只能通过stdin（标准输入）接收输入（无法通过命令行参数接收）</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="U"><a href="#U" class="headerlink" title="U"></a>U</h1><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><h1 id="W"><a href="#W" class="headerlink" title="W"></a>W</h1><h2 id="which-查找并显示给定命令的绝对路径"><a href="#which-查找并显示给定命令的绝对路径" class="headerlink" title="which-查找并显示给定命令的绝对路径"></a>which-查找并显示给定命令的绝对路径</h2><ul>
<li><p>简介：</p>
</li>
<li><p>环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p>
</li>
<li><p>语法：</p>
<ul>
<li><code>which cmdName</code></li>
</ul>
</li>
<li><p>选项值：</p>
</li>
<li><p>注意事项</p>
<blockquote>
<p>which是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</p>
</blockquote>
<blockquote>
<p>cd 这种常用的命令找不到,因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以找不到的！</p>
</blockquote>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查找文件、显示命令路径</span><br><span class="line">$ which pwd</span><br><span class="line">&gt; &#x2F;bin&#x2F;pwd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><h2 id="xargs-参数传递过滤器"><a href="#xargs-参数传递过滤器" class="headerlink" title="xargs-参数传递过滤器"></a>xargs-参数传递过滤器</h2><ul>
<li><p>简介：</p>
<ul>
<li>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</li>
<li>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</li>
<li>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</li>
<li>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</li>
<li>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</li>
<li>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令，例如：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F;sbin -perm +700 |ls -l       #这个命令是错误的</span><br><span class="line">find &#x2F;sbin -perm +700 |xargs ls -l   #这样才是正确的</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>somecommand |xargs -item  command</code></li>
</ul>
</li>
<li><p>选项值：</p>
<ul>
<li><p><strong>-a file</strong></p>
<ul>
<li>从文件中读入作为sdtin</li>
</ul>
</li>
<li><p><strong>-e flag 或 -E flag</strong></p>
<ul>
<li>flag必须是一个以空格分隔的标志，当xargs分析到含有flag这个标志的时候就停止。</li>
</ul>
</li>
<li><p><strong>-p</strong></p>
<ul>
<li>当每次执行一个argument的时候询问一次用户。</li>
</ul>
</li>
<li><p><strong>-n num</strong></p>
<ul>
<li>后面加次数，表示命令在执行的时候一次用的argument的个数，默认是用所有的。如果用在输出场景，那就是一行有n个</li>
</ul>
</li>
<li><p><strong>-t</strong></p>
<ul>
<li>表示先打印命令，然后再执行。</li>
</ul>
</li>
<li><p><strong>-i 或-I</strong></p>
<ul>
<li>可以用于指定替换字符串，这个字符串会在xargs解析输入时被参数替换掉。如 复制所有图片文件到/data/images 目录下：-I 指定替换符号是{}，那么xargs每个输出，都会替换cp后面的{}<br><code>ls *.jpg | xargs -n1 -I {} cp {} /data/images</code></li>
</ul>
</li>
<li><p><strong>-r no-run-if-empty</strong></p>
<ul>
<li>当xargs的输入为空的时候则停止xargs，不用再去执行了。</li>
</ul>
</li>
<li><p><strong>-s num</strong></p>
<ul>
<li>命令行的最大字符数，指的是 xargs 后面那个命令的最大命令行字符数。</li>
</ul>
</li>
<li><p><strong>-L num</strong></p>
<ul>
<li>从标准输入一次读取 num 行送给 command 命令。</li>
</ul>
</li>
<li><p><strong>-l</strong></p>
<ul>
<li>同 -L。</li>
</ul>
</li>
<li><p><strong>-d delim</strong></p>
<ul>
<li>xargs对于输入的默认分隔符是空格，-d选项可以为输入数据指定自定义的分隔符</li>
</ul>
</li>
<li><p><strong>-x</strong></p>
<ul>
<li>exit的意思，主要是配合-s使用。。</li>
</ul>
</li>
<li><p><strong>-P</strong></p>
<ul>
<li>修改最大的进程数，默认是1，为0时候为as many as it can</li>
</ul>
</li>
</ul>
</li>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;多行输入单行输出</span><br><span class="line">$ cat test.txt</span><br><span class="line">&gt; a b c d e f g</span><br><span class="line">&gt; h i j k l m n</span><br><span class="line"></span><br><span class="line">$ cat test.txt | xargs</span><br><span class="line">&gt; a b c d e f g h i j k l m n</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;-n 选项多行输出,每行三个元素</span><br><span class="line">$ cat test.txt | xargs -n 3</span><br><span class="line">&gt; a b c</span><br><span class="line">&gt; d e f</span><br><span class="line">&gt; g h i</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;stdin中是一个包含了多个X字符的字符串。我们可以用–d选项将X定义为输入分隔符。</span><br><span class="line">$ echo &quot;splitXsplit2Xsplit3Xsplit4&quot; | xargs -d X </span><br><span class="line">&gt; Split1 split2 split3 split4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在系统中搜索.docx文件，这些文件名中通常会包含大写字母和空格。其中使用了grep找出内容中不包含image的文件</span><br><span class="line">$ find &#x2F;smbMount -iname &#39;*.docx&#39; -print0 | xargs -0 grep -L image</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
<p>xargs 一般是和管道一起使用。</p>
</blockquote>
<blockquote>
<p>xargs命令可以同find命令很好地结合在一起。find的输出可以通过管道传给xargs，由后者执行-exec选项所无法处理的复杂操作。如果文件系统的有些文件名中包含空格，find命令的-print0选项可以使用0（NULL）来分隔查找到的元素，然后再用xargs对应的-0选项进行解析。</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h1><h1 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h1><h2 id="xxx"><a href="#xxx" class="headerlink" title="xxx"></a>xxx</h2><ul>
<li><p>简介：</p>
<ul>
<li>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</li>
</ul>
</li>
<li><p>语法：</p>
<ul>
<li><code>xxxxxxxxxxxxxxxxx</code></li>
</ul>
</li>
<li><p>选项值：</p>
</li>
</ul>
<ul>
<li><p>代码示例</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">$ </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<blockquote>
</blockquote>
</li>
</ul>
<hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/shell/" rel="tag"># shell</a>
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/17/shell-notes-tips/" rel="next" title="shell notes&tips">
                <i class="fa fa-chevron-left"></i> shell notes&tips
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/12/paxos%E7%AE%97%E6%B3%95%E8%AE%BA%E8%BF%B0%E5%92%8C%E6%8E%A8%E5%AF%BC/" rel="prev" title="paxos算法论述和推导">
                paxos算法论述和推导 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2019/07/21/常用shell命令导航/"
           data-title="常用shell命令导航" data-url="http://yoursite.com/2019/07/21/%E5%B8%B8%E7%94%A8shell%E5%91%BD%E4%BB%A4%E5%AF%BC%E8%88%AA/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">99</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#A"><span class="nav-text">A</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#alias-设置指令的别名"><span class="nav-text">alias-设置指令的别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#awk——把文件逐行的读入，以分隔符将其切片，再进行处理。"><span class="nav-text">awk——把文件逐行的读入，以分隔符将其切片，再进行处理。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B"><span class="nav-text">B</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C"><span class="nav-text">C</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cat-连接文件或标准输入至标准输出"><span class="nav-text">cat-连接文件或标准输入至标准输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cd——切换当前工作目录"><span class="nav-text">cd——切换当前工作目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chmod-设置文件权限"><span class="nav-text">chmod-设置文件权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chown-更改文件或目录的所有权"><span class="nav-text">chown-更改文件或目录的所有权</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cp-于复制文件或目录"><span class="nav-text">cp-于复制文件或目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#curl——发送各种HTTP请求"><span class="nav-text">curl——发送各种HTTP请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cut——按列切分文件"><span class="nav-text">cut——按列切分文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#D"><span class="nav-text">D</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#date-显示或设定系统的日期与时间"><span class="nav-text">date-显示或设定系统的日期与时间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#E"><span class="nav-text">E</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#echo-打印内容"><span class="nav-text">echo-打印内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#F"><span class="nav-text">F</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#find-查找文件"><span class="nav-text">find-查找文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ftp-lftp——使用ftp协议共享文件"><span class="nav-text">ftp&#x2F;lftp——使用ftp协议共享文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#G"><span class="nav-text">G</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#grep——在文件中搜索文本"><span class="nav-text">grep——在文件中搜索文本</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#H"><span class="nav-text">H</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#head-打印文件的前n行"><span class="nav-text">head-打印文件的前n行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I"><span class="nav-text">I</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ifconfig——配置和展示网络信息"><span class="nav-text">ifconfig——配置和展示网络信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#J"><span class="nav-text">J</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#K"><span class="nav-text">K</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#L"><span class="nav-text">L</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#less——对文件或其它输出进行分页显示"><span class="nav-text">less——对文件或其它输出进行分页显示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ls———显示指定工作目录下之内容"><span class="nav-text">ls———显示指定工作目录下之内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#M"><span class="nav-text">M</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#N"><span class="nav-text">N</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#O"><span class="nav-text">O</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P"><span class="nav-text">P</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#paste——合并文件的列"><span class="nav-text">paste——合并文件的列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#printf-打印内容"><span class="nav-text">printf-打印内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Q"><span class="nav-text">Q</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#R"><span class="nav-text">R</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#read-从键盘或标准输入中读取文本"><span class="nav-text">read-从键盘或标准输入中读取文本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rm-删除一个文件或者目录"><span class="nav-text">rm-删除一个文件或者目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rsync——数据远程同步工具"><span class="nav-text">rsync——数据远程同步工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#S"><span class="nav-text">S</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#scp——安全复制工具"><span class="nav-text">scp——安全复制工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sed——对文本进行编辑"><span class="nav-text">sed——对文本进行编辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-调试执行命令"><span class="nav-text">set-调试执行命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统"><span class="nav-text">sftp——运行在SSH连接之上并模拟了FTP接口的文件传输系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-命令延迟一段时间执行。"><span class="nav-text">sleep-命令延迟一段时间执行。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ssh——远程连接工具"><span class="nav-text">ssh——远程连接工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#T"><span class="nav-text">T</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tar——归档或者压缩，解压文件"><span class="nav-text">tar——归档或者压缩，解压文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tail–打印文件尾部内容"><span class="nav-text">tail–打印文件尾部内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#time-量测命令执行消耗的时间"><span class="nav-text">time-量测命令执行消耗的时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tr-转换或删除文件中的字符。"><span class="nav-text">tr-转换或删除文件中的字符。</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#U"><span class="nav-text">U</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#V"><span class="nav-text">V</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#W"><span class="nav-text">W</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#which-查找并显示给定命令的绝对路径"><span class="nav-text">which-查找并显示给定命令的绝对路径</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#X"><span class="nav-text">X</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#xargs-参数传递过滤器"><span class="nav-text">xargs-参数传递过滤器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Y"><span class="nav-text">Y</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Z"><span class="nav-text">Z</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#xxx"><span class="nav-text">xxx</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">451.4k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
