<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JAVA,AQS,并发编程,锁,ReentrantLock," />










<meta name="description" content="1. 概念在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础，许多实现都依赖其所提供的队列式同步器。 AQS的功能">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA并发之AQS详解">
<meta property="og:url" content="http://yoursite.com/2019/08/23/JAVA%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="cherish">
<meta property="og:description" content="1. 概念在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础，许多实现都依赖其所提供的队列式同步器。 AQS的功能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/a637d282fecd36584c7c7bfc6587911543e.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/7e44fbc800913348d7e9c169e9c597b2fbc.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/b0a383ed47e17b63787953d80e48673cee3.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/7215e10a01926df7cf7fb31927ab4388c52.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/9ee0ef0255f8bf5d74e23cdb3f1134ad17b.jpg">
<meta property="og:image" content="https://oscimg.oschina.net/oscnet/6d8cc66f9760007e7cf8213087cf517d768.jpg">
<meta property="article:published_time" content="2019-08-23T14:05:35.000Z">
<meta property="article:modified_time" content="2020-09-21T13:31:28.927Z">
<meta property="article:author" content="cherish-ls">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="AQS">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="锁">
<meta property="article:tag" content="ReentrantLock">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://oscimg.oschina.net/oscnet/a637d282fecd36584c7c7bfc6587911543e.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/23/JAVA并发之AQS详解/"/>





  <title>JAVA并发之AQS详解 | cherish</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cherish</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">返朴归真</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/23/JAVA%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cherish-ls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cherish">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JAVA并发之AQS详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-23T22:05:35+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/JAVA%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA线程与并发控制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/08/23/JAVA%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/08/23/JAVA并发之AQS详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  16.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  70
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础，许多实现都依赖其所提供的队列式同步器。</p>
<p>AQS的功能可以分为两类：独占锁和共享锁。它的所有子类中，要么实现并使用了它独占锁的API，要么使用了共享锁的API，而不会同时使用两套API，即便是它最有名的子类ReentrantReadWriteLock，也是通过两个内部类：读锁和写锁，分别实现的两套API来实现的，到目前为止，我们只需要明白AQS在功能上有独占锁和共享锁两种功能即可。</p>
<h2 id="1-1-如何使用AQS"><a href="#1-1-如何使用AQS" class="headerlink" title="1.1 如何使用AQS"></a>1.1 如何使用AQS</h2><p>AQS管理一个关于状态信息的单一整数，该整数可以表现任何状态。比如， Semaphore 用它来表现剩余的许可数，ReentrantLock 用它来表现拥有它的线程已经请求了多少次锁；FutureTask 用它来表现任务的状态(尚未开始、运行、完成和取消)。</p>
<p>AQS有众多方法，大致可以分为两类：</p>
<h3 id="1-1-1-需要子类实现的方法（模板方法）"><a href="#1-1-1-需要子类实现的方法（模板方法）" class="headerlink" title="1.1.1 需要子类实现的方法（模板方法）"></a>1.1.1 需要子类实现的方法（模板方法）</h3><ol>
<li><p>tryAcquire(int arg)：独占式的获取锁，返回值是boolean类型的，true代表获取锁，false代表获取失败。</p>
</li>
<li><p>tryRelease(int arg)：释放独占式同步状态，释放操作会唤醒其后继节点获取同步状态。</p>
</li>
<li><p>tryAcquireShared(int arg)：共享式的获取同步状态，返回大于0代表获取成功，否则就是获取失败。</p>
</li>
<li><p>tryReleaseShared(int arg)：共享式的释放同步状态。</p>
</li>
<li><p>isHeldExclusively()：判断当前的线程是否已经获取到了同步状态。</p>
</li>
</ol>
<p>这些方法是子类实现时可能实现的方法，通过上面的这些方法来判断是否获取了锁，然后再通过AQS本身的方法执行获取锁与未获取锁的过程。</p>
<p>以上方法不需要全部实现，根据获取的锁的种类可以选择实现不同的方法，支持独占(排他)获取锁的同步器应该实现tryAcquire、 tryRelease、isHeldExclusively而支持共享获取的同步器应该实现tryAcquireShared、tryReleaseShared。</p>
<h3 id="1-1-2-AQS本身的实现的方法"><a href="#1-1-2-AQS本身的实现的方法" class="headerlink" title="1.1.2 AQS本身的实现的方法"></a>1.1.2 AQS本身的实现的方法</h3><ol>
<li><p>acquire(int arg)/acquireInterruptibly(int arg)：独占式的获取锁操作，独占式获取同步状态都调用这个方法，通过子类实现的tryAcquire方法判断是否获取了锁。Interruptibly后缀的方法带有中断异常的签名，表示可以响应中断异常，无此后缀的acquire方法则通过重新标记中断状态的方式响应中断。</p>
</li>
<li><p>acquireShared(int arg)/acquireSharedInterruptibly：共享式的获取锁操作，在读写锁中用到，通过tryAcquireShared方法判断是否获取到了同步状态。Interruptibly后缀的方法带有中断异常的签名，表示可以响应中断异常，无此后缀的acquire方法则通过重新标记中断状态的方式响应中断。</p>
</li>
<li><p>release(int arg)：独占式的释放同步状态，通过tryRelease方法判断是否释放了独占式同步状态。</p>
</li>
<li><p>releaseShared(int arg)：共享式的释放同步状态，通过tryReleaseShared方法判断是否已经释放了共享同步状态。</p>
</li>
</ol>
<p>从这两类方法可以看出，AQS为子类定义了一套获取锁和释放锁以后的操作，而具体的如何判断是否获取锁和释放锁都是交由不同的子类自己去实现其中的逻辑，这也是Java设计模式之一：模板模式的实现。有了AQS我们就可以实现一个属于自己的Lock。</p>
<h1 id="2-源码分析（基于jdk1-8）"><a href="#2-源码分析（基于jdk1-8）" class="headerlink" title="2.源码分析（基于jdk1.8）"></a>2.源码分析（基于jdk1.8）</h1><h2 id="2-1-AQS类"><a href="#2-1-AQS类" class="headerlink" title="2.1 AQS类"></a>2.1 AQS类</h2><p>首先是类图↓</p>
<p><img src="https://oscimg.oschina.net/oscnet/a637d282fecd36584c7c7bfc6587911543e.jpg" alt=""></p>
<p>从图中可以看出来，AbstractQueuedSynchronizer内部维护了一个Node节点类和一个ConditionObject内部类。Node内部类是一个双向的FIFO队列，用来保存阻塞中的线程以及获取同步状态的线程，而ConditionObject对应的是后面要讲的Lock中的等待和通知机制。↓</p>
<p><img src="https://oscimg.oschina.net/oscnet/7e44fbc800913348d7e9c169e9c597b2fbc.jpg" alt=""></p>
<p>我们可以看到，AQS类是JUC框架的基石。为什么这么说？我们以ReentrantLock为例，ReentrantLock把所有Lock接口的操作都委派到一个自定义的内部类Sync类上，该类继承自AbstractQueuedSynchronizer。同时该类又有两个子类，NonfairSync 和 FairSync，实现非公平锁和公平锁。↓</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">公平锁：线程获取锁的顺序和调用lock的顺序一样，FIFO，先到先得；  </span><br><span class="line">非公平锁：线程获取锁的顺序和调用lock的顺序无关，全凭运气。</span><br></pre></td></tr></table></figure>

<p><img src="https://oscimg.oschina.net/oscnet/b0a383ed47e17b63787953d80e48673cee3.jpg" alt=""></p>
<p>同样的，CountDownLatch、Semaphore等其他类，也自定义了自己的Sync类和NonfairSync 和 FairSync，以达到功能的差异化。</p>
<h2 id="2-2-AQS的属性"><a href="#2-2-AQS的属性" class="headerlink" title="2.2 AQS的属性"></a>2.2 AQS的属性</h2><h3 id="2-2-1-状态位state"><a href="#2-2-1-状态位state" class="headerlink" title="2.2.1 状态位state"></a>2.2.1 状态位state</h3><p>AQS用的是一个32位的整型来表示同步状态的，它是用volatile修饰的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> * 在互斥锁中它表示着线程是否已经获取了锁，0未获取，1已经获取了，大于1表示重入数。</span></span><br><span class="line"><span class="comment"> * 同时AQS提供了getState()、setState()、compareAndSetState()方法来获取和修改该值：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-当前持有独占锁的线程"><a href="#2-2-2-当前持有独占锁的线程" class="headerlink" title="2.2.2 当前持有独占锁的线程"></a>2.2.2 当前持有独占锁的线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span></span><br><span class="line"><span class="comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread; <span class="comment">//继承自AbstractOwnableSynchronizer</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-获取锁的阻塞队列——CLH同步队列"><a href="#2-2-3-获取锁的阻塞队列——CLH同步队列" class="headerlink" title="2.2.3 获取锁的阻塞队列——CLH同步队列"></a>2.2.3 获取锁的阻塞队列——CLH同步队列</h3><h4 id="2-2-3-1-head和tail属性"><a href="#2-2-3-1-head和tail属性" class="headerlink" title="2.2.3.1 head和tail属性"></a>2.2.3.1 head和tail属性</h4><p>AQS内部维护着一个FIFO的CLH队列，用来保存阻塞中的线程以及获取同步状态的线程，每个node都封装着一个独立的线程，<strong>head指向的node可以简单理解为当前持有锁的线程</strong>，tail指向了等待队列的链尾。正因为head指向当前持有锁的线程，<strong>所以，真正的等待队列，不包括head</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">     * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">     * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">     * CANCELLED.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">     * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail</span><br></pre></td></tr></table></figure>

<p>因为是CLH队列，所以AQS并不支持基于优先级的同步策略。至于为何要选择CLH队列，主要在于CLH锁相对于MSC锁，他更加容易处理cancel和timeout，同时他进出队列快、检查是否有线程在等待也非常容易（head != tail,头尾指针不同）。<strong>当然相对于原始的CLH队列锁，ASQ采用的是一种变种的CLH队列锁</strong>：</p>
<ol>
<li><p>原始CLH使用的locked自旋，而AQS的CLH则是在每个node里面使用一个状态字段来控制阻塞，而不是自旋。</p>
</li>
<li><p>为了可以处理timeout和cancel操作，每个node维护一个指向前驱的指针。如果一个node的前驱被cancel，这个node可以前向移动使用前驱的状态字段。</p>
</li>
<li><p>head结点使用的是傀儡结点。虽然node对象（封装了线程）在获取到锁的时候，逻辑会将这个node置为head，看起来head表示的是当前正在拥有锁的node节点的意思。但看setHead方法就能知道，node赋值为head后，node封装的thread对象被清空，node成为一个空对象。</p>
</li>
</ol>
<p><img src="https://oscimg.oschina.net/oscnet/7215e10a01926df7cf7fb31927ab4388c52.jpg" alt=""></p>
<p>我们来看看这个队列结点的实现：</p>
<h4 id="2-2-3-2-node实现"><a href="#2-2-3-2-node实现" class="headerlink" title="2.2.3.2 node实现"></a>2.2.3.2 node实现</h4><p>我们来看看node的源码 ↓</p>
<p><img src="https://oscimg.oschina.net/oscnet/9ee0ef0255f8bf5d74e23cdb3f1134ad17b.jpg" alt=""></p>
<p>众多字段，我们一个一个来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**共享模式是允许多个线程可以获取同一个锁，而独占模式则一个锁只能被一个线程持有，其他线程必须要等待。**/</span></span><br><span class="line">       </span><br><span class="line"><span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"><span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>下面的几个int常量是给waitStatus字段使用的，表示节点现在的状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**代表此线程取消了争抢这个锁</span></span><br><span class="line"><span class="comment">*场景：当该线程等待超时或者被中断，需要从同步队列中取消等待，则该线程被置1，即被取消（这里该线程在取消之前是等待状态）</span></span><br><span class="line"><span class="comment">*被取消状态的结点不应该去竞争锁，只能保持取消状态不变，不能转换为其他状态。处于这种状态的结点会被踢出队列</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate successor's thread needs unparking </span></span><br><span class="line"><span class="comment"> *  场景：后继的节点处于等待状态，当前节点的线程如果释放了同步状态或者被取消（当前节点状态置为-1），</span></span><br><span class="line"><span class="comment"> *  将会唤醒后继节点，使后继节点的线程得以运行；</span></span><br><span class="line"><span class="comment"> *  当一个节点的状态为SIGNAL时就意味着在等待获取同步状态</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition</span></span><br><span class="line"><span class="comment"> * 场景：节点处于等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，</span></span><br><span class="line"><span class="comment"> * 与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上</span></span><br><span class="line"><span class="comment"> * 当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment"> * unconditionally propagate</span></span><br><span class="line"><span class="comment"> * 场景：表示下一次共享式同步状态获取将会被无条件的被传播下去（读写锁中存在的状态，代表后续还有资源，可以多个线程同时拥有同步状态）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>然后就是状态字段的主角了，上面的这些常量，都是给该字段赋值用的 ↓</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br></pre></td></tr></table></figure>

<p>前面说过，在AQS中，我们维护了一个链表，故而node节点中，也定义了前后驱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment"> * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment"> * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment"> * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment"> * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment"> * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment"> * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment"> * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment"> * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment"> * 前驱节点，当节点加入同步队列的时候被设置（尾部添加）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment"> * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment"> * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment"> * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment"> * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment"> * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment"> * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment"> * to be null, we can scan prev's from the tail to</span></span><br><span class="line"><span class="comment"> * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment"> * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment"> * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment"> * 后继节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br></pre></td></tr></table></figure>

<p>当然，还有node节点的最重要主角：被封装的线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment"> * construction and nulled out after use.</span></span><br><span class="line"><span class="comment"> * 节点封装的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br></pre></td></tr></table></figure>
<p>还有一个很特殊的后驱节点，这个后驱，负责维护node节点参与的第二个链表（第一个就是AQS的同步等待链表）——condition等待链表，至于什么是condition，我们最后再来讨论。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment"> * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment"> * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment"> * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment"> * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment"> * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment"> * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment"> * mode.</span></span><br><span class="line"><span class="comment"> * 指向condition等待队列中的下一个节点，或特殊值SHARED。 </span></span><br><span class="line"><span class="comment"> * 因为condition等待队列只有在保持独占模式时才被访问，</span></span><br><span class="line"><span class="comment"> * 所以我们只需要一个简单的链表来在节点等待condition时保存节点。 </span></span><br><span class="line"><span class="comment"> * 然后将它们转移到队列中以重新获取。 并且因为条件只能是独占的，所以我们通过使用特殊值来指示共享模式来保存字段。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// nextWaiter还有一个作用，是区别当前CLH队列是 ‘独占锁’队列 还是 ‘共享锁’队列 的标记</span></span><br><span class="line"> <span class="comment">// 若nextWaiter=SHARED，则CLH队列是“独占锁”队列；</span></span><br><span class="line"> <span class="comment">// 若nextWaiter=EXCLUSIVE，(即nextWaiter=null)，则CLH队列是“共享锁”队列。</span></span><br><span class="line">Node nextWaiter;</span><br></pre></td></tr></table></figure>

<p>你可以把node节点简单看作 thread + waitStatus + pre + next 四个属性的封装，从本质上来说，这是没错的，node几乎所有的api也都服务于这四个属性。</p>
<h2 id="2-3-AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）"><a href="#2-3-AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）" class="headerlink" title="2.3 AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）"></a>2.3 AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）</h2><p><img src="https://oscimg.oschina.net/oscnet/6d8cc66f9760007e7cf8213087cf517d768.jpg" alt=""></p>
<p>从上图可以看到，AQS的<strong>实现有许多种</strong>，我们以最典型的在ReentrantLock类内部定义的公平锁FairSync和非公平锁NonFairSync为例，来探讨一下AQS<strong>独占模式</strong>的同步原理。（ReentrantLock是典型的独占锁，真正管理锁的也是其内部实现类FairSync或者NonFairSync）</p>
<p>独占锁是独占的，排他的，因此在独占锁中有一个exclusiveOwnerThread属性，用来记录当前持有锁的线程。</p>
<p>我们一般怎么使用ReentrantLock呢？很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">needLockFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 比如我们对下面这段逻辑加锁</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        <span class="comment">// 通常，lock 之后紧跟着 try 语句</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span></span><br><span class="line">            <span class="comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">            <span class="comment">// 执行代码...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们可以从lock方法看起</p>
<h3 id="2-3-1-公平锁的加锁逻辑"><a href="#2-3-1-公平锁的加锁逻辑" class="headerlink" title="2.3.1 公平锁的加锁逻辑"></a>2.3.1 公平锁的加锁逻辑</h3><p>reentrantLock的lock方法调用的是reentrantLock内部的sync字段的lock方法，sync字段在reentrantLock的构造方法中就开始初始化默认是非公平锁：</p>
<blockquote>
<p>ReentrantLock默认使用非公平锁是基于性能考虑，公平锁为了保证线程规规矩矩地排队，需要增加阻塞和唤醒的时间开销。如果直接插队获取非公平锁，跳过了对队列的处理，速度会更快</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-1-FairSync-lock"><a href="#2-3-1-1-FairSync-lock" class="headerlink" title="2.3.1.1 FairSync.lock()"></a>2.3.1.1 FairSync.lock()</h4><p>我们来看看FairSync的lock()，很简单直接调用了acquire(); ↓</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-1-2-AQS-acquire"><a href="#2-3-1-2-AQS-acquire" class="headerlink" title="2.3.1.2 AQS.acquire()"></a>2.3.1.2 AQS.acquire()</h4><p>所以lock()的重点都在acquire()，FairSync调用了AQS类中实现的acquire();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span><br><span class="line"> * by invoking at least once &#123;@link #tryAcquire&#125;,</span><br><span class="line"> * returning on success.  Otherwise the thread is queued, possibly</span><br><span class="line"> * repeatedly blocking and unblocking, invoking &#123;@link</span><br><span class="line"> * #tryAcquire&#125; until success.  This method can be used</span><br><span class="line"> * to implement method &#123;@link Lock#lock&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param arg the acquire argument.  This value is conveyed to</span><br><span class="line"> *        &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and</span><br><span class="line"> *        can represent anything you like.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final void acquire(int arg) &#123;&#x2F;&#x2F;记住此时arg&#x3D;1</span><br><span class="line">    &#x2F;&#x2F;我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。方法return，逻辑继续执行。</span><br><span class="line">    &#x2F;&#x2F; 否则，acquireQueued方法会将当前线程压到队列中，阻塞在里面</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;首先执行tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br><span class="line">    &#x2F;&#x2F; 因为有可能直接就成功了呢，也就不需要进队列排队了。</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        &#x2F;&#x2F; tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        &#x2F;&#x2F;该方法就是调用：Thread.currentThread().interrupt();中断当前线程</span><br><span class="line">        &#x2F;&#x2F;之所以有这个逻辑，是因为acquire方法没有中断异常的签名，</span><br><span class="line">        &#x2F;&#x2F;所以为了外层能继续响应中断，需要感应到acquireQueued内的中断，并在这里重新设置中断状态</span><br><span class="line">        &#x2F;&#x2F;可抛出中断异常的acquire方法为acquireInterruptibly(),除了中断处理不同以外，其他实现与acquire大同小异。</span><br><span class="line">        &#x2F;&#x2F;同理，其他带有Interruptibly后缀的方法，都是原方法的中断模式实现。</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一句话总结，AbstractQueuedSynchronizer.acquire()方法的作用是：先尝试获取锁，若成功则不用进队列阻塞，逻辑往下走（其实就是返回了）。否则封装当前线程为node，塞进队列，然后在acquireQueued方法中一直尝试，先期会自旋，如果在自旋期间内获得锁了，那么返回，返回结果是false，表示不需要调用selfInterrupt()做自我中断。如果是阻塞后才获取锁，返回，返回结果是true，表示要设置自我中断。（只是设置中断状态，至于到底何时中断，由线程本身决定）</p>
</blockquote>
<hr>
<h4 id="2-3-1-3-FairSync-tryAcquire"><a href="#2-3-1-3-FairSync-tryAcquire" class="headerlink" title="2.3.1.3 FairSync.tryAcquire()"></a>2.3.1.3 FairSync.tryAcquire()</h4><p>AQS类中实现的acquire()又调用了FairSync中实现的tryAcquire(1)，我们来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">        * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line">       <span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">           <span class="comment">//获取AQS的状态，我们之前说过，0未加锁，1已经加锁了，大于1表示重入数。</span></span><br><span class="line">           <span class="keyword">int</span> c = getState();</span><br><span class="line">           <span class="comment">//如果AQS未加锁</span></span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">               <span class="comment">// 看看有没有别人在队列中等了半天了，没有才改变状态</span></span><br><span class="line">               <span class="comment">//hasQueuedPredecessors()根据 当前线程是否是等待队列的第一个 来判断是否有等待更久的节点。</span></span><br><span class="line">               <span class="comment">//记住，我们说过，等待队列不包括头结点head</span></span><br><span class="line">               <span class="comment">//所以hasQueuedPredecessors判断的是当前线程是否为head的后驱next</span></span><br><span class="line">               <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   <span class="comment">//执行到这里，意味着队列中没有更老的节点，那么CAS置换状态为1或者大于1（重入时大于1）</span></span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                   <span class="comment">//设置拥有独占锁的线程是当前线程</span></span><br><span class="line">	    <span class="comment">//代码就一行，exclusiveOwnerThread = thread;</span></span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">				<span class="comment">//获取到锁</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//否则，说明AQS是被持有锁的状态，先判断持有锁的是不是自己</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">	<span class="comment">//如果是自己，那么说明自己重入了，status+1</span></span><br><span class="line">               <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">               <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">	<span class="comment">//nextc只有在重入次数超过int值上限，导致溢出为负时才会达到，报错超过最大锁计数</span></span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">               setState(nextc);</span><br><span class="line">			<span class="comment">//获取到锁</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//上述逻辑都不满足，未获取到锁</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一句话总结，FairSync.tryAcquire()方法的作用是：如果未加锁，那么判断自己是不是队列的头名，若是，设置独占锁线程，获得锁。否则，判断加锁的人是不是自己，如果是，那么重入，status+1，设置独占锁线程，获得锁。再否则，返回false，占锁失败。</p>
</blockquote>
<hr>
<h4 id="2-3-1-2-AQS-addWaiter"><a href="#2-3-1-2-AQS-addWaiter" class="headerlink" title="2.3.1.2 AQS.addWaiter()"></a>2.3.1.2 AQS.addWaiter()</h4><p>看完了tryAcquire方法，我们知道在acquire方法中，如果tryAcquire方法返回false，即没有获取到锁，那么将会执行addWaiter，将当前线程封装为node，addWaiter()是AbstractQueuedSynchronizer的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Creates and enqueues node for current thread and given mode.</span><br><span class="line"> *</span><br><span class="line"> * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="line"> * @return the new node</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;mode值有Node.EXCLUSIVE 和Node.SHARED，表示封装为独占模式还是分享模式</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    &#x2F;&#x2F;先使用快速入列法来尝试一下,如果失败,则进行更加完备的入列算法.</span><br><span class="line">    &#x2F;&#x2F;只有在必要的情况下才会使用更加复杂耗时的算法，也就是乐观的态度</span><br><span class="line">    Node pred &#x3D; tail;&#x2F;&#x2F;tail为队尾指针</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;进行入列操作</span><br><span class="line">        node.prev &#x3D; pred;&#x2F;&#x2F;该节点的前趋指针指向tail</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;&#x2F;&#x2F;cas将尾指针指向该节点</span><br><span class="line">            pred.next &#x3D; node;&#x2F;&#x2F;如果成果,让旧列尾节点的next指针指向该节点</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;cas失败,或在pred &#x3D;&#x3D; null时调用enq</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123; &#x2F;&#x2F;cas无锁算法的标准for循环,不停的尝试，直到成功入队</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;t &#x3D;&#x3D; null为真的话，说明队列为空，要初始化一个空队列，即只存在一个哨兵node的队列</span><br><span class="line">            &#x2F;&#x2F;还是那句话，head是一个哨兵的作用，并不代表某个要获取锁的线程节点，所以并没有将node赋给head</span><br><span class="line">            &#x2F;&#x2F;而是new了一个无关紧要的新node</span><br><span class="line">            &#x2F;&#x2F;compareAndSetHead方法，用cas，期望head为null时将其更新为new Node()</span><br><span class="line">            if (compareAndSetHead(new Node())) </span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">           &#x2F;&#x2F;注意，这里没有return，执行完后，还是要继续for循环，下一次，必定走else逻辑。</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;和addWaiter中一致，不过有了外侧的无限循环，不停的尝试，相当于自旋锁</span><br><span class="line">            &#x2F;&#x2F;将node的前驱改为原来的队尾node</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            &#x2F;&#x2F;新创建的节点指向队列尾节点，毫无疑问并发情况下这里会有多个新创建的节点指向队列尾节点</span><br><span class="line">            &#x2F;&#x2F;基于这一步的CAS，不管前一步有多少新节点都指向了尾节点，这一步只有一个能真正入队成功</span><br><span class="line">            &#x2F;&#x2F;其他的都必须重新执行循环体</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;&#x2F;&#x2F;改变队尾指针的值</span><br><span class="line">                t.next &#x3D; node;&#x2F;&#x2F;原本的队尾的后驱设为node</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，AbstractQueuedSynchronizer.addWaiter()方法的作用是将当前线程封装为node，并将node节点塞入等待队列，塞入逻辑包括节点前后驱，head和tail指针的维护，以及必要时对空列表的初始化。然后返回封装好的node。</p>
</blockquote>
<hr>
<h4 id="2-3-1-3-AQS-acquireQueued"><a href="#2-3-1-3-AQS-acquireQueued" class="headerlink" title="2.3.1.3 AQS.acquireQueued()"></a>2.3.1.3 AQS.acquireQueued()</h4><p>回到acquire方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           &#x2F;&#x2F; tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           &#x2F;&#x2F;该方法就是调用：Thread.currentThread().interrupt();中断当前线程</span><br><span class="line">           selfInterrupt();</span><br></pre></td></tr></table></figure>
<p>addWaiter()将当前线程封装为node，紧接着，执行的是AbstractQueuedSynchronizer.acquireQueued()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">  * Acquires in exclusive uninterruptible mode for thread already in</span><br><span class="line">  * queue. Used by condition wait methods as well as acquire.</span><br><span class="line">  *</span><br><span class="line">  * @param node the node</span><br><span class="line">  * @param arg the acquire argument</span><br><span class="line">  * @return &#123;@code true&#125; if interrupted while waiting</span><br><span class="line">  *&#x2F;</span><br><span class="line"> final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">     boolean failed &#x3D; true;</span><br><span class="line">     try &#123;</span><br><span class="line">         boolean interrupted &#x3D; false;</span><br><span class="line">         &#x2F;&#x2F;不会一直自旋，如果判断还没轮到自己，那么线程会阻塞在这个for循环中的parkAndCheckInterrupt里面</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">             final Node p &#x3D; node.predecessor();</span><br><span class="line">             &#x2F;&#x2F;node的前驱p是head，就说明，node是将要获取锁的下一个节点.</span><br><span class="line">             if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;&#x2F;&#x2F;所以再次尝试获取锁</span><br><span class="line">                 setHead(node);&#x2F;&#x2F;如果成功，那么就将自己设置为head，前文说过，node会被置为傀儡，然后赋给head</span><br><span class="line">                 p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                 failed &#x3D; false;</span><br><span class="line">                 return interrupted;</span><br><span class="line">             &#x2F;&#x2F;此时，还没有进入阻塞状态，所以直接返回false，表示不需要中断调用后面的selfInterrupt函数</span><br><span class="line">             &#x2F;&#x2F;此时方法返回后，在acquire方法内也走完了所有逻辑，acquire方法返回，执行lock操作后的业务逻辑。</span><br><span class="line">             &#125;</span><br><span class="line">             &#x2F;&#x2F;判断是否要进入阻塞状态。</span><br><span class="line">             &#x2F;&#x2F;如果shouldParkAfterFailedAcquire返回true，表示需要进入阻塞，则调用parkAndCheckInterrupt，进行阻塞；</span><br><span class="line">             &#x2F;&#x2F;否则表示还可以再次尝试获取锁，继续进行for循环</span><br><span class="line">             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                 parkAndCheckInterrupt())</span><br><span class="line">                 interrupted &#x3D; true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         if (failed)</span><br><span class="line">             cancelAcquire(node);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">    int ws &#x3D; pred.waitStatus;</span><br><span class="line">    if (ws &#x3D;&#x3D; Node.SIGNAL) &#x2F;&#x2F;前一个节点在等待锁释放的通知，所以还没那么快轮到自己，当前节点可以阻塞</span><br><span class="line">        return true;</span><br><span class="line">    &#x2F;&#x2F;static final int CANCELLED &#x3D;  1;节点状态中，只有CANCELLED大于0</span><br><span class="line">    &#x2F;&#x2F;前一个节点处于取消获取锁的状态，所以，可以跳过去</span><br><span class="line">    if (ws &gt; 0) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F;前驱的前驱变为自己的前驱，即前驱在链表中被剔除了。</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">          &#x2F;&#x2F;如果前驱都是取消，那么一直剔除。</span><br><span class="line">        &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">        pred.next &#x3D; node;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;将上一个节点的状态设置为signal，返回false。</span><br><span class="line">        &#x2F;&#x2F;但因为前驱被置为SIGNAL，外面的for循环下一次获取还失败后，该node也会返回true了。</span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this); &#x2F;&#x2F;将AQS对象自己传入</span><br><span class="line">    &#x2F;&#x2F;LockSupport.park()也能响应中断信号，但是跟Thread.sleep()之类不同的是它不会抛出InterruptedException</span><br><span class="line">    &#x2F;&#x2F;那怎么知道线程是被unpark还是被中断的呢，根据线程的interrupted status。</span><br><span class="line">    &#x2F;&#x2F;如果线程是被中断退出阻塞的那么该值被设置为true，通过Thread的interrupted和isInterrupted方法都能获取该值，不再赘述。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;线程waiting在park方法中，这个返回，肯定是线程被唤醒后才会执行</span><br><span class="line">    &#x2F;&#x2F;此时它表示的意思为：在waiting中时，是否是被中断唤醒了。如果是unpark，那么Thread.interrupted()为false。中断唤醒才为true；</span><br><span class="line">    &#x2F;&#x2F;我们知道处理中断时最好不要将其吃掉，要么抛出新的中断异常，要么重新设置interrupted status</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;结合上文，我们知道这里如果返回true，那么外面acquireQueued方法在获取到锁的时候也会返回interrupted &#x3D; true;</span><br><span class="line">    &#x2F;&#x2F;表示是中断唤醒的，届时acquireQueued方法会调用selfInterrupt();</span><br><span class="line">    &#x2F;&#x2F;selfInterrupt()方法其实就是调用：Thread.currentThread().interrupt();中断当前线程</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void park(Object blocker) &#123;</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);&#x2F;&#x2F;设置阻塞对象，用来记录线程被谁阻塞的，用于线程监控和分析工具来定位</span><br><span class="line">    UNSAFE.park(false, 0L);&#x2F;&#x2F;让当前线程不再被线程调度，就是当前线程不再执行.</span><br><span class="line">    setBlocker(t, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们回到acquireQueued方法的最后一步，finally模块。这里是针对锁资源获取失败以后做的一些善后工作，翻看上面的代码，其实能进入这里的就是tryAcquire()方法抛出异常，也就是说AQS框架针对开发人员自己实现的获取锁操作如果抛出异常，也做了妥善的处理，一起来看下源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;传入的方法参数是当前获取锁资源失败的节点</span><br><span class="line">private void cancelAcquire(Node node) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果节点不存在则直接忽略</span><br><span class="line">        if (node &#x3D;&#x3D; null)</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        node.thread &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 跳过所有已经取消的前置节点，跟上面的那段跳转逻辑类似</span><br><span class="line">        Node pred &#x3D; node.prev;</span><br><span class="line">        while (pred.waitStatus &gt; 0)</span><br><span class="line">            node.prev &#x3D; pred &#x3D; pred.prev;</span><br><span class="line">        &#x2F;&#x2F;这个是前置节点的后继节点，由于上面可能的跳节点的操作，所以这里可不一定就是当前节点</span><br><span class="line">        Node predNext &#x3D; pred.next;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;把当前节点waitStatus置为取消，这样别的节点在处理时就会跳过该节点</span><br><span class="line">        node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">        &#x2F;&#x2F;如果当前是尾节点，则直接删除，即出队</span><br><span class="line">        &#x2F;&#x2F;注：这里不用关心CAS失败，因为即使并发导致失败，该节点也已经被成功删除</span><br><span class="line">        if (node &#x3D;&#x3D; tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">            compareAndSetNext(pred, predNext, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int ws;</span><br><span class="line">            if (pred !&#x3D; head &amp;&amp;</span><br><span class="line">                ((ws &#x3D; pred.waitStatus) &#x3D;&#x3D; Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;&#x3D; 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread !&#x3D; null) &#123;</span><br><span class="line">                Node next &#x3D; node.next;</span><br><span class="line">                if (next !&#x3D; null &amp;&amp; next.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                    &#x2F;&#x2F;这里的判断逻辑很绕，具体就是如果当前节点的前置节点不是头节点且它后面的节点等待它唤醒（waitStatus小于0）</span><br><span class="line">                    &#x2F;&#x2F;再加上如果当前节点的后继节点没有被取消就把前置节点跟后置节点进行连接，相当于删除了当前节点</span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;进入这里，要么当前节点的前置节点是头结点，要么前置节点的waitStatus是PROPAGATE，直接唤醒当前节点的后继节点</span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next &#x3D; node; &#x2F;&#x2F; help GC</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，AbstractQueuedSynchronizer.acquireQueued()方法会一直循环来尝试获取锁，当并非一直自旋，而是会在每一次循环判断是否要进入阻塞，如果通过判断前置节点状态得知无法很快得到锁（这其中会将cancel状态的node踢出队列），那么该node会进入阻塞。<br>阻塞被唤醒后，如果是中断唤醒的，那么会将这个中断唤醒的标记往外层传，并在次尝试获取锁，如果还是失败，继续进入上述判断阻塞逻辑。直到获取到锁。<br>同时，如果tryAcquire()方法抛出异常，也会有体面的退出逻辑。</p>
</blockquote>
<h3 id="2-3-2-非公平锁的加锁逻辑"><a href="#2-3-2-非公平锁的加锁逻辑" class="headerlink" title="2.3.2 非公平锁的加锁逻辑"></a>2.3.2 非公平锁的加锁逻辑</h3><h4 id="2-3-2-1-NonFairSync-lock"><a href="#2-3-2-1-NonFairSync-lock" class="headerlink" title="2.3.2.1 NonFairSync.lock()"></a>2.3.2.1 NonFairSync.lock()</h4><p>再来看看NonFairSync的lock(); </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line"> * acquire on failure.</span><br><span class="line"> *&#x2F;</span><br><span class="line">final void lock() &#123;&#x2F;&#x2F;不管三七二十一，先尝试获取一次锁</span><br><span class="line">    &#x2F;&#x2F;CAS,成功了就设置拥有独占锁的线程是当前线程</span><br><span class="line">    if (compareAndSetState(0, 1))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    else</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-2-AQS-acquire"><a href="#2-3-2-2-AQS-acquire" class="headerlink" title="2.3.2.2 AQS.acquire()"></a>2.3.2.2 AQS.acquire()</h4><p>调用AQS.acquire()方法，前文已说过，不再赘述。可通过侧边导航快速回看。</p>
<h4 id="2-3-2-3-NonFairSync-nonfairTryAcquire"><a href="#2-3-2-3-NonFairSync-nonfairTryAcquire" class="headerlink" title="2.3.2.3 NonFairSync.nonfairTryAcquire()"></a>2.3.2.3 NonFairSync.nonfairTryAcquire()</h4><p>AQS.acquire()中重要的tryAcquire方法，非公平锁定义了自己的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">	return nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Performs non-fair tryLock.  tryAcquire is implemented in</span><br><span class="line"> * subclasses, but both need nonfair try for trylock method.</span><br><span class="line"> *&#x2F;</span><br><span class="line">final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">    int c &#x3D; getState();</span><br><span class="line">    &#x2F;&#x2F;和公平锁一样，获取AQS的状态，我们之前说过，0未加锁，1已经加锁了，大于1表示重入数。</span><br><span class="line">    &#x2F;&#x2F;如果AQS未加锁</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;注意，这里和公平锁的区别来了，还记得公平锁中这里的实现么？</span><br><span class="line">        &#x2F;&#x2F;公平锁中，如果AQS未加锁，逻辑即便到了这里，也会调用hasQueuedPredecessors()来判断等待线程是否有等了更久的node</span><br><span class="line">        &#x2F;&#x2F;但是非公平锁不管，我到了这里是我本事，本身不讲究公平，直接CAS设置锁状态，抢锁</span><br><span class="line">        if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;否则，说明AQS是被持有锁的状态，先判断持有锁的是不是自己</span><br><span class="line">    else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果是自己，那么说明自己重入了，status+1，同样的，如果int值溢出，抛异常</span><br><span class="line">        int nextc &#x3D; c + acquires;</span><br><span class="line">        if (nextc &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;上述逻辑都不满足，未获取到锁</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，NonFairSync.nonfairTryAcquire方法的作用是：如果未加锁，那么直接抢锁，而不是像公平锁一样去检查是否轮到自己。若AQS已经上锁，判断加锁的人是不是自己，如果是，那么重入，status+1，设置独占锁线程，获得锁。再否则，返回false，占锁失败。</p>
</blockquote>
<p><strong>剩下的加锁逻辑，则完全和公平锁没有区别了，因为实际都是调用的AQS的addWaiter()和acquireQueued()方法，不再赘述。</strong></p>
<h3 id="2-3-3-释放锁逻辑"><a href="#2-3-3-释放锁逻辑" class="headerlink" title="2.3.3 释放锁逻辑"></a>2.3.3 释放锁逻辑</h3><p>释放锁的逻辑，公平锁和非公平锁没有区别，本质都是调用的AQS.release()方法和Sync.tryRelease()方法</p>
<h4 id="2-3-3-1-ReentrantLock-unlock"><a href="#2-3-3-1-ReentrantLock-unlock" class="headerlink" title="2.3.3.1 ReentrantLock.unlock()"></a>2.3.3.1 ReentrantLock.unlock()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">    sync.release(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-2-AQS-release"><a href="#2-3-3-2-AQS-release" class="headerlink" title="2.3.3.2 AQS.release()"></a>2.3.3.2 AQS.release()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;&#x2F;&#x2F;release就是先调用tryRelease来释放独占性变量。</span><br><span class="line">        &#x2F;&#x2F;释放独占性变量,起始就是将status的值减1,因为acquire时是加1</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)&#x2F;&#x2F;是否有等待锁的阻塞线程，0为waitStatus的初始值，表示未赋值任何状态</span><br><span class="line">            unparkSuccessor(h);&#x2F;&#x2F;唤醒head的后继节点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-3-AQS-tryRelease"><a href="#2-3-3-3-AQS-tryRelease" class="headerlink" title="2.3.3.3 AQS.tryRelease()"></a>2.3.3.3 AQS.tryRelease()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    &#x2F;&#x2F;由于只有一个线程可以获得独占先变量，也只有这个线程才能有效调用unlock，所以所有操作不需要考虑多线程</span><br><span class="line">    int c &#x3D; getState() - releases;&#x2F;&#x2F;对于重入场景，重入数-1，非重入场景，解锁。</span><br><span class="line">    if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread())</span><br><span class="line">        &#x2F;&#x2F;如果不是持有独占锁的线程执行unlock，抛出异常。</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    boolean free &#x3D; false;</span><br><span class="line">    if (c &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;如果等于0,那么说明锁应该被释放了，否则表示当前线程有重入操作，该次解锁只是一次重入的释放</span><br><span class="line">        free &#x3D; true;</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-4-AQS-unparkSuccessor"><a href="#2-3-3-4-AQS-unparkSuccessor" class="headerlink" title="2.3.3.4 AQS.unparkSuccessor()"></a>2.3.3.4 AQS.unparkSuccessor()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">	&#x2F;&#x2F;注意这里的node是AQS.release()中塞进来的head节点</span><br><span class="line">	int ws &#x3D; node.waitStatus;</span><br><span class="line">	if (ws &lt; 0)&#x2F;&#x2F;head的状态为非取消</span><br><span class="line">		compareAndSetWaitStatus(node, ws, 0);&#x2F;&#x2F;将head的waitStatus置为0，即没有任何有实质意思的状态</span><br><span class="line">		</span><br><span class="line">	 &#x2F;&#x2F;一般来说,需要唤醒的线程就是head的下一个节点，但是如果它获取锁的操作被取消,或在节点为null时</span><br><span class="line">	 &#x2F;&#x2F;就直接继续往后遍历，找到第一个未取消的后继节点.</span><br><span class="line">	Node s &#x3D; node.next;</span><br><span class="line">	if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">		s &#x3D; null;</span><br><span class="line">		for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">			if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">				s &#x3D; t;</span><br><span class="line">	&#125;</span><br><span class="line">	if (s !&#x3D; null)</span><br><span class="line">		LockSupport.unpark(s.thread);&#x2F;&#x2F;将对应节点唤醒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了unpark方法后，进行lock操作被阻塞的线程就恢复到运行状态,就会再次执行acquireQueued中的无限for循环中的操作，再次尝试获取锁。</p>
<h2 id="2-4-AQS的共享锁实现（以Semaphore为例）"><a href="#2-4-AQS的共享锁实现（以Semaphore为例）" class="headerlink" title="2.4 AQS的共享锁实现（以Semaphore为例）"></a>2.4 AQS的共享锁实现（以Semaphore为例）</h2><p>前面我们学习了AQS独占锁的逻辑，对于独占锁而言，锁只能被一个线程独占持有，而对于共享锁而言，由于锁是可以被共享的，因此它可以被多个线程同时持有。</p>
<p>AQS的共享锁应用于Semaphore、ReentrantReadWriteLock等实现中，本次我们以Semaphore为例来剖析一下AQS的共享锁</p>
<p>共享锁的实现和独占锁是对应的，我们可以从下面这张表中看出</p>
<table>
<thead>
<tr>
<th align="left">独占锁</th>
<th align="left">共享锁</th>
</tr>
</thead>
<tbody><tr>
<td align="left">tryAcquire(int arg)</td>
<td align="left">tryAcquireShared(int arg)</td>
</tr>
<tr>
<td align="left">tryAcquireNanos(int arg, long nanosTimeout)</td>
<td align="left">tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
</tr>
<tr>
<td align="left">acquire(int arg)</td>
<td align="left">acquireShared(int arg)</td>
</tr>
<tr>
<td align="left">acquireQueued(final Node node, int arg)</td>
<td align="left">doAcquireShared(int arg)</td>
</tr>
<tr>
<td align="left">acquireInterruptibly(int arg)</td>
<td align="left">acquireSharedInterruptibly(int arg)</td>
</tr>
<tr>
<td align="left">doAcquireInterruptibly(int arg)</td>
<td align="left">doAcquireSharedInterruptibly(int arg)</td>
</tr>
<tr>
<td align="left">doAcquireNanos(int arg, long nanosTimeout)</td>
<td align="left">doAcquireSharedNanos(int arg, long nanosTimeout)</td>
</tr>
<tr>
<td align="left">release(int arg)</td>
<td align="left">releaseShared(int arg)</td>
</tr>
<tr>
<td align="left">tryRelease(int arg)</td>
<td align="left">tryReleaseShared(int arg)</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">doReleaseShared()</td>
</tr>
<tr>
<td align="left">除了最后一个属于共享锁的doReleaseShared()方法没有对应外，其他的方法，独占锁和共享锁都是一一对应的。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="2-4-1-Semaphore"><a href="#2-4-1-Semaphore" class="headerlink" title="2.4.1 Semaphore"></a>2.4.1 Semaphore</h3><p>在解析之前，我们先来了解一下Semaphore是什么。</p>
<blockquote>
<p>Semaphore也叫信号量，在JDK1.5被引入，用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。还可以用来实现某种资源池，或者对容器施加边界。</p>
</blockquote>
<p>打个比喻，Semaphore就像一道阀门，可以控制同时进入某一逻辑的线程数量（构造方法中指定），我们使用acquire方法来争取通行票，使用release方法来归还通行票。通行票只是一个比喻，一般我们称之为许可。</p>
<ul>
<li>Semaphore内部维护了一组虚拟的许可，许可的数量可以通过构造函数的参数指定。<ul>
<li><code>public Semaphore(int permits) {
  sync = new NonfairSync(permits);
}</code></li>
</ul>
</li>
<li>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。</li>
<li>访问资源后，使用release释放许可。</li>
<li>Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。<ul>
<li><code>public Semaphore(int permits, boolean fair) {
  sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}</code></li>
</ul>
</li>
<li>当初始值为1时，可以用作互斥锁，并具备不可重入的加锁语义。</li>
<li>Semaphore将AQS的同步状态（status字段）用于保存当前可用许可的数量。</li>
</ul>
<p>我们调用Semaphore方法时，其实是在间接调用其内部类或AQS方法执行的。Semaphore类结构与ReetrantLock类相似，内部类Sync继承自AQS，然后其子类FairSync和NoFairSync分别实现公平锁和非公平锁的获取锁方法tryAcquireShared(int arg)，而释放锁的tryReleaseShared(int arg)方法则有Sync类实现，因为非公平或公平锁的释放过程都是相同的。</p>
<h3 id="2-4-2-Semaphore公平锁争锁逻辑"><a href="#2-4-2-Semaphore公平锁争锁逻辑" class="headerlink" title="2.4.2 Semaphore公平锁争锁逻辑"></a>2.4.2 Semaphore公平锁争锁逻辑</h3><p>不论是公平锁还是非公平锁，Semaphore使用acquire()方法来争锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquireSharedInterruptibly方法，<strong>是定义在AQS中的</strong>，它可以响应中断异常，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())&#x2F;&#x2F;如果当前线程被中断，抛出中断异常。</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;尝试获取共享锁，返回值小于0表示获取失败</span><br><span class="line">        doAcquireSharedInterruptibly(arg);&#x2F;&#x2F;未获取成功则加入同步队列等待</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-4-2-1-Semaphore-FairSync-tryAcquireShared"><a href="#2-4-2-1-Semaphore-FairSync-tryAcquireShared" class="headerlink" title="2.4.2.1 Semaphore.FairSync.tryAcquireShared"></a>2.4.2.1 Semaphore.FairSync.tryAcquireShared</h4><p>我们知道AQS中，try开头的几个方法都是模板方法，需要各个实现自己重写，Semaphore的公平锁实现类FairSync同样实现了自己的tryAcquireShared</p>
<p>tryAcquire的返回值是个boolean类型，表示是否成功获取到了锁，而tryAcquireShared的返回值是一个int类型，这表示tryAcquireShared的返回含义绝不止是或者否这么简单，它的返回有三种情况：</p>
<ul>
<li>小于0 ： 表示获取锁失败，需要进入等待队列。</li>
<li>等于0 ： 表示当前线程获取共享锁成功，但它后续的线程是无法继续获取的。</li>
<li>大于0 ： 表示当前线程获取共享锁成功且它后续等待的节点也有可能继续获取共享锁成功。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;&#x2F;&#x2F;一直执行，直到要么失败，要么成功</span><br><span class="line">        &#x2F;&#x2F;hasQueuedPredecessors我们在上文见过了，它实现在AQS中</span><br><span class="line">        &#x2F;&#x2F;根据 当前线程是否是等待队列的第一个 来判断是否有等待更久的节点。</span><br><span class="line">        &#x2F;&#x2F;因为是公平锁，所以要先判断先来后到</span><br><span class="line">        if (hasQueuedPredecessors())</span><br><span class="line">            return -1;&#x2F;&#x2F;还没轮到你，所以获取锁失败，需要进入等待队列</span><br><span class="line">        int available &#x3D; getState();&#x2F;&#x2F;Semaphore的status表示许可总数量</span><br><span class="line">        int remaining &#x3D; available - acquires;&#x2F;&#x2F;总数量-索取量</span><br><span class="line">        &#x2F;&#x2F;如果索取量超过剩余量，返回的是小于0，表示获取许可失败。</span><br><span class="line">        &#x2F;&#x2F;如果CAS成功，表示获取许可成功，那么返回剩余量。</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，FairSync.tryAcquireShared方法的作用是：重复判断是否轮到自己来获取许可了，如果不是，返回获取失败。否则检查剩余量，若许可的剩余量满足索取量，那么CAS获取许可，返回索取后的剩余量。</p>
</blockquote>
<h4 id="2-4-2-2-AQS-doAcquireSharedInterruptibly"><a href="#2-4-2-2-AQS-doAcquireSharedInterruptibly" class="headerlink" title="2.4.2.2 AQS.doAcquireSharedInterruptibly()"></a>2.4.2.2 AQS.doAcquireSharedInterruptibly()</h4><p>acquireSharedInterruptibly中，如果tryAcquireShared获取许可失败，那么逻辑就进入了doAcquireSharedInterruptibly方法中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Acquires in shared interruptible mode.</span><br><span class="line"> * @param arg the acquire argument</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F;以共享模式调用addWaiter封装一个node，</span><br><span class="line">    &#x2F;&#x2F;addWaiter前文已分析，具体可见右侧导航栏跳转2.3.1.2 AQS.addWaiter()</span><br><span class="line">    final Node node &#x3D; addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;&#x2F;&#x2F;重复执行</span><br><span class="line">            &#x2F;&#x2F;获取node的前驱</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            if (p &#x3D;&#x3D; head) &#123;&#x2F;&#x2F;前驱如果是head，表示自己已经在队首</span><br><span class="line">            &#x2F;&#x2F;tryAcquireShared再尝试一次</span><br><span class="line">                int r &#x3D; tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F;这里是重点，获取到锁以后的唤醒操作，后面详细说</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                    failed &#x3D; false;&#x2F;&#x2F;获取许可成功</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;自己不在队首，或者取锁失败，调用AQS.shouldParkAfterFailedAcquire判断是否需要阻塞，</span><br><span class="line">            &#x2F;&#x2F;若需要则调用parkAndCheckInterrupt，进行阻塞；</span><br><span class="line">            &#x2F;&#x2F;否则表示还可以再次尝试获取锁，继续进行for循环</span><br><span class="line">            &#x2F;&#x2F;这两个方法前文都已分析，具体可见右侧导航栏跳转2.3.1.3 AQS.acquireQueued()</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                &#x2F;&#x2F;注意，非Interruptibly后缀的方法，在进入这里的时候是将它们定义的interrupted设为true;</span><br><span class="line">                &#x2F;&#x2F;而Interruptibly后缀的方法则不需要向外传递中断状态，直接抛出中断异常即可</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            &#x2F;&#x2F;cancelAcquire方法前文也已分析，体面的退出获取。只有报异常才会来到这里。</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一句话总结，AQS.doAcquireSharedInterruptibly方法的作用是：调用addWaiter封装当前线程，然后重复执行取锁逻辑，直到渠道锁为止，如果取到锁，设置各个状态并唤醒后继线程，如果没有获取到锁，改变前驱节点状态，然后阻塞，等待唤醒</p>
</blockquote>
<h4 id="2-4-2-3-AQS-setHeadAndPropagate"><a href="#2-4-2-3-AQS-setHeadAndPropagate" class="headerlink" title="2.4.2.3 AQS.setHeadAndPropagate()"></a>2.4.2.3 AQS.setHeadAndPropagate()</h4><p>获取到许可时，逻辑调用了AQS.setHeadAndPropagate()，从方法名就可以看出除了设置新的头结点以外还有一个传递动作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">    &#x2F;&#x2F;两个入参，一个是当前成功获取共享锁的节点，一个就是tryAcquireShared方法的返回值</span><br><span class="line">    &#x2F;&#x2F;注意上面说的，它可能大于0也可能等于0</span><br><span class="line">    Node h &#x3D; head; &#x2F;&#x2F;将老的头结点记录下来，用来下面if的check</span><br><span class="line">    &#x2F;&#x2F;设置新的头节点，即把当前获取到锁的节点设置为头节点</span><br><span class="line">    setHead(node);&#x2F;&#x2F;此时head&#x3D;&#x3D;node了</span><br><span class="line">    &#x2F;&#x2F;这里意思是：有两种情况是需要执行唤醒操作</span><br><span class="line">    &#x2F;&#x2F;1.propagate &gt; 0 表示调用方指明了后继节点还可以被唤醒，因为许可还有</span><br><span class="line">    &#x2F;&#x2F;2.头节点后面的节点需要被唤醒（waitStatus&lt;0），不论是老的头结点（h &#x3D; head）还是新的头结点（node）</span><br><span class="line">    if (propagate &gt; 0 || h &#x3D;&#x3D; null || h.waitStatus &lt; 0 ||</span><br><span class="line">        (h &#x3D; head) &#x3D;&#x3D; null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">        Node s &#x3D; node.next;&#x2F;&#x2F;此时node已经是head了，node的next就是在等待队列的队首</span><br><span class="line">        &#x2F;&#x2F;如果当前节点的后继节点是共享类型或者没有后继节点，则进行唤醒</span><br><span class="line">        &#x2F;&#x2F;这里可以理解为除非明确指明不需要唤醒（后继等待节点是独占类型），否则都要唤醒</span><br><span class="line">        if (s &#x3D;&#x3D; null || s.isShared())</span><br><span class="line">            &#x2F;&#x2F;doReleaseShared不会释放锁，别被名字误导，它会唤醒后续节点，讲到释放锁时重点说</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final boolean isShared() &#123;</span><br><span class="line">    return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，在条件队列中，nextWaiter是指向条件队列中的下一个节点的，它将条件队列中的节点串起来，构成了单链表。但是在sync queue队列中，我们只用prev/next属性来串联节点，形成双向链表，nextWaiter属性在这里只起到一个标记作用，不会串联节点，这里不要被Node SHARED = new Node()所指向的空节点迷惑，这个空节点并不属于sync queue，不代表任何线程，它只起到标记作用，仅仅用作判断节点是否处于共享模式的依据。</p>
<blockquote>
<p>一句话总结，AQS.setHeadAndPropagate方法的作用是：设置head节点，并在许可还有剩余或者后继新旧head节点的后驱都应该被唤醒时（waitStatus &lt; 0），唤醒head的后继，让其参与争锁。</p>
</blockquote>
<h3 id="2-4-3-Semaphore非公平锁争锁逻辑"><a href="#2-4-3-Semaphore非公平锁争锁逻辑" class="headerlink" title="2.4.3 Semaphore非公平锁争锁逻辑"></a>2.4.3 Semaphore非公平锁争锁逻辑</h3><p>前文说过，不论是公平锁还是非公平锁，Semaphore都使用acquire()方法来争锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void acquire() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquireSharedInterruptibly方法，<strong>是定义在AQS中的</strong>，它可以响应中断异常，这个前文介绍过了，不再多说，拷贝过来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())&#x2F;&#x2F;如果当前线程被中断，抛出中断异常。</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;尝试获取共享锁，返回值小于0表示获取失败</span><br><span class="line">        doAcquireSharedInterruptibly(arg);&#x2F;&#x2F;未获取成功则加入同步队列等待</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-1-Semaphore-nonfairTryAcquireShared"><a href="#2-4-3-1-Semaphore-nonfairTryAcquireShared" class="headerlink" title="2.4.3.1 Semaphore.nonfairTryAcquireShared()"></a>2.4.3.1 Semaphore.nonfairTryAcquireShared()</h4><p>acquireSharedInterruptibly方法中的tryAcquireShared是模板方法，在Semaphore的两个内部类NonfairSync和FairSync中有各自的实现，FairSync.tryAcquireShared我们讲过了，我们来看下NonfairSync.tryAcquireShared</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected int tryAcquireShared(int acquires) &#123;</span><br><span class="line">    return nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接调用了nonfairTryAcquireShared方法，该方法定义在Semaphore类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final int nonfairTryAcquireShared(int acquires) &#123;</span><br><span class="line">    for (;;) &#123;&#x2F;&#x2F;一直执行，直到要么失败，要么成功</span><br><span class="line">        &#x2F;&#x2F;在FairSync.tryAcquireShared中，此时会判断if (hasQueuedPredecessors())</span><br><span class="line">        &#x2F;&#x2F;如果为true，则返回抢锁失败</span><br><span class="line">        &#x2F;&#x2F;但非公平锁不讲究先来后到，直接争锁</span><br><span class="line">        int available &#x3D; getState();&#x2F;&#x2F;Semaphore的status表示许可总数量</span><br><span class="line">        int remaining &#x3D; available - acquires;&#x2F;&#x2F;总数量-索取量</span><br><span class="line">        &#x2F;&#x2F;如果索取量超过剩余量，返回的是小于0，表示获取许可失败。</span><br><span class="line">        &#x2F;&#x2F;如果CAS成功，表示获取许可成功，那么返回剩余量。</span><br><span class="line">        if (remaining &lt; 0 ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            return remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一句话总结，Semaphore.nonfairTryAcquireShared方法的作用是：重复检查剩余量，若许可的剩余量满足索取量，那么CAS获取许可，返回索取后的剩余量。</p>
</blockquote>
<h3 id="2-4-4-Semaphore释放锁逻辑"><a href="#2-4-4-Semaphore释放锁逻辑" class="headerlink" title="2.4.4 Semaphore释放锁逻辑"></a>2.4.4 Semaphore释放锁逻辑</h3><h4 id="2-4-4-1-AQS-releaseShared"><a href="#2-4-4-1-AQS-releaseShared" class="headerlink" title="2.4.4.1 AQS.releaseShared()"></a>2.4.4.1 AQS.releaseShared()</h4><p>我们使用releaseShared(int arg)方法来释放共享锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在独占锁模式下，由于头节点就是持有独占锁的节点，在它释放独占锁后，如果发现自己的waitStatus不为0，则它将负责唤醒它的后继节点。</p>
<p>在共享锁模式下，头节点就是持有共享锁的节点，在它释放共享锁后，它也应该唤醒它的后继节点，但是值得注意的是，我们在之前的setHeadAndPropagate方法中可能已经调用过该方法了，也就是说它可能会被同一个头节点调用两次，也有可能在我们从releaseShared方法中调用它时，当前的头节点已经易主了。</p>
<h4 id="2-4-4-2-Semaphore-tryReleaseShared"><a href="#2-4-4-2-Semaphore-tryReleaseShared" class="headerlink" title="2.4.4.2 Semaphore.tryReleaseShared()"></a>2.4.4.2 Semaphore.tryReleaseShared()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryReleaseShared(int releases) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int current &#x3D; getState();&#x2F;&#x2F;当前剩余的许可数</span><br><span class="line">        int next &#x3D; current + releases;&#x2F;&#x2F;剩余许可数+这次释放的许可数</span><br><span class="line">        if (next &lt; current) &#x2F;&#x2F; overflow &#x2F;&#x2F;int型溢出才会有这种情况</span><br><span class="line">            throw new Error(&quot;Maximum permit count exceeded&quot;);</span><br><span class="line">        if (compareAndSetState(current, next))&#x2F;&#x2F;成功释放锁，重置剩余许可数</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一句话总结，Semaphore.tryReleaseShared方法的作用是：一直尝试将锁释放，CAS控制并发，将state值加回来</p>
</blockquote>
<h4 id="2-4-4-3-AQS-doReleaseShared"><a href="#2-4-4-3-AQS-doReleaseShared" class="headerlink" title="2.4.4.3 AQS.doReleaseShared()"></a>2.4.4.3 AQS.doReleaseShared()</h4><p>doReleaseShared是共享锁中最难理解的部分，我们来看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;&#x2F;&#x2F;循环check</span><br><span class="line">        Node h &#x3D; head;&#x2F;&#x2F;当前的head节点，执行到这里时，head可能是当前线程之前绑定的节点，也可能节点已经易主了</span><br><span class="line">        &#x2F;&#x2F;如果当前线程获取到锁后没有其他线程再获取到共享锁，那么这个head就是之前自己绑定的节点，否则，就不是了。</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;&#x2F;&#x2F;等待队列不为空</span><br><span class="line">            int ws &#x3D; h.waitStatus;</span><br><span class="line">            &#x2F;&#x2F;表示后继节点需要被唤醒</span><br><span class="line">            if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;</span><br><span class="line">                &#x2F;&#x2F;将head节点状态置为0，0为默认值，无特殊含义。</span><br><span class="line">                &#x2F;&#x2F;CAS不成功，重新执行for循环判断。</span><br><span class="line">                &#x2F;&#x2F;正是因为这个CAS的存在，保证即便doReleaseShared入口有setHeadAndPropagate跟release两个</span><br><span class="line">                &#x2F;&#x2F;但同一时间也只会唤醒一个后继节点。</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            &#x2F;&#x2F; loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);&#x2F;&#x2F;CAS成功，执行唤醒操作，唤醒h.next</span><br><span class="line">                &#x2F;&#x2F;注意，这里唤醒h.next后，逻辑就到了if (h &#x3D;&#x3D; head)这里</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;如果后继节点暂时不需要唤醒，则把当前节点状态设置为PROPAGATE确保以后可以传递下去</span><br><span class="line">            &#x2F;&#x2F;head的ws什么情况下会等于0？</span><br><span class="line">            &#x2F;&#x2F;1.上面的if会将ws从Node.SIGNAL置为0</span><br><span class="line">                 &#x2F;&#x2F;但执行了if，在本次迭代中不会执行else，得等到下次循环，如果期间head节点没有易主，那就没有下次循环。</span><br><span class="line">                 &#x2F;&#x2F;如果易主了，这里的h和ws就指向的是新head节点和其waitStatus。</span><br><span class="line">                 &#x2F;&#x2F;所以情况1不成立。</span><br><span class="line">            &#x2F;&#x2F;2.当前队列的最后一个节点成为了头节点</span><br><span class="line">                 &#x2F;&#x2F;因为只要有新节点入列，都会在shouldParkAfterFailedAcquire把前置节点的waitStatus置为Node.SIGNAL</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;当队列里唯一的节点成为了头节点，那什么情况下compareAndSetWaitStatus(h, 0, Node.PROPAGATE)会失败呢？</span><br><span class="line">            &#x2F;&#x2F;答案是：并发时，ws &#x3D;&#x3D; 0判断刚过，就有新节点将ws改为Node.SIGNAL。</span><br><span class="line">            &#x2F;&#x2F;但别忘了，for循环的第一个if，也是最外层的if是if (h !&#x3D; null &amp;&amp; h !&#x3D; tail)</span><br><span class="line">            else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;如果这个方法期间head没有易主，说明没有其他线程在这个期间获取到共享锁，它就可以break了。</span><br><span class="line">        &#x2F;&#x2F;如果head易主，说明方法执行过程中其他线程获取到了锁，</span><br><span class="line">        if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法最难理解的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">else if (ws &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">	!compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">	continue;</span><br></pre></td></tr></table></figure>
<p>为什么要有这个continue呢？？</p>
<p>根据上述的注解，我们知道要进入continue，得满足如下条件：</p>
<ul>
<li>队列中的最后一个节点成为了head，不然head的ws不会为0；</li>
<li>判断<code>if (h != null &amp;&amp; h != tail)</code>时，队列中不能只有head一个节点，否则不会进入if语句。</li>
<li>判断<code>else if (ws == 0</code>时，ws还要为0，但紧接着<code>compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</code>时却不能成功，说明此时ws不为0；</li>
</ul>
<p>所以总结下来，只有一个极其短暂的瞬间，逻辑有可能走到这里：</p>
<ul>
<li>队列中的最后一个节点成为了head</li>
<li>在当前线程中（我们称线程A）判断<code>if (h != null &amp;&amp; h != tail)</code>之前，等待队列中新加入一个节点（执行入列逻辑的线程我们称为线程B），该节点即head的后驱（等待队列不包括head），使得<code>if (h != null &amp;&amp; h != tail)</code>通过。</li>
<li>此时线程B中，head的后驱尝试获取锁失败，于是准备入列，刚刚执行addWaiter加入队列，还没有将head的ws改写，ws还是为0</li>
<li>然后线程A中我们判断<code>if (ws == Node.SIGNAL)</code> 不成立，进而判断<code>else if (ws == 0</code> ，逻辑通过</li>
<li>紧接着线程A判断<code>compareAndSetWaitStatus(h, 0, Node.PROPAGATE)</code>之前的一瞬间，ws在线程B中被head后驱通过调用<code>shouldParkAfterFailedAcquire</code>改写</li>
<li>改写后，线程B中，head后驱在下个循环就会进入阻塞了，而此时线程A执行<code>compareAndSetWaitStatus(h, 0, Node.PROPAGATE)</code>失败，触发了这个continue，而不是去进行<code>if (h == head)</code>判断。<ul>
<li>为什么要有这个continue？因为此时如果没有continue，那么进行<code>if (h == head)</code>判断，可能（其实是大概率）会通过，逻辑直接break了（break后就不会再唤醒后继了），逻辑A将唤醒后驱的逻辑break，而head的后驱却要阻塞，这使得head的后驱短时间内可能无人唤醒。</li>
<li>有了这个continue，那么下次循环，<code>if (ws == Node.SIGNAL)</code>通过，会对head的后继进行一次unpark，如果此时线程B已经park，那么唤醒正好。如果线程B慢悠悠的还没执行到park，那么我们知道，当我们unpark一个并没有被park的线程时，该线程在下一次调用park方法时就不会被阻塞，这时候如果线程B再执行park，也不会被阻塞了。</li>
</ul>
</li>
</ul>
<p>(上述只是个人猜想总结，如有缺漏或错误，还请指正)</p>
<blockquote>
<p>一句话总结，AQS.doReleaseShared方法的作用是：运用精细的逻辑控制，重复尝试唤醒head节点的后继。</p>
</blockquote>
<h2 id="2-5-AQS-condition实现"><a href="#2-5-AQS-condition实现" class="headerlink" title="2.5 AQS condition实现"></a>2.5 AQS condition实现</h2><h3 id="2-5-1-condition是什么"><a href="#2-5-1-condition是什么" class="headerlink" title="2.5.1 condition是什么"></a>2.5.1 condition是什么</h3><h4 id="2-5-1-1-简介"><a href="#2-5-1-1-简介" class="headerlink" title="2.5.1.1 简介"></a>2.5.1.1 简介</h4><p>condition又叫做条件队列，是AQS的一个内部实现，它能实现线程之间的通信，condition对象维护了一个FIFO的单向node链表，我们称之为等待队列（单向体现在只有后驱）（上文中争锁的队列我们叫做同步队列，以示区分，但其实他们的元素都是AQS.Node对象）。</p>
<p>我们在利用condition可以特定的场景下使线程休眠或被唤醒，和wait、notify实现的功能是一样的，但condition将休眠的对象放入等待队列，使其变得更为灵活。比如我们知道notify无法唤醒特定的一个线程，而是随机唤醒一个线程，但condition基于等待队列就能做到唤醒特定的一个线程（队首的线程），甚至我们还可以定义多个condition，使其能够互不干扰的休眠或唤醒。</p>
<p>condition是AQS的一个内部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractQueuedSynchronizer</span><br><span class="line">    extends AbstractOwnableSynchronizer</span><br><span class="line">    implements java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">	private static final long serialVersionUID &#x3D; 7373984972572414691L;</span><br><span class="line">	...</span><br><span class="line">	...</span><br><span class="line">	public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">			private static final long serialVersionUID &#x3D; 1173984872572414699L;</span><br><span class="line">			&#x2F;** First node of condition queue. *&#x2F;</span><br><span class="line">			private transient Node firstWaiter;</span><br><span class="line">			&#x2F;** Last node of condition queue. *&#x2F;</span><br><span class="line">			private transient Node lastWaiter;</span><br><span class="line"></span><br><span class="line">			&#x2F;**</span><br><span class="line">			 * Creates a new &#123;@code ConditionObject&#125; instance.</span><br><span class="line">			 *&#x2F;</span><br><span class="line">			public ConditionObject() &#123; &#125;</span><br><span class="line">			...</span><br><span class="line">			...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-1-2-语义"><a href="#2-5-1-2-语义" class="headerlink" title="2.5.1.2 语义"></a>2.5.1.2 语义</h4><p>从语义上来看，AQS实现的锁机制对应的是对象内置锁（synchronized语义对应的同步机制）的语义，这很好理解，在AQS这种显性锁出现前，我们使用java内置的对象的monitor来当做锁（对象锁或者类锁，即synchronized关键字和 (lock)等 ），AQS使用精妙的逻辑，重新显性的实现了锁机制。</p>
<p><strong>同理的，AQS.condition也是相对于内置锁的条件队列的一种显性存在。</strong></p>
<ul>
<li><p>用对象锁时，我们有Object.wait()、Object.notify()和Object.notifyAll()这三个api来操作对象的内部条件队列：</p>
<ul>
<li>用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）。</li>
<li>用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程；</li>
<li>用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程；</li>
</ul>
</li>
<li><p>用AQS实现的锁时，我们有condition.await(),condition.signal(),condition.ignalAll（）这三个api来操作AQS实现的锁的内部条件队列：</p>
<ul>
<li>Condition提供了await()方法将当前线程阻塞，线程调用await()方法前必须获取锁，调用await()方法时，将线程构造成节点加入等待队列，同时释放锁，并挂起当前线程</li>
<li>Condition提供了signal()方法支持另外一个线程将已经阻塞的线程唤醒。其他线程调用signal()方法前也必须获取锁，当执行signal()方法时将等待队列的节点移入到同步队列，当线程退出临界区释放锁的时候，唤醒同步队列的首个节点</li>
</ul>
</li>
</ul>
<h4 id="2-5-1-3-condition的使用"><a href="#2-5-1-3-condition的使用" class="headerlink" title="2.5.1.3 condition的使用"></a>2.5.1.3 condition的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">public void doSomething()&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(String.format(&quot;%s线程，获取到锁了&quot;,Thread.currentThread().getName()));</span><br><span class="line">    try &#123;</span><br><span class="line">        System.out.println(String.format(&quot;%s线程，await&quot;,Thread.currentThread().getName()));</span><br><span class="line">        TimeUnit.SECONDS.sleep(2L); &#x2F;&#x2F;模拟耗时业务逻辑执行</span><br><span class="line">        condition.await();  &#x2F;&#x2F;await</span><br><span class="line">        System.out.println(String.format(&quot;%s线程，await被唤醒&quot;,Thread.currentThread().getName()));</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(String.format(&quot;%s线程，业务执行完毕&quot;,Thread.currentThread().getName()));</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    ReentrantLockTest test &#x3D; new ReentrantLockTest();</span><br><span class="line">    int total &#x3D; 1;</span><br><span class="line">    while (total&gt;0)&#123;</span><br><span class="line">        Thread t &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">            test.doSomething();</span><br><span class="line">        &#125;,&quot;T-&quot;+total);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(200L);  &#x2F;&#x2F;让子线程T-1率先获取到锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(String.format(&quot;%s线程，获取到锁了&quot;,Thread.currentThread().getName()));</span><br><span class="line">        test.condition.signal();</span><br><span class="line">        System.out.println(String.format(&quot;%s线程，signal&quot;,Thread.currentThread().getName()));</span><br><span class="line">        lock.unlock();</span><br><span class="line">        total--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T-1线程，获取到锁了</span><br><span class="line">T-1线程，await</span><br><span class="line">main线程，获取到锁了</span><br><span class="line">main线程，signal</span><br><span class="line">T-1线程，await被唤醒</span><br><span class="line">T-1线程，业务执行完毕</span><br></pre></td></tr></table></figure>

<h3 id="2-5-2-condition源码解析"><a href="#2-5-2-condition源码解析" class="headerlink" title="2.5.2 condition源码解析"></a>2.5.2 condition源码解析</h3><p>看完demo，我们来看源码，以ReentrantLock实现的condition为例，看看ReentrantLock是如何在AQS的condition上继承和实现的。</p>
<h4 id="2-5-2-1-ReentrantLock-newCondition"><a href="#2-5-2-1-ReentrantLock-newCondition" class="headerlink" title="2.5.2.1 ReentrantLock.newCondition"></a>2.5.2.1 ReentrantLock.newCondition</h4><p>如之前的demo所示，我们使用如下方式来获得condition对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">Condition condition &#x3D; lock.newCondition();</span><br></pre></td></tr></table></figure>
<p>来看下newCondition（）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final ConditionObject newCondition() &#123;</span><br><span class="line">	return new ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-2-AQS-ConditionObject"><a href="#2-5-2-2-AQS-ConditionObject" class="headerlink" title="2.5.2.2 AQS.ConditionObject"></a>2.5.2.2 AQS.ConditionObject</h4><p>newCondition()返回的就是一个ConditionObject对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">        private static final long serialVersionUID &#x3D; 1173984872572414699L;</span><br><span class="line">        &#x2F;** First node of condition queue. *&#x2F;</span><br><span class="line">        private transient Node firstWaiter;</span><br><span class="line">        &#x2F;** Last node of condition queue. *&#x2F;</span><br><span class="line">        private transient Node lastWaiter;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * Creates a new &#123;@code ConditionObject&#125; instance.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public ConditionObject() &#123; &#125;</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>condition通过firstWaiter字段和lastWaiter字段组成了一个单向队列，即等待队列，并且和AQS的同步队列相比，他们虽然都是FIFO的，但等待队列的首节点并不具备同步队列首节点的传播通知的功能。而且首节点是第一个阻塞的线程节点。</p>
<ul>
<li>firstWaiter字段<ul>
<li>首个等待节点</li>
</ul>
</li>
<li>lastWaiter字段<ul>
<li>最后一个等待节点</li>
</ul>
</li>
</ul>
<h4 id="2-5-2-3-AQS-await"><a href="#2-5-2-3-AQS-await" class="headerlink" title="2.5.2.3 AQS.await()"></a>2.5.2.3 AQS.await()</h4><p>我们先来看一下condition将当前线程挂起的方法：await()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())&#x2F;&#x2F;当前线程加入等待队列前先判断是否被中断，若是，得响应中断</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    Node node &#x3D; addConditionWaiter();&#x2F;&#x2F;将同步队列中的当前线程构造成一个新的节点添加到等待队列尾部，后面详讲</span><br><span class="line">    &#x2F;&#x2F;释放node的同步状态（即释放锁）并返回释放之前的同步状态，后面详讲</span><br><span class="line">    &#x2F;&#x2F;因为condition的使用基于当前线程已经获取到锁了，所以release不会报错IllegalMonitorStateException</span><br><span class="line">    &#x2F;&#x2F;IllegalMonitorStateException：未持有锁的线程去释放锁时报该异常</span><br><span class="line">    int savedState &#x3D; fullyRelease(node);</span><br><span class="line">    int interruptMode &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;第一次进入while，判断被唤醒的node是否已经转移到AQS的同步队列中，不再则挂起线程，转移成功才退出循环</span><br><span class="line">    &#x2F;&#x2F;后面被唤醒后的线程，将从await()方法中的while循环中退出</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;&#x2F;&#x2F;（isOnSyncQueue(Node node)方法返回true，表示节点状态不为condition，且已经在同步队列中）</span><br><span class="line">        &#x2F;&#x2F;挂起线程，之后如果被被unpark或者发生中断时，也从此方法返回</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        &#x2F;&#x2F;被唤醒后来到这里，</span><br><span class="line">				</span><br><span class="line">        &#x2F;&#x2F;checkInterruptWhileWaiting方法有点绕，但其实不重要</span><br><span class="line">        &#x2F;&#x2F;只需知道是为了发生中断的时候能够让node跳出while循环</span><br><span class="line">        if ((interruptMode &#x3D; checkInterruptWhileWaiting(node)) !&#x3D; 0)</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;&#x2F;如果开到这里，说明被唤醒了，但不是因为发生中断</span><br><span class="line">        &#x2F;&#x2F;这时还需要继续判断是否进入同步队列，如果没有则继续挂起。</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;跳出循环了，调用AQS的acquireQueued()方法加入到获取同步状态的竞争中。State还是之前释放锁时保存的status</span><br><span class="line">    &#x2F;&#x2F;interruptMode !&#x3D; THROW_IE:如果不是因为中断异常而退出循环的话；</span><br><span class="line">    &#x2F;&#x2F;AQS的acquireQueued()前文已分析，具体可见右侧导航栏跳转2.3.1.3 AQS.acquireQueued()</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode !&#x3D; THROW_IE)</span><br><span class="line">        &#x2F;&#x2F;处理中断要么抛出中断异常，要么重设置中断态。</span><br><span class="line">        &#x2F;&#x2F;这里排除了抛出异常，那么标记一下后面如果要处理中断，应该采用重置中断态的方式</span><br><span class="line">        interruptMode &#x3D; REINTERRUPT;</span><br><span class="line">    if (node.nextWaiter !&#x3D; null) &#x2F;&#x2F; clean up if cancelled</span><br><span class="line">        &#x2F;&#x2F; 从队首开始往后溯，清空条件等待队列中节点状态不为 CONDITION 的节点</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode !&#x3D; 0)</span><br><span class="line">        &#x2F;&#x2F; 如果线程已经被中断，则根据之前获取的interruptMode的值来判断是继续中断还是抛出异常</span><br><span class="line">        &#x2F;&#x2F;reportInterruptAfterWait方法作用：</span><br><span class="line">        &#x2F;&#x2F;如果之前是抛出中断异常，那么这里要再次抛出</span><br><span class="line">        &#x2F;&#x2F;如果之前是给自己设置中断状态，那么这里也要设置</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Adds a new waiter to wait queue.</span><br><span class="line"> * @return its new wait node</span><br><span class="line"> *&#x2F;</span><br><span class="line">private Node addConditionWaiter() &#123;&#x2F;&#x2F;该方法比较简单，构造node，并加入condition等待队列</span><br><span class="line">    Node t &#x3D; lastWaiter;&#x2F;&#x2F;获取等待队列队尾</span><br><span class="line">    &#x2F;&#x2F; If lastWaiter is cancelled, clean out.</span><br><span class="line">    if (t !&#x3D; null &amp;&amp; t.waitStatus !&#x3D; Node.CONDITION) &#123;&#x2F;&#x2F;如果队尾被取消了，将其清理</span><br><span class="line">        unlinkCancelledWaiters();&#x2F;&#x2F;该方法从队首开始往后清理被取消的节点</span><br><span class="line">        t &#x3D; lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), Node.CONDITION);&#x2F;&#x2F;构造node</span><br><span class="line">    if (t &#x3D;&#x3D; null)&#x2F;&#x2F;如果等待队列为空，加入队首</span><br><span class="line">        firstWaiter &#x3D; node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter &#x3D; node;&#x2F;&#x2F;否则加入队尾</span><br><span class="line">    lastWaiter &#x3D; node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Invokes release with current state value; returns saved state.</span><br><span class="line"> * Cancels node and throws exception on failure.</span><br><span class="line"> * @param node the condition node for this wait</span><br><span class="line"> * @return previous sync state</span><br><span class="line"> *&#x2F;</span><br><span class="line">final int fullyRelease(Node node) &#123;&#x2F;&#x2F;fully的意思是将持有的锁完全释放：即即便有n次重入或许可，也要全部释放。</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        int savedState &#x3D; getState();&#x2F;&#x2F;因为要释放所有重入次数或者许可，所以要获取总量</span><br><span class="line">        if (release(savedState)) &#123;&#x2F;&#x2F;调用AQS的release一次释放总量，详见上文2.3.3.3 AQS.tryRelease()</span><br><span class="line">            failed &#x3D; false;</span><br><span class="line">            return savedState;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;IllegalMonitorStateException：未持有锁的线程去释放锁时报该异常</span><br><span class="line">            &#x2F;&#x2F;这里如果</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            &#x2F;&#x2F;释放锁失败的场景，只有IllegalMonitorStateException异常。这时可以认为该节点已经被取消。</span><br><span class="line">            node.waitStatus &#x3D; Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-2-4-AQS-signal"><a href="#2-5-2-4-AQS-signal" class="headerlink" title="2.5.2.4 AQS.signal()"></a>2.5.2.4 AQS.signal()</h4><p>看完了挂起线程的方法，我们来看下唤醒线程的方法，signal方法会唤醒condition等待队列中队首的那个线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Moves the longest-waiting thread, if one exists, from the</span><br><span class="line"> * wait queue for this condition to the wait queue for the</span><br><span class="line"> * owning lock.</span><br><span class="line"> *</span><br><span class="line"> * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125;</span><br><span class="line"> *         returns &#123;@code false&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final void signal() &#123;</span><br><span class="line">    if (!isHeldExclusively())&#x2F;&#x2F;该方法AQS未实现，ReentrantLock的实现是判断当前线程是不是持有锁的线程，是，则true</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first &#x3D; firstWaiter;&#x2F;&#x2F;获取等待队列的队首</span><br><span class="line">    if (first !&#x3D; null)</span><br><span class="line">        doSignal(first);&#x2F;&#x2F;下面我们来看看这个方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="line"> * null. Split out from signal in part to encourage compilers</span><br><span class="line"> * to inline the case of no waiters.</span><br><span class="line"> * @param first (non-null) the first node on condition queue</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)</span><br><span class="line">            lastWaiter &#x3D; null;</span><br><span class="line">        first.nextWaiter &#x3D; null;</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first &#x3D; firstWaiter) !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doSignal进来就是一个do-while，我们先看transferForSignal，回头再看doSignal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 将一个node从等待队列转移至同步队列，</span><br><span class="line"> * 如果成功，返回true</span><br><span class="line"> * @param node the node</span><br><span class="line"> * @return true if successfully transferred (else the node was</span><br><span class="line"> * cancelled before signal)</span><br><span class="line"> *&#x2F;</span><br><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * If cannot change waitStatus, the node has been cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;尝试将node的状态置为无意义的0，如果失败，说明该节点已经被取消。</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="line">     * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="line">     * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="line">     * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Node p &#x3D; enq(node);&#x2F;&#x2F;node进入同步队列的入列操作，在前文2.3.1.2 AQS.addWaiter()有过介绍</span><br><span class="line">    &#x2F;&#x2F;enq会返回入队前同步队列的队尾指针，即刚入队的node的前驱。</span><br><span class="line">    int ws &#x3D; p.waitStatus;</span><br><span class="line">    &#x2F;&#x2F;只有取消ws才会 大于0</span><br><span class="line">    &#x2F;&#x2F;我们知道同步队列中的节点都是依靠前驱节点来唤醒</span><br><span class="line">    &#x2F;&#x2F;如果入队后node的前驱已经被取消或者设置SIGNAL状态不成功，那么尝试唤醒当前node</span><br><span class="line">    &#x2F;&#x2F;虽然唤醒了可能还是争不到锁，但该操作至少是无害的。</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：传进transferForSignal的node节点被取消，会返回false，成功入同步队列了，会返回true。这时我们再看doSignal</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="line"> * null. Split out from signal in part to encourage compilers</span><br><span class="line"> * to inline the case of no waiters.</span><br><span class="line"> * @param first (non-null) the first node on condition queue</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F;第一次进来，先把firstWaiter设置为first.nextWaiter，这相当于first已经脱离等待队列了。</span><br><span class="line">        &#x2F;&#x2F;为什么这么果断呢，因为transferForSignal如果返回true，while循环结束</span><br><span class="line">        &#x2F;&#x2F;那么说明first已经进入同步队列，确实应该取消</span><br><span class="line">				</span><br><span class="line">        &#x2F;&#x2F;如果transferForSignal返回false，那么说明first节点已经被canceled了，也应该脱离等待队列。</span><br><span class="line">        if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)&#x2F;&#x2F;如果条件满足，说明等待队列已经为空了</span><br><span class="line">            lastWaiter &#x3D; null;&#x2F;&#x2F;则将lastWaiter指针也置空</span><br><span class="line">        first.nextWaiter &#x3D; null;&#x2F;&#x2F;first此时已经脱队，将其单向链表的后继也置空，first彻底脱离等待队列</span><br><span class="line">				</span><br><span class="line">    &#x2F;&#x2F;如果transferForSignal返回true，说明first入同步队列成功，while条件不满足，退出循环</span><br><span class="line">    &#x2F;&#x2F;如果transferForSignal返回false，说明first被取消，如果此时等待队列已经空了，那么也退出循环，</span><br><span class="line">    &#x2F;&#x2F;否则，将新的等待队列队首设置为first，执行重复逻辑。</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first &#x3D; firstWaiter) !&#x3D; null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-5-AQS-signalAll"><a href="#2-5-2-5-AQS-signalAll" class="headerlink" title="2.5.2.5 AQS.signalAll()"></a>2.5.2.5 AQS.signalAll()</h4><p>signalAll可唤醒等待队列中的全部线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Moves all threads from the wait queue for this condition to</span><br><span class="line"> * the wait queue for the owning lock.</span><br><span class="line"> *</span><br><span class="line"> * @throws IllegalMonitorStateException if &#123;@link #isHeldExclusively&#125;</span><br><span class="line"> *         returns &#123;@code false&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final void signalAll() &#123;</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first &#x3D; firstWaiter;</span><br><span class="line">    if (first !&#x3D; null)&#x2F;&#x2F;等待队列不为空，执行doSignalAll</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不赘述，直接看doSignalAll</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Removes and transfers all nodes.</span><br><span class="line"> * @param first (non-null) the first node on condition queue</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void doSignalAll(Node first) &#123;</span><br><span class="line">    lastWaiter &#x3D; firstWaiter &#x3D; null;&#x2F;&#x2F;先把标示性的指针lastWaiter和firstWaiter清空，因为等待队列即将要空了。</span><br><span class="line">    do &#123;</span><br><span class="line">        Node next &#x3D; first.nextWaiter;</span><br><span class="line">        first.nextWaiter &#x3D; null;</span><br><span class="line">        transferForSignal(first);&#x2F;&#x2F;现将first转移至同步队列，不管成功或者失败，都要继续执行。</span><br><span class="line">        first &#x3D; next;&#x2F;&#x2F;将first改为原来first的后继</span><br><span class="line">    &#125; while (first !&#x3D; null);&#x2F;&#x2F;只要等待队列不空，就一直将队首移入同步队列。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，将等待队列从队首无脑移入同步队列。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          
            <a href="/tags/AQS/" rel="tag"># AQS</a>
          
            <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag"># 并发编程</a>
          
            <a href="/tags/%E9%94%81/" rel="tag"># 锁</a>
          
            <a href="/tags/ReentrantLock/" rel="tag"># ReentrantLock</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/20/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E6%9C%8D%E5%8A%A1zookeeper%E7%AE%80%E8%AE%BA/" rel="next" title="分布式协调服务zookeeper简论">
                <i class="fa fa-chevron-left"></i> 分布式协调服务zookeeper简论
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/27/dump%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E5%92%8C%E5%88%86%E6%9E%90%E6%9F%A5%E7%9C%8B/" rel="prev" title="dump文件生成和分析查看">
                dump文件生成和分析查看 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2019/08/23/JAVA并发之AQS详解/"
           data-title="JAVA并发之AQS详解" data-url="http://yoursite.com/2019/08/23/JAVA%E5%B9%B6%E5%8F%91%E4%B9%8BAQS%E8%AF%A6%E8%A7%A3/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://oscimg.oschina.net/oscnet/up-c01f8b7b68770ed58c420d68072f773a30b.png"
                alt="cherish-ls" />
            
              <p class="site-author-name" itemprop="name">cherish-ls</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">94</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="git@github.com:cherish-ls/cherish-ls.github.io.git" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-概念"><span class="nav-text">1. 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-如何使用AQS"><span class="nav-text">1.1 如何使用AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-需要子类实现的方法（模板方法）"><span class="nav-text">1.1.1 需要子类实现的方法（模板方法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-AQS本身的实现的方法"><span class="nav-text">1.1.2 AQS本身的实现的方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-源码分析（基于jdk1-8）"><span class="nav-text">2.源码分析（基于jdk1.8）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-AQS类"><span class="nav-text">2.1 AQS类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-AQS的属性"><span class="nav-text">2.2 AQS的属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-状态位state"><span class="nav-text">2.2.1 状态位state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-当前持有独占锁的线程"><span class="nav-text">2.2.2 当前持有独占锁的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-获取锁的阻塞队列——CLH同步队列"><span class="nav-text">2.2.3 获取锁的阻塞队列——CLH同步队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-1-head和tail属性"><span class="nav-text">2.2.3.1 head和tail属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-2-node实现"><span class="nav-text">2.2.3.2 node实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）"><span class="nav-text">2.3 AQS的独占锁实现（以ReentrantLock的公平锁和非公平锁为例）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-公平锁的加锁逻辑"><span class="nav-text">2.3.1 公平锁的加锁逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-1-FairSync-lock"><span class="nav-text">2.3.1.1 FairSync.lock()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-2-AQS-acquire"><span class="nav-text">2.3.1.2 AQS.acquire()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-3-FairSync-tryAcquire"><span class="nav-text">2.3.1.3 FairSync.tryAcquire()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-2-AQS-addWaiter"><span class="nav-text">2.3.1.2 AQS.addWaiter()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-3-AQS-acquireQueued"><span class="nav-text">2.3.1.3 AQS.acquireQueued()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-非公平锁的加锁逻辑"><span class="nav-text">2.3.2 非公平锁的加锁逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-1-NonFairSync-lock"><span class="nav-text">2.3.2.1 NonFairSync.lock()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-2-AQS-acquire"><span class="nav-text">2.3.2.2 AQS.acquire()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-3-NonFairSync-nonfairTryAcquire"><span class="nav-text">2.3.2.3 NonFairSync.nonfairTryAcquire()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-释放锁逻辑"><span class="nav-text">2.3.3 释放锁逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-1-ReentrantLock-unlock"><span class="nav-text">2.3.3.1 ReentrantLock.unlock()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-2-AQS-release"><span class="nav-text">2.3.3.2 AQS.release()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-3-AQS-tryRelease"><span class="nav-text">2.3.3.3 AQS.tryRelease()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-4-AQS-unparkSuccessor"><span class="nav-text">2.3.3.4 AQS.unparkSuccessor()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-AQS的共享锁实现（以Semaphore为例）"><span class="nav-text">2.4 AQS的共享锁实现（以Semaphore为例）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-Semaphore"><span class="nav-text">2.4.1 Semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-Semaphore公平锁争锁逻辑"><span class="nav-text">2.4.2 Semaphore公平锁争锁逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-1-Semaphore-FairSync-tryAcquireShared"><span class="nav-text">2.4.2.1 Semaphore.FairSync.tryAcquireShared</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-2-AQS-doAcquireSharedInterruptibly"><span class="nav-text">2.4.2.2 AQS.doAcquireSharedInterruptibly()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-3-AQS-setHeadAndPropagate"><span class="nav-text">2.4.2.3 AQS.setHeadAndPropagate()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-Semaphore非公平锁争锁逻辑"><span class="nav-text">2.4.3 Semaphore非公平锁争锁逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-1-Semaphore-nonfairTryAcquireShared"><span class="nav-text">2.4.3.1 Semaphore.nonfairTryAcquireShared()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-4-Semaphore释放锁逻辑"><span class="nav-text">2.4.4 Semaphore释放锁逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-1-AQS-releaseShared"><span class="nav-text">2.4.4.1 AQS.releaseShared()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-2-Semaphore-tryReleaseShared"><span class="nav-text">2.4.4.2 Semaphore.tryReleaseShared()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4-3-AQS-doReleaseShared"><span class="nav-text">2.4.4.3 AQS.doReleaseShared()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-AQS-condition实现"><span class="nav-text">2.5 AQS condition实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-condition是什么"><span class="nav-text">2.5.1 condition是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-1-简介"><span class="nav-text">2.5.1.1 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-2-语义"><span class="nav-text">2.5.1.2 语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-3-condition的使用"><span class="nav-text">2.5.1.3 condition的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-condition源码解析"><span class="nav-text">2.5.2 condition源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-1-ReentrantLock-newCondition"><span class="nav-text">2.5.2.1 ReentrantLock.newCondition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-2-AQS-ConditionObject"><span class="nav-text">2.5.2.2 AQS.ConditionObject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-3-AQS-await"><span class="nav-text">2.5.2.3 AQS.await()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-4-AQS-signal"><span class="nav-text">2.5.2.4 AQS.signal()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-5-AQS-signalAll"><span class="nav-text">2.5.2.5 AQS.signalAll()</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cherish-ls</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">376.6k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"cherish"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'TQhjcmooFXWGQ3qgqUroDKsD-gzGzoHsz',
        appKey: 'zjA9PvG5eljY1JErig8WVQQD',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
